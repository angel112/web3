self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/containers/HomeComp/index.tsx":
/*!*******************************************!*\
  !*** ./src/containers/HomeComp/index.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _home_angel_projects_web3_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _components_Box__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/Box */ "./src/components/Box.tsx");
/* harmony import */ var _components_NavBar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/NavBar */ "./src/components/NavBar.tsx");
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! styled-components */ "./node_modules/styled-components/dist/styled-components.browser.esm.js");
/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gsap */ "./node_modules/gsap/index.js");
/* harmony import */ var gsap_src_all__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! gsap/src/all */ "./node_modules/gsap/src/all.js");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "/home/angel/projects/web3/src/containers/HomeComp/index.tsx",
    _this = undefined,
    _s = $RefreshSig$();








var HomeComp = function HomeComp() {
  _s();

  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(function () {
    if (true) {
      var ethField = document.getElementsByClassName("ethField")[0];

      (0,_home_angel_projects_web3_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(Array(80)).forEach(function () {
        var eth = document.createElement("img");
        eth.setAttribute("src", "/eth.png");
        eth.setAttribute("class", "star");
        eth.style.height = "4rem";
        eth.style.opacity = "0.2";
        gsap__WEBPACK_IMPORTED_MODULE_5__.gsap.fromTo(eth, {
          autoAlpha: 0,
          x: (0,gsap_src_all__WEBPACK_IMPORTED_MODULE_6__.random)(0, 100)
        }, {
          autoAlpha: 0.2,
          duration: 1
        });
        console.log("hello");
        ethField.appendChild(eth);
      });
    }
  });
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Box__WEBPACK_IMPORTED_MODULE_3__.default, {
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(EthField, {
      className: "ethField",
      zIndex: 1
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 29,
      columnNumber: 13
    }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_NavBar__WEBPACK_IMPORTED_MODULE_4__.default, {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 30,
      columnNumber: 13
    }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Box__WEBPACK_IMPORTED_MODULE_3__.default, {
      column: true,
      center: true,
      textAlign: "center",
      mx: "1.8rem",
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Box__WEBPACK_IMPORTED_MODULE_3__.default, {
        maxWidth: "110rem",
        fontSize: {
          mobileXs: "3.2rem",
          tabletMd: "6.8rem"
        },
        mt: ["14rem", "26rem"],
        color: "purple-text",
        children: "Interact Your Apps with the Ethereum Blockchain"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 32,
        columnNumber: 17
      }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Box__WEBPACK_IMPORTED_MODULE_3__.default, {
        fontSize: {
          mobileXs: "1.6rem",
          tabletMd: "2.4rem"
        },
        maxWidth: "60rem",
        fontWeight: "6000",
        mt: {
          mobileXs: "2rem",
          tabletMd: "5rem"
        },
        color: "purple-50",
        children: "Web3.js is a collection of libraries that allow you to interact with a local or remote ethereum node using HTTP, IPC or WebSocket."
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 40,
        columnNumber: 17
      }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("a", {
        href: "https://web3js.readthedocs.io/en/v1.3.4/",
        target: "_self",
        children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(DocumentationButton, {
          as: "button",
          bg: "purple-text",
          fontSize: {
            mobileXs: "1.6rem",
            tabletMd: "2rem"
          },
          p: {
            mobileXs: "1rem",
            tabletMd: "2rem"
          },
          mt: {
            mobileXs: "2rem",
            tabletMd: "4rem"
          },
          border: "none",
          borderRadius: "0.5rem",
          color: "white-100",
          cursor: "pointer",
          children: "Documentation"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 50,
          columnNumber: 21
        }, _this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 49,
        columnNumber: 17
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 31,
      columnNumber: 13
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 28,
    columnNumber: 9
  }, _this);
};

_s(HomeComp, "OD7bBpZva5O2jO+Puf00hKivP7c=");

_c = HomeComp;
var DocumentationButton = (0,styled_components__WEBPACK_IMPORTED_MODULE_7__.default)(_components_Box__WEBPACK_IMPORTED_MODULE_3__.default)(function (props) {
  return "\n    transition: transform ease-in 150ms;\n    transform-origin: 50% 50%;\n    \n    &:hover {\n        transform: scale(1.05);\n    }\n";
});
var EthField = (0,styled_components__WEBPACK_IMPORTED_MODULE_7__.default)(_components_Box__WEBPACK_IMPORTED_MODULE_3__.default)(function (pros) {
  return "\n    position: absolute;\n\n";
});
/* harmony default export */ __webpack_exports__["default"] = (HomeComp);

var _c;

$RefreshReg$(_c, "HomeComp");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/gsap/src/CSSPlugin.js":
/*!********************************************!*\
  !*** ./node_modules/gsap/src/CSSPlugin.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSSPlugin": function() { return /* binding */ CSSPlugin; },
/* harmony export */   "default": function() { return /* binding */ CSSPlugin; },
/* harmony export */   "_getBBox": function() { return /* binding */ _getBBox; },
/* harmony export */   "_createElement": function() { return /* binding */ _createElement; },
/* harmony export */   "checkPrefix": function() { return /* binding */ _checkPropPrefix; }
/* harmony export */ });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./node_modules/gsap/src/gsap-core.js");
/*!
 * CSSPlugin 3.7.0
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */



let _win, _doc, _docElement, _pluginInitted, _tempDiv, _tempDivStyler, _recentSetterPlugin,
	_windowExists = () => typeof(window) !== "undefined",
	_transformProps = {},
	_RAD2DEG = 180 / Math.PI,
	_DEG2RAD = Math.PI / 180,
	_atan2 = Math.atan2,
	_bigNum = 1e8,
	_capsExp = /([A-Z])/g,
	_horizontalExp = /(?:left|right|width|margin|padding|x)/i,
	_complexExp = /[\s,\(]\S/,
	_propertyAliases = {autoAlpha:"opacity,visibility", scale:"scaleX,scaleY", alpha:"opacity"},
	_renderCSSProp = (ratio, data) => data.set(data.t, data.p, (Math.round((data.s + data.c * ratio) * 10000) / 10000) + data.u, data),
	_renderPropWithEnd = (ratio, data) => data.set(data.t, data.p, ratio === 1 ? data.e : (Math.round((data.s + data.c * ratio) * 10000) / 10000) + data.u, data),
	_renderCSSPropWithBeginning = (ratio, data) => data.set(data.t, data.p, ratio ? (Math.round((data.s + data.c * ratio) * 10000) / 10000) + data.u : data.b, data), //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
	_renderRoundedCSSProp = (ratio, data) => {
		let value = data.s + data.c * ratio;
		data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
	},
	_renderNonTweeningValue = (ratio, data) => data.set(data.t, data.p, ratio ? data.e : data.b, data),
	_renderNonTweeningValueOnlyAtEnd = (ratio, data) => data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data),
	_setterCSSStyle = (target, property, value) => target.style[property] = value,
	_setterCSSProp = (target, property, value) => target.style.setProperty(property, value),
	_setterTransform = (target, property, value) => target._gsap[property] = value,
	_setterScale = (target, property, value) => target._gsap.scaleX = target._gsap.scaleY = value,
	_setterScaleWithRender = (target, property, value, data, ratio) => {
		let cache = target._gsap;
		cache.scaleX = cache.scaleY = value;
		cache.renderTransform(ratio, cache);
	},
	_setterTransformWithRender = (target, property, value, data, ratio) => {
		let cache = target._gsap;
		cache[property] = value;
		cache.renderTransform(ratio, cache);
	},
	_transformProp = "transform",
	_transformOriginProp = _transformProp + "Origin",
	_supports3D,
	_createElement = (type, ns) => {
		let e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.
		return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
	},
	_getComputedProperty = (target, property, skipPrefixFallback) => {
		let cs = getComputedStyle(target);
		return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || (!skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1)) || ""; //css variables may not need caps swapped out for dashes and lowercase.
	},
	_prefixes = "O,Moz,ms,Ms,Webkit".split(","),
	_checkPropPrefix = (property, element, preferPrefix) => {
		let e = element || _tempDiv,
			s = e.style,
			i = 5;
		if (property in s && !preferPrefix) {
			return property;
		}
		property = property.charAt(0).toUpperCase() + property.substr(1);
		while (i-- && !((_prefixes[i]+property) in s)) { }
		return (i < 0) ? null : ((i === 3) ? "ms" : (i >= 0) ? _prefixes[i] : "") + property;
	},
	_initCore = () => {
		if (_windowExists() && window.document) {
			_win = window;
			_doc = _win.document;
			_docElement = _doc.documentElement;
			_tempDiv = _createElement("div") || {style:{}};
			_tempDivStyler = _createElement("div");
			_transformProp = _checkPropPrefix(_transformProp);
			_transformOriginProp = _transformProp + "Origin";
			_tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.
			_supports3D = !!_checkPropPrefix("perspective");
			_pluginInitted = 1;
		}
	},
	_getBBoxHack = function(swapIfPossible) { //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
		let svg = _createElement("svg", (this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns")) || "http://www.w3.org/2000/svg"),
			oldParent = this.parentNode,
			oldSibling = this.nextSibling,
			oldCSS = this.style.cssText,
			bbox;
		_docElement.appendChild(svg);
		svg.appendChild(this);
		this.style.display = "block";
		if (swapIfPossible) {
			try {
				bbox = this.getBBox();
				this._gsapBBox = this.getBBox; //store the original
				this.getBBox = _getBBoxHack;
			} catch (e) { }
		} else if (this._gsapBBox) {
			bbox = this._gsapBBox();
		}
		if (oldParent) {
			if (oldSibling) {
				oldParent.insertBefore(this, oldSibling);
			} else {
				oldParent.appendChild(this);
			}
		}
		_docElement.removeChild(svg);
		this.style.cssText = oldCSS;
		return bbox;
	},
	_getAttributeFallbacks = (target, attributesArray) => {
		let i = attributesArray.length;
		while (i--) {
			if (target.hasAttribute(attributesArray[i])) {
				return target.getAttribute(attributesArray[i]);
			}
		}
	},
	_getBBox = target => {
		let bounds;
		try {
			bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
		} catch (error) {
			bounds = _getBBoxHack.call(target, true);
		}
		(bounds && (bounds.width || bounds.height)) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
		//some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.
		return (bounds && !bounds.width && !bounds.x && !bounds.y) ? {x: +_getAttributeFallbacks(target, ["x","cx","x1"]) || 0, y:+_getAttributeFallbacks(target, ["y","cy","y1"]) || 0, width:0, height:0} : bounds;
	},
	_isSVG = e => !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e)), //reports if the element is an SVG on which getBBox() actually works
	_removeProperty = (target, property) => {
		if (property) {
			let style = target.style;
			if (property in _transformProps && property !== _transformOriginProp) {
				property = _transformProp;
			}
			if (style.removeProperty) {
				if (property.substr(0,2) === "ms" || property.substr(0,6) === "webkit") { //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
					property = "-" + property;
				}
				style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
			} else { //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
				style.removeAttribute(property);
			}
		}
	},
	_addNonTweeningPT = (plugin, target, property, beginning, end, onlySetAtEnd) => {
		let pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
		plugin._pt = pt;
		pt.b = beginning;
		pt.e = end;
		plugin._props.push(property);
		return pt;
	},
	_nonConvertibleUnits = {deg:1, rad:1, turn:1},
	//takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
	_convertToUnit = (target, property, value, unit) => {
		let curValue = parseFloat(value) || 0,
			curUnit = (value + "").trim().substr((curValue + "").length) || "px", // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
			style = _tempDiv.style,
			horizontal = _horizontalExp.test(property),
			isRootSVG = target.tagName.toLowerCase() === "svg",
			measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
			amount = 100,
			toPixels = unit === "px",
			toPercent = unit === "%",
			px, parent, cache, isSVG;
		if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
			return curValue;
		}
		(curUnit !== "px" && !toPixels) && (curValue = _convertToUnit(target, property, value, "px"));
		isSVG = target.getCTM && _isSVG(target);
		if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
			px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
			return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPercent ? curValue / px * amount : curValue / 100 * px);
		}
		style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
		parent = (~property.indexOf("adius") || (unit === "em" && target.appendChild && !isRootSVG)) ? target : target.parentNode;
		if (isSVG) {
			parent = (target.ownerSVGElement || {}).parentNode;
		}
		if (!parent || parent === _doc || !parent.appendChild) {
			parent = _doc.body;
		}
		cache = parent._gsap;
		if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time) {
			return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(curValue / cache.width * amount);
		} else {
			(toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));
			(parent === target) && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.
			parent.appendChild(_tempDiv);
			px = _tempDiv[measureProperty];
			parent.removeChild(_tempDiv);
			style.position = "absolute";
			if (horizontal && toPercent) {
				cache = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(parent);
				cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time;
				cache.width = parent[measureProperty];
			}
		}
		return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
	},
	_get = (target, property, unit, uncache) => {
		let value;
		_pluginInitted || _initCore();
		if ((property in _propertyAliases) && property !== "transform") {
			property = _propertyAliases[property];
			if (~property.indexOf(",")) {
				property = property.split(",")[0];
			}
		}
		if (_transformProps[property] && property !== "transform") {
			value = _parseTransform(target, uncache);
			value = (property !== "transformOrigin") ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
		} else {
			value = target.style[property];
			if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
				value = (_specialProps[property] && _specialProps[property](target, property, unit)) || _getComputedProperty(target, property) || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getProperty)(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
			}
		}
		return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;

	},
	_tweenComplexCSSString = function(target, prop, start, end) { //note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
		if (!start || start === "none") { // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/
			let p = _checkPropPrefix(prop, target, 1),
				s = p && _getComputedProperty(target, p, 1);
			if (s && s !== start) {
				prop = p;
				start = s;
			} else if (prop === "borderColor") {
				start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
			}
		}
		let pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._renderComplexString),
			index = 0,
			matchIndex = 0,
			a, result,	startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, relative, endValues;
		pt.b = start;
		pt.e = end;
		start += ""; //ensure values are strings
		end += "";
		if (end === "auto") {
			target.style[prop] = end;
			end = _getComputedProperty(target, prop) || end;
			target.style[prop] = start;
		}
		a = [start, end];
		(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorStringFilter)(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().
		start = a[0];
		end = a[1];
		startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];
		endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];
		if (endValues.length) {
			while ((result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.exec(end))) {
				endValue = result[0];
				chunk = end.substring(index, result.index);
				if (color) {
					color = (color + 1) % 5;
				} else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
					color = 1;
				}
				if (endValue !== (startValue = startValues[matchIndex++] || "")) {
					startNum = parseFloat(startValue) || 0;
					startUnit = startValue.substr((startNum + "").length);
					relative = (endValue.charAt(1) === "=") ? +(endValue.charAt(0) + "1") : 0;
					if (relative) {
						endValue = endValue.substr(2);
					}
					endNum = parseFloat(endValue);
					endUnit = endValue.substr((endNum + "").length);
					index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.lastIndex - endUnit.length;
					if (!endUnit) { //if something like "perspective:300" is passed in and we must add a unit to the end
						endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[prop] || startUnit;
						if (index === end.length) {
							end += endUnit;
							pt.e += endUnit;
						}
					}
					if (startUnit !== endUnit) {
						startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
					}
					//these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.
					pt._pt = {
						_next:pt._pt,
						p:(chunk || (matchIndex === 1)) ? chunk : ",", //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
						s:startNum,
						c:relative ? relative * endNum : endNum - startNum,
						m:(color && color < 4) || prop === "zIndex" ? Math.round : 0
					};
				}
			}
			pt.c = (index < end.length) ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
		} else {
			pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
		}
		_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
		this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.
		return pt;
	},
	_keywordToPercent = {top:"0%", bottom:"100%", left:"0%", right:"100%", center:"50%"},
	_convertKeywordsToPercentages = value => {
		let split = value.split(" "),
			x = split[0],
			y = split[1] || "50%";
		if (x === "top" || x === "bottom" || y === "left" || y === "right") { //the user provided them in the wrong order, so flip them
			value = x;
			x = y;
			y = value;
		}
		split[0] = _keywordToPercent[x] || x;
		split[1] = _keywordToPercent[y] || y;
		return split.join(" ");
	},
	_renderClearProps = (ratio, data) => {
		if (data.tween && data.tween._time === data.tween._dur) {
			let target = data.t,
				style = target.style,
				props = data.u,
				cache = target._gsap,
				prop, clearTransforms, i;
			if (props === "all" || props === true) {
				style.cssText = "";
				clearTransforms = 1;
			} else {
				props = props.split(",");
				i = props.length;
				while (--i > -1) {
					prop = props[i];
					if (_transformProps[prop]) {
						clearTransforms = 1;
						prop = (prop === "transformOrigin") ? _transformOriginProp : _transformProp;
					}
					_removeProperty(target, prop);
				}
			}
			if (clearTransforms) {
				_removeProperty(target, _transformProp);
				if (cache) {
					cache.svg && target.removeAttribute("transform");
					_parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.
					cache.uncache = 1;
				}
			}
		}
	},
	// note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
	_specialProps = {
		clearProps(plugin, target, property, endValue, tween) {
			if (tween.data !== "isFromStart") {
				let pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
				pt.u = endValue;
				pt.pr = -10;
				pt.tween = tween;
				plugin._props.push(property);
				return 1;
			}
		}
		/* className feature (about 0.4kb gzipped).
		, className(plugin, target, property, endValue, tween) {
			let _renderClassName = (ratio, data) => {
					data.css.render(ratio, data.css);
					if (!ratio || ratio === 1) {
						let inline = data.rmv,
							target = data.t,
							p;
						target.setAttribute("class", ratio ? data.e : data.b);
						for (p in inline) {
							_removeProperty(target, p);
						}
					}
				},
				_getAllStyles = (target) => {
					let styles = {},
						computed = getComputedStyle(target),
						p;
					for (p in computed) {
						if (isNaN(p) && p !== "cssText" && p !== "length") {
							styles[p] = computed[p];
						}
					}
					_setDefaults(styles, _parseTransform(target, 1));
					return styles;
				},
				startClassList = target.getAttribute("class"),
				style = target.style,
				cssText = style.cssText,
				cache = target._gsap,
				classPT = cache.classPT,
				inlineToRemoveAtEnd = {},
				data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
				changingVars = {},
				startVars = _getAllStyles(target),
				transformRelated = /(transform|perspective)/i,
				endVars, p;
			if (classPT) {
				classPT.r(1, classPT.d);
				_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
			}
			target.setAttribute("class", data.e);
			endVars = _getAllStyles(target, true);
			target.setAttribute("class", startClassList);
			for (p in endVars) {
				if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
					changingVars[p] = endVars[p];
					if (!style[p] && style[p] !== "0") {
						inlineToRemoveAtEnd[p] = 1;
					}
				}
			}
			cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
			if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
				style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
			}
			_parseTransform(target, true); //to clear the caching of transforms
			data.css = new gsap.plugins.css();
			data.css.init(target, changingVars, tween);
			plugin._props.push(...data.css._props);
			return 1;
		}
		*/
	},





	/*
	 * --------------------------------------------------------------------------------------
	 * TRANSFORMS
	 * --------------------------------------------------------------------------------------
	 */
	_identity2DMatrix = [1,0,0,1,0,0],
	_rotationalProperties = {},
	_isNullTransform = value => (value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value),
	_getComputedTransformMatrixAsArray = target => {
		let matrixString = _getComputedProperty(target, _transformProp);
		return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numExp).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round);
	},
	_getMatrix = (target, force2D) => {
		let cache = target._gsap || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(target),
			style = target.style,
			matrix = _getComputedTransformMatrixAsArray(target),
			parent, nextSibling, temp, addedToDOM;
		if (cache.svg && target.getAttribute("transform")) {
			temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.
			matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
			return (matrix.join(",") === "1,0,0,1,0,0") ? _identity2DMatrix : matrix;
		} else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) { //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
			//browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
			temp = style.display;
			style.display = "block";
			parent = target.parentNode;
			if (!parent || !target.offsetParent) { // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375
				addedToDOM = 1; //flag
				nextSibling = target.nextSibling;
				_docElement.appendChild(target); //we must add it to the DOM in order to get values properly
			}
			matrix = _getComputedTransformMatrixAsArray(target);
			temp ? (style.display = temp) : _removeProperty(target, "display");
			if (addedToDOM) {
				nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
			}
		}
		return (force2D && matrix.length > 6) ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
	},
	_applySVGOrigin = (target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) => {
		let cache = target._gsap,
			matrix = matrixArray || _getMatrix(target, true),
			xOriginOld = cache.xOrigin || 0,
			yOriginOld = cache.yOrigin || 0,
			xOffsetOld = cache.xOffset || 0,
			yOffsetOld = cache.yOffset || 0,
			a = matrix[0],
			b = matrix[1],
			c = matrix[2],
			d = matrix[3],
			tx = matrix[4],
			ty = matrix[5],
			originSplit = origin.split(" "),
			xOrigin = parseFloat(originSplit[0]) || 0,
			yOrigin = parseFloat(originSplit[1]) || 0,
			bounds, determinant, x, y;
		if (!originIsAbsolute) {
			bounds = _getBBox(target);
			xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
			yOrigin = bounds.y + (~((originSplit[1] || originSplit[0]).indexOf("%")) ? yOrigin / 100 * bounds.height : yOrigin);
		} else if (matrix !== _identity2DMatrix && (determinant = (a * d - b * c))) { //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
			x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + ((c * ty - d * tx) / determinant);
			y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - ((a * ty - b * tx) / determinant);
			xOrigin = x;
			yOrigin = y;
		}
		if (smooth || (smooth !== false && cache.smooth)) {
			tx = xOrigin - xOriginOld;
			ty = yOrigin - yOriginOld;
			cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
			cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
		} else {
			cache.xOffset = cache.yOffset = 0;
		}
		cache.xOrigin = xOrigin;
		cache.yOrigin = yOrigin;
		cache.smooth = !!smooth;
		cache.origin = origin;
		cache.originIsAbsolute = !!originIsAbsolute;
		target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).
		if (pluginToAddPropTweensTo) {
			_addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
			_addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
			_addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
			_addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
		}
		target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
	},
	_parseTransform = (target, uncache) => {
		let cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.GSCache(target);
		if ("x" in cache && !uncache && !cache.uncache) {
			return cache;
		}
		let style = target.style,
			invertedScaleX = cache.scaleX < 0,
			px = "px",
			deg = "deg",
			origin = _getComputedProperty(target, _transformOriginProp) || "0",
			x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin,
			matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;
		x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
		scaleX = scaleY = 1;
		cache.svg = !!(target.getCTM && _isSVG(target));
		matrix = _getMatrix(target, cache.svg);
		if (cache.svg) {
			t1 = (!cache.uncache || origin === "0px 0px") && !uncache && target.getAttribute("data-svg-origin"); // if origin is 0,0 and cache.uncache is true, let the recorded data-svg-origin stay. Otherwise, whenever we set cache.uncache to true, we'd need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.
			_applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
		}
		xOrigin = cache.xOrigin || 0;
		yOrigin = cache.yOrigin || 0;
		if (matrix !== _identity2DMatrix) {
			a = matrix[0]; //a11
			b = matrix[1]; //a21
			c = matrix[2]; //a31
			d = matrix[3]; //a41
			x = a12 = matrix[4];
			y = a22 = matrix[5];

			//2D matrix
			if (matrix.length === 6) {
				scaleX = Math.sqrt(a * a + b * b);
				scaleY = Math.sqrt(d * d + c * c);
				rotation = (a || b) ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
				skewX = (c || d) ? _atan2(c, d) * _RAD2DEG + rotation : 0;
				skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
				if (cache.svg) {
					x -= xOrigin - (xOrigin * a + yOrigin * c);
					y -= yOrigin - (xOrigin * b + yOrigin * d);
				}

			//3D matrix
			} else {
				a32 = matrix[6];
				a42 = matrix[7];
				a13 = matrix[8];
				a23 = matrix[9];
				a33 = matrix[10];
				a43 = matrix[11];
				x = matrix[12];
				y = matrix[13];
				z = matrix[14];

				angle = _atan2(a32, a33);
				rotationX = angle * _RAD2DEG;
				//rotationX
				if (angle) {
					cos = Math.cos(-angle);
					sin = Math.sin(-angle);
					t1 = a12*cos+a13*sin;
					t2 = a22*cos+a23*sin;
					t3 = a32*cos+a33*sin;
					a13 = a12*-sin+a13*cos;
					a23 = a22*-sin+a23*cos;
					a33 = a32*-sin+a33*cos;
					a43 = a42*-sin+a43*cos;
					a12 = t1;
					a22 = t2;
					a32 = t3;
				}
				//rotationY
				angle = _atan2(-c, a33);
				rotationY = angle * _RAD2DEG;
				if (angle) {
					cos = Math.cos(-angle);
					sin = Math.sin(-angle);
					t1 = a*cos-a13*sin;
					t2 = b*cos-a23*sin;
					t3 = c*cos-a33*sin;
					a43 = d*sin+a43*cos;
					a = t1;
					b = t2;
					c = t3;
				}
				//rotationZ
				angle = _atan2(b, a);
				rotation = angle * _RAD2DEG;
				if (angle) {
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					t1 = a*cos+b*sin;
					t2 = a12*cos+a22*sin;
					b = b*cos-a*sin;
					a22 = a22*cos-a12*sin;
					a = t1;
					a12 = t2;
				}

				if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) { //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
					rotationX = rotation = 0;
					rotationY = 180 - rotationY;
				}
				scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a * a + b * b + c * c));
				scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a22 * a22 + a32 * a32));
				angle = _atan2(a12, a22);
				skewX = (Math.abs(angle) > 0.0002) ? angle * _RAD2DEG : 0;
				perspective = a43 ? 1 / ((a43 < 0) ? -a43 : a43) : 0;
			}

			if (cache.svg) { //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
				t1 = target.getAttribute("transform");
				cache.forceCSS = target.setAttribute("transform", "") || (!_isNullTransform(_getComputedProperty(target, _transformProp)));
				t1 && target.setAttribute("transform", t1);
			}
		}

		if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
			if (invertedScaleX) {
				scaleX *= -1;
				skewX += (rotation <= 0) ? 180 : -180;
				rotation += (rotation <= 0) ? 180 : -180;
			} else {
				scaleY *= -1;
				skewX += (skewX <= 0) ? 180 : -180;
			}
		}
		cache.x = x - ((cache.xPercent = x && (cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
		cache.y = y - ((cache.yPercent = y && (cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
		cache.z = z + px;
		cache.scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleX);
		cache.scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleY);
		cache.rotation = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotation) + deg;
		cache.rotationX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationX) + deg;
		cache.rotationY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationY) + deg;
		cache.skewX = skewX + deg;
		cache.skewY = skewY + deg;
		cache.transformPerspective = perspective + px;
		if ((cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0)) {
			style[_transformOriginProp] = _firstTwoOnly(origin);
		}
		cache.xOffset = cache.yOffset = 0;
		cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.force3D;
		cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
		cache.uncache = 0;
		return cache;
	},
	_firstTwoOnly = value => (value = value.split(" "))[0] + " " + value[1], //for handling transformOrigin values, stripping out the 3rd dimension
	_addPxTranslate = (target, start, value) => {
		let unit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(start);
		return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
	},
	_renderNon3DTransforms = (ratio, cache) => {
		cache.z = "0px";
		cache.rotationY = cache.rotationX = "0deg";
		cache.force3D = 0;
		_renderCSSTransforms(ratio, cache);
	},
	_zeroDeg = "0deg",
	_zeroPx = "0px",
	_endParenthesis = ") ",
	_renderCSSTransforms = function(ratio, cache) {
		let {xPercent, yPercent, x, y, z, rotation, rotationY, rotationX, skewX, skewY, scaleX, scaleY, transformPerspective, force3D, target, zOrigin} = cache || this,
			transforms = "",
			use3D = (force3D === "auto" && ratio && ratio !== 1) || force3D === true;

		// Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)
		if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
			let angle = parseFloat(rotationY) * _DEG2RAD,
				a13 = Math.sin(angle),
				a33 = Math.cos(angle),
				cos;
			angle = parseFloat(rotationX) * _DEG2RAD;
			cos = Math.cos(angle);
			x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
			y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
			z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
		}

		if (transformPerspective !== _zeroPx) {
			transforms += "perspective(" + transformPerspective + _endParenthesis;
		}
		if (xPercent || yPercent) {
			transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
		}
		if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
			transforms += (z !== _zeroPx || use3D) ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
		}
		if (rotation !== _zeroDeg) {
			transforms += "rotate(" + rotation + _endParenthesis;
		}
		if (rotationY !== _zeroDeg) {
			transforms += "rotateY(" + rotationY + _endParenthesis;
		}
		if (rotationX !== _zeroDeg) {
			transforms += "rotateX(" + rotationX + _endParenthesis;
		}
		if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
			transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
		}
		if (scaleX !== 1 || scaleY !== 1) {
			transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
		}
		target.style[_transformProp] = transforms || "translate(0, 0)";
	},
	_renderSVGTransforms = function(ratio, cache) {
		let {xPercent, yPercent, x, y, rotation, skewX, skewY, scaleX, scaleY, target, xOrigin, yOrigin, xOffset, yOffset, forceCSS} = cache || this,
			tx = parseFloat(x),
			ty = parseFloat(y),
			a11, a21, a12, a22, temp;
		rotation = parseFloat(rotation);
		skewX = parseFloat(skewX);
		skewY = parseFloat(skewY);
		if (skewY) { //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
			skewY = parseFloat(skewY);
			skewX += skewY;
			rotation += skewY;
		}
		if (rotation || skewX) {
			rotation *= _DEG2RAD;
			skewX *= _DEG2RAD;
			a11 = Math.cos(rotation) * scaleX;
			a21 = Math.sin(rotation) * scaleX;
			a12 = Math.sin(rotation - skewX) * -scaleY;
			a22 = Math.cos(rotation - skewX) * scaleY;
			if (skewX) {
				skewY *= _DEG2RAD;
				temp = Math.tan(skewX - skewY);
				temp = Math.sqrt(1 + temp * temp);
				a12 *= temp;
				a22 *= temp;
				if (skewY) {
					temp = Math.tan(skewY);
					temp = Math.sqrt(1 + temp * temp);
					a11 *= temp;
					a21 *= temp;
				}
			}
			a11 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a11);
			a21 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a21);
			a12 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a12);
			a22 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a22);
		} else {
			a11 = scaleX;
			a22 = scaleY;
			a21 = a12 = 0;
		}
		if ((tx && !~(x + "").indexOf("px")) || (ty && !~(y + "").indexOf("px"))) {
			tx = _convertToUnit(target, "x", x, "px");
			ty = _convertToUnit(target, "y", y, "px");
		}
		if (xOrigin || yOrigin || xOffset || yOffset) {
			tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
			ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
		}
		if (xPercent || yPercent) {
			//The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
			temp = target.getBBox();
			tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xPercent / 100 * temp.width);
			ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yPercent / 100 * temp.height);
		}
		temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
		target.setAttribute("transform", temp);
		forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the  transform attribute changes!)
	},
	_addRotationalPropTween = function(plugin, target, property, startNum, endValue, relative) {
		let cap = 360,
			isString = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(endValue),
			endNum = parseFloat(endValue) * ((isString && ~endValue.indexOf("rad")) ? _RAD2DEG : 1),
			change = relative ? endNum * relative : endNum - startNum,
			finalValue = (startNum + change) + "deg",
			direction, pt;
		if (isString) {
			direction = endValue.split("_")[1];
			if (direction === "short") {
				change %= cap;
				if (change !== change % (cap / 2)) {
					change += (change < 0) ? cap : -cap;
				}
			}
			if (direction === "cw" && change < 0) {
				change = ((change + cap * _bigNum) % cap) - ~~(change / cap) * cap;
			} else if (direction === "ccw" && change > 0) {
				change = ((change - cap * _bigNum) % cap) - ~~(change / cap) * cap;
			}
		}
		plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
		pt.e = finalValue;
		pt.u = "deg";
		plugin._props.push(property);
		return pt;
	},
	_assign = (target, source) => { // Internet Explorer doesn't have Object.assign(), so we recreate it here.
		for (let p in source) {
			target[p] = source[p];
		}
		return target;
	},
	_addRawTransformPTs = (plugin, transforms, target) => { //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
		let startCache = _assign({}, target._gsap),
			exclude = "perspective,force3D,transformOrigin,svgOrigin",
			style = target.style,
			endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit;
		if (startCache.svg) {
			startValue = target.getAttribute("transform");
			target.setAttribute("transform", "");
			style[_transformProp] = transforms;
			endCache = _parseTransform(target, 1);
			_removeProperty(target, _transformProp);
			target.setAttribute("transform", startValue);
		} else {
			startValue = getComputedStyle(target)[_transformProp];
			style[_transformProp] = transforms;
			endCache = _parseTransform(target, 1);
			style[_transformProp] = startValue;
		}
		for (p in _transformProps) {
			startValue = startCache[p];
			endValue = endCache[p];
			if (startValue !== endValue && exclude.indexOf(p) < 0) { //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
				startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);
				endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);
				startNum = (startUnit !== endUnit) ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
				endNum = parseFloat(endValue);
				plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
				plugin._pt.u = endUnit || 0;
				plugin._props.push(p);
			}
		}
		_assign(endCache, startCache);
	};

// handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.
(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("padding,margin,Width,Radius", (name, index) => {
	let t = "Top",
		r = "Right",
		b = "Bottom",
		l = "Left",
		props = (index < 3 ? [t,r,b,l] : [t+l, t+r, b+r, b+l]).map(side => index < 2 ? name + side : "border" + side + name);
	_specialProps[(index > 1 ? "border" + name : name)] = function(plugin, target, property, endValue, tween) {
		let a, vars;
		if (arguments.length < 4) { // getter, passed target, property, and unit (from _get())
			a = props.map(prop => _get(plugin, prop, property));
			vars = a.join(" ");
			return vars.split(a[0]).length === 5 ? a[0] : vars;
		}
		a = (endValue + "").split(" ");
		vars = {};
		props.forEach((prop, i) => vars[prop] = a[i] = a[i] || a[(((i - 1) / 2) | 0)]);
		plugin.init(target, vars, tween);
	}
});


const CSSPlugin = {
	name: "css",
	register: _initCore,
	targetTest(target) {
		return target.style && target.nodeType;
	},
	init(target, vars, tween, index, targets) {
		let props = this._props,
			style = target.style,
			startAt = tween.vars.startAt,
			startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority;
		_pluginInitted || _initCore();
		for (p in vars) {
			if (p === "autoRound") {
				continue;
			}
			endValue = vars[p];
			if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._plugins[p] && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._checkPlugin)(p, vars, tween, index, target, targets)) { // plugins
				continue;
			}
			type = typeof(endValue);
			specialProp = _specialProps[p];
			if (type === "function") {
				endValue = endValue.call(tween, index, target, targets);
				type = typeof(endValue);
			}
			if (type === "string" && ~endValue.indexOf("random(")) {
				endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(endValue);
			}
			if (specialProp) {
				specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
			} else if (p.substr(0,2) === "--") { //CSS variable
				startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
				endValue += "";
				_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.lastIndex = 0;
				if (!_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.test(startValue)) { // colors don't have units
					startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);
					endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);
				}
				endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
				this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
				props.push(p);
			} else if (type !== "undefined") {
				if (startAt && p in startAt) { // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
					startValue = typeof(startAt[p]) === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
					(p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units) && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue) && (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p]); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.
					(startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
				} else {
					startValue = _get(target, p);
				}
				startNum = parseFloat(startValue);
				relative = (type === "string" && endValue.charAt(1) === "=") ? +(endValue.charAt(0) + "1") : 0;
				relative && (endValue = endValue.substr(2));
				endNum = parseFloat(endValue);
				if (p in _propertyAliases) {
					if (p === "autoAlpha") { //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
						if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) { //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
							startNum = 0;
						}
						_addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
					}
					if (p !== "scale" && p !== "transform") {
						p = _propertyAliases[p];
						~p.indexOf(",") && (p = p.split(",")[0]);
					}
				}

				isTransformRelated = (p in _transformProps);

				//--- TRANSFORM-RELATED ---
				if (isTransformRelated) {
					if (!transformPropTween) {
						cache = target._gsap;
						(cache.renderTransform && !vars.parseTransform) || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.
						smooth = (vars.smoothOrigin !== false && cache.smooth);
						transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)
						transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
					}
					if (p === "scale") {
						this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? relative * endNum : endNum - cache.scaleY) || 0);
						props.push("scaleY", p);
						p += "X";
					} else if (p === "transformOrigin") {
						endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.
						if (cache.svg) {
							_applySVGOrigin(target, endValue, 0, smooth, 0, this);
						} else {
							endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!
							endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
							_addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
						}
						continue;
					} else if (p === "svgOrigin") {
						_applySVGOrigin(target, endValue, 1, smooth, 0, this);
						continue;
					} else if (p in _rotationalProperties) {
						_addRotationalPropTween(this, cache, p, startNum, endValue, relative);
						continue;

					} else if (p === "smoothOrigin") {
						_addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
						continue;
					} else if (p === "force3D") {
						cache[p] = endValue;
						continue;
					} else if (p === "transform") {
						_addRawTransformPTs(this, endValue, target);
						continue;
					}
				} else if (!(p in style)) {
					p = _checkPropPrefix(p) || p;
				}

				if (isTransformRelated || ((endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && (p in style))) {
					startUnit = (startValue + "").substr((startNum + "").length);
					endNum || (endNum = 0); // protect against NaN
					endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue) || ((p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units) ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] : startUnit);
					startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
					this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, relative ? relative * endNum : endNum - startNum, (!isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false) ? _renderRoundedCSSProp : _renderCSSProp);
					this._pt.u = endUnit || 0;
					if (startUnit !== endUnit) { //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
						this._pt.b = startValue;
						this._pt.r = _renderCSSPropWithBeginning;
					}
				} else if (!(p in style)) {
					if (p in target) { //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
						this.add(target, p, startValue || target[p], endValue, index, targets);
					} else {
						(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._missingPlugin)(p, endValue);
						continue;
					}
				} else {
					_tweenComplexCSSString.call(this, target, p, startValue, endValue);
				}
				props.push(p);
			}
		}
		hasPriority && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._sortPropTweensByPriority)(this);

	},
	get: _get,
	aliases: _propertyAliases,
	getSetter(target, property, plugin) { //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
		let p = _propertyAliases[property];
		(p && p.indexOf(",") < 0) && (property = p);
		return (property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x"))) ? (plugin && _recentSetterPlugin === plugin ? (property === "scale" ? _setterScale : _setterTransform) : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender)) : target.style && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getSetter)(target, property);
	},
	core: { _removeProperty, _getMatrix }

};

_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.utils.checkPrefix = _checkPropPrefix;
(function(positionAndScale, rotation, others, aliases) {
	let all = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(positionAndScale + "," + rotation + "," + others, name => {_transformProps[name] = 1});
	(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(rotation, name => {_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "deg"; _rotationalProperties[name] = 1});
	_propertyAliases[all[13]] = positionAndScale + "," + rotation;
	(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(aliases, name => {
		let split = name.split(":");
		_propertyAliases[split[1]] = all[split[0]];
	});
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", name => {_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "px"});

_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(CSSPlugin);



/***/ }),

/***/ "./node_modules/gsap/src/CSSRulePlugin.js":
/*!************************************************!*\
  !*** ./node_modules/gsap/src/CSSRulePlugin.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSSRulePlugin": function() { return /* binding */ CSSRulePlugin; },
/* harmony export */   "default": function() { return /* binding */ CSSRulePlugin; }
/* harmony export */ });
/*!
 * CSSRulePlugin 3.7.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */

let gsap, _coreInitted, _win, _doc, CSSPlugin,
	_windowExists = () => typeof(window) !== "undefined",
	_getGSAP = () => gsap || (_windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap),
	_checkRegister = () => {
		if (!_coreInitted) {
			_initCore();
			if (!CSSPlugin) {
				console.warn("Please gsap.registerPlugin(CSSPlugin, CSSRulePlugin)");
			}
		}
		return _coreInitted;
	},
	_initCore = core => {
		gsap = core || _getGSAP();
		if (_windowExists()) {
			_win = window;
			_doc = document;
		}
		if (gsap) {
			CSSPlugin = gsap.plugins.css;
			if (CSSPlugin) {
				_coreInitted = 1;
			}
		}
	};


const CSSRulePlugin = {
	version: "3.7.0",
	name: "cssRule",
	init(target, value, tween, index, targets) {
		if (!_checkRegister() || typeof(target.cssText) === "undefined") {
			return false;
		}
		let div = target._gsProxy = target._gsProxy || _doc.createElement("div");
		this.ss = target;
		this.style = div.style;
		div.style.cssText = target.cssText;
		CSSPlugin.prototype.init.call(this, div, value, tween, index, targets); //we just offload all the work to the regular CSSPlugin and then copy the cssText back over to the rule in the render() method. This allows us to have all of the updates to CSSPlugin automatically flow through to CSSRulePlugin instead of having to maintain both
	},
	render(ratio, data) {
		let pt = data._pt,
			style = data.style,
			ss = data.ss,
			i;
		while (pt) {
			pt.r(ratio, pt.d);
			pt = pt._next;
		}
		i = style.length;
		while (--i > -1) {
			ss[style[i]] = style[style[i]];
		}
	},
	getRule(selector) {
		_checkRegister();
		let ruleProp = _doc.all ? "rules" : "cssRules",
			styleSheets = _doc.styleSheets,
			i = styleSheets.length,
			pseudo = (selector.charAt(0) === ":"),
			j, curSS, cs, a;
		selector = (pseudo ? "" : ",") + selector.split("::").join(":").toLowerCase() + ","; //note: old versions of IE report tag name selectors as upper case, so we just change everything to lowercase.
		if (pseudo) {
			a = [];
		}
		while (i--) {
			//Firefox may throw insecure operation errors when css is loaded from other domains, so try/catch.
			try {
				curSS = styleSheets[i][ruleProp];
				if (!curSS) {
					continue;
				}
				j = curSS.length;
			} catch (e) {
				console.warn(e);
				continue;
			}
			while (--j > -1) {
				cs = curSS[j];
				if (cs.selectorText && ("," + cs.selectorText.split("::").join(":").toLowerCase() + ",").indexOf(selector) !== -1) { //note: IE adds an extra ":" to pseudo selectors, so .myClass:after becomes .myClass::after, so we need to strip the extra one out.
					if (pseudo) {
						a.push(cs.style);
					} else {
						return cs.style;
					}
				}
			}
		}
		return a;
	},
	register: _initCore
};

_getGSAP() && gsap.registerPlugin(CSSRulePlugin);



/***/ }),

/***/ "./node_modules/gsap/src/Draggable.js":
/*!********************************************!*\
  !*** ./node_modules/gsap/src/Draggable.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Draggable": function() { return /* binding */ Draggable; },
/* harmony export */   "default": function() { return /* binding */ Draggable; }
/* harmony export */ });
/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/matrix.js */ "./node_modules/gsap/src/utils/matrix.js");
/*!
 * Draggable 3.7.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
/* eslint-disable */



let gsap, _win, _doc, _docElement, _body, _tempDiv, _placeholderDiv, _coreInitted, _checkPrefix, _toArray, _supportsPassive, _isTouchDevice, _touchEventLookup, _dragCount, _isMultiTouching, _isAndroid, InertiaPlugin, _defaultCursor, _supportsPointer,
	_windowExists = () => typeof(window) !== "undefined",
	_getGSAP = () => gsap || (_windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap),
	_isFunction = value => typeof(value) === "function",
	_isObject = value => typeof(value) === "object",
	_isUndefined = value => typeof(value) === "undefined",
	_emptyFunc = () => false,
	_transformProp = "transform",
	_transformOriginProp = "transformOrigin",
	_round = value => Math.round(value * 10000) / 10000,
	_isArray = Array.isArray,
	_createElement = (type, ns) => {
		let e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.
		return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
	},
	_RAD2DEG = 180 / Math.PI,
	_bigNum = 1e20,
	_identityMatrix = new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D(),
	_getTime = Date.now || (() => new Date().getTime()),
	_renderQueue = [],
	_lookup = {}, //when a Draggable is created, the target gets a unique _gsDragID property that allows gets associated with the Draggable instance for quick lookups in Draggable.get(). This avoids circular references that could cause gc problems.
	_lookupCount = 0,
	_clickableTagExp = /^(?:a|input|textarea|button|select)$/i,
	_lastDragTime = 0,
	_temp1 = {}, // a simple object we reuse and populate (usually x/y properties) to conserve memory and improve performance.
	_windowProxy = {}, //memory/performance optimization - we reuse this object during autoScroll to store window-related bounds/offsets.
	_copy = (obj, factor) => {
		let copy = {}, p;
		for (p in obj) {
			copy[p] = factor ? obj[p] * factor : obj[p];
		}
		return copy;
	},
	_extend = (obj, defaults) => {
		for (let p in defaults) {
			if (!(p in obj)) {
				obj[p] = defaults[p];
			}
		}
		return obj;
	},
	_setTouchActionForAllDescendants = (elements, value) => {
		let i = elements.length,
			children;
		while (i--) {
			value ? (elements[i].style.touchAction = value) : elements[i].style.removeProperty("touch-action");
			children = elements[i].children;
			children && children.length && _setTouchActionForAllDescendants(children, value);
		}
	},
	_renderQueueTick = () => _renderQueue.forEach(func => func()),
	_addToRenderQueue = func => {
		_renderQueue.push(func);
		if (_renderQueue.length === 1) {
			gsap.ticker.add(_renderQueueTick);
		}
	},
	_renderQueueTimeout = () => !_renderQueue.length && gsap.ticker.remove(_renderQueueTick),
	_removeFromRenderQueue = func => {
		let i = _renderQueue.length;
		while (i--) {
			if (_renderQueue[i] === func) {
				_renderQueue.splice(i, 1);
			}
		}
		gsap.to(_renderQueueTimeout, {overwrite:true, delay:15, duration:0, onComplete:_renderQueueTimeout, data:"_draggable"}); //remove the "tick" listener only after the render queue is empty for 15 seconds (to improve performance). Adding/removing it constantly for every click/touch wouldn't deliver optimal speed, and we also don't want the ticker to keep calling the render method when things are idle for long periods of time (we want to improve battery life on mobile devices).
	},
	_setDefaults = (obj, defaults) => {
		for (let p in defaults) {
			if (!(p in obj)) {
				obj[p] = defaults[p];
			}
		}
		return obj;
	},
	_addListener = (element, type, func, capture) => {
		if (element.addEventListener) {
			let touchType = _touchEventLookup[type];
			capture = capture || (_supportsPassive ? {passive: false} : null);
			element.addEventListener(touchType || type, func, capture);
			(touchType && type !== touchType) && element.addEventListener(type, func, capture);//some browsers actually support both, so must we. But pointer events cover all.
		}
	},
	_removeListener = (element, type, func) => {
		if (element.removeEventListener) {
			let touchType = _touchEventLookup[type];
			element.removeEventListener(touchType || type, func);
			(touchType && type !== touchType) && element.removeEventListener(type, func);
		}
	},
	_preventDefault = event => {
		event.preventDefault && event.preventDefault();
		event.preventManipulation && event.preventManipulation();  //for some Microsoft browsers
	},
	_hasTouchID = (list, ID) => {
		let i = list.length;
		while (i--) {
			if (list[i].identifier === ID) {
				return true;
			}
		}
	},
	_onMultiTouchDocumentEnd = event => {
		_isMultiTouching = (event.touches && _dragCount < event.touches.length);
		_removeListener(event.target, "touchend", _onMultiTouchDocumentEnd);
	},

	_onMultiTouchDocument = event => {
		_isMultiTouching = (event.touches && _dragCount < event.touches.length);
		_addListener(event.target, "touchend", _onMultiTouchDocumentEnd);
	},
	_getDocScrollTop = doc => _win.pageYOffset  || doc.scrollTop || doc.documentElement.scrollTop || doc.body.scrollTop || 0,
	_getDocScrollLeft = doc => _win.pageXOffset || doc.scrollLeft || doc.documentElement.scrollLeft || doc.body.scrollLeft || 0,
	_addScrollListener = (e, callback) => {
		_addListener(e, "scroll", callback);
		if (!_isRoot(e.parentNode)) {
			_addScrollListener(e.parentNode, callback);
		}
	},
	_removeScrollListener = (e, callback) => {
		_removeListener(e, "scroll", callback);
		if (!_isRoot(e.parentNode)) {
			_removeScrollListener(e.parentNode, callback);
		}
	},
	_isRoot = e => !!(!e || e === _docElement || e.nodeType === 9 || e === _doc.body || e === _win || !e.nodeType || !e.parentNode),
	_getMaxScroll = (element, axis) => {
		let dim = (axis === "x") ? "Width" : "Height",
			scroll = "scroll" + dim,
			client = "client" + dim;
		return Math.max(0, _isRoot(element) ? Math.max(_docElement[scroll], _body[scroll]) - (_win["inner" + dim] || _docElement[client] || _body[client]) : element[scroll] - element[client]);
	},
	_recordMaxScrolls = (e, skipCurrent) => { //records _gsMaxScrollX and _gsMaxScrollY properties for the element and all ancestors up the chain so that we can cap it, otherwise dragging beyond the edges with autoScroll on can endlessly scroll.
		let x = _getMaxScroll(e, "x"),
			y = _getMaxScroll(e, "y");
		if (_isRoot(e)) {
			e = _windowProxy;
		} else {
			_recordMaxScrolls(e.parentNode, skipCurrent);
		}
		e._gsMaxScrollX = x;
		e._gsMaxScrollY = y;
		if (!skipCurrent) {
			e._gsScrollX = e.scrollLeft || 0;
			e._gsScrollY = e.scrollTop || 0;
		}
	},
	_setStyle = (element, property, value) => {
		let style = element.style;
		if (!style) {
			return;
		}
		if (_isUndefined(style[property])) {
			property = _checkPrefix(property, element) || property;
		}
		if (value == null) {
			style.removeProperty && style.removeProperty(property.replace(/([A-Z])/g, "-$1").toLowerCase());
		} else {
			style[property] = value;
		}
	},
	_getComputedStyle = element => _win.getComputedStyle((element instanceof Element) ? element : element.host || (element.parentNode || {}).host || element), //the "host" stuff helps to accommodate ShadowDom objects.

	_tempRect = {}, //reuse to reduce garbage collection tasks
	_parseRect = e => { //accepts a DOM element, a mouse event, or a rectangle object and returns the corresponding rectangle with left, right, width, height, top, and bottom properties
		if (e === _win) {
			_tempRect.left = _tempRect.top = 0;
			_tempRect.width = _tempRect.right = _docElement.clientWidth || e.innerWidth || _body.clientWidth || 0;
			_tempRect.height = _tempRect.bottom = ((e.innerHeight || 0) - 20 < _docElement.clientHeight) ? _docElement.clientHeight : e.innerHeight || _body.clientHeight || 0;
			return _tempRect;
		}
		let doc = e.ownerDocument || _doc,
			r = !_isUndefined(e.pageX) ? {left: e.pageX - _getDocScrollLeft(doc), top: e.pageY - _getDocScrollTop(doc), right: e.pageX - _getDocScrollLeft(doc) + 1, bottom: e.pageY - _getDocScrollTop(doc) + 1} : (!e.nodeType && !_isUndefined(e.left) && !_isUndefined(e.top)) ? e : _toArray(e)[0].getBoundingClientRect();
		if (_isUndefined(r.right) && !_isUndefined(r.width)) {
			r.right = r.left + r.width;
			r.bottom = r.top + r.height;
		} else if (_isUndefined(r.width)) { //some browsers don't include width and height properties. We can't just set them directly on r because some browsers throw errors, so create a new generic object.
			r = {width: r.right - r.left, height: r.bottom - r.top, right: r.right, left: r.left, bottom: r.bottom, top: r.top};
		}
		return r;
	},

	_dispatchEvent = (target, type, callbackName) => {
		let vars = target.vars,
			callback = vars[callbackName],
			listeners = target._listeners[type],
			result;
		if (_isFunction(callback)) {
			result = callback.apply(vars.callbackScope || target, vars[callbackName + "Params"] || [target.pointerEvent]);
		}
		if (listeners && target.dispatchEvent(type) === false) {
			result = false;
		}
		return result;
	},
	_getBounds = (target, context) => { //accepts any of the following: a DOM element, jQuery object, selector text, or an object defining bounds as {top, left, width, height} or {minX, maxX, minY, maxY}. Returns an object with left, top, width, and height properties.
		let e = _toArray(target)[0],
			top, left, offset;
		if (!e.nodeType && e !== _win) {
			if (!_isUndefined(target.left)) {
				offset = {x:0, y:0}; //_getOffsetTransformOrigin(context); //the bounds should be relative to the origin
				return {left: target.left - offset.x, top: target.top - offset.y, width: target.width, height: target.height};
			}
			left = target.min || target.minX || target.minRotation || 0;
			top = target.min || target.minY || 0;
			return {left:left, top:top, width:(target.max || target.maxX || target.maxRotation || 0) - left, height:(target.max || target.maxY || 0) - top};
		}
		return _getElementBounds(e, context);
	},
	_point1 = {}, //we reuse to minimize garbage collection tasks.
	_getElementBounds = (element, context) => {
		context = _toArray(context)[0];
		let isSVG = (element.getBBox && element.ownerSVGElement),
			doc = element.ownerDocument || _doc,
			left, right, top, bottom, matrix, p1, p2, p3, p4, bbox, width, height, cs, contextParent;
		if (element === _win) {
			top = _getDocScrollTop(doc);
			left = _getDocScrollLeft(doc);
			right = left + (doc.documentElement.clientWidth || element.innerWidth || doc.body.clientWidth || 0);
			bottom = top + (((element.innerHeight || 0) - 20 < doc.documentElement.clientHeight) ? doc.documentElement.clientHeight : element.innerHeight || doc.body.clientHeight || 0); //some browsers (like Firefox) ignore absolutely positioned elements, and collapse the height of the documentElement, so it could be 8px, for example, if you have just an absolutely positioned div. In that case, we use the innerHeight to resolve this.
		} else if (context === _win || _isUndefined(context)) {
			return element.getBoundingClientRect();
		} else {
			left = top =  0;
			if (isSVG) {
				bbox = element.getBBox();
				width = bbox.width;
				height = bbox.height;
			} else {
				if (element.viewBox && (bbox = element.viewBox.baseVal)) {
					left = bbox.x || 0;
					top = bbox.y || 0;
					width = bbox.width;
					height = bbox.height;
				}
				if (!width) {
					cs = _getComputedStyle(element);
					bbox = cs.boxSizing === "border-box";
					width = (parseFloat(cs.width) || element.clientWidth || 0) + (bbox ? 0 : parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth));
					height = (parseFloat(cs.height) || element.clientHeight || 0) + (bbox ? 0 : parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth));
				}
			}
			right = width;
			bottom = height;
		}
		if (element === context) {
			return {left:left, top:top, width: right - left, height: bottom - top};
		}
		matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(context, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(element));
		p1 = matrix.apply({x:left, y:top});
		p2 = matrix.apply({x:right, y:top});
		p3 = matrix.apply({x:right, y:bottom});
		p4 = matrix.apply({x:left, y:bottom});
		left = Math.min(p1.x, p2.x, p3.x, p4.x);
		top = Math.min(p1.y, p2.y, p3.y, p4.y);
		contextParent = context.parentNode || {};
		return {left: left + (contextParent.scrollLeft || 0), top: top + (contextParent.scrollTop || 0), width: Math.max(p1.x, p2.x, p3.x, p4.x) - left, height: Math.max(p1.y, p2.y, p3.y, p4.y) - top};
	},
	_parseInertia = (draggable, snap, max, min, factor, forceZeroVelocity) => {
		let vars = {},
			a, i, l;
		if (snap) {
			if (factor !== 1 && snap instanceof Array) { //some data must be altered to make sense, like if the user passes in an array of rotational values in degrees, we must convert it to radians. Or for scrollLeft and scrollTop, we invert the values.
				vars.end = a = [];
				l = snap.length;
				if (_isObject(snap[0])) { //if the array is populated with objects, like points ({x:100, y:200}), make copies before multiplying by the factor, otherwise we'll mess up the originals and the user may reuse it elsewhere.
					for (i = 0; i < l; i++) {
						a[i] = _copy(snap[i], factor);
					}
				} else {
					for (i = 0; i < l; i++) {
						a[i] = snap[i] * factor;
					}
				}
				max += 1.1; //allow 1.1 pixels of wiggle room when snapping in order to work around some browser inconsistencies in the way bounds are reported which can make them roughly a pixel off. For example, if "snap:[-$('#menu').width(), 0]" was defined and #menu had a wrapper that was used as the bounds, some browsers would be one pixel off, making the minimum -752 for example when snap was [-753,0], thus instead of snapping to -753, it would snap to 0 since -753 was below the minimum.
				min -= 1.1;
			} else if (_isFunction(snap)) {
				vars.end = value => {
					let result = snap.call(draggable, value),
						copy, p;
					if (factor !== 1) {
						if (_isObject(result)) {
							copy = {};
							for (p in result) {
								copy[p] = result[p] * factor;
							}
							result = copy;
						} else {
							result *= factor;
						}
					}
					return result; //we need to ensure that we can scope the function call to the Draggable instance itself so that users can access important values like maxX, minX, maxY, minY, x, and y from within that function.
				};
			} else {
				vars.end = snap;
			}
		}
		if (max || max === 0) {
			vars.max = max;
		}
		if (min || min === 0) {
			vars.min = min;
		}
		if (forceZeroVelocity) {
			vars.velocity = 0;
		}
		return vars;
	},
	_isClickable = element => { //sometimes it's convenient to mark an element as clickable by adding a data-clickable="true" attribute (in which case we won't preventDefault() the mouse/touch event). This method checks if the element is an <a>, <input>, or <button> or has an onclick or has the data-clickable or contentEditable attribute set to true (or any of its parent elements).
		let data;
		return (!element || !element.getAttribute || element === _body) ? false : ((data = element.getAttribute("data-clickable")) === "true" || (data !== "false" && (element.onclick || _clickableTagExp.test(element.nodeName + "") || element.getAttribute("contentEditable") === "true"))) ? true : _isClickable(element.parentNode);
	},
	_setSelectable = (elements, selectable) => {
		let i = elements.length,
			e;
		while (i--) {
			e = elements[i];
			e.ondragstart = e.onselectstart = selectable ? null : _emptyFunc;
			gsap.set(e, {lazy:true, userSelect: (selectable ? "text" : "none")});
		}
	},
	_isFixed = element => {
		if (_getComputedStyle(element).position === "fixed") {
			return true;
		}
		element = element.parentNode;
		if (element && element.nodeType === 1) { // avoid document fragments which will throw an error.
			return _isFixed(element);
		}
	},
	_supports3D, _addPaddingBR,

	//The ScrollProxy class wraps an element's contents into another div (we call it "content") that we either add padding when necessary or apply a translate3d() transform in order to overscroll (scroll past the boundaries). This allows us to simply set the scrollTop/scrollLeft (or top/left for easier reverse-axis orientation, which is what we do in Draggable) and it'll do all the work for us. For example, if we tried setting scrollTop to -100 on a normal DOM element, it wouldn't work - it'd look the same as setting it to 0, but if we set scrollTop of a ScrollProxy to -100, it'll give the correct appearance by either setting paddingTop of the wrapper to 100 or applying a 100-pixel translateY.
	ScrollProxy = function(element, vars) {
		element = gsap.utils.toArray(element)[0];
		vars = vars || {};
		let content = document.createElement("div"),
			style = content.style,
			node = element.firstChild,
			offsetTop = 0,
			offsetLeft = 0,
			prevTop = element.scrollTop,
			prevLeft = element.scrollLeft,
			scrollWidth = element.scrollWidth,
			scrollHeight = element.scrollHeight,
			extraPadRight = 0,
			maxLeft = 0,
			maxTop = 0,
			elementWidth, elementHeight, contentHeight, nextNode, transformStart, transformEnd;
		if (_supports3D && vars.force3D !== false) {
			transformStart = "translate3d(";
			transformEnd = "px,0px)";
		} else if (_transformProp) {
			transformStart = "translate(";
			transformEnd = "px)";
		}
		this.scrollTop = function(value, force) {
			if (!arguments.length) {
				return -this.top();
			}
			this.top(-value, force);
		};
		this.scrollLeft = function(value, force) {
			if (!arguments.length) {
				return -this.left();
			}
			this.left(-value, force);
		};
		this.left = function(value, force) {
			if (!arguments.length) {
				return -(element.scrollLeft + offsetLeft);
			}
			let dif = element.scrollLeft - prevLeft,
				oldOffset = offsetLeft;
			if ((dif > 2 || dif < -2) && !force) { //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.
				prevLeft = element.scrollLeft;
				gsap.killTweensOf(this, {left:1, scrollLeft:1});
				this.left(-prevLeft);
				if (vars.onKill) {
					vars.onKill();
				}
				return;
			}
			value = -value; //invert because scrolling works in the opposite direction
			if (value < 0) {
				offsetLeft = (value - 0.5) | 0;
				value = 0;
			} else if (value > maxLeft) {
				offsetLeft = (value - maxLeft) | 0;
				value = maxLeft;
			} else {
				offsetLeft = 0;
			}
			if (offsetLeft || oldOffset) {
				if (!this._skip) {
					style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
				}
				if (offsetLeft + extraPadRight >= 0) {
					style.paddingRight =  offsetLeft + extraPadRight + "px";
				}
			}
			element.scrollLeft = value | 0;
			prevLeft = element.scrollLeft; //don't merge this with the line above because some browsers adjust the scrollLeft after it's set, so in order to be 100% accurate in tracking it, we need to ask the browser to report it.
		};
		this.top = function(value, force) {
			if (!arguments.length) {
				return -(element.scrollTop + offsetTop);
			}
			let dif = element.scrollTop - prevTop,
				oldOffset = offsetTop;
			if ((dif > 2 || dif < -2) && !force) { //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.
				prevTop = element.scrollTop;
				gsap.killTweensOf(this, {top:1, scrollTop:1});
				this.top(-prevTop);
				if (vars.onKill) {
					vars.onKill();
				}
				return;
			}
			value = -value; //invert because scrolling works in the opposite direction
			if (value < 0) {
				offsetTop = (value - 0.5) | 0;
				value = 0;
			} else if (value > maxTop) {
				offsetTop = (value - maxTop) | 0;
				value = maxTop;
			} else {
				offsetTop = 0;
			}
			if (offsetTop || oldOffset) {
				if (!this._skip) {
					style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
				}
			}
			element.scrollTop = value | 0;
			prevTop = element.scrollTop;
		};

		this.maxScrollTop = () => maxTop;
		this.maxScrollLeft = () => maxLeft;

		this.disable = function() {
			node = content.firstChild;
			while (node) {
				nextNode = node.nextSibling;
				element.appendChild(node);
				node = nextNode;
			}
			if (element === content.parentNode) { //in case disable() is called when it's already disabled.
				element.removeChild(content);
			}
		};
		this.enable = function() {
			node = element.firstChild;
			if (node === content) {
				return;
			}
			while (node) {
				nextNode = node.nextSibling;
				content.appendChild(node);
				node = nextNode;
			}
			element.appendChild(content);
			this.calibrate();
		};
		this.calibrate = function(force) {
			let widthMatches = (element.clientWidth === elementWidth),
				cs, x, y;
			prevTop = element.scrollTop;
			prevLeft = element.scrollLeft;
			if (widthMatches && element.clientHeight === elementHeight && content.offsetHeight === contentHeight && scrollWidth === element.scrollWidth && scrollHeight === element.scrollHeight && !force) {
				return; //no need to recalculate things if the width and height haven't changed.
			}
			if (offsetTop || offsetLeft) {
				x = this.left();
				y = this.top();
				this.left(-element.scrollLeft);
				this.top(-element.scrollTop);
			}
			cs = _getComputedStyle(element);
			//first, we need to remove any width constraints to see how the content naturally flows so that we can see if it's wider than the containing element. If so, we've got to record the amount of overage so that we can apply that as padding in order for browsers to correctly handle things. Then we switch back to a width of 100% (without that, some browsers don't flow the content correctly)
			if (!widthMatches || force) {
				style.display = "block";
				style.width = "auto";
				style.paddingRight = "0px";
				extraPadRight = Math.max(0, element.scrollWidth - element.clientWidth);
				//if the content is wider than the container, we need to add the paddingLeft and paddingRight in order for things to behave correctly.
				if (extraPadRight) {
					extraPadRight += parseFloat(cs.paddingLeft) + (_addPaddingBR ? parseFloat(cs.paddingRight) : 0);
				}
			}
			style.display = "inline-block";
			style.position = "relative";
			style.overflow = "visible";
			style.verticalAlign = "top";
			style.boxSizing = "content-box";
			style.width = "100%";
			style.paddingRight = extraPadRight + "px";
			//some browsers neglect to factor in the bottom padding when calculating the scrollHeight, so we need to add that padding to the content when that happens. Allow a 2px margin for error
			if (_addPaddingBR) {
				style.paddingBottom = cs.paddingBottom;
			}
			elementWidth = element.clientWidth;
			elementHeight = element.clientHeight;
			scrollWidth = element.scrollWidth;
			scrollHeight = element.scrollHeight;
			maxLeft = element.scrollWidth - elementWidth;
			maxTop = element.scrollHeight - elementHeight;
			contentHeight = content.offsetHeight;
			style.display = "block";
			if (x || y) {
				this.left(x);
				this.top(y);
			}
		};
		this.content = content;
		this.element = element;
		this._skip = false;
		this.enable();
	},
	_initCore = required => {
		if (_windowExists() && document.body) {
			let nav = window && window.navigator;
			_win = window;
			_doc = document;
			_docElement = _doc.documentElement;
			_body = _doc.body;
			_tempDiv = _createElement("div");
			_supportsPointer = !!window.PointerEvent;
			_placeholderDiv = _createElement("div");
			_placeholderDiv.style.cssText = "visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;cursor:grab";
			_defaultCursor = _placeholderDiv.style.cursor === "grab" ? "grab" : "move";
			_isAndroid = (nav && nav.userAgent.toLowerCase().indexOf("android") !== -1); //Android handles touch events in an odd way and it's virtually impossible to "feature test" so we resort to UA sniffing
			_isTouchDevice = (("ontouchstart" in _docElement) && ("orientation" in _win)) || (nav && (nav.MaxTouchPoints > 0 || nav.msMaxTouchPoints > 0));
			_addPaddingBR = (function() { //this function is in charge of analyzing browser behavior related to padding. It sets the _addPaddingBR to true if the browser doesn't normally factor in the bottom or right padding on the element inside the scrolling area, and it sets _addPaddingLeft to true if it's a browser that requires the extra offset (offsetLeft) to be added to the paddingRight (like Opera).
				let div = _createElement("div"),
					child = _createElement("div"),
					childStyle = child.style,
					parent = _body,
					val;
				childStyle.display = "inline-block";
				childStyle.position = "relative";
				div.style.cssText = child.innerHTML = "width:90px;height:40px;padding:10px;overflow:auto;visibility:hidden";
				div.appendChild(child);
				parent.appendChild(div);
				val = (child.offsetHeight + 18 > div.scrollHeight); //div.scrollHeight should be child.offsetHeight + 20 because of the 10px of padding on each side, but some browsers ignore one side. We allow a 2px margin of error.
				parent.removeChild(div);
				return val;
			}());
			_touchEventLookup = (function(types) { //we create an object that makes it easy to translate touch event types into their "pointer" counterparts if we're in a browser that uses those instead. Like IE10 uses "MSPointerDown" instead of "touchstart", for example.
				let standard = types.split(","),
					converted = ("onpointerdown" in _tempDiv ? "pointerdown,pointermove,pointerup,pointercancel" : "onmspointerdown" in _tempDiv ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : types).split(","),
					obj = {},
					i = 4;
				while (--i > -1) {
					obj[standard[i]] = converted[i];
					obj[converted[i]] = standard[i];
				}
				//to avoid problems in iOS 9, test to see if the browser supports the "passive" option on addEventListener().
				try {
					_docElement.addEventListener("test", null, Object.defineProperty({}, "passive", {
						get: function () {
							_supportsPassive = 1;
						}
					}));
				} catch (e) {}
				return obj;
			}("touchstart,touchmove,touchend,touchcancel"));
			_addListener(_doc, "touchcancel", _emptyFunc); //some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document. Very strange indeed.
			_addListener(_win, "touchmove", _emptyFunc); //works around Safari bugs that still allow the page to scroll even when we preventDefault() on the touchmove event.
			_body && _body.addEventListener("touchstart", _emptyFunc); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/
			_addListener(_doc, "contextmenu", function() {
				for (let p in _lookup) {
					if (_lookup[p].isPressed) {
						_lookup[p].endDrag();
					}
				}
			});
			gsap = _coreInitted = _getGSAP();
		}
		if (gsap) {
			InertiaPlugin = gsap.plugins.inertia;
			_checkPrefix = gsap.utils.checkPrefix;
			_transformProp = _checkPrefix(_transformProp);
			_transformOriginProp = _checkPrefix(_transformOriginProp);
			_toArray = gsap.utils.toArray;
			_supports3D = !!_checkPrefix("perspective");
		} else if (required) {
			console.warn("Please gsap.registerPlugin(Draggable)");
		}
	};






class EventDispatcher {

	constructor(target) {
		this._listeners = {};
		this.target = target || this;
	}

	addEventListener(type, callback) {
		let list = this._listeners[type] || (this._listeners[type] = []);
		if (!~list.indexOf(callback)) {
			list.push(callback);
		}
	}

	removeEventListener(type, callback) {
		let list = this._listeners[type],
			i = (list && list.indexOf(callback)) || -1;
		(i > -1) && list.splice(i, 1);
	}

	dispatchEvent(type) {
		let result;
		(this._listeners[type] || []).forEach(callback => (callback.call(this, {type: type, target: this.target}) === false) && (result = false));
		return result; //if any of the callbacks return false, pass that along.
	}
}









class Draggable extends EventDispatcher {

	constructor(target, vars) {
		super();
		_coreInitted || _initCore(1);
		target = _toArray(target)[0]; //in case the target is a selector object or selector text
		if (!InertiaPlugin) {
			InertiaPlugin = gsap.plugins.inertia;
		}
		this.vars = vars = _copy(vars || {});
		this.target = target;
		this.x = this.y = this.rotation = 0;
		this.dragResistance = parseFloat(vars.dragResistance) || 0;
		this.edgeResistance = isNaN(vars.edgeResistance) ? 1 : parseFloat(vars.edgeResistance) || 0;
		this.lockAxis = vars.lockAxis;
		this.autoScroll = vars.autoScroll || 0;
		this.lockedAxis = null;
		this.allowEventDefault = !!vars.allowEventDefault;

		gsap.getProperty(target, "x"); // to ensure that transforms are instantiated.

		let type = (vars.type || "x,y").toLowerCase(),
			xyMode = (~type.indexOf("x") || ~type.indexOf("y")),
			rotationMode = (type.indexOf("rotation") !== -1),
			xProp = rotationMode ? "rotation" : xyMode ? "x" : "left",
			yProp = xyMode ? "y" : "top",
			allowX = !!(~type.indexOf("x") || ~type.indexOf("left") || type === "scroll"),
			allowY = !!(~type.indexOf("y") || ~type.indexOf("top") || type === "scroll"),
			minimumMovement = vars.minimumMovement || 2,
			self = this,
			triggers = _toArray(vars.trigger || vars.handle || target),
			killProps = {},
			dragEndTime = 0,
			checkAutoScrollBounds = false,
			autoScrollMarginTop = vars.autoScrollMarginTop || 40,
			autoScrollMarginRight = vars.autoScrollMarginRight || 40,
			autoScrollMarginBottom = vars.autoScrollMarginBottom || 40,
			autoScrollMarginLeft = vars.autoScrollMarginLeft || 40,
			isClickable = vars.clickableTest || _isClickable,
			clickTime = 0,
			gsCache = target._gsap || gsap.core.getCache(target),
			isFixed = _isFixed(target),
			getPropAsNum = (property, unit) => parseFloat(gsCache.get(target, property, unit)),
			ownerDoc = target.ownerDocument || _doc,
			enabled, scrollProxy, startPointerX, startPointerY, startElementX, startElementY, hasBounds, hasDragCallback, hasMoveCallback, maxX, minX, maxY, minY, touch, touchID, rotationOrigin, dirty, old, snapX, snapY, snapXY, isClicking, touchEventTarget, matrix, interrupted, allowNativeTouchScrolling, touchDragAxis, isDispatching, clickDispatch, trustedClickDispatch, isPreventingDefault,

			onContextMenu = e => { //used to prevent long-touch from triggering a context menu.
				// (self.isPressed && e.which < 2) && self.endDrag() // previously ended drag when context menu was triggered, but instead we should just stop propagation and prevent the default event behavior.
				_preventDefault(e);
				e.stopImmediatePropagation && e.stopImmediatePropagation();
				return false;
			},

			//this method gets called on every tick of TweenLite.ticker which allows us to synchronize the renders to the core engine (which is typically synchronized with the display refresh via requestAnimationFrame). This is an optimization - it's better than applying the values inside the "mousemove" or "touchmove" event handler which may get called many times inbetween refreshes.
			render = suppressEvents => {
				if (self.autoScroll && self.isDragging && (checkAutoScrollBounds || dirty)) {
					let e = target,
						autoScrollFactor = self.autoScroll * 15, //multiplying by 15 just gives us a better "feel" speed-wise.
						parent, isRoot, rect, pointerX, pointerY, changeX, changeY, gap;
					checkAutoScrollBounds = false;
					_windowProxy.scrollTop = ((_win.pageYOffset != null) ? _win.pageYOffset : (ownerDoc.documentElement.scrollTop != null) ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop);
					_windowProxy.scrollLeft = ((_win.pageXOffset != null) ? _win.pageXOffset : (ownerDoc.documentElement.scrollLeft != null) ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft);
					pointerX = self.pointerX - _windowProxy.scrollLeft;
					pointerY = self.pointerY - _windowProxy.scrollTop;
					while (e && !isRoot) { //walk up the chain and sense wherever the pointer is within 40px of an edge that's scrollable.
						isRoot = _isRoot(e.parentNode);
						parent = isRoot ? _windowProxy : e.parentNode;
						rect = isRoot ? {bottom:Math.max(_docElement.clientHeight, _win.innerHeight || 0), right: Math.max(_docElement.clientWidth, _win.innerWidth || 0), left:0, top:0} : parent.getBoundingClientRect();
						changeX = changeY = 0;
						if (allowY) {
							gap = parent._gsMaxScrollY - parent.scrollTop;
							if (gap < 0) {
								changeY = gap;
							} else if (pointerY > rect.bottom - autoScrollMarginBottom && gap) {
								checkAutoScrollBounds = true;
								changeY = Math.min(gap, (autoScrollFactor * (1 - Math.max(0, (rect.bottom - pointerY)) / autoScrollMarginBottom)) | 0);
							} else if (pointerY < rect.top + autoScrollMarginTop && parent.scrollTop) {
								checkAutoScrollBounds = true;
								changeY = -Math.min(parent.scrollTop, (autoScrollFactor * (1 - Math.max(0, (pointerY - rect.top)) / autoScrollMarginTop)) | 0);
							}
							if (changeY) {
								parent.scrollTop += changeY;
							}
						}
						if (allowX) {
							gap = parent._gsMaxScrollX - parent.scrollLeft;
							if (gap < 0) {
								changeX = gap;
							} else if (pointerX > rect.right - autoScrollMarginRight && gap) {
								checkAutoScrollBounds = true;
								changeX = Math.min(gap, (autoScrollFactor * (1 - Math.max(0, (rect.right - pointerX)) / autoScrollMarginRight)) | 0);
							} else if (pointerX < rect.left + autoScrollMarginLeft && parent.scrollLeft) {
								checkAutoScrollBounds = true;
								changeX = -Math.min(parent.scrollLeft, (autoScrollFactor * (1 - Math.max(0, (pointerX - rect.left)) / autoScrollMarginLeft)) | 0);
							}
							if (changeX) {
								parent.scrollLeft += changeX;
							}
						}

						if (isRoot && (changeX || changeY)) {
							_win.scrollTo(parent.scrollLeft, parent.scrollTop);
							setPointerPosition(self.pointerX + changeX, self.pointerY + changeY);
						}
						e = parent;
					}
				}
				if (dirty) {
					let {x, y} = self;
					if (rotationMode) {
						self.deltaX = x - parseFloat(gsCache.rotation);
						self.rotation = x;
						gsCache.rotation = x + "deg";
						gsCache.renderTransform(1, gsCache);
					} else {
						if (scrollProxy) {
							if (allowY) {
								self.deltaY = y - scrollProxy.top();
								scrollProxy.top(y);
							}
							if (allowX) {
								self.deltaX = x - scrollProxy.left();
								scrollProxy.left(x);
							}
						} else if (xyMode) {
							if (allowY) {
								self.deltaY = y - parseFloat(gsCache.y);
								gsCache.y = y + "px";
							}
							if (allowX) {
								self.deltaX = x - parseFloat(gsCache.x);
								gsCache.x = x + "px";
							}
							gsCache.renderTransform(1, gsCache);
						} else {
							if (allowY) {
								self.deltaY = y - parseFloat(target.style.top || 0);
								target.style.top = y + "px";
							}
							if (allowX) {
								self.deltaX = x - parseFloat(target.style.left || 0);
								target.style.left = x + "px";
							}
						}
					}
					if (hasDragCallback && !suppressEvents && !isDispatching) {
						isDispatching = true; //in case onDrag has an update() call (avoid endless loop)
						if (_dispatchEvent(self, "drag", "onDrag") === false) {
							if (allowX) {
								self.x -= self.deltaX;
							}
							if (allowY) {
								self.y -= self.deltaY;
							}
							render(true);
						}
						isDispatching = false;
					}
				}
				dirty = false;
			},

			//copies the x/y from the element (whether that be transforms, top/left, or ScrollProxy's top/left) to the Draggable's x and y (and rotation if necessary) properties so that they reflect reality and it also (optionally) applies any snapping necessary. This is used by the InertiaPlugin tween in an onUpdate to ensure things are synced and snapped.
			syncXY = (skipOnUpdate, skipSnap) => {
				let { x, y } = self,
					snappedValue, cs;
				if (!target._gsap) { //just in case the _gsap cache got wiped, like if the user called clearProps on the transform or something (very rare).
					gsCache = gsap.core.getCache(target);
				}
				gsCache.uncache && gsap.getProperty(target, "x"); // trigger a re-cache
				if (xyMode) {
					self.x = parseFloat(gsCache.x);
					self.y = parseFloat(gsCache.y);
				} else if (rotationMode) {
					self.x = self.rotation = parseFloat(gsCache.rotation);
				} else if (scrollProxy) {
					self.y = scrollProxy.top();
					self.x = scrollProxy.left();
				} else {
					self.y = parseFloat(target.style.top || ((cs = _getComputedStyle(target)) && cs.top)) || 0;
					self.x = parseFloat(target.style.left || (cs || {}).left) || 0;
				}
				if ((snapX || snapY || snapXY) && !skipSnap && (self.isDragging || self.isThrowing)) {
					if (snapXY) {
						_temp1.x = self.x;
						_temp1.y = self.y;
						snappedValue = snapXY(_temp1);
						if (snappedValue.x !== self.x) {
							self.x = snappedValue.x;
							dirty = true;
						}
						if (snappedValue.y !== self.y) {
							self.y = snappedValue.y;
							dirty = true;
						}
					}
					if (snapX) {
						snappedValue = snapX(self.x);
						if (snappedValue !== self.x) {
							self.x = snappedValue;
							if (rotationMode) {
								self.rotation = snappedValue;
							}
							dirty = true;
						}
					}
					if (snapY) {
						snappedValue = snapY(self.y);
						if (snappedValue !== self.y) {
							self.y = snappedValue;
						}
						dirty = true;
					}
				}
				dirty && render(true);
				if (!skipOnUpdate) {
					self.deltaX = self.x - x;
					self.deltaY = self.y - y;
					_dispatchEvent(self, "throwupdate", "onThrowUpdate");
				}
			},

			buildSnapFunc = (snap, min, max, factor) => {
				if (min == null) {
					min = -_bigNum;
				}
				if (max == null) {
					max = _bigNum;
				}
				if (_isFunction(snap)) {
					return n => {
						let edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)
						return snap.call(self, (n > max ? max + (n - max) * edgeTolerance : (n < min) ? min + (n - min) * edgeTolerance : n)) * factor;
					};
				}
				if (_isArray(snap)) {
					return n => {
						let i = snap.length,
							closest = 0,
							absDif = _bigNum,
							val, dif;
						while (--i > -1) {
							val = snap[i];
							dif = val - n;
							if (dif < 0) {
								dif = -dif;
							}
							if (dif < absDif && val >= min && val <= max) {
								closest = i;
								absDif = dif;
							}
						}
						return snap[closest];
					};
				}
				return isNaN(snap) ? n => n : () => snap * factor;
			},

			buildPointSnapFunc = (snap, minX, maxX, minY, maxY, radius, factor) => {
				radius = (radius && radius < _bigNum) ? radius * radius : _bigNum; //so we don't have to Math.sqrt() in the functions. Performance optimization.
				if (_isFunction(snap)) {
					return point => {
						let edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance,
							x = point.x,
							y = point.y,
							result, dx, dy; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)
						point.x = x = (x > maxX ? maxX + (x - maxX) * edgeTolerance : (x < minX) ? minX + (x - minX) * edgeTolerance : x);
						point.y = y = (y > maxY ? maxY + (y - maxY) * edgeTolerance : (y < minY) ? minY + (y - minY) * edgeTolerance : y);
						result = snap.call(self, point);
						if (result !== point) {
							point.x = result.x;
							point.y = result.y;
						}
						if (factor !== 1) {
							point.x *= factor;
							point.y *= factor;
						}
						if (radius < _bigNum) {
							dx = point.x - x;
							dy = point.y - y;
							if (dx * dx + dy * dy > radius) {
								point.x = x;
								point.y = y;
							}
						}
						return point;
					};
				}
				if (_isArray(snap)) {
					return p => {
						let i = snap.length,
							closest = 0,
							minDist = _bigNum,
							x, y, point, dist;
						while (--i > -1) {
							point = snap[i];
							x = point.x - p.x;
							y = point.y - p.y;
							dist = x * x + y * y;
							if (dist < minDist) {
								closest = i;
								minDist = dist;
							}
						}
						return (minDist <= radius) ? snap[closest] : p;
					};
				}
				return n => n;
			},

			calculateBounds = () => {
				let bounds, targetBounds, snap, snapIsRaw;
				hasBounds = false;
				if (scrollProxy) {
					scrollProxy.calibrate();
					self.minX = minX = -scrollProxy.maxScrollLeft();
					self.minY = minY = -scrollProxy.maxScrollTop();
					self.maxX = maxX = self.maxY = maxY = 0;
					hasBounds = true;
				} else if (!!vars.bounds) {
					bounds = _getBounds(vars.bounds, target.parentNode); //could be a selector/jQuery object or a DOM element or a generic object like {top:0, left:100, width:1000, height:800} or {minX:100, maxX:1100, minY:0, maxY:800}
					if (rotationMode) {
						self.minX = minX = bounds.left;
						self.maxX = maxX = bounds.left + bounds.width;
						self.minY = minY = self.maxY = maxY = 0;
					} else if (!_isUndefined(vars.bounds.maxX) || !_isUndefined(vars.bounds.maxY)) {
						bounds = vars.bounds;
						self.minX = minX = bounds.minX;
						self.minY = minY = bounds.minY;
						self.maxX = maxX = bounds.maxX;
						self.maxY = maxY = bounds.maxY;
					} else {
						targetBounds = _getBounds(target, target.parentNode);
						self.minX = minX = Math.round(getPropAsNum(xProp, "px") + bounds.left - targetBounds.left - 0.5);
						self.minY = minY = Math.round(getPropAsNum(yProp, "px") + bounds.top - targetBounds.top - 0.5);
						self.maxX = maxX = Math.round(minX + (bounds.width - targetBounds.width));
						self.maxY = maxY = Math.round(minY + (bounds.height - targetBounds.height));
					}
					if (minX > maxX) {
						self.minX = maxX;
						self.maxX = maxX = minX;
						minX = self.minX;
					}
					if (minY > maxY) {
						self.minY = maxY;
						self.maxY = maxY = minY;
						minY = self.minY;
					}
					if (rotationMode) {
						self.minRotation = minX;
						self.maxRotation = maxX;
					}
					hasBounds = true;
				}
				if (vars.liveSnap) {
					snap = (vars.liveSnap === true) ? (vars.snap || {}) : vars.liveSnap;
					snapIsRaw = (_isArray(snap) || _isFunction(snap));
					if (rotationMode) {
						snapX = buildSnapFunc((snapIsRaw ? snap : snap.rotation), minX, maxX, 1);
						snapY = null;
					} else {
						if (snap.points) {
							snapXY = buildPointSnapFunc((snapIsRaw ? snap : snap.points), minX, maxX, minY, maxY, snap.radius, scrollProxy ? -1 : 1);
						} else {
							if (allowX) {
								snapX = buildSnapFunc((snapIsRaw ? snap : snap.x || snap.left || snap.scrollLeft), minX, maxX, scrollProxy ? -1 : 1);
							}
							if (allowY) {
								snapY = buildSnapFunc((snapIsRaw ? snap : snap.y || snap.top || snap.scrollTop), minY, maxY, scrollProxy ? -1 : 1);
							}
						}
					}
				}
			},

			onThrowComplete = () => {
				self.isThrowing = false;
				_dispatchEvent(self, "throwcomplete", "onThrowComplete");
			},
			onThrowInterrupt = () => {
				self.isThrowing = false;
			},

			animate = (inertia, forceZeroVelocity) => {
				let snap, snapIsRaw, tween, overshootTolerance;
				if (inertia && InertiaPlugin) {
					if (inertia === true) {
						snap = vars.snap || vars.liveSnap || {};
						snapIsRaw = (_isArray(snap) || _isFunction(snap));
						inertia = {resistance:(vars.throwResistance || vars.resistance || 1000) / (rotationMode ? 10 : 1)};
						if (rotationMode) {
							inertia.rotation = _parseInertia(self, snapIsRaw ? snap : snap.rotation, maxX, minX, 1, forceZeroVelocity);
						} else {
							if (allowX) {
								inertia[xProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.x || snap.left, maxX, minX, scrollProxy ? -1 : 1, forceZeroVelocity || (self.lockedAxis === "x"));
							}
							if (allowY) {
								inertia[yProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.y || snap.top, maxY, minY, scrollProxy ? -1 : 1, forceZeroVelocity || (self.lockedAxis === "y"));
							}
							if (snap.points || (_isArray(snap) && _isObject(snap[0]))) {
								inertia.linkedProps = xProp + "," + yProp;
								inertia.radius = snap.radius; //note: we also disable liveSnapping while throwing if there's a "radius" defined, otherwise it looks weird to have the item thrown past a snapping point but live-snapping mid-tween. We do this by altering the onUpdateParams so that "skipSnap" parameter is true for syncXY.
							}
						}
					}
					self.isThrowing = true;
					overshootTolerance = (!isNaN(vars.overshootTolerance)) ? vars.overshootTolerance : (vars.edgeResistance === 1) ? 0 : (1 - self.edgeResistance) + 0.2;
					if (!inertia.duration) {
						inertia.duration = {max: Math.max(vars.minDuration || 0, ("maxDuration" in vars) ? vars.maxDuration : 2), min: (!isNaN(vars.minDuration) ? vars.minDuration : (overshootTolerance === 0 || (_isObject(inertia) && inertia.resistance > 1000)) ? 0 : 0.5), overshoot: overshootTolerance};
					}
					self.tween = tween = gsap.to(scrollProxy || target, {
						inertia: inertia,
						data: "_draggable",
						onComplete: onThrowComplete,
						onInterrupt: onThrowInterrupt,
						onUpdate: (vars.fastMode ? _dispatchEvent : syncXY),
						onUpdateParams: (vars.fastMode ? [self, "onthrowupdate", "onThrowUpdate"] : (snap && snap.radius) ? [false, true] : [])
					});
					if (!vars.fastMode) {
						if (scrollProxy) {
							scrollProxy._skip = true; // Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.
						}
						tween.render(1e9, true, true); // force to the end. Remember, the duration will likely change upon initting because that's when InertiaPlugin calculates it.
						syncXY(true, true);
						self.endX = self.x;
						self.endY = self.y;
						if (rotationMode) {
							self.endRotation = self.x;
						}
						tween.play(0);
						syncXY(true, true);
						if (scrollProxy) {
							scrollProxy._skip = false; //Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.
						}
					}
				} else if (hasBounds) {
					self.applyBounds();
				}
			},

			updateMatrix = shiftStart => {
				let start = matrix,
					p;
				matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target.parentNode, true);
				if (shiftStart && self.isPressed && !matrix.equals(start || new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D())) { //if the matrix changes WHILE the element is pressed, we must adjust the startPointerX and startPointerY accordingly, so we invert the original matrix and figure out where the pointerX and pointerY were in the global space, then apply the new matrix to get the updated coordinates.
					p = start.inverse().apply({x:startPointerX, y:startPointerY});
					matrix.apply(p, p);
					startPointerX = p.x;
					startPointerY = p.y;
				}
				if (matrix.equals(_identityMatrix)) { //if there are no transforms, we can optimize performance by not factoring in the matrix
					matrix = null;
				}
			},

			recordStartPositions = () => {
				let edgeTolerance = 1 - self.edgeResistance,
					offsetX = isFixed ? _getDocScrollLeft(ownerDoc) : 0,
					offsetY = isFixed ? _getDocScrollTop(ownerDoc) : 0,
					parsedOrigin, x, y;
				updateMatrix(false);
				_point1.x = self.pointerX - offsetX;
				_point1.y = self.pointerY - offsetY;
				matrix && matrix.apply(_point1, _point1);
				startPointerX = _point1.x; //translate to local coordinate system
				startPointerY = _point1.y;
				if (dirty) {
					setPointerPosition(self.pointerX, self.pointerY);
					render(true);
				}
				if (scrollProxy) {
					calculateBounds();
					startElementY = scrollProxy.top();
					startElementX = scrollProxy.left();
				} else {
					//if the element is in the process of tweening, don't force snapping to occur because it could make it jump. Imagine the user throwing, then before it's done, clicking on the element in its inbetween state.
					if (isTweening()) {
						syncXY(true, true);
						calculateBounds();
					} else {
						self.applyBounds();
					}
					if (rotationMode) {
						parsedOrigin = target.ownerSVGElement ? [gsCache.xOrigin - target.getBBox().x, gsCache.yOrigin - target.getBBox().y] : (_getComputedStyle(target)[_transformOriginProp] || "0 0").split(" ");
						rotationOrigin = self.rotationOrigin = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target).apply({x: parseFloat(parsedOrigin[0]) || 0, y: parseFloat(parsedOrigin[1]) || 0});
						syncXY(true, true);
						x = self.pointerX - rotationOrigin.x - offsetX;
						y = rotationOrigin.y - self.pointerY + offsetY;
						startElementX = self.x; //starting rotation (x always refers to rotation in type:"rotation", measured in degrees)
						startElementY = self.y = Math.atan2(y, x) * _RAD2DEG;
					} else {
						//parent = !isFixed && target.parentNode;
						//startScrollTop = parent ? parent.scrollTop || 0 : 0;
						//startScrollLeft = parent ? parent.scrollLeft || 0 : 0;
						startElementY = getPropAsNum(yProp, "px"); //record the starting top and left values so that we can just add the mouse's movement to them later.
						startElementX = getPropAsNum(xProp, "px");
					}
				}

				if (hasBounds && edgeTolerance) {
					if (startElementX > maxX) {
						startElementX = maxX + (startElementX - maxX) / edgeTolerance;
					} else if (startElementX < minX) {
						startElementX = minX - (minX - startElementX) / edgeTolerance;
					}
					if (!rotationMode) {
						if (startElementY > maxY) {
							startElementY = maxY + (startElementY - maxY) / edgeTolerance;
						} else if (startElementY < minY) {
							startElementY = minY - (minY - startElementY) / edgeTolerance;
						}
					}
				}
				self.startX = startElementX = _round(startElementX);
				self.startY = startElementY = _round(startElementY);
			},

			isTweening = () => self.tween && self.tween.isActive(),

			removePlaceholder = () => {
				if (_placeholderDiv.parentNode && !isTweening() && !self.isDragging) { //_placeholderDiv just props open auto-scrolling containers so they don't collapse as the user drags left/up. We remove it after dragging (and throwing, if necessary) finishes.
					_placeholderDiv.parentNode.removeChild(_placeholderDiv);
				}
			},

			//called when the mouse is pressed (or touch starts)
			onPress = (e, force) => {
				let i;
				if (!enabled || self.isPressed || !e || ((e.type === "mousedown" || e.type === "pointerdown") && !force && _getTime() - clickTime < 30 && _touchEventLookup[self.pointerEvent.type])) { //when we DON'T preventDefault() in order to accommodate touch-scrolling and the user just taps, many browsers also fire a mousedown/mouseup sequence AFTER the touchstart/touchend sequence, thus it'd result in two quick "click" events being dispatched. This line senses that condition and halts it on the subsequent mousedown.
					isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchstart, pointerdown, mousedown. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.
					return;
				}
				interrupted = isTweening();
				self.pointerEvent = e;
				if (_touchEventLookup[e.type]) { //note: on iOS, BOTH touchmove and mousemove are dispatched, but the mousemove has pageY and pageX of 0 which would mess up the calculations and needlessly hurt performance.
					touchEventTarget = ~e.type.indexOf("touch") ? (e.currentTarget || e.target) : ownerDoc; //pointer-based touches (for Microsoft browsers) don't remain locked to the original target like other browsers, so we must use the document instead. The event type would be "MSPointerDown" or "pointerdown".
					_addListener(touchEventTarget, "touchend", onRelease);
					_addListener(touchEventTarget, "touchmove", onMove);
					_addListener(touchEventTarget, "touchcancel", onRelease);
					_addListener(ownerDoc, "touchstart", _onMultiTouchDocument);
				} else {
					touchEventTarget = null;
					_addListener(ownerDoc, "mousemove", onMove); //attach these to the document instead of the box itself so that if the user's mouse moves too quickly (and off of the box), things still work.
				}
				touchDragAxis = null;
				if (!_supportsPointer  || !touchEventTarget) {
					_addListener(ownerDoc, "mouseup", onRelease);
					e && e.target && _addListener(e.target, "mouseup", onRelease); //we also have to listen directly on the element because some browsers don't bubble up the event to the _doc on elements with contentEditable="true"
				}
				isClicking = (isClickable.call(self, e.target) && vars.dragClickables === false && !force);
				if (isClicking) {
					_addListener(e.target, "change", onRelease); //in some browsers, when you mousedown on a <select> element, no mouseup gets dispatched! So we listen for a "change" event instead.
					_dispatchEvent(self, "pressInit", "onPressInit");
					_dispatchEvent(self, "press", "onPress");
					_setSelectable(triggers, true); //accommodates things like inputs and elements with contentEditable="true" (otherwise user couldn't drag to select text)
					isPreventingDefault = false;
					return;
				}
				allowNativeTouchScrolling = (!touchEventTarget || allowX === allowY || self.vars.allowNativeTouchScrolling === false || (self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2))) ? false : allowX ? "y" : "x"; //note: in Chrome, right-clicking (for a context menu) fires onPress and it doesn't have the event.which set properly, so we must look for event.ctrlKey. If the user wants to allow context menus we should of course sense it here and not allow native touch scrolling.
				isPreventingDefault = !allowNativeTouchScrolling && !self.allowEventDefault;
				if (isPreventingDefault) {
					_preventDefault(e);
					_addListener(_win, "touchforcechange", _preventDefault); //works around safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/
				}
				if (e.changedTouches) { //touch events store the data slightly differently
					e = touch = e.changedTouches[0];
					touchID = e.identifier;
				} else if (e.pointerId) {
					touchID = e.pointerId; //for some Microsoft browsers
				} else {
					touch = touchID = null;
				}
				_dragCount++;
				_addToRenderQueue(render); //causes the Draggable to render on each "tick" of TweenLite.ticker (performance optimization - updating values in a mousemove can cause them to happen too frequently, like multiple times between frame redraws which is wasteful, and it also prevents values from updating properly in IE8)
				startPointerY = self.pointerY = e.pageY; //record the starting x and y so that we can calculate the movement from the original in _onMouseMove
				startPointerX = self.pointerX = e.pageX;
				_dispatchEvent(self, "pressInit", "onPressInit");
				if (allowNativeTouchScrolling || self.autoScroll) {
					_recordMaxScrolls(target.parentNode);
				}
				if (target.parentNode && self.autoScroll && !scrollProxy && !rotationMode && target.parentNode._gsMaxScrollX && !_placeholderDiv.parentNode && !target.getBBox) { //add a placeholder div to prevent the parent container from collapsing when the user drags the element left.
					_placeholderDiv.style.width = target.parentNode.scrollWidth + "px";
					target.parentNode.appendChild(_placeholderDiv);
				}
				recordStartPositions();
				self.tween && self.tween.kill();
				self.isThrowing = false;
				gsap.killTweensOf(scrollProxy || target, killProps, true); //in case the user tries to drag it before the last tween is done.
				scrollProxy && gsap.killTweensOf(target, {scrollTo:1}, true); //just in case the original target's scroll position is being tweened somewhere else.
				self.tween = self.lockedAxis = null;
				if (vars.zIndexBoost || (!rotationMode && !scrollProxy && vars.zIndexBoost !== false)) {
					target.style.zIndex = Draggable.zIndex++;
				}
				self.isPressed = true;
				hasDragCallback = !!(vars.onDrag || self._listeners.drag);
				hasMoveCallback = !!(vars.onMove || self._listeners.move);
				if (vars.cursor !== false || vars.activeCursor) {
					i = triggers.length;
					while (--i > -1) {
						gsap.set(triggers[i], {cursor: vars.activeCursor || vars.cursor || (_defaultCursor === "grab" ? "grabbing" : _defaultCursor)});
					}
				}
				_dispatchEvent(self, "press", "onPress");
			},

			//called every time the mouse/touch moves
			onMove = e => {
				let originalEvent = e,
					touches, pointerX, pointerY, i, dx, dy;
				if (!enabled || _isMultiTouching || !self.isPressed || !e) {
					isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchmove, pointermove, mousemove. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.
					return;
				}
				self.pointerEvent = e;
				touches = e.changedTouches;
				if (touches) { //touch events store the data slightly differently
					e = touches[0];
					if (e !== touch && e.identifier !== touchID) { //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)
						i = touches.length;
						while (--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target) {} // Some Android devices dispatch a touchstart AND pointerdown initially, and then only pointermove thus the touchID may not match because it was grabbed from the touchstart event whereas the pointer event is the one that the browser dispatches for move, so if the event target matches this Draggable's target, let it through.
						if (i < 0) {
							return;
						}
					}
				} else if (e.pointerId && touchID && e.pointerId !== touchID) { //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)
					return;
				}

				if (touchEventTarget && allowNativeTouchScrolling && !touchDragAxis) { //Android browsers force us to decide on the first "touchmove" event if we should allow the default (scrolling) behavior or preventDefault(). Otherwise, a "touchcancel" will be fired and then no "touchmove" or "touchend" will fire during the scrolling (no good).
					_point1.x = e.pageX - (isFixed ? _getDocScrollLeft(ownerDoc) : 0);
					_point1.y = e.pageY - (isFixed ? _getDocScrollTop(ownerDoc) : 0);
					matrix && matrix.apply(_point1, _point1);
					pointerX = _point1.x;
					pointerY = _point1.y;
					dx = Math.abs(pointerX - startPointerX);
					dy = Math.abs(pointerY - startPointerY);
					if ((dx !== dy && (dx > minimumMovement || dy > minimumMovement)) || (_isAndroid && allowNativeTouchScrolling === touchDragAxis)) {
						touchDragAxis = (dx > dy && allowX) ? "x" : "y";
						if (allowNativeTouchScrolling && touchDragAxis !== allowNativeTouchScrolling) {
							_addListener(_win, "touchforcechange", _preventDefault); // prevents native touch scrolling from taking over if the user started dragging in the other direction in iOS Safari
						}
						if (self.vars.lockAxisOnTouchScroll !== false && allowX && allowY) {
							self.lockedAxis = (touchDragAxis === "x") ? "y" : "x";
							_isFunction(self.vars.onLockAxis) && self.vars.onLockAxis.call(self, originalEvent);
						}
						if (_isAndroid && allowNativeTouchScrolling === touchDragAxis) {
							onRelease(originalEvent);
							return;
						}
					}
				}
				if (!self.allowEventDefault && (!allowNativeTouchScrolling || (touchDragAxis && allowNativeTouchScrolling !== touchDragAxis)) && originalEvent.cancelable !== false) {
					_preventDefault(originalEvent);
					isPreventingDefault = true;
				} else if (isPreventingDefault) {
					isPreventingDefault = false;
				}

				if (self.autoScroll) {
					checkAutoScrollBounds = true;
				}
				setPointerPosition(e.pageX, e.pageY, hasMoveCallback);
			},

			setPointerPosition = (pointerX, pointerY, invokeOnMove) => {
				let dragTolerance = 1 - self.dragResistance,
					edgeTolerance = 1 - self.edgeResistance,
					prevPointerX = self.pointerX,
					prevPointerY = self.pointerY,
					prevStartElementY = startElementY,
					prevX = self.x,
					prevY = self.y,
					prevEndX = self.endX,
					prevEndY = self.endY,
					prevEndRotation = self.endRotation,
					prevDirty = dirty,
					xChange, yChange, x, y, dif, temp;
				self.pointerX = pointerX;
				self.pointerY = pointerY;
				if (isFixed) {
					pointerX -= _getDocScrollLeft(ownerDoc);
					pointerY -= _getDocScrollTop(ownerDoc);
				}
				if (rotationMode) {
					y = Math.atan2(rotationOrigin.y - pointerY, pointerX - rotationOrigin.x) * _RAD2DEG;
					dif = self.y - y;
					if (dif > 180) {
						startElementY -= 360;
						self.y = y;
					} else if (dif < -180) {
						startElementY += 360;
						self.y = y;
					}
					if (self.x !== startElementX || Math.abs(startElementY - y) > minimumMovement) {
						self.y = y;
						x = startElementX + (startElementY - y) * dragTolerance;
					} else {
						x = startElementX;
					}

				} else {
					if (matrix) {
						temp = pointerX * matrix.a + pointerY * matrix.c + matrix.e;
						pointerY = pointerX * matrix.b + pointerY * matrix.d + matrix.f;
						pointerX = temp;
					}
					yChange = (pointerY - startPointerY);
					xChange = (pointerX - startPointerX);
					if (yChange < minimumMovement && yChange > -minimumMovement) {
						yChange = 0;
					}
					if (xChange < minimumMovement && xChange > -minimumMovement) {
						xChange = 0;
					}
					if ((self.lockAxis || self.lockedAxis) && (xChange || yChange)) {
						temp = self.lockedAxis;
						if (!temp) {
							self.lockedAxis = temp = (allowX && Math.abs(xChange) > Math.abs(yChange)) ? "y" : allowY ? "x" : null;
							if (temp && _isFunction(self.vars.onLockAxis)) {
								self.vars.onLockAxis.call(self, self.pointerEvent);
							}
						}
						if (temp === "y") {
							yChange = 0;
						} else if (temp === "x") {
							xChange = 0;
						}
					}
					x = _round(startElementX + xChange * dragTolerance);
					y = _round(startElementY + yChange * dragTolerance);
				}

				if ((snapX || snapY || snapXY) && (self.x !== x || (self.y !== y && !rotationMode))) {
					if (snapXY) {
						_temp1.x = x;
						_temp1.y = y;
						temp = snapXY(_temp1);
						x = _round(temp.x);
						y = _round(temp.y);
					}
					if (snapX) {
						x = _round(snapX(x));
					}
					if (snapY) {
						y = _round(snapY(y));
					}
				} else if (hasBounds) {
					if (x > maxX) {
						x = maxX + Math.round((x - maxX) * edgeTolerance);
					} else if (x < minX) {
						x = minX + Math.round((x - minX) * edgeTolerance);
					}
					if (!rotationMode) {
						if (y > maxY) {
							y = Math.round(maxY + (y - maxY) * edgeTolerance);
						} else if (y < minY) {
							y = Math.round(minY + (y - minY) * edgeTolerance);
						}
					}
				}
				if (self.x !== x || (self.y !== y && !rotationMode)) {
					if (rotationMode) {
						self.endRotation = self.x = self.endX = x;
						dirty = true;
					} else {
						if (allowY) {
							self.y = self.endY = y;
							dirty = true; //a flag that indicates we need to render the target next time the TweenLite.ticker dispatches a "tick" event (typically on a requestAnimationFrame) - this is a performance optimization (we shouldn't render on every move because sometimes many move events can get dispatched between screen refreshes, and that'd be wasteful to render every time)
						}
						if (allowX) {
							self.x = self.endX = x;
							dirty = true;
						}
					}
					if (!invokeOnMove || _dispatchEvent(self, "move", "onMove") !== false) {
						if (!self.isDragging && self.isPressed) {
							self.isDragging = true;
							_dispatchEvent(self, "dragstart", "onDragStart");
						}
					} else { //revert because the onMove returned false!
						self.pointerX = prevPointerX;
						self.pointerY = prevPointerY;
						startElementY = prevStartElementY;
						self.x = prevX;
						self.y = prevY;
						self.endX = prevEndX;
						self.endY = prevEndY;
						self.endRotation = prevEndRotation;
						dirty = prevDirty;
					}
				}
			},

			//called when the mouse/touch is released
			onRelease = (e, force) => {
				if (!enabled || !self.isPressed || (e && touchID != null && !force && ((e.pointerId && e.pointerId !== touchID && e.target !== target) || (e.changedTouches && !_hasTouchID(e.changedTouches, touchID))))) {  //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)
					isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchend, pointerup, mouseup. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.
					return;
				}
				self.isPressed = false;
				let originalEvent = e,
					wasDragging = self.isDragging,
					isContextMenuRelease = (self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2)),
					placeholderDelayedCall = gsap.delayedCall(0.001, removePlaceholder),
					touches, i, syntheticEvent, eventTarget, syntheticClick;
				if (touchEventTarget) {
					_removeListener(touchEventTarget, "touchend", onRelease);
					_removeListener(touchEventTarget, "touchmove", onMove);
					_removeListener(touchEventTarget, "touchcancel", onRelease);
					_removeListener(ownerDoc, "touchstart", _onMultiTouchDocument);
				} else {
					_removeListener(ownerDoc, "mousemove", onMove);
				}
				_removeListener(_win, "touchforcechange", _preventDefault);
				if (!_supportsPointer || !touchEventTarget) {
					_removeListener(ownerDoc, "mouseup", onRelease);
					e && e.target && _removeListener(e.target, "mouseup", onRelease);
				}
				dirty = false;
				if (wasDragging) {
					dragEndTime = _lastDragTime = _getTime();
					self.isDragging = false;
				}
				if (isClicking && !isContextMenuRelease) {
					if (e) {
						_removeListener(e.target, "change", onRelease);
						self.pointerEvent = originalEvent;
					}
					_setSelectable(triggers, false);
					_dispatchEvent(self, "release", "onRelease");
					_dispatchEvent(self, "click", "onClick");
					isClicking = false;
					return;
				}
				_removeFromRenderQueue(render);
				i = triggers.length;
				while (--i > -1) {
					_setStyle(triggers[i], "cursor", vars.cursor || (vars.cursor !== false ? _defaultCursor : null));
				}
				_dragCount--;
				if (e) {
					touches = e.changedTouches;
					if (touches) { //touch events store the data slightly differently
						e = touches[0];
						if (e !== touch && e.identifier !== touchID) { //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)
							i = touches.length;
							while (--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target) {}
							if (i < 0) {
								return;
							}
						}
					}
					self.pointerEvent = originalEvent;
					self.pointerX = e.pageX;
					self.pointerY = e.pageY;
				}
				if (isContextMenuRelease && originalEvent) {
					_preventDefault(originalEvent);
					isPreventingDefault = true;
					_dispatchEvent(self, "release", "onRelease");
				} else if (originalEvent && !wasDragging) {
					isPreventingDefault = false;
					if (interrupted && (vars.snap || vars.bounds)) { //otherwise, if the user clicks on the object while it's animating to a snapped position, and then releases without moving 3 pixels, it will just stay there (it should animate/snap)
						animate(vars.inertia || vars.throwProps);
					}
					_dispatchEvent(self, "release", "onRelease");
					if ((!_isAndroid || originalEvent.type !== "touchmove") && originalEvent.type.indexOf("cancel") === -1) { //to accommodate native scrolling on Android devices, we have to immediately call onRelease() on the first touchmove event, but that shouldn't trigger a "click".
						_dispatchEvent(self, "click", "onClick");
						if (_getTime() - clickTime < 300) {
							_dispatchEvent(self, "doubleclick", "onDoubleClick");
						}
						eventTarget = originalEvent.target || target; //old IE uses srcElement
						clickTime = _getTime();
						syntheticClick = () => { // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular "click" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the "real"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the "real" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.
							if (clickTime !== clickDispatch && self.enabled() && !self.isPressed && !originalEvent.defaultPrevented) {
								if (eventTarget.click) { //some browsers (like mobile Safari) don't properly trigger the click event
									eventTarget.click();
								} else if (ownerDoc.createEvent) {
									syntheticEvent = ownerDoc.createEvent("MouseEvents");
									syntheticEvent.initMouseEvent("click", true, true, _win, 1, self.pointerEvent.screenX, self.pointerEvent.screenY, self.pointerX, self.pointerY, false, false, false, false, 0, null);
									eventTarget.dispatchEvent(syntheticEvent);
								}
							}
						};
						if (!_isAndroid && !originalEvent.defaultPrevented) { //iOS Safari requires the synthetic click to happen immediately or else it simply won't work, but Android doesn't play nice.
							gsap.delayedCall(0.05, syntheticClick); //in addition to the iOS bug workaround, there's a Firefox issue with clicking on things like a video to play, so we must fake a click event in a slightly delayed fashion. Previously, we listened for the "click" event with "capture" false which solved the video-click-to-play issue, but it would allow the "click" event to be dispatched twice like if you were using a jQuery.click() because that was handled in the capture phase, thus we had to switch to the capture phase to avoid the double-dispatching, but do the delayed synthetic click. Don't fire it too fast (like 0.00001) because we want to give the native event a chance to fire first as it's "trusted".
						}
					}
				} else {
					animate(vars.inertia || vars.throwProps); //will skip if inertia/throwProps isn't defined or IntertiaPlugin isn't loaded.
					if (!self.allowEventDefault && originalEvent && (vars.dragClickables !== false || !isClickable.call(self, originalEvent.target)) && wasDragging && (!allowNativeTouchScrolling || (touchDragAxis && allowNativeTouchScrolling === touchDragAxis)) && originalEvent.cancelable !== false) {
						isPreventingDefault = true;
						_preventDefault(originalEvent);
					} else {
						isPreventingDefault = false;
					}
					_dispatchEvent(self, "release", "onRelease");
				}
				isTweening() && placeholderDelayedCall.duration( self.tween.duration() ); //sync the timing so that the placeholder DIV gets
				wasDragging && _dispatchEvent(self, "dragend", "onDragEnd");
				return true;
			},

			updateScroll = e => {
				if (e && self.isDragging && !scrollProxy) {
					let parent = e.target || target.parentNode,
						deltaX = parent.scrollLeft - parent._gsScrollX,
						deltaY = parent.scrollTop - parent._gsScrollY;
					if (deltaX || deltaY) {
						if (matrix) {
							startPointerX -= deltaX * matrix.a + deltaY * matrix.c;
							startPointerY -= deltaY * matrix.d + deltaX * matrix.b;
						} else {
							startPointerX -= deltaX;
							startPointerY -= deltaY;
						}
						parent._gsScrollX += deltaX;
						parent._gsScrollY += deltaY;
						setPointerPosition(self.pointerX, self.pointerY);
					}
				}
			},

			onClick = e => { //this was a huge pain in the neck to align all the various browsers and their behaviors. Chrome, Firefox, Safari, Opera, Android, and Microsoft Edge all handle events differently! Some will only trigger native behavior (like checkbox toggling) from trusted events. Others don't even support isTrusted, but require 2 events to flow through before triggering native behavior. Edge treats everything as trusted but also mandates that 2 flow through to trigger the correct native behavior.
				let time = _getTime(),
					recentlyClicked = (time - clickTime < 40),
					recentlyDragged = (time - dragEndTime < 40),
					alreadyDispatched = (recentlyClicked && clickDispatch === clickTime),
					defaultPrevented = (self.pointerEvent && self.pointerEvent.defaultPrevented),
					alreadyDispatchedTrusted = (recentlyClicked && trustedClickDispatch === clickTime),
					trusted = e.isTrusted || (e.isTrusted == null && recentlyClicked && alreadyDispatched); //note: Safari doesn't support isTrusted, and it won't properly execute native behavior (like toggling checkboxes) on the first synthetic "click" event - we must wait for the 2nd and treat it as trusted (but stop propagation at that point). Confusing, I know. Don't you love cross-browser compatibility challenges?
				if ((alreadyDispatched || (recentlyDragged && self.vars.suppressClickOnDrag !== false) ) && e.stopImmediatePropagation) {
					e.stopImmediatePropagation();
				}
				if (recentlyClicked && !(self.pointerEvent && self.pointerEvent.defaultPrevented) && (!alreadyDispatched || (trusted && !alreadyDispatchedTrusted))) { //let the first click pass through unhindered. Let the next one only if it's trusted, then no more (stop quick-succession ones)
					if (trusted && alreadyDispatched) {
						trustedClickDispatch = clickTime;
					}
					clickDispatch = clickTime;
					return;
				}
				if (self.isPressed || recentlyDragged || recentlyClicked) {
					if (!trusted || !e.detail || !recentlyClicked || defaultPrevented) {
						_preventDefault(e);
					}
				}
				if (!recentlyClicked && !recentlyDragged) { // for script-triggered event dispatches, like element.click()
					e && e.target && (self.pointerEvent = e);
					_dispatchEvent(self, "click", "onClick");
				}
			},

			localizePoint = p => matrix ? {x:p.x * matrix.a + p.y * matrix.c + matrix.e, y:p.x * matrix.b + p.y * matrix.d + matrix.f} : {x:p.x, y:p.y};

		old = Draggable.get(target);
		old && old.kill(); // avoids duplicates (an element can only be controlled by one Draggable)

		//give the user access to start/stop dragging...
		this.startDrag = (event, align) => {
			let r1, r2, p1, p2;
			onPress(event || self.pointerEvent, true);
			//if the pointer isn't on top of the element, adjust things accordingly
			if (align && !self.hitTest(event || self.pointerEvent)) {
				r1 = _parseRect(event || self.pointerEvent);
				r2 = _parseRect(target);
				p1 = localizePoint({x:r1.left + r1.width / 2, y:r1.top + r1.height / 2});
				p2 = localizePoint({x:r2.left + r2.width / 2, y:r2.top + r2.height / 2});
				startPointerX -= p1.x - p2.x;
				startPointerY -= p1.y - p2.y;
			}
			if (!self.isDragging) {
				self.isDragging = true;
				_dispatchEvent(self, "dragstart", "onDragStart");
			}
		};
		this.drag = onMove;
		this.endDrag = e =>	onRelease(e || self.pointerEvent, true);
		this.timeSinceDrag = () => self.isDragging ? 0 : (_getTime() - dragEndTime) / 1000;
		this.timeSinceClick = () => (_getTime() - clickTime) / 1000;
		this.hitTest = (target, threshold) => Draggable.hitTest(self.target, target, threshold);

		this.getDirection = (from, diagonalThreshold) => { //from can be "start" (default), "velocity", or an element
			let mode = (from === "velocity" && InertiaPlugin) ? from : (_isObject(from) && !rotationMode) ? "element" : "start",
				xChange, yChange, ratio, direction, r1, r2;
			if (mode === "element") {
				r1 = _parseRect(self.target);
				r2 = _parseRect(from);
			}
			xChange = (mode === "start") ? self.x - startElementX : (mode === "velocity") ? InertiaPlugin.getVelocity(target, xProp) : (r1.left + r1.width / 2) - (r2.left + r2.width / 2);
			if (rotationMode) {
				return xChange < 0 ? "counter-clockwise" : "clockwise";
			} else {
				diagonalThreshold = diagonalThreshold || 2;
				yChange = (mode === "start") ? self.y - startElementY : (mode === "velocity") ? InertiaPlugin.getVelocity(target, yProp) : (r1.top + r1.height / 2) - (r2.top + r2.height / 2);
				ratio = Math.abs(xChange / yChange);
				direction = (ratio < 1 / diagonalThreshold) ? "" : (xChange < 0) ? "left" : "right";
				if (ratio < diagonalThreshold) {
					if (direction !== "") {
						direction += "-";
					}
					direction += (yChange < 0) ? "up" : "down";
				}
			}
			return direction;
		};

		this.applyBounds = (newBounds, sticky) => {
			let x, y, forceZeroVelocity, e, parent, isRoot;
			if (newBounds && vars.bounds !== newBounds) {
				vars.bounds = newBounds;
				return self.update(true, sticky);
			}
			syncXY(true);
			calculateBounds();
			if (hasBounds && !isTweening()) {
				x = self.x;
				y = self.y;
				if (x > maxX) {
					x = maxX;
				} else if (x < minX) {
					x = minX;
				}
				if (y > maxY) {
					y = maxY;
				} else if (y < minY) {
					y = minY;
				}
				if (self.x !== x || self.y !== y) {
					forceZeroVelocity = true;
					self.x = self.endX = x;
					if (rotationMode) {
						self.endRotation = x;
					} else {
						self.y = self.endY = y;
					}
					dirty = true;
					render(true);
					if (self.autoScroll && !self.isDragging) {
						_recordMaxScrolls(target.parentNode);
						e = target;
						_windowProxy.scrollTop = ((_win.pageYOffset != null) ? _win.pageYOffset : (ownerDoc.documentElement.scrollTop != null) ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop);
						_windowProxy.scrollLeft = ((_win.pageXOffset != null) ? _win.pageXOffset : (ownerDoc.documentElement.scrollLeft != null) ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft);
						while (e && !isRoot) { //walk up the chain and sense wherever the scrollTop/scrollLeft exceeds the maximum.
							isRoot = _isRoot(e.parentNode);
							parent = isRoot ? _windowProxy : e.parentNode;
							if (allowY && parent.scrollTop > parent._gsMaxScrollY) {
								parent.scrollTop = parent._gsMaxScrollY;
							}
							if (allowX && parent.scrollLeft > parent._gsMaxScrollX) {
								parent.scrollLeft = parent._gsMaxScrollX;
							}
							e = parent;
						}
					}
				}
				if (self.isThrowing && (forceZeroVelocity || self.endX > maxX || self.endX < minX || self.endY > maxY || self.endY < minY)) {
					animate(vars.inertia || vars.throwProps, forceZeroVelocity);
				}
			}
			return self;
		};

		this.update = (applyBounds, sticky, ignoreExternalChanges) => {
			let { x, y } = self;
			updateMatrix(!sticky);
			if (applyBounds) {
				self.applyBounds();
			} else {
				dirty && ignoreExternalChanges && render(true);
				syncXY(true);
			}
			if (sticky) {
				setPointerPosition(self.pointerX, self.pointerY);
				dirty && render(true);
			}
			if (self.isPressed && !sticky && ((allowX && Math.abs(x - self.x) > 0.01) || (allowY && (Math.abs(y - self.y) > 0.01 && !rotationMode)))) {
				recordStartPositions();
			}
			if (self.autoScroll) {
				_recordMaxScrolls(target.parentNode, self.isDragging);
				checkAutoScrollBounds = self.isDragging;
				render(true);
				//in case reparenting occurred.
				_removeScrollListener(target, updateScroll);
				_addScrollListener(target, updateScroll);
			}
			return self;
		};

		this.enable = type => {
			let setVars = {lazy: true},
				id, i, trigger;
			if (vars.cursor !== false) {
				setVars.cursor = vars.cursor || _defaultCursor;
			}
			if (gsap.utils.checkPrefix("touchCallout")) {
				setVars.touchCallout = "none";
			}
			if (type !== "soft") {
				_setTouchActionForAllDescendants(triggers, (allowX === allowY) ? "none" : (vars.allowNativeTouchScrolling && (target.scrollHeight === target.clientHeight) === (target.scrollWidth === target.clientHeight)) || vars.allowEventDefault ? "manipulation" : allowX ? "pan-y" : "pan-x"); // Some browsers like Internet Explorer will fire a pointercancel event when the user attempts to drag when touchAction is "manipulate" because it's perceived as a pan. If the element has scrollable content in only one direction, we should use pan-x or pan-y accordingly so that the pointercancel doesn't prevent dragging.
				i = triggers.length;
				while (--i > -1) {
					trigger = triggers[i];
					_supportsPointer || _addListener(trigger, "mousedown", onPress);
					_addListener(trigger, "touchstart", onPress);
					_addListener(trigger, "click", onClick, true); //note: used to pass true for capture but it prevented click-to-play-video functionality in Firefox.
					gsap.set(trigger, setVars);
					if (trigger.getBBox && trigger.ownerSVGElement) { // a bug in chrome doesn't respect touch-action on SVG elements - it only works if we set it on the parent SVG.
						gsap.set(trigger.ownerSVGElement, {touchAction: (allowX === allowY) ? "none" : vars.allowNativeTouchScrolling || vars.allowEventDefault ? "manipulation" : allowX ? "pan-y" : "pan-x"});
					}
					vars.allowContextMenu || _addListener(trigger, "contextmenu", onContextMenu);
				}
				_setSelectable(triggers, false);
			}
			_addScrollListener(target, updateScroll);
			enabled = true;
			if (InertiaPlugin && type !== "soft") {
				InertiaPlugin.track(scrollProxy || target, (xyMode ? "x,y" : rotationMode ? "rotation" : "top,left"));
			}
			target._gsDragID = id = "d" + (_lookupCount++);
			_lookup[id] = self;
			if (scrollProxy) {
				scrollProxy.enable();
				scrollProxy.element._gsDragID = id;
			}
			(vars.bounds || rotationMode) && recordStartPositions();
			vars.bounds && self.applyBounds();
			return self;
		};

		this.disable = type => {
			let dragging = self.isDragging,
				i = triggers.length,
				trigger;
			while (--i > -1) {
				_setStyle(triggers[i], "cursor", null);
			}
			if (type !== "soft") {
				_setTouchActionForAllDescendants(triggers, null);
				i = triggers.length;
				while (--i > -1) {
					trigger = triggers[i];
					_setStyle(trigger, "touchCallout", null);
					_removeListener(trigger, "mousedown", onPress);
					_removeListener(trigger, "touchstart", onPress);
					_removeListener(trigger, "click", onClick);
					_removeListener(trigger, "contextmenu", onContextMenu);
				}
				_setSelectable(triggers, true);
				if (touchEventTarget) {
					_removeListener(touchEventTarget, "touchcancel", onRelease);
					_removeListener(touchEventTarget, "touchend", onRelease);
					_removeListener(touchEventTarget, "touchmove", onMove);
				}
				_removeListener(ownerDoc, "mouseup", onRelease);
				_removeListener(ownerDoc, "mousemove", onMove);
			}
			_removeScrollListener(target, updateScroll);
			enabled = false;
			InertiaPlugin && type !== "soft" && InertiaPlugin.untrack(scrollProxy || target, (xyMode ? "x,y" : rotationMode ? "rotation" : "top,left"));
			scrollProxy && scrollProxy.disable();
			_removeFromRenderQueue(render);
			self.isDragging = self.isPressed = isClicking = false;
			dragging && _dispatchEvent(self, "dragend", "onDragEnd");
			return self;
		};

		this.enabled = function(value, type) {
			return arguments.length ? (value ? self.enable(type) : self.disable(type)) : enabled;
		};

		this.kill = function() {
			self.isThrowing = false;
			self.tween && self.tween.kill();
			self.disable();
			gsap.set(triggers, {clearProps:"userSelect"});
			delete _lookup[target._gsDragID];
			return self;
		};

		if (~type.indexOf("scroll")) {
			scrollProxy = this.scrollProxy = new ScrollProxy(target, _extend({onKill:function() { //ScrollProxy's onKill() gets called if/when the ScrollProxy senses that the user interacted with the scroll position manually (like using the scrollbar). IE9 doesn't fire the "mouseup" properly when users drag the scrollbar of an element, so this works around that issue.
					self.isPressed && onRelease(null);
			}}, vars));
			//a bug in many Android devices' stock browser causes scrollTop to get forced back to 0 after it is altered via JS, so we set overflow to "hidden" on mobile/touch devices (they hide the scroll bar anyway). That works around the bug. (This bug is discussed at https://code.google.com/p/android/issues/detail?id=19625)
			target.style.overflowY = (allowY && !_isTouchDevice) ? "auto" : "hidden";
			target.style.overflowX = (allowX && !_isTouchDevice) ? "auto" : "hidden";
			target = scrollProxy.content;
		}

		if (rotationMode) {
			killProps.rotation = 1;
		} else {
			if (allowX) {
				killProps[xProp] = 1;
			}
			if (allowY) {
				killProps[yProp] = 1;
			}
		}

		gsCache.force3D = ("force3D" in vars) ? vars.force3D : true; //otherwise, normal dragging would be in 2D and then as soon as it's released and there's an inertia tween, it'd jump to 3D which can create an initial jump due to the work the browser must to do layerize it.

		this.enable();
	}




	static register(core) {
		gsap = core;
		_initCore();
	}

	static create(targets, vars) {
		_coreInitted || _initCore(true);
		return _toArray(targets).map(target => new Draggable(target, vars));
	}

	static get(target) {
		return _lookup[(_toArray(target)[0] || {})._gsDragID];
	}

	static timeSinceDrag() {
		return (_getTime() - _lastDragTime) / 1000;
	}

	static hitTest(obj1, obj2, threshold) {
		if (obj1 === obj2) {
			return false;
		}
		let r1 = _parseRect(obj1),
			r2 = _parseRect(obj2),
			{ top, left, right, bottom, width, height } = r1,
			isOutside = (r2.left > right || r2.right < left || r2.top > bottom || r2.bottom < top),
			overlap, area, isRatio;
		if (isOutside || !threshold) {
			return !isOutside;
		}
		isRatio = ((threshold + "").indexOf("%") !== -1);
		threshold = parseFloat(threshold) || 0;
		overlap = {left: Math.max(left, r2.left), top: Math.max(top, r2.top)};
		overlap.width = Math.min(right, r2.right) - overlap.left;
		overlap.height = Math.min(bottom, r2.bottom) - overlap.top;
		if (overlap.width < 0 || overlap.height < 0) {
			return false;
		}
		if (isRatio) {
			threshold *= 0.01;
			area = overlap.width * overlap.height;
			return (area >= width * height * threshold || area >= r2.width * r2.height * threshold);
		}
		return (overlap.width > threshold && overlap.height > threshold);
	}

}

_setDefaults(Draggable.prototype, {pointerX:0, pointerY: 0, startX: 0, startY: 0, deltaX: 0, deltaY: 0, isDragging: false, isPressed: false});

Draggable.zIndex = 1000;
Draggable.version = "3.7.0";

_getGSAP() && gsap.registerPlugin(Draggable);



/***/ }),

/***/ "./node_modules/gsap/src/EasePack.js":
/*!*******************************************!*\
  !*** ./node_modules/gsap/src/EasePack.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SlowMo": function() { return /* binding */ SlowMo; },
/* harmony export */   "ExpoScaleEase": function() { return /* binding */ ExpoScaleEase; },
/* harmony export */   "RoughEase": function() { return /* binding */ RoughEase; },
/* harmony export */   "EasePack": function() { return /* binding */ EasePack; },
/* harmony export */   "default": function() { return /* binding */ EasePack; }
/* harmony export */ });
/*!
 * EasePack 3.7.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */

let gsap, _coreInitted, _registerEase,
	_getGSAP = () => gsap || (typeof(window) !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap),
	_boolean = (value, defaultValue) => !!(typeof(value) === "undefined" ? defaultValue : value && !~((value + "").indexOf("false"))),
	_initCore = core => {
		gsap = core || _getGSAP();
		if (gsap) {
			_registerEase = gsap.registerEase;
			//add weighted ease capabilities to standard eases so users can do "power2.inOut(0.8)" for example to push everything toward the "out", or (-0.8) to push it toward the "in" (0 is neutral)
			let eases = gsap.parseEase(),
				createConfig = ease => ratio => {
					let y = 0.5 + ratio / 2;
					ease.config = p => ease(2 * (1 - p) * p * y + p * p);
				},
				p;
			for (p in eases) {
				if (!eases[p].config) {
					createConfig(eases[p]);
				}
			}
			_registerEase("slow", SlowMo);
			_registerEase("expoScale", ExpoScaleEase);
			_registerEase("rough", RoughEase);
			for (p in EasePack) {
				p !== "version" && gsap.core.globals(p, EasePack[p]);
			}
			_coreInitted = 1;
		}
	},
	_createSlowMo = (linearRatio, power, yoyoMode) => {
		linearRatio = Math.min(1, linearRatio || 0.7);
		let pow = linearRatio < 1 ? ((power || power === 0) ? power : 0.7) : 0,
			p1 = (1 - linearRatio) / 2,
			p3 = p1 + linearRatio,
			calcEnd = _boolean(yoyoMode);
		return p => {
			let r = p + (0.5 - p) * pow;
			return (p < p1) ? (calcEnd ? 1 - ((p = 1 - (p / p1)) * p) : r - ((p = 1 - (p / p1)) * p * p * p * r)) : (p > p3) ? (calcEnd ? (p === 1 ? 0 : 1 - (p = (p - p3) / p1) * p) : r + ((p - r) * (p = (p - p3) / p1) * p * p * p)) : (calcEnd ? 1 : r);
		}
	},
	_createExpoScale = (start, end, ease) => {
		let p1 = Math.log(end / start),
			p2 = end - start;
		ease && (ease = gsap.parseEase(ease));
		return p => (start * Math.exp(p1 * (ease ? ease(p) : p)) - start) / p2;
	},
	EasePoint = function(time, value, next) {
		this.t = time;
		this.v = value;
		if (next) {
			this.next = next;
			next.prev = this;
			this.c = next.v - value;
			this.gap = next.t - time;
		}
	},
	_createRoughEase = vars => {
		if (typeof(vars) !== "object") { //users may pass in via a string, like "rough(30)"
			vars = {points: +vars || 20};
		}
		let taper = vars.taper || "none",
			a = [],
			cnt = 0,
			points = (+vars.points || 20) | 0,
			i = points,
			randomize = _boolean(vars.randomize, true),
			clamp = _boolean(vars.clamp),
			template = gsap ? gsap.parseEase(vars.template) : 0,
			strength = (+vars.strength || 1) * 0.4,
			x, y, bump, invX, obj, pnt, recent;
		while (--i > -1) {
			x = randomize ? Math.random() : (1 / points) * i;
			y = template ? template(x) : x;
			if (taper === "none") {
				bump = strength;
			} else if (taper === "out") {
				invX = 1 - x;
				bump = invX * invX * strength;
			} else if (taper === "in") {
				bump = x * x * strength;
			} else if (x < 0.5) {  //"both" (start)
				invX = x * 2;
				bump = invX * invX * 0.5 * strength;
			} else {				//"both" (end)
				invX = (1 - x) * 2;
				bump = invX * invX * 0.5 * strength;
			}
			if (randomize) {
				y += (Math.random() * bump) - (bump * 0.5);
			} else if (i % 2) {
				y += bump * 0.5;
			} else {
				y -= bump * 0.5;
			}
			if (clamp) {
				if (y > 1) {
					y = 1;
				} else if (y < 0) {
					y = 0;
				}
			}
			a[cnt++] = {x:x, y:y};
		}
		a.sort((a, b) => a.x - b.x);
		pnt = new EasePoint(1, 1, null);
		i = points;
		while (i--) {
			obj = a[i];
			pnt = new EasePoint(obj.x, obj.y, pnt);
		}
		recent = new EasePoint(0, 0, pnt.t ? pnt : pnt.next);
		return p => {
			let pnt = recent;
			if (p > pnt.t) {
				while (pnt.next && p >= pnt.t) {
					pnt = pnt.next;
				}
				pnt = pnt.prev;
			} else {
				while (pnt.prev && p <= pnt.t) {
					pnt = pnt.prev;
				}
			}
			recent = pnt;
			return pnt.v + ((p - pnt.t) / pnt.gap) * pnt.c;
		};
	};

const SlowMo = _createSlowMo(0.7);
SlowMo.ease = SlowMo; //for backward compatibility
SlowMo.config = _createSlowMo;

const ExpoScaleEase = _createExpoScale(1, 2);
ExpoScaleEase.config = _createExpoScale;

const RoughEase = _createRoughEase();
RoughEase.ease = RoughEase; //for backward compatibility
RoughEase.config = _createRoughEase;

const EasePack = {
	SlowMo: SlowMo,
	RoughEase: RoughEase,
	ExpoScaleEase: ExpoScaleEase
};

for (let p in EasePack) {
	EasePack[p].register = _initCore;
	EasePack[p].version = "3.7.0";
}

_getGSAP() && gsap.registerPlugin(SlowMo);



/***/ }),

/***/ "./node_modules/gsap/src/EaselPlugin.js":
/*!**********************************************!*\
  !*** ./node_modules/gsap/src/EaselPlugin.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EaselPlugin": function() { return /* binding */ EaselPlugin; },
/* harmony export */   "default": function() { return /* binding */ EaselPlugin; }
/* harmony export */ });
/*!
 * EaselPlugin 3.7.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */

let gsap, _coreInitted, _win, _createJS, _ColorFilter, _ColorMatrixFilter,
	_colorProps = "redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier,redOffset,greenOffset,blueOffset,alphaOffset".split(","),
	_windowExists = () => typeof(window) !== "undefined",
	_getGSAP = () => gsap || (_windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap),
	_getCreateJS = () => _createJS || (_win && _win.createjs) || _win || {},
	_warn = message => console.warn(message),
	_cache = target => {
		let b = target.getBounds && target.getBounds();
		if (!b) {
			b = target.nominalBounds || {x:0, y:0, width: 100, height: 100};
			target.setBounds && target.setBounds(b.x, b.y, b.width, b.height);
		}
		target.cache && target.cache(b.x, b.y, b.width, b.height);
		_warn("EaselPlugin: for filters to display in EaselJS, you must call the object's cache() method first. GSAP attempted to use the target's getBounds() for the cache but that may not be completely accurate. " + target);
	},
	_parseColorFilter = (target, v, plugin) => {
		if (!_ColorFilter) {
			_ColorFilter = _getCreateJS().ColorFilter;
			if (!_ColorFilter) {
				_warn("EaselPlugin error: The EaselJS ColorFilter JavaScript file wasn't loaded.");
			}
		}
		let filters = target.filters || [],
			i = filters.length,
			c, s, e, a, p, pt;
		while (i--) {
			if (filters[i] instanceof _ColorFilter) {
				s = filters[i];
				break;
			}
		}
		if (!s) {
			s = new _ColorFilter();
			filters.push(s);
			target.filters = filters;
		}
		e = s.clone();
		if (v.tint != null) {
			c = gsap.utils.splitColor(v.tint);
			a = (v.tintAmount != null) ? +v.tintAmount : 1;
			e.redOffset = +c[0] * a;
			e.greenOffset = +c[1] * a;
			e.blueOffset = +c[2] * a;
			e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1 - a;
		} else {
			for (p in v) {
				if (p !== "exposure") if (p !== "brightness") {
					e[p] = +v[p];
				}
			}
		}
		if (v.exposure != null) {
			e.redOffset = e.greenOffset = e.blueOffset = 255 * (+v.exposure - 1);
			e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1;
		} else if (v.brightness != null) {
			a = +v.brightness - 1;
			e.redOffset = e.greenOffset = e.blueOffset = (a > 0) ? a * 255 : 0;
			e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1 - Math.abs(a);
		}
		i = 8;
		while (i--) {
			p = _colorProps[i];
			if (s[p] !== e[p]) {
				pt = plugin.add(s, p, s[p], e[p]);
				if (pt) {
					pt.op = "easel_colorFilter";
				}
			}
		}
		plugin._props.push("easel_colorFilter");
		if (!target.cacheID) {
			_cache(target);
		}
	},

	_idMatrix = [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],
	_lumR = 0.212671,
	_lumG = 0.715160,
	_lumB = 0.072169,

	_applyMatrix = (m, m2) => {
		if (!(m instanceof Array) || !(m2 instanceof Array)) {
			return m2;
		}
		let temp = [],
			i = 0,
			z = 0,
			y, x;
		for (y = 0; y < 4; y++) {
			for (x = 0; x < 5; x++) {
				z = (x === 4) ? m[i + 4] : 0;
				temp[i + x] = m[i]   * m2[x] + m[i+1] * m2[x + 5] +	m[i+2] * m2[x + 10] + m[i+3] * m2[x + 15] +	z;
			}
			i += 5;
		}
		return temp;
	},

	_setSaturation = (m, n) => {
		if (isNaN(n)) {
			return m;
		}
		let inv = 1 - n,
			r = inv * _lumR,
			g = inv * _lumG,
			b = inv * _lumB;
		return _applyMatrix([r + n, g, b, 0, 0, r, g + n, b, 0, 0, r, g, b + n, 0, 0, 0, 0, 0, 1, 0], m);
	},

	_colorize = (m, color, amount) => {
		if (isNaN(amount)) {
			amount = 1;
		}
		let c = gsap.utils.splitColor(color),
			r = c[0] / 255,
			g = c[1] / 255,
			b = c[2] / 255,
			inv = 1 - amount;
		return _applyMatrix([inv + amount * r * _lumR, amount * r * _lumG, amount * r * _lumB, 0, 0, amount * g * _lumR, inv + amount * g * _lumG, amount * g * _lumB, 0, 0, amount * b * _lumR, amount * b * _lumG, inv + amount * b * _lumB, 0, 0, 0, 0, 0, 1, 0], m);
	},

	_setHue = (m, n) => {
		if (isNaN(n)) {
			return m;
		}
		n *= Math.PI / 180;
		let c = Math.cos(n),
			s = Math.sin(n);
		return _applyMatrix([(_lumR + (c * (1 - _lumR))) + (s * (-_lumR)), (_lumG + (c * (-_lumG))) + (s * (-_lumG)), (_lumB + (c * (-_lumB))) + (s * (1 - _lumB)), 0, 0, (_lumR + (c * (-_lumR))) + (s * 0.143), (_lumG + (c * (1 - _lumG))) + (s * 0.14), (_lumB + (c * (-_lumB))) + (s * -0.283), 0, 0, (_lumR + (c * (-_lumR))) + (s * (-(1 - _lumR))), (_lumG + (c * (-_lumG))) + (s * _lumG), (_lumB + (c * (1 - _lumB))) + (s * _lumB), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], m);
	},

	_setContrast = (m, n) => {
		if (isNaN(n)) {
			return m;
		}
		n += 0.01;
		return _applyMatrix([n,0,0,0,128 * (1 - n), 0,n,0,0,128 * (1 - n), 0,0,n,0,128 * (1 - n), 0,0,0,1,0], m);
	},

	_parseColorMatrixFilter = (target, v, plugin) => {
		if (!_ColorMatrixFilter) {
			_ColorMatrixFilter = _getCreateJS().ColorMatrixFilter;
			if (!_ColorMatrixFilter) {
				_warn("EaselPlugin: The EaselJS ColorMatrixFilter JavaScript file wasn't loaded.");
			}
		}
		let filters = target.filters || [],
			i = filters.length,
			matrix, startMatrix, s, pg;
		while (--i > -1) {
			if (filters[i] instanceof _ColorMatrixFilter) {
				s = filters[i];
				break;
			}
		}
		if (!s) {
			s = new _ColorMatrixFilter(_idMatrix.slice());
			filters.push(s);
			target.filters = filters;
		}
		startMatrix = s.matrix;
		matrix = _idMatrix.slice();
		if (v.colorize != null) {
			matrix = _colorize(matrix, v.colorize, Number(v.colorizeAmount));
		}
		if (v.contrast != null) {
			matrix = _setContrast(matrix, Number(v.contrast));
		}
		if (v.hue != null) {
			matrix = _setHue(matrix, Number(v.hue));
		}
		if (v.saturation != null) {
			matrix = _setSaturation(matrix, Number(v.saturation));
		}

		i = matrix.length;
		while (--i > -1) {
			if (matrix[i] !== startMatrix[i]) {
				pg = plugin.add(startMatrix, i, startMatrix[i], matrix[i]);
				if (pg) {
					pg.op = "easel_colorMatrixFilter";
				}
			}
		}

		plugin._props.push("easel_colorMatrixFilter");
		if (!target.cacheID) {
			_cache();
		}

		plugin._matrix = startMatrix;
	},

	_initCore = core => {
		gsap = core || _getGSAP();
		if (_windowExists()) {
			_win = window;
		}
		if (gsap) {

			_coreInitted = 1;
		}
	};


const EaselPlugin = {
	version: "3.7.0",
	name: "easel",
	init(target, value, tween, index, targets) {
		if (!_coreInitted) {
			_initCore();
			if (!gsap) {
				_warn("Please gsap.registerPlugin(EaselPlugin)");
			}
		}
		this.target = target;
		let p, pt, tint, colorMatrix, end, labels, i;
		for (p in value) {

			end = value[p];
			if (p === "colorFilter" || p === "tint" || p === "tintAmount" || p === "exposure" || p === "brightness") {
				if (!tint) {
					_parseColorFilter(target, value.colorFilter || value, this);
					tint = true;
				}

			} else if (p === "saturation" || p === "contrast" || p === "hue" || p === "colorize" || p === "colorizeAmount") {
				if (!colorMatrix) {
					_parseColorMatrixFilter(target, value.colorMatrixFilter || value, this);
					colorMatrix = true;
				}

			} else if (p === "frame") {
				if (typeof(end) === "string" && end.charAt(1) !== "=" && (labels = target.labels)) {
					for (i = 0; i < labels.length; i++) {
						if (labels[i].label === end) {
							end = labels[i].position;
						}
					}
				}
				pt = this.add(target, "gotoAndStop", target.currentFrame, end, index, targets, Math.round);
				if (pt) {
					pt.op = p;
				}

			} else if (target[p] != null) {
				this.add(target, p, "get", end);
			}

		}
	},
	render(ratio, data) {
		let pt = data._pt;
		while (pt) {
			pt.r(ratio, pt.d);
			pt = pt._next;
		}
		if (data.target.cacheID) {
			data.target.updateCache();
		}
	},
	register: _initCore
};

EaselPlugin.registerCreateJS = createjs => {
	_createJS = createjs;
};

_getGSAP() && gsap.registerPlugin(EaselPlugin);



/***/ }),

/***/ "./node_modules/gsap/src/MotionPathPlugin.js":
/*!***************************************************!*\
  !*** ./node_modules/gsap/src/MotionPathPlugin.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MotionPathPlugin": function() { return /* binding */ MotionPathPlugin; },
/* harmony export */   "default": function() { return /* binding */ MotionPathPlugin; }
/* harmony export */ });
/* harmony import */ var _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/paths.js */ "./node_modules/gsap/src/utils/paths.js");
/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/matrix.js */ "./node_modules/gsap/src/utils/matrix.js");
/*!
 * MotionPathPlugin 3.7.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */




let _xProps = "x,translateX,left,marginLeft,xPercent".split(","),
	_yProps = "y,translateY,top,marginTop,yPercent".split(","),
	_DEG2RAD = Math.PI / 180,
	gsap, PropTween, _getUnit, _toArray,
	_getGSAP = () => gsap || (typeof(window) !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap),
	_populateSegmentFromArray = (segment, values, property, mode) => { //mode: 0 = x but don't fill y yet, 1 = y, 2 = x and fill y with 0.
		let l = values.length,
			si = mode === 2 ? 0 : mode,
			i = 0,
			v;
		for (; i < l; i++) {
			segment[si] = v = parseFloat(values[i][property]);
			mode === 2 && (segment[si+1] = 0);
			si += 2;
		}
		return segment;
	},
	_getPropNum = (target, prop, unit) => parseFloat(target._gsap.get(target, prop, unit || "px")) || 0,
	_relativize = segment => {
		let x = segment[0],
			y = segment[1],
			i;
		for (i = 2; i < segment.length; i+=2) {
			x = (segment[i] += x);
			y = (segment[i+1] += y);
		}
	},
	_segmentToRawPath = (plugin, segment, target, x, y, slicer, vars, unitX, unitY) => {
		if (vars.type === "cubic") {
			segment = [segment];
		} else {
			vars.fromCurrent !== false && segment.unshift(_getPropNum(target, x, unitX), y ? _getPropNum(target, y, unitY) : 0);
			vars.relative && _relativize(segment);
			let pointFunc = y ? _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment : _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.flatPointsToSegment;
			segment = [pointFunc(segment, vars.curviness)];
		}
		segment = slicer(_align(segment, target, vars));
		_addDimensionalPropTween(plugin, target, x, segment, "x", unitX);
		y && _addDimensionalPropTween(plugin, target, y, segment, "y", unitY);
		return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements)(segment, vars.resolution || (vars.curviness === 0 ? 20 : 12)); //when curviness is 0, it creates control points right on top of the anchors which makes it more sensitive to resolution, thus we change the default accordingly.
	},
	_emptyFunc = v => v,
	_numExp = /[-+\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/g,
	_originToPoint = (element, origin, parentMatrix) => { // origin is an array of normalized values (0-1) in relation to the width/height, so [0.5, 0.5] would be the center. It can also be "auto" in which case it will be the top left unless it's a <path>, when it will start at the beginning of the path itself.
		let m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(element),
			svg, x, y;
		if ((element.tagName + "").toLowerCase() === "svg") {
			svg = element.viewBox.baseVal;
			x = svg.x;
			y = svg.y;
			svg.width || (svg = {width: +element.getAttribute("width"), height: +element.getAttribute("height")});
		} else {
			svg = origin && element.getBBox && element.getBBox();
			x = y = 0;
		}
		if (origin && origin !== "auto") {
			x += origin.push ? origin[0] * (svg ? svg.width : element.offsetWidth || 0) : origin.x;
			y += origin.push ? origin[1] * (svg ? svg.height : element.offsetHeight || 0) : origin.y;
		}
		return parentMatrix.apply( x || y ? m.apply({x: x, y: y}) : {x: m.e, y: m.f} );
	},
	_getAlignMatrix = (fromElement, toElement, fromOrigin, toOrigin) => {
		let parentMatrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(fromElement.parentNode, true, true),
			m = parentMatrix.clone().multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(toElement)),
			fromPoint = _originToPoint(fromElement, fromOrigin, parentMatrix),
			{x, y} = _originToPoint(toElement, toOrigin, parentMatrix),
			p;
		m.e = m.f = 0;
		if (toOrigin === "auto" && toElement.getTotalLength && toElement.tagName.toLowerCase() === "path") {
			p = toElement.getAttribute("d").match(_numExp) || [];
			p = m.apply({x:+p[0], y:+p[1]});
			x += p.x;
			y += p.y;
		}
		if (p || (toElement.getBBox && fromElement.getBBox && toElement.ownerSVGElement === fromElement.ownerSVGElement)) {
			p = m.apply(toElement.getBBox());
			x -= p.x;
			y -= p.y;
		}
		m.e = x - fromPoint.x;
		m.f = y - fromPoint.y;
		return m;
	},
	_align = (rawPath, target, {align, matrix, offsetX, offsetY, alignOrigin}) => {
		let x = rawPath[0][0],
			y = rawPath[0][1],
			curX = _getPropNum(target, "x"),
			curY = _getPropNum(target, "y"),
			alignTarget, m, p;
		if (!rawPath || !rawPath.length) {
			return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath)("M0,0L0,0");
		}
		if (align) {
			if (align === "self" || ((alignTarget = _toArray(align)[0] || target) === target)) {
				(0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, 1, 0, 0, 1, curX - x, curY - y);
			} else {
				if (alignOrigin && alignOrigin[2] !== false) {
					gsap.set(target, {transformOrigin:(alignOrigin[0] * 100) + "% " + (alignOrigin[1] * 100) + "%"});
				} else {
					alignOrigin = [_getPropNum(target, "xPercent") / -100, _getPropNum(target, "yPercent") / -100];
				}
				m = _getAlignMatrix(target, alignTarget, alignOrigin, "auto");
				p = m.apply({x: x, y: y});
				(0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, m.a, m.b, m.c, m.d, curX + m.e - (p.x - m.e), curY + m.f - (p.y - m.f));
			}
		}
		if (matrix) {
			(0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
		} else if (offsetX || offsetY) {
			(0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, 1, 0, 0, 1, offsetX || 0, offsetY || 0);
		}
		return rawPath;
	},
	_addDimensionalPropTween = (plugin, target, property, rawPath, pathProperty, forceUnit) => {
		let cache = target._gsap,
			harness = cache.harness,
			alias = (harness && harness.aliases && harness.aliases[property]),
			prop = alias && alias.indexOf(",") < 0 ? alias : property,
			pt = plugin._pt = new PropTween(plugin._pt, target, prop, 0, 0, _emptyFunc, 0, cache.set(target, prop, plugin));
		pt.u = _getUnit(cache.get(target, prop, forceUnit)) || 0;
		pt.path = rawPath;
		pt.pp = pathProperty;
		plugin._props.push(prop);
	},
	_sliceModifier = (start, end) => rawPath => (start || end !== 1) ? (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.sliceRawPath)(rawPath, start, end) : rawPath;


const MotionPathPlugin = {
	version: "3.7.0",
	name: "motionPath",
	register(core, Plugin, propTween) {
		gsap = core;
		_getUnit = gsap.utils.getUnit;
		_toArray = gsap.utils.toArray;
		PropTween = propTween;
	},
	init(target, vars) {
		if (!gsap) {
			console.warn("Please gsap.registerPlugin(MotionPathPlugin)");
			return false;
		}
		if (!(typeof(vars) === "object" && !vars.style) || !vars.path) {
			vars = {path:vars};
		}
		let rawPaths = [],
			{path, autoRotate, unitX, unitY, x, y} = vars,
			firstObj = path[0],
			slicer = _sliceModifier(vars.start, ("end" in vars) ? vars.end : 1),
			rawPath, p;
		this.rawPaths = rawPaths;
		this.target = target;
		if ((this.rotate = (autoRotate || autoRotate === 0))) { //get the rotational data FIRST so that the setTransform() method is called in the correct order in the render() loop - rotation gets set last.
			this.rOffset = parseFloat(autoRotate) || 0;
			this.radians = !!vars.useRadians;
			this.rProp = vars.rotation || "rotation";                       // rotation property
			this.rSet = target._gsap.set(target, this.rProp, this);         // rotation setter
			this.ru = _getUnit(target._gsap.get(target, this.rProp)) || 0;  // rotation units
		}
		if (Array.isArray(path) && !("closed" in path) && typeof(firstObj) !== "number") {
			for (p in firstObj) {
				if (!x && ~_xProps.indexOf(p)) {
					x = p;
				} else if (!y && ~_yProps.indexOf(p)) {
					y = p;
				}
			}
			if (x && y) { //correlated values
				rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray(_populateSegmentFromArray([], path, x, 0), path, y, 1), target, x, y, slicer, vars, unitX || _getUnit(path[0][x]), unitY || _getUnit(path[0][y])));
			} else {
				x = y = 0;
			}
			for (p in firstObj) {
				p !== x && p !== y && rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray([], path, p, 2), target, p, 0, slicer, vars, _getUnit(path[0][p])));
			}
		} else {
			rawPath = slicer(_align((0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath)(vars.path), target, vars));
			(0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements)(rawPath, vars.resolution);
			rawPaths.push(rawPath);
			_addDimensionalPropTween(this, target, vars.x || "x", rawPath, "x", vars.unitX || "px");
			_addDimensionalPropTween(this, target, vars.y || "y", rawPath, "y", vars.unitY || "px");
		}
	},
	render(ratio, data) {
		let rawPaths = data.rawPaths,
			i = rawPaths.length,
			pt = data._pt;
		if (ratio > 1) {
			ratio = 1;
		} else if (ratio < 0) {
			ratio = 0;
		}
		while (i--) {
			(0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getPositionOnPath)(rawPaths[i], ratio, !i && data.rotate, rawPaths[i]);
		}
		while (pt) {
			pt.set(pt.t, pt.p, pt.path[pt.pp] + pt.u, pt.d, ratio);
			pt = pt._next;
		}
		data.rotate && data.rSet(data.target, data.rProp, rawPaths[0].angle * (data.radians ? _DEG2RAD : 1) + data.rOffset + data.ru, data, ratio);
	},
	getLength(path) {
		return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements)((0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath)(path)).totalLength;
	},
	sliceRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.sliceRawPath,
	getRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath,
	pointsToSegment: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment,
	stringToRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.stringToRawPath,
	rawPathToString: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.rawPathToString,
	transformRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath,
	getGlobalMatrix: _utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix,
	getPositionOnPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getPositionOnPath,
	cacheRawPathMeasurements: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements,
	convertToPath: (targets, swap) => _toArray(targets).map(target => (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.convertToPath)(target, swap !== false)),
	convertCoordinates(fromElement, toElement, point) {
		let m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(toElement, true, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(fromElement));
		return point ? m.apply(point) : m;
	},
	getAlignMatrix: _getAlignMatrix,
	getRelativePosition(fromElement, toElement, fromOrigin, toOrigin) {
		let m =_getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin);
		return {x: m.e, y: m.f};
	},
	arrayToRawPath(value, vars) {
		vars = vars || {};
		let segment = _populateSegmentFromArray(_populateSegmentFromArray([], value, vars.x || "x", 0), value, vars.y || "y", 1);
		vars.relative && _relativize(segment);
		return [(vars.type === "cubic") ? segment : (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment)(segment, vars.curviness)];
	}
};

_getGSAP() && gsap.registerPlugin(MotionPathPlugin);



/***/ }),

/***/ "./node_modules/gsap/src/PixiPlugin.js":
/*!*********************************************!*\
  !*** ./node_modules/gsap/src/PixiPlugin.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PixiPlugin": function() { return /* binding */ PixiPlugin; },
/* harmony export */   "default": function() { return /* binding */ PixiPlugin; }
/* harmony export */ });
/*!
 * PixiPlugin 3.7.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */

let gsap, _win, _splitColor, _coreInitted, _PIXI, PropTween, _getSetter,
	_windowExists = () => typeof(window) !== "undefined",
	_getGSAP = () => gsap || (_windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap),
	_isFunction = value => typeof(value) === "function",
	_warn = message => console.warn(message),
	_idMatrix = [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],
	_lumR = 0.212671,
	_lumG = 0.715160,
	_lumB = 0.072169,
	_applyMatrix = (m, m2) => {
		let temp = [],
			i = 0,
			z = 0,
			y, x;
		for (y = 0; y < 4; y++) {
			for (x = 0; x < 5; x++) {
				z = (x === 4) ? m[i + 4] : 0;
				temp[i + x] = m[i]   * m2[x] + m[i+1] * m2[x + 5] +	m[i+2] * m2[x + 10] + m[i+3] * m2[x + 15] +	z;
			}
			i += 5;
		}
		return temp;
	},
	_setSaturation = (m, n) => {
		let inv = 1 - n,
			r = inv * _lumR,
			g = inv * _lumG,
			b = inv * _lumB;
		return _applyMatrix([r + n, g, b, 0, 0, r, g + n, b, 0, 0, r, g, b + n, 0, 0, 0, 0, 0, 1, 0], m);
	},
	_colorize = (m, color, amount) => {
		let c = _splitColor(color),
			r = c[0] / 255,
			g = c[1] / 255,
			b = c[2] / 255,
			inv = 1 - amount;
		return _applyMatrix([inv + amount * r * _lumR, amount * r * _lumG, amount * r * _lumB, 0, 0, amount * g * _lumR, inv + amount * g * _lumG, amount * g * _lumB, 0, 0, amount * b * _lumR, amount * b * _lumG, inv + amount * b * _lumB, 0, 0, 0, 0, 0, 1, 0], m);
	},
	_setHue = (m, n) => {
		n *= Math.PI / 180;
		let c = Math.cos(n),
			s = Math.sin(n);
		return _applyMatrix([(_lumR + (c * (1 - _lumR))) + (s * (-_lumR)), (_lumG + (c * (-_lumG))) + (s * (-_lumG)), (_lumB + (c * (-_lumB))) + (s * (1 - _lumB)), 0, 0, (_lumR + (c * (-_lumR))) + (s * 0.143), (_lumG + (c * (1 - _lumG))) + (s * 0.14), (_lumB + (c * (-_lumB))) + (s * -0.283), 0, 0, (_lumR + (c * (-_lumR))) + (s * (-(1 - _lumR))), (_lumG + (c * (-_lumG))) + (s * _lumG), (_lumB + (c * (1 - _lumB))) + (s * _lumB), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], m);
	},
	_setContrast = (m, n) => _applyMatrix([n,0,0,0,0.5 * (1 - n), 0,n,0,0,0.5 * (1 - n), 0,0,n,0,0.5 * (1 - n), 0,0,0,1,0], m),
	_getFilter = (target, type) => {
		let filterClass = _PIXI.filters[type],
			filters = target.filters || [],
			i = filters.length,
			filter;
		if (!filterClass) {
			_warn(type + " not found. PixiPlugin.registerPIXI(PIXI)");
		}
		while (--i > -1) {
			if (filters[i] instanceof filterClass) {
				return filters[i];
			}
		}
		filter = new filterClass();
		if (type === "BlurFilter") {
			filter.blur = 0;
		}
		filters.push(filter);
		target.filters = filters;
		return filter;
	},
	_addColorMatrixFilterCacheTween = (p, plugin, cache, vars) => { //we cache the ColorMatrixFilter components in a _gsColorMatrixFilter object attached to the target object so that it's easy to grab the current value at any time.
		plugin.add(cache, p, cache[p], vars[p]);
		plugin._props.push(p);
	},
	_applyBrightnessToMatrix = (brightness, matrix) => {
		let temp = new _PIXI.filters.ColorMatrixFilter();
		temp.matrix = matrix;
		temp.brightness(brightness, true);
		return temp.matrix;
	},
	_copy = obj => {
		let copy = {},
			p;
		for (p in obj) {
			copy[p] = obj[p];
		}
		return copy;
	},
	_CMFdefaults = {contrast:1, saturation:1, colorizeAmount:0, colorize:"rgb(255,255,255)", hue:0, brightness:1},
	_parseColorMatrixFilter = (target, v, pg) => {
		let filter = _getFilter(target, "ColorMatrixFilter"),
			cache = target._gsColorMatrixFilter = target._gsColorMatrixFilter || _copy(_CMFdefaults),
			combine = v.combineCMF && !("colorMatrixFilter" in v && !v.colorMatrixFilter),
			i, matrix, startMatrix;
		startMatrix = filter.matrix;
		if (v.resolution) {
			filter.resolution = v.resolution;
		}
		if (v.matrix && v.matrix.length === startMatrix.length) {
			matrix = v.matrix;
			if (cache.contrast !== 1) {
				_addColorMatrixFilterCacheTween("contrast", pg, cache, _CMFdefaults);
			}
			if (cache.hue) {
				_addColorMatrixFilterCacheTween("hue", pg, cache, _CMFdefaults);
			}
			if (cache.brightness !== 1) {
				_addColorMatrixFilterCacheTween("brightness", pg, cache, _CMFdefaults);
			}
			if (cache.colorizeAmount) {
				_addColorMatrixFilterCacheTween("colorize", pg, cache, _CMFdefaults);
				_addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, _CMFdefaults);
			}
			if (cache.saturation !== 1) {
				_addColorMatrixFilterCacheTween("saturation", pg, cache, _CMFdefaults);
			}

		} else {
			matrix = _idMatrix.slice();
			if (v.contrast != null) {
				matrix = _setContrast(matrix, +v.contrast);
				_addColorMatrixFilterCacheTween("contrast", pg, cache, v);
			} else if (cache.contrast !== 1) {
				if (combine) {
					matrix = _setContrast(matrix, cache.contrast);
				} else {
					_addColorMatrixFilterCacheTween("contrast", pg, cache, _CMFdefaults);
				}
			}
			if (v.hue != null) {
				matrix = _setHue(matrix, +v.hue);
				_addColorMatrixFilterCacheTween("hue", pg, cache, v);
			} else if (cache.hue) {
				if (combine) {
					matrix = _setHue(matrix, cache.hue);
				} else {
					_addColorMatrixFilterCacheTween("hue", pg, cache, _CMFdefaults);
				}
			}
			if (v.brightness != null) {
				matrix = _applyBrightnessToMatrix(+v.brightness, matrix);
				_addColorMatrixFilterCacheTween("brightness", pg, cache, v);
			} else if (cache.brightness !== 1) {
				if (combine) {
					matrix = _applyBrightnessToMatrix(cache.brightness, matrix);
				} else {
					_addColorMatrixFilterCacheTween("brightness", pg, cache, _CMFdefaults);
				}
			}
			if (v.colorize != null) {
				v.colorizeAmount = ("colorizeAmount" in v) ? +v.colorizeAmount : 1;
				matrix = _colorize(matrix, v.colorize, v.colorizeAmount);
				_addColorMatrixFilterCacheTween("colorize", pg, cache, v);
				_addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, v);
			} else if (cache.colorizeAmount) {
				if (combine) {
					matrix = _colorize(matrix, cache.colorize, cache.colorizeAmount);
				} else {
					_addColorMatrixFilterCacheTween("colorize", pg, cache, _CMFdefaults);
					_addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, _CMFdefaults);
				}
			}
			if (v.saturation != null) {
				matrix = _setSaturation(matrix, +v.saturation);
				_addColorMatrixFilterCacheTween("saturation", pg, cache, v);
			} else if (cache.saturation !== 1) {
				if (combine) {
					matrix = _setSaturation(matrix, cache.saturation);
				} else {
					_addColorMatrixFilterCacheTween("saturation", pg, cache, _CMFdefaults);
				}
			}
		}
		i = matrix.length;
		while (--i > -1) {
			if (matrix[i] !== startMatrix[i]) {
				pg.add(startMatrix, i, startMatrix[i], matrix[i], "colorMatrixFilter");
			}
		}
		pg._props.push("colorMatrixFilter");
	},
	_renderColor = (ratio, {t, p, color, set}) => {
		set(t, p, color[0] << 16 | color[1] << 8 | color[2]);
	},
	_renderDirtyCache = (ratio, {g}) => {
		if (g) { //in order for PixiJS to actually redraw GraphicsData, we've gotta increment the "dirty" and "clearDirty" values. If we don't do this, the values will be tween properly, but not rendered.
			g.dirty++;
			g.clearDirty++;
		}
	},
	_renderAutoAlpha = (ratio, data) => {
		data.t.visible = !!data.t.alpha;
	},
	_addColorTween = (target, p, value, plugin) => {
		let currentValue = target[p],
			startColor = _splitColor(_isFunction(currentValue) ? target[ ((p.indexOf("set") || !_isFunction(target["get" + p.substr(3)])) ? p : "get" + p.substr(3)) ]() : currentValue),
			endColor = _splitColor(value);
		plugin._pt = new PropTween(plugin._pt, target, p, 0, 0, _renderColor, {t:target, p:p, color:startColor, set:_getSetter(target, p)});
		plugin.add(startColor, 0, startColor[0], endColor[0]);
		plugin.add(startColor, 1, startColor[1], endColor[1]);
		plugin.add(startColor, 2, startColor[2], endColor[2]);
	},

	_colorProps = {tint:1, lineColor:1, fillColor:1},
	_xyContexts = "position,scale,skew,pivot,anchor,tilePosition,tileScale".split(","),
	_contexts = {x:"position", y:"position", tileX:"tilePosition", tileY:"tilePosition"},
	_colorMatrixFilterProps = {colorMatrixFilter:1, saturation:1, contrast:1, hue:1, colorize:1, colorizeAmount:1, brightness:1, combineCMF:1},
	_DEG2RAD = Math.PI / 180,
	_isString = value => typeof(value) === "string",
	_degreesToRadians = value => (_isString(value) && value.charAt(1) === "=") ? value.substr(0, 2) + (parseFloat(value.substr(2)) * _DEG2RAD) : value * _DEG2RAD,
	_renderPropWithEnd = (ratio, data) => data.set(data.t, data.p, ratio === 1 ? data.e : (Math.round((data.s + data.c * ratio) * 100000) / 100000), data),
	_addRotationalPropTween = (plugin, target, property, startNum, endValue, radians) => {
		let cap = 360 * (radians ? _DEG2RAD : 1),
			isString = _isString(endValue),
			relative = (isString && endValue.charAt(1) === "=") ? +(endValue.charAt(0) + "1") : 0,
			endNum = parseFloat(relative ? endValue.substr(2) : endValue) * (radians ? _DEG2RAD : 1),
			change = relative ? endNum * relative : endNum - startNum,
			finalValue = startNum + change,
			direction, pt;
		if (isString) {
			direction = endValue.split("_")[1];
			if (direction === "short") {
				change %= cap;
				if (change !== change % (cap / 2)) {
					change += (change < 0) ? cap : -cap;
				}
			}
			if (direction === "cw" && change < 0) {
				change = ((change + cap * 1e10) % cap) - ~~(change / cap) * cap;
			} else if (direction === "ccw" && change > 0) {
				change = ((change - cap * 1e10) % cap) - ~~(change / cap) * cap;
			}
		}
		plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
		pt.e = finalValue;
		return pt;
	},
	_initCore = () => {
		if (_windowExists()) {
			_win = window;
			gsap = _coreInitted = _getGSAP();
			_PIXI = _PIXI || _win.PIXI;
			_splitColor = color => gsap.utils.splitColor((color + "").substr(0,2) === "0x" ? "#" + color.substr(2) : color); // some colors in PIXI are reported as "0xFF4421" instead of "#FF4421".
		}
	}, i, p;

//context setup...
for (i = 0; i < _xyContexts.length; i++) {
	p = _xyContexts[i];
	_contexts[p + "X"] = p;
	_contexts[p + "Y"] = p;
}


const PixiPlugin = {
	version:"3.7.0",
	name:"pixi",
	register(core, Plugin, propTween) {
		gsap = core;
		PropTween = propTween;
		_getSetter = Plugin.getSetter;
		_initCore();
	},
	registerPIXI(pixi) {
		_PIXI = pixi;
	},
	init(target, values, tween, index, targets) {
		if (!_PIXI) {
			_initCore();
		}
		if (!target instanceof _PIXI.DisplayObject) {
			return false;
		}
		let isV4 = _PIXI.VERSION.charAt(0) === "4",
			context, axis, value, colorMatrix, filter, p, padding, i, data;
		for (p in values) {
			context = _contexts[p];
			value = values[p];
			if (context) {
				axis = ~p.charAt(p.length-1).toLowerCase().indexOf("x") ? "x" : "y";
				this.add(target[context], axis, target[context][axis], (context === "skew") ? _degreesToRadians(value) : value);
			} else if (p === "scale" || p === "anchor" || p === "pivot" || p === "tileScale") {
				this.add(target[p], "x", target[p].x, value);
				this.add(target[p], "y", target[p].y, value);
			} else if (p === "rotation" || p === "angle") { //PIXI expects rotation in radians, but as a convenience we let folks define it in degrees and we do the conversion.
				_addRotationalPropTween(this, target, p, target[p], value, p === "rotation");
			} else if (_colorMatrixFilterProps[p]) {
				if (!colorMatrix) {
					_parseColorMatrixFilter(target, values.colorMatrixFilter || values, this);
					colorMatrix = true;
				}
			} else if (p === "blur" || p === "blurX" || p === "blurY" || p === "blurPadding") {
				filter = _getFilter(target, "BlurFilter");
				this.add(filter, p, filter[p], value);
				if (values.blurPadding !== 0) {
					padding = values.blurPadding || Math.max(filter[p], value) * 2;
					i = target.filters.length;
					while (--i > -1) {
						target.filters[i].padding = Math.max(target.filters[i].padding, padding); //if we don't expand the padding on all the filters, it can look clipped.
					}
				}
			} else if (_colorProps[p]) {
				if ((p === "lineColor" || p === "fillColor") && target instanceof _PIXI.Graphics) {
					data = (target.geometry || target).graphicsData; //"geometry" was introduced in PIXI version 5
					this._pt = new PropTween(this._pt, target, p, 0, 0, _renderDirtyCache, {g: target.geometry || target});
					i = data.length;
					while (--i > -1) {
						_addColorTween(isV4 ? data[i] : data[i][p.substr(0, 4) + "Style"], isV4 ? p : "color", value, this);
					}
				} else {
					_addColorTween(target, p, value, this);
				}
			} else if (p === "autoAlpha") {
				this._pt = new PropTween(this._pt, target, "visible", 0, 0, _renderAutoAlpha);
				this.add(target, "alpha", target.alpha, value);
				this._props.push("alpha", "visible");
			} else if (p !== "resolution") {
				this.add(target, p, "get", value);
			}
			this._props.push(p);
		}
	}
};

_getGSAP() && gsap.registerPlugin(PixiPlugin);



/***/ }),

/***/ "./node_modules/gsap/src/ScrollToPlugin.js":
/*!*************************************************!*\
  !*** ./node_modules/gsap/src/ScrollToPlugin.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScrollToPlugin": function() { return /* binding */ ScrollToPlugin; },
/* harmony export */   "default": function() { return /* binding */ ScrollToPlugin; }
/* harmony export */ });
/*!
 * ScrollToPlugin 3.7.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */

let gsap, _coreInitted, _window, _docEl, _body, _toArray, _config,
	_windowExists = () => typeof(window) !== "undefined",
	_getGSAP = () => gsap || (_windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap),
	_isString = value => typeof(value) === "string",
	_isFunction = value => typeof(value) === "function",
	_max = (element, axis) => {
		let dim = (axis === "x") ? "Width" : "Height",
			scroll = "scroll" + dim,
			client = "client" + dim;
		return (element === _window || element === _docEl || element === _body) ? Math.max(_docEl[scroll], _body[scroll]) - (_window["inner" + dim] || _docEl[client] || _body[client]) : element[scroll] - element["offset" + dim];
	},
	_buildGetter = (e, axis) => { //pass in an element and an axis ("x" or "y") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.
		let p = "scroll" + ((axis === "x") ? "Left" : "Top");
		if (e === _window) {
			if (e.pageXOffset != null) {
				p = "page" + axis.toUpperCase() + "Offset";
			} else {
				e = _docEl[p] != null ? _docEl : _body;
			}
		}
		return () => e[p];
	},
	_clean = (value, index, target, targets) => {
		_isFunction(value) && (value = value(index, target, targets));
		if (typeof(value) !== "object") {
			return _isString(value) && value !== "max" && value.charAt(1) !== "=" ? {x: value, y: value} : {y: value}; //if we don't receive an object as the parameter, assume the user intends "y".
		} else if (value.nodeType) {
			return {y: value, x: value};
		} else {
			let result = {}, p;
			for (p in value) {
				result[p] = p !== "onAutoKill" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];
			}
			return result;
		}
	},
	_getOffset = (element, container) => {
		element = _toArray(element)[0];
		if (!element || !element.getBoundingClientRect) {
			return console.warn("scrollTo target doesn't exist. Using 0") || {x:0, y:0};
		}
		let rect = element.getBoundingClientRect(),
			isRoot = (!container || container === _window || container === _body),
			cRect = isRoot ? {top:_docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0), left:_docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)} : container.getBoundingClientRect(),
			offsets = {x: rect.left - cRect.left, y: rect.top - cRect.top};
		if (!isRoot && container) { //only add the current scroll position if it's not the window/body.
			offsets.x += _buildGetter(container, "x")();
			offsets.y += _buildGetter(container, "y")();
		}
		return offsets;
	},
	_parseVal = (value, target, axis, currentVal, offset) => !isNaN(value) && typeof(value) !== "object" ? parseFloat(value) - offset : (_isString(value) && value.charAt(1) === "=") ? parseFloat(value.substr(2)) * (value.charAt(0) === "-" ? -1 : 1) + currentVal - offset : (value === "max") ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset),
	_initCore = () => {
		gsap = _getGSAP();
		if (_windowExists() && gsap && document.body) {
			_window = window;
			_body = document.body;
			_docEl = document.documentElement;
			_toArray = gsap.utils.toArray;
			gsap.config({autoKillThreshold:7});
			_config = gsap.config();
			_coreInitted = 1;
		}
	};


const ScrollToPlugin = {
	version: "3.7.0",
	name: "scrollTo",
	rawVars: 1,
	register(core) {
		gsap = core;
		_initCore();
	},
	init(target, value, tween, index, targets) {
		_coreInitted || _initCore();
		let data = this,
			snapType = gsap.getProperty(target, "scrollSnapType");
		data.isWin = (target === _window);
		data.target = target;
		data.tween = tween;
		value = _clean(value, index, target, targets);
		data.vars = value;
		data.autoKill = !!value.autoKill;
		data.getX = _buildGetter(target, "x");
		data.getY = _buildGetter(target, "y");
		data.x = data.xPrev = data.getX();
		data.y = data.yPrev = data.getY();
		if (snapType && snapType !== "none") { // disable scroll snapping to avoid strange behavior
			data.snap = 1;
			data.snapInline = target.style.scrollSnapType;
			target.style.scrollSnapType = "none";
		}
		if (value.x != null) {
			data.add(data, "x", data.x, _parseVal(value.x, target, "x", data.x, value.offsetX || 0), index, targets);
			data._props.push("scrollTo_x");
		} else {
			data.skipX = 1;
		}
		if (value.y != null) {
			data.add(data, "y", data.y, _parseVal(value.y, target, "y", data.y, value.offsetY || 0), index, targets);
			data._props.push("scrollTo_y");
		} else {
			data.skipY = 1;
		}
	},
	render(ratio, data) {
		let pt = data._pt,
			{ target, tween, autoKill, xPrev, yPrev, isWin, snap, snapInline } = data,
			x, y, yDif, xDif, threshold;
		while (pt) {
			pt.r(ratio, pt.d);
			pt = pt._next;
		}
		x = (isWin || !data.skipX) ? data.getX() : xPrev;
		y = (isWin || !data.skipY) ? data.getY() : yPrev;
		yDif = y - yPrev;
		xDif = x - xPrev;
		threshold = _config.autoKillThreshold;
		if (data.x < 0) { //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)
			data.x = 0;
		}
		if (data.y < 0) {
			data.y = 0;
		}
		if (autoKill) {
			//note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.
			if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, "x")) {
				data.skipX = 1; //if the user scrolls separately, we should stop tweening!
			}
			if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, "y")) {
				data.skipY = 1; //if the user scrolls separately, we should stop tweening!
			}
			if (data.skipX && data.skipY) {
				tween.kill();
				data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);
			}
		}
		if (isWin) {
			_window.scrollTo((!data.skipX) ? data.x : x, (!data.skipY) ? data.y : y);
		} else {
			data.skipY || (target.scrollTop = data.y);
			data.skipX || (target.scrollLeft = data.x);
		}
		if (snap && (ratio === 1 || ratio === 0)) {
			y = target.scrollTop;
			x = target.scrollLeft;
			snapInline ? (target.style.scrollSnapType = snapInline) : target.style.removeProperty("scroll-snap-type");
			target.scrollTop = y + 1; // bug in Safari causes the element to totally reset its scroll position when scroll-snap-type changes, so we need to set it to a slightly different value and then back again to work around this bug.
			target.scrollLeft = x + 1;
			target.scrollTop = y;
			target.scrollLeft = x;
		}
		data.xPrev = data.x;
		data.yPrev = data.y;
	},
	kill(property) {
		let both = (property === "scrollTo");
		if (both || property === "scrollTo_x") {
			this.skipX = 1;
		}
		if (both || property === "scrollTo_y") {
			this.skipY = 1;
		}
	}
};

ScrollToPlugin.max = _max;
ScrollToPlugin.getOffset = _getOffset;
ScrollToPlugin.buildGetter = _buildGetter;

_getGSAP() && gsap.registerPlugin(ScrollToPlugin);



/***/ }),

/***/ "./node_modules/gsap/src/ScrollTrigger.js":
/*!************************************************!*\
  !*** ./node_modules/gsap/src/ScrollTrigger.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScrollTrigger": function() { return /* binding */ ScrollTrigger; },
/* harmony export */   "default": function() { return /* binding */ ScrollTrigger; }
/* harmony export */ });
/*!
 * ScrollTrigger 3.7.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */

let gsap, _coreInitted, _win, _doc, _docEl, _body, _root, _resizeDelay, _raf, _request, _toArray, _clamp, _time2, _syncInterval, _refreshing, _pointerIsDown, _transformProp, _i, _prevWidth, _prevHeight, _autoRefresh, _sort, _suppressOverwrites, _ignoreResize,
	_limitCallbacks, // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.
	_startup = 1,
	_proxies = [],
	_scrollers = [],
	_getTime = Date.now,
	_time1 = _getTime(),
	_lastScrollTime = 0,
	_enabled = 1,
	_passThrough = v => v,
	_round = value => Math.round(value * 100000) / 100000 || 0,
	_windowExists = () => typeof(window) !== "undefined",
	_getGSAP = () => gsap || (_windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap),
	_isViewport = e => !!~_root.indexOf(e),
	_getProxyProp = (element, property) => ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property],
	_getScrollFunc = (element, {s, sc}) => { // we store the scroller functions in a alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a ".rec" property in order to revert to that after refreshing to ensure things don't shift around.
		let i = _scrollers.indexOf(element),
			offset = sc === _vertical.sc ? 1 : 2;
		!~i && (i = _scrollers.push(element) - 1);
		return _scrollers[i + offset] || (_scrollers[i + offset] = _getProxyProp(element, s) || (_isViewport(element) ? sc : function(value) { return arguments.length ? (element[s] = value) : element[s]; }));
	},
	_getBoundsFunc = element => _getProxyProp(element, "getBoundingClientRect") || (_isViewport(element) ? () => {_winOffsets.width = _win.innerWidth; _winOffsets.height = _win.innerHeight; return _winOffsets;} : () => _getBounds(element)),
	_getSizeFunc = (scroller, isViewport, {d, d2, a}) => (a = _getProxyProp(scroller, "getBoundingClientRect")) ? () => a()[d] : () => (isViewport ? _win["inner" + d2] : scroller["client" + d2]) || 0,
	_getOffsetsFunc = (element, isViewport) => !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : () => _winOffsets,
	_maxScroll = (element, {s, d2, d, a}) => (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? Math.max(_docEl[s], _body[s]) - (_win["inner" + d2] || _docEl["client" + d2] || _body["client" + d2]) : element[s] - element["offset" + d2],
	_iterateAutoRefresh = (func, events) => {
		for (let i = 0; i < _autoRefresh.length; i += 3) {
			(!events || ~events.indexOf(_autoRefresh[i+1])) && func(_autoRefresh[i], _autoRefresh[i+1], _autoRefresh[i+2]);
		}
	},
	_isString = value => typeof(value) === "string",
	_isFunction = value => typeof(value) === "function",
	_isNumber = value => typeof(value) === "number",
	_isObject = value => typeof(value) === "object",
	_callIfFunc = value => _isFunction(value) && value(),
	_combineFunc = (f1, f2) => () => {
		let result1 = _callIfFunc(f1),
			result2 = _callIfFunc(f2);
		return () => {
			_callIfFunc(result1);
			_callIfFunc(result2);
		}
	},
	_abs = Math.abs,
	_scrollLeft = "scrollLeft",
	_scrollTop = "scrollTop",
	_left = "left",
	_top = "top",
	_right = "right",
	_bottom = "bottom",
	_width = "width",
	_height = "height",
	_Right = "Right",
	_Left = "Left",
	_Top = "Top",
	_Bottom = "Bottom",
	_padding = "padding",
	_margin = "margin",
	_Width = "Width",
	_Height = "Height",
	_px = "px",
	_horizontal = {s: _scrollLeft, p: _left, p2: _Left, os: _right, os2: _Right, d: _width, d2: _Width, a: "x", sc: function(value) { return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0}},
	_vertical = {s: _scrollTop, p: _top, p2: _Top, os: _bottom, os2: _Bottom, d: _height, d2: _Height, a: "y", op: _horizontal, sc: function(value) { return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0}},
	_getComputedStyle = element => _win.getComputedStyle(element),
	_makePositionable = element => { // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative
		let position = _getComputedStyle(element).position;
		element.style.position = (position === "absolute" || position === "fixed") ? position : "relative";
	},
	_setDefaults = (obj, defaults) => {
		for (let p in defaults) {
			(p in obj) || (obj[p] = defaults[p]);
		}
		return obj;
	},
	//_isInViewport = element => (element = _getBounds(element)) && !(element.top > (_win.innerHeight || _docEl.clientHeight) || element.bottom < 0 || element.left > (_win.innerWidth || _docEl.clientWidth) || element.right < 0) && element,
	_getBounds = (element, withoutTransforms) => {
		let tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap.to(element, {x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0}).progress(1),
			bounds = element.getBoundingClientRect();
		tween && tween.progress(0).kill();
		return bounds;
	},
	_getSize = (element, {d2}) => element["offset" + d2] || element["client" + d2] || 0,
	_getLabelRatioArray = timeline => {
		let a = [],
			labels = timeline.labels,
			duration = timeline.duration(),
			p;
		for (p in labels) {
			a.push(labels[p] / duration);
		}
		return a;
	},
	_getClosestLabel = animation => value => gsap.utils.snap(_getLabelRatioArray(animation), value),
	_getLabelAtDirection = timeline => {
		return (value, st) => {
			let a = _getLabelRatioArray(timeline),
				i;
			a.sort((a, b) => a - b);
			if (st.direction > 0) {
				value -= 1e-4; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.
				for (i = 0; i < a.length; i++) {
					if (a[i] >= value) {
						return a[i];
					}
				}
				return a.pop();
			} else {
				i = a.length;
				value += 1e-4;
				while (i--) {
					if (a[i] <= value) {
						return a[i];
					}
				}
			}
			return a[0];
		};
	},
	_multiListener = (func, element, types, callback) => types.split(",").forEach(type => func(element, type, callback)),
	_addListener = (element, type, func) => element.addEventListener(type, func, {passive: true}),
	_removeListener = (element, type, func) => element.removeEventListener(type, func),
	_markerDefaults = {startColor: "green", endColor: "red", indent: 0, fontSize: "16px", fontWeight:"normal"},
	_defaults = {toggleActions: "play", anticipatePin: 0},
	_keywords = {top: 0, left: 0, center: 0.5, bottom: 1, right: 1},
	_offsetToPx = (value, size) => {
		if (_isString(value)) {
			let eqIndex = value.indexOf("="),
				relative = ~eqIndex ? +(value.charAt(eqIndex-1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;
			if (~eqIndex) {
				(value.indexOf("%") > eqIndex) && (relative *= size / 100);
				value = value.substr(0, eqIndex-1);
			}
			value = relative + ((value in _keywords) ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
		}
		return value;
	},
	_createMarker = (type, name, container, direction, {startColor, endColor, fontSize, indent, fontWeight}, offset, matchWidthEl) => {
		let e = _doc.createElement("div"),
			useFixedPosition = _isViewport(container) || _getProxyProp(container, "pinType") === "fixed",
			isScroller = type.indexOf("scroller") !== -1,
			parent = useFixedPosition ? _body : container,
			isStart = type.indexOf("start") !== -1,
			color = isStart ? startColor : endColor,
			css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
		css += "position:" + (isScroller && useFixedPosition ? "fixed;" : "absolute;");
		(isScroller || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
		matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
		e._isStart = isStart;
		e.setAttribute("class", "gsap-marker-" + type);
		e.style.cssText = css;
		e.innerText = name || name === 0 ? type + "-" + name : type;
		parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
		e._offset = e["offset" + direction.op.d2];
		_positionMarker(e, 0, direction, isStart);
		return e;
	},
	_positionMarker = (marker, start, direction, flipped) => {
		let vars = {display: "block"},
			side = direction[flipped ? "os2" : "p2"],
			oppositeSide = direction[flipped ? "p2" : "os2"];
		marker._isFlipped = flipped;
		vars[direction.a + "Percent"] = flipped ? -100 : 0;
		vars[direction.a] = flipped ? "1px" : 0;
		vars["border" + side + _Width] = 1;
		vars["border" + oppositeSide + _Width] = 0;
		vars[direction.p] = start + "px";
		gsap.set(marker, vars);
	},
	_triggers = [],
	_ids = {},
	_sync = () => _request || (_request = _raf(_updateAll)),
	_onScroll = () => {
		if (!_request) {
			_request = _raf(_updateAll);
			_lastScrollTime || _dispatch("scrollStart");
			_lastScrollTime = _getTime();
		}
	},
	_onResize = () => !_refreshing && !_ignoreResize && !_doc.fullscreenElement && _resizeDelay.restart(true), // ignore resizes triggered by refresh()
	_listeners = {},
	_emptyArray = [],
	_media = [],
	_creatingMedia, // when ScrollTrigger.matchMedia() is called, we record the current media key here (like "(min-width: 800px)") so that we can assign it to everything that's created during that call. Then we can revert just those when necessary. In the ScrollTrigger's init() call, the _creatingMedia is recorded as a "media" property on the instance.
	_lastMediaTick,
	_onMediaChange = e => {
		let tick = gsap.ticker.frame,
			matches = [],
			i = 0,
			index;
		if (_lastMediaTick !== tick || _startup) {
			_revertAll();
			for (; i < _media.length; i+=4) {
				index = _win.matchMedia(_media[i]).matches;
				if (index !== _media[i+3]) { // note: some browsers fire the matchMedia event multiple times, like when going full screen, so we shouldn't call the function multiple times. Check to see if it's already matched.
					_media[i+3] = index;
					index ? matches.push(i) : _revertAll(1, _media[i]) || (_isFunction(_media[i+2]) && _media[i+2]()); // Firefox doesn't update the "matches" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.
				}
			}
			_revertRecorded(); // in case killing/reverting any of the animations actually added inline styles back.
			for (i = 0; i < matches.length; i++) {
				index = matches[i];
				_creatingMedia = _media[index];
				_media[index+2] = _media[index+1](e);
			}
			_creatingMedia = 0;
			_coreInitted && _refreshAll(0, 1);
			_lastMediaTick = tick;
			_dispatch("matchMedia");
		}
	},
	_softRefresh = () => _removeListener(ScrollTrigger, "scrollEnd", _softRefresh) || _refreshAll(true),
	_dispatch = type => (_listeners[type] && _listeners[type].map(f => f())) || _emptyArray,
	_savedStyles = [], // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.
	_revertRecorded = media => {
		for (let i = 0; i < _savedStyles.length; i+=5) {
			if (!media || _savedStyles[i+4] === media) {
				_savedStyles[i].style.cssText = _savedStyles[i+1];
				_savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i+2] || "");
				_savedStyles[i+3].uncache = 1;
			}
		}
	},
	_revertAll = (kill, media) => {
		let trigger;
		for (_i = 0; _i < _triggers.length; _i++) {
			trigger = _triggers[_i];
			if (!media || trigger.media === media) {
				if (kill) {
					trigger.kill(1);
				} else {
					trigger.revert();
				}
			}
		}
		media && _revertRecorded(media);
		media || _dispatch("revert");
	},
	_refreshAll = (force, skipRevert) => {
		if (_lastScrollTime && !force) {
			_addListener(ScrollTrigger, "scrollEnd", _softRefresh);
			return;
		}
		let refreshInits = _dispatch("refreshInit");
		_sort && ScrollTrigger.sort();
		skipRevert || _revertAll();
		_triggers.forEach(t => t.refresh()) // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.
		refreshInits.forEach(result => result && result.render && result.render(-1)); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.
		_scrollers.forEach(obj => typeof(obj) === "function" && (obj.rec = 0)); // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.
		_resizeDelay.pause();
		_dispatch("refresh");
	},
	_lastScroll = 0,
	_direction = 1,
	_updateAll = () => {
		let l = _triggers.length,
			time = _getTime(),
			recordVelocity = time - _time1 >= 50,
			scroll = l && _triggers[0].scroll();
		_direction = _lastScroll > scroll ? -1 : 1;
		_lastScroll = scroll;
		if (recordVelocity) {
			if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
				_lastScrollTime = 0;
				_dispatch("scrollEnd");
			}
			_time2 = _time1;
			_time1 = time;
		}
		if (_direction < 0) {
			_i = l;
			while (_i-- > 0) {
				_triggers[_i] && _triggers[_i].update(0, recordVelocity);
			}
			_direction = 1;
		} else {
			for (_i = 0; _i < l; _i++) {
				_triggers[_i] && _triggers[_i].update(0, recordVelocity);
			}
		}
		_request = 0;
	},
	_propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "grid-column-start", "grid-column-end", "grid-row-start", "grid-row-end", "grid-area", "justify-self", "align-self", "place-self"],
	_stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),
	_swapPinOut = (pin, spacer, state) => {
		_setState(state);
		if (pin.parentNode === spacer) {
			let parent = spacer.parentNode;
			if (parent) {
				parent.insertBefore(pin, spacer);
				parent.removeChild(spacer);
			}
		}
	},
	_swapPinIn = (pin, spacer, cs, spacerState) => {
		if (pin.parentNode !== spacer) {
			let i = _propNamesToCopy.length,
				spacerStyle = spacer.style,
				pinStyle = pin.style,
				p;
			while (i--) {
				p = _propNamesToCopy[i];
				spacerStyle[p] = cs[p];
			}
			spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
			(cs.display === "inline") && (spacerStyle.display = "inline-block");
			pinStyle[_bottom] = pinStyle[_right] = "auto";
			spacerStyle.overflow = "visible";
			spacerStyle.boxSizing = "border-box";
			spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
			spacerStyle[_height] = _getSize(pin, _vertical) + _px;
			spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";
			_setState(spacerState);
			pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
			pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
			pinStyle[_padding] = cs[_padding];
			pin.parentNode.insertBefore(spacer, pin);
			spacer.appendChild(pin);
		}
	},
	_capsExp = /([A-Z])/g,
	_setState = state => {
		if (state) {
			let style = state.t.style,
				l = state.length,
				i = 0,
				p, value;
			(state.t._gsap || gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off
			for (; i < l; i +=2) {
				value = state[i+1];
				p = state[i];
				if (value) {
					style[p] = value;
				} else if (style[p]) {
					style.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
				}
			}
		}
	},
	_getState = element => { // returns an Array with alternating values like [property, value, property, value] and a "t" property pointing to the target (element). Makes it fast and cheap.
		let l = _stateProps.length,
			style = element.style,
			state = [],
			i = 0;
		for (; i < l; i++) {
			state.push(_stateProps[i], style[_stateProps[i]]);
		}
		state.t = element;
		return state;
	},
	_copyState = (state, override, omitOffsets) => {
		let result = [],
			l = state.length,
			i = omitOffsets ? 8 : 0, // skip top, left, right, bottom if omitOffsets is true
			p;
		for (; i < l; i += 2) {
			p = state[i];
			result.push(p, (p in override) ? override[p] : state[i+1]);
		}
		result.t = state.t;
		return result;
	},
	_winOffsets = {left:0, top:0},
	_parsePosition = (value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax) => {
		_isFunction(value) && (value = value(self));
		if (_isString(value) && value.substr(0,3) === "max") {
			value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
		}
		if (!_isNumber(value)) {
			_isFunction(trigger) && (trigger = trigger(self));
			let element = _toArray(trigger)[0] || _body,
				bounds = _getBounds(element) || {},
				offsets = value.split(" "),
				localOffset, globalOffset, display;
			if ((!bounds || (!bounds.left && !bounds.top)) && _getComputedStyle(element).display === "none") { // if display is "none", it won't report getBoundingClientRect() properly
				display = element.style.display;
				element.style.display = "block";
				bounds = _getBounds(element);
				display ? (element.style.display = display) : element.style.removeProperty("display");
			}
			localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
			globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
			value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
			markerScroller && _positionMarker(markerScroller, globalOffset, direction, (scrollerSize - globalOffset < 20 || (markerScroller._isStart && globalOffset > 20)));
			scrollerSize -= scrollerSize - globalOffset; // adjust for the marker
		} else if (markerScroller) {
			_positionMarker(markerScroller, scrollerSize, direction, true);
		}
		if (marker) {
			let position = value + scrollerSize,
				isStart = marker._isStart;
			scrollerMax = "scroll" + direction.d2;
			_positionMarker(marker, position, direction, (isStart && position > 20) || (!isStart && (useFixedPosition ? Math.max(_body[scrollerMax], _docEl[scrollerMax]) : marker.parentNode[scrollerMax]) <= position + 1));
			if (useFixedPosition) {
				scrollerBounds = _getBounds(markerScroller);
				useFixedPosition && (marker.style[direction.op.p] = (scrollerBounds[direction.op.p] - direction.op.m - marker._offset) + _px);
			}
		}
		return Math.round(value);
	},
	_prefixExp = /(?:webkit|moz|length|cssText|inset)/i,
	_reparent = (element, parent, top, left) => {
		if (element.parentNode !== parent) {
			let style = element.style,
				p, cs;
			if (parent === _body) {
				element._stOrig = style.cssText; // record original inline styles so we can revert them later
				cs = _getComputedStyle(element);
				for (p in cs) { // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.
					if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
						style[p] = cs[p];
					}
				}
				style.top = top;
				style.left = left;
			} else {
				style.cssText = element._stOrig;
			}
			gsap.core.getCache(element).uncache = 1;
			parent.appendChild(element);
		}
	},
	// returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)
	_getTweenCreator = (scroller, direction) => {
		let getScroll = _getScrollFunc(scroller, direction),
			prop = "_scroll" + direction.p2, // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.
			lastScroll1, lastScroll2,
			getTween = (scrollTo, vars, initialValue, change1, change2) => {
				let tween = getTween.tween,
					onComplete = vars.onComplete,
					modifiers = {};
				tween && tween.kill();
				lastScroll1 = Math.round(initialValue);
				vars[prop] = scrollTo;
				vars.modifiers = modifiers;
				modifiers[prop] = value => {
					value = _round(getScroll()); // round because in some [very uncommon] Windows environments, it can get reported with decimals even though it was set without.
					if (value !== lastScroll1 && value !== lastScroll2 && Math.abs(value - lastScroll1) > 2) { // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.
						tween.kill();
						getTween.tween = 0;
					} else {
						value = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;
					}
					lastScroll2 = lastScroll1;
					return (lastScroll1 = _round(value));
				};
				vars.onComplete = () => {
					getTween.tween = 0;
					onComplete && onComplete.call(tween);
				};
				tween = getTween.tween = gsap.to(scroller, vars);
				return tween;
			};
		scroller[prop] = getScroll;
		scroller.addEventListener("wheel", () => getTween.tween && getTween.tween.kill() && (getTween.tween = 0)); // Windows machines handle mousewheel scrolling in chunks (like "3 lines per scroll") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.
		return getTween;
	};

_horizontal.op = _vertical;



class ScrollTrigger {

	constructor(vars, animation) {
		_coreInitted || ScrollTrigger.register(gsap) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
		this.init(vars, animation);
	}

	init(vars, animation) {
		this.progress = this.start = 0;
		this.vars && this.kill(1); // in case it's being initted again
		if (!_enabled) {
			this.update = this.refresh = this.kill = _passThrough;
			return;
		}
		vars = _setDefaults((_isString(vars) || _isNumber(vars) || vars.nodeType) ? {trigger: vars} : vars, _defaults);
		let direction = vars.horizontal ? _horizontal : _vertical,
			{onUpdate, toggleClass, id, onToggle, onRefresh, scrub, trigger, pin, pinSpacing, invalidateOnRefresh, anticipatePin, onScrubComplete, onSnapComplete, once, snap, pinReparent} = vars,
			isToggle = !scrub && scrub !== 0,
			scroller = _toArray(vars.scroller || _win)[0],
			scrollerCache = gsap.core.getCache(scroller),
			isViewport = _isViewport(scroller),
			useFixedPosition = "pinType" in vars ? vars.pinType === "fixed" : isViewport || _getProxyProp(scroller, "pinType") === "fixed",
			callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],
			toggleActions = isToggle && vars.toggleActions.split(" "),
			markers = "markers" in vars ? vars.markers : _defaults.markers,
			borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0,
			self = this,
			onRefreshInit = vars.onRefreshInit && (() => vars.onRefreshInit(self)),
			getScrollerSize = _getSizeFunc(scroller, isViewport, direction),
			getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),
			lastSnap = 0,
			tweenTo, pinCache, snapFunc, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars,
			change, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacerState, markerStartSetter,
			markerEndSetter, cs, snap1, snap2, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, prevProgress, prevScroll, prevAnimProgress;

		self.media = _creatingMedia;
		anticipatePin *= 45;
		self.scroller = scroller;
		self.scroll = _getScrollFunc(scroller, direction);
		scroll1 = self.scroll();
		self.vars = vars;
		animation = animation || vars.animation;
		("refreshPriority" in vars) && (_sort = 1);
		scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
			top: _getTweenCreator(scroller, _vertical),
			left: _getTweenCreator(scroller, _horizontal)
		};
		self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];
		if (animation) {
			animation.vars.lazy = false;
			animation._initted || (animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.render(0, true, true));
			self.animation = animation.pause();
			animation.scrollTrigger = self;
			scrubSmooth = _isNumber(scrub) && scrub;
			scrubSmooth && (scrubTween = gsap.to(animation, {ease: "power3", duration: scrubSmooth, onComplete: () => onScrubComplete && onScrubComplete(self)}));
			snap1 = 0;
			id || (id = animation.vars.id);
		}
		_triggers.push(self);
		if (snap) {
			_isObject(snap) || (snap = {snapTo: snap});
			("scrollBehavior" in _body.style) && gsap.set(isViewport ? [_body, _docEl] : scroller, {scrollBehavior: "auto"}); // smooth scrolling doesn't work with snap.
			snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : gsap.utils.snap(snap.snapTo);
			snapDurClamp = snap.duration || {min: 0.1, max: 2};
			snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);
			snapDelayedCall = gsap.delayedCall(snap.delay || (scrubSmooth / 2) || 0.1, () => {
				if (Math.abs(self.getVelocity()) < 10 && !_pointerIsDown && lastSnap !== self.scroll()) {
					let totalProgress = animation && !isToggle ? animation.totalProgress() : self.progress,
						velocity = ((totalProgress - snap2) / (_getTime() - _time2) * 1000) || 0,
						change1 = gsap.utils.clamp(-self.progress, 1 - self.progress, _abs(velocity / 2) * velocity / 0.185),
						naturalEnd = self.progress + (snap.inertia === false ? 0 : change1),
						endValue = _clamp(0, 1, snapFunc(naturalEnd, self)),
						scroll = self.scroll(),
						endScroll = Math.round(start + endValue * change),
						{ onStart, onInterrupt, onComplete } = snap,
						tween = tweenTo.tween;
					if (scroll <= end && scroll >= start && endScroll !== scroll) {
						if (tween && !tween._initted && tween.data <= Math.abs(endScroll - scroll)) { // there's an overlapping snap! So we must figure out which one is closer and let that tween live.
							return;
						}
						if (snap.inertia === false) {
							change1 = endValue - self.progress;
						}
						tweenTo(endScroll, {
							duration: snapDurClamp(_abs( (Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05) || 0)),
							ease: snap.ease || "power3",
							data: Math.abs(endScroll - scroll), // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
							onInterrupt: () => snapDelayedCall.restart(true) && onInterrupt && onInterrupt(self),
							onComplete: () => {
								lastSnap = self.scroll();
								snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;
								onSnapComplete && onSnapComplete(self);
								onComplete && onComplete(self);
							}
						}, scroll, change1 * change, endScroll - scroll - change1 * change);
						onStart && onStart(self, tweenTo.tween);
					}
				} else if (self.isActive) {
					snapDelayedCall.restart(true);
				}
			}).pause();
		}
		id && (_ids[id] = self);
		trigger = self.trigger = _toArray(trigger || pin)[0];
		pin = pin === true ? trigger : _toArray(pin)[0];
		_isString(toggleClass) && (toggleClass = {targets: trigger, className: toggleClass});
		if (pin) {
			(pinSpacing === false || pinSpacing === _margin) || (pinSpacing = !pinSpacing && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default.
			self.pin = pin;
			vars.force3D !== false && gsap.set(pin, {force3D: true});
			pinCache = gsap.core.getCache(pin);
			if (!pinCache.spacer) { // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the "original" pin state after it has already been affected by another ScrollTrigger.
				pinCache.spacer = spacer = _doc.createElement("div");
				spacer.setAttribute("class", "pin-spacer" + (id ? " pin-spacer-" + id : ""));
				pinCache.pinState = pinOriginalState = _getState(pin);
			} else {
				pinOriginalState = pinCache.pinState;
			}
			self.spacer = spacer = pinCache.spacer;
			cs = _getComputedStyle(pin);
			spacingStart = cs[pinSpacing + direction.os2];
			pinGetter = gsap.getProperty(pin);
			pinSetter = gsap.quickSetter(pin, direction.a, _px);
			// pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = "hidden"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).
			_swapPinIn(pin, spacer, cs);
			pinState = _getState(pin);
		}
		if (markers) {
			markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;
			markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
			markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
			offset = markerStartTrigger["offset" + direction.op.d2];
			markerStart = _createMarker("start", id, scroller, direction, markerVars, offset);
			markerEnd =_createMarker("end", id, scroller, direction, markerVars, offset);
			if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
				_makePositionable(isViewport ? _body : scroller);
				gsap.set([markerStartTrigger, markerEndTrigger], {force3D: true});
				markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);
				markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);
			}
		}

		self.revert = revert => {
			let r = revert !== false || !self.enabled,
				prevRefreshing = _refreshing;
			if (r !== self.isReverted) {
				if (r) {
					self.scroll.rec || (self.scroll.rec = self.scroll());
					prevScroll = Math.max(self.scroll(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.
					prevProgress = self.progress;
					prevAnimProgress = animation && animation.progress();
				}
				markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(m => m.style.display = r ? "none" : "block");
				r && (_refreshing = 1);
				self.update(r); // make sure the pin is back in its original position so that all the measurements are correct.
				_refreshing = prevRefreshing;
				pin && (r ? _swapPinOut(pin, spacer, pinOriginalState) : (!pinReparent || !self.isActive) && _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState));
				self.isReverted = r;
			}
		}


		self.refresh = (soft, force) => {
			if ((_refreshing || !self.enabled) && !force) {
				return;
			}
			if (pin && soft && _lastScrollTime) {
				_addListener(ScrollTrigger, "scrollEnd", _softRefresh);
				return;
			}

			_refreshing = 1;
			scrubTween && scrubTween.pause();
			invalidateOnRefresh && animation && animation.progress(0).invalidate();
			self.isReverted || self.revert();
			let size = getScrollerSize(),
				scrollerBounds = getScrollerOffsets(),
				max = _maxScroll(scroller, direction),
				offset = 0,
				otherPinOffset = 0,
				parsedEnd = vars.end,
				parsedEndTrigger = vars.endTrigger || trigger,
				parsedStart = vars.start || (vars.start === 0 || !trigger ? 0 : (pin ? "0 0" : "0 100%")),
				pinnedContainer = vars.pinnedContainer && _toArray(vars.pinnedContainer)[0],
				triggerIndex = (trigger && Math.max(0, _triggers.indexOf(self))) || 0,
				i = triggerIndex,
				cs, bounds, scroll, isVertical, override, curTrigger, curPin, oppositeScroll, initted, revertedPins;
			while (i--) { // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things "rewind" properly.
				curTrigger = _triggers[i];
				curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = 1); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.
				curPin = curTrigger.pin;
				if (curPin && (curPin === trigger || curPin === pin) && !curTrigger.isReverted) {
					revertedPins || (revertedPins = []);
					revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly
					curTrigger.revert();
				}
			}
			start = _parsePosition(parsedStart, trigger, size, direction, self.scroll(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max) || (pin ? -0.001 : 0);
			_isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));
			if (_isString(parsedEnd) && !parsedEnd.indexOf("+=")) {
				if (~parsedEnd.indexOf(" ")) {
					parsedEnd = (_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
				} else {
					offset = _offsetToPx(parsedEnd.substr(2), size);
					parsedEnd = _isString(parsedStart) ? parsedStart : start + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.
					parsedEndTrigger = trigger;
				}
			}
			end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, self.scroll() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max)) || -0.001;
			change = (end - start) || ((start -= 0.01) && 0.001);

			offset = 0;
			i = triggerIndex;
			while (i--) {
				curTrigger = _triggers[i];
				curPin = curTrigger.pin;
				if (curPin && curTrigger.start - curTrigger._pinPush < start) {
					cs = curTrigger.end - curTrigger.start;
					(curPin === trigger || curPin === pinnedContainer) && (offset += cs);
					curPin === pin && (otherPinOffset += cs);
				}
			}
			start += offset;
			end += offset;
			self._pinPush = otherPinOffset;
			if (markerStart && offset) { // offset the markers if necessary
				cs = {};
				cs[direction.a] = "+=" + offset;
				pinnedContainer && (cs[direction.p] = "-=" + self.scroll());
				gsap.set([markerStart, markerEnd], cs);
			}

			if (pin) {
				cs = _getComputedStyle(pin);
				isVertical = direction === _vertical;
				scroll = self.scroll(); // recalculate because the triggers can affect the scroll
				pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
				!max && end > 1 && ((isViewport ? _body : scroller).style["overflow-" + direction.a] = "scroll"); // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://greensock.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/
				_swapPinIn(pin, spacer, cs);
				pinState = _getState(pin);
				// transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.
				bounds = _getBounds(pin, true);
				oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();
				if (pinSpacing) {
					spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
					spacerState.t = spacer;
					i = (pinSpacing === _padding) ? _getSize(pin, direction) + change + otherPinOffset : 0;
					i && spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).
					_setState(spacerState);
					useFixedPosition && self.scroll(prevScroll);
				}
				if (useFixedPosition) {
					override = {
						top: (bounds.top + (isVertical ? scroll - start : oppositeScroll)) + _px,
						left: (bounds.left + (isVertical ? oppositeScroll : scroll - start)) + _px,
						boxSizing: "border-box",
						position: "fixed"
					};
					override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
					override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
					override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
					override[_padding] = cs[_padding];
					override[_padding + _Top] = cs[_padding + _Top];
					override[_padding + _Right] = cs[_padding + _Right];
					override[_padding + _Bottom] = cs[_padding + _Bottom];
					override[_padding + _Left] = cs[_padding + _Left];
					pinActiveState = _copyState(pinOriginalState, override, pinReparent);
				}
				if (animation) { // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.
					initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.
					_suppressOverwrites(1);
					animation.render(animation.duration(), true, true);
					pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
					change !== pinChange && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.
					animation.render(0, true, true);
					initted || animation.invalidate();
					_suppressOverwrites(0);
				} else {
					pinChange = change
				}
			} else if (trigger && self.scroll()) { // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()
				bounds = trigger.parentNode;
				while (bounds && bounds !== _body) {
					if (bounds._pinOffset) {
						start -= bounds._pinOffset;
						end -= bounds._pinOffset;
					}
					bounds = bounds.parentNode;
				}
			}
			revertedPins && revertedPins.forEach(t => t.revert(false));
			self.start = start;
			self.end = end;
			scroll1 = scroll2 = self.scroll(); // reset velocity
			scroll1 < prevScroll && self.scroll(prevScroll);
			self.revert(false);
			_refreshing = 0;
			animation && isToggle && animation._initted && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().
			if (prevProgress !== self.progress) { // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.
				scrubTween && animation.totalProgress(prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.
				self.progress = prevProgress;
				self.update();
			}
			pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));
			onRefresh && onRefresh(self);
		};

		self.getVelocity = () => ((self.scroll() - scroll2) / (_getTime() - _time2) * 1000) || 0;

		self.update = (reset, recordVelocity) => {
			let scroll = self.scroll(),
				p = reset ? 0 : (scroll - start) / change,
				clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,
				prevProgress = self.progress,
				isActive, wasActive, toggleState, action, stateChanged, toggled;
			if (recordVelocity) {
				scroll2 = scroll1;
				scroll1 = scroll;
				if (snap) {
					snap2 = snap1;
					snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
				}
			}
			// anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).
			(anticipatePin && !clipped && pin && !_refreshing && !_startup && _lastScrollTime && start < scroll + ((scroll - scroll2) / (_getTime() - _time2)) * anticipatePin) && (clipped = 0.0001);
			if (clipped !== prevProgress && self.enabled) {
				isActive = self.isActive = !!clipped && clipped < 1;
				wasActive = !!prevProgress && prevProgress < 1;
				toggled = isActive !== wasActive;
				stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)
				self.direction = clipped > prevProgress ? 1 : -1;
				self.progress = clipped;
				if (!isToggle) {
					if (scrubTween && !_refreshing && !_startup) {
						scrubTween.vars.totalProgress = clipped;
						scrubTween.invalidate().restart();
					} else if (animation) {
						animation.totalProgress(clipped, !!_refreshing);
					}
				}
				if (pin) {
					reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);
					if (!useFixedPosition) {
						pinSetter(pinStart + pinChange * clipped);
					} else if (stateChanged) {
						action = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)
						if (pinReparent) {
							if (!reset && (isActive || action)) {
								let bounds = _getBounds(pin, true),
									offset = scroll - start;
								_reparent(pin, _body, (bounds.top + (direction === _vertical ? offset : 0)) + _px, (bounds.left + (direction === _vertical ? 0 : offset)) + _px);
							} else {
								_reparent(pin, spacer);
							}
						}
						_setState(isActive || action ? pinActiveState : pinState);
						(pinChange !== change && clipped < 1 && isActive) || pinSetter(pinStart + (clipped === 1 && !action ? pinChange : 0));
					}
				}
				snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);
				toggleClass && (toggled || (once && clipped && (clipped < 1 || !_limitCallbacks))) && _toArray(toggleClass.targets).forEach(el => el.classList[isActive || once ? "add" : "remove"](toggleClass.className)); // classes could affect positioning, so do it even if reset or refreshing is true.
				onUpdate && !isToggle && !reset && onUpdate(self);
				if (stateChanged && !_refreshing) {
					toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.
					if (isToggle) {
						action = (!toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1]) || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the "enter" action, we should switch to the "leave" in this case (but only if one is defined)
						if (animation && (action === "complete" || action === "reset" || action in animation)) {
							if (action === "complete") {
								animation.pause().totalProgress(1);
							} else if (action === "reset") {
								animation.restart(true).pause();
							} else if (action === "restart") {
								animation.restart(true);
							} else {
								animation[action]();
							}
						}
						onUpdate && onUpdate(self);
					}
					if (toggled || !_limitCallbacks) { // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.
						onToggle && toggled && onToggle(self);
						callbacks[toggleState] && callbacks[toggleState](self);
						once && (clipped === 1 ? self.kill(false, 1) : (callbacks[toggleState] = 0)); // a callback shouldn't be called again if once is true.
						if (!toggled) { // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order
							toggleState = clipped === 1 ? 1 : 3;
							callbacks[toggleState] && callbacks[toggleState](self);
						}
					}
				} else if (isToggle && onUpdate && !_refreshing) {
					onUpdate(self);
				}
			}
			// update absolutely-positioned markers (only if the scroller isn't the viewport)
			if (markerEndSetter) {
				markerStartSetter(scroll + (markerStartTrigger._isFlipped ? 1 : 0));
				markerEndSetter(scroll);
			}
		};

		self.enable = (reset, refresh) => {
			if (!self.enabled) {
				self.enabled = true;
				_addListener(scroller, "resize", _onResize);
				_addListener(scroller, "scroll", _onScroll);
				onRefreshInit && _addListener(ScrollTrigger, "refreshInit", onRefreshInit);
				if (reset !== false) {
					self.progress = prevProgress = 0;
					scroll1 = scroll2 = lastSnap = self.scroll();
				}
				refresh !== false && self.refresh();
			}
		};

		self.getTween = snap => snap && tweenTo ? tweenTo.tween : scrubTween;

		self.disable = (reset, allowAnimation) => {
			if (self.enabled) {
				reset !== false && self.revert();
				self.enabled = self.isActive = false;
				allowAnimation || (scrubTween && scrubTween.pause());
				prevScroll = 0;
				pinCache && (pinCache.uncache = 1);
				onRefreshInit && _removeListener(ScrollTrigger, "refreshInit", onRefreshInit);
				if (snapDelayedCall) {
					snapDelayedCall.pause();
					tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
				}
				if (!isViewport) {
					let i = _triggers.length;
					while (i--) {
						if (_triggers[i].scroller === scroller && _triggers[i] !== self) {
							return; //don't remove the listeners if there are still other triggers referencing it.
						}
					}
					_removeListener(scroller, "resize", _onResize);
					_removeListener(scroller, "scroll", _onScroll);
				}
			}
		};

		self.kill = (revert, allowAnimation) => {
			self.disable(revert, allowAnimation);
			id && (delete _ids[id]);
			let i = _triggers.indexOf(self);
			_triggers.splice(i, 1);
			i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...
			if (animation) {
				animation.scrollTrigger = null;
				revert && animation.render(-1);
				allowAnimation || animation.kill();
			}
			markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(m => m.parentNode && m.parentNode.removeChild(m));
			if (pin) {
				pinCache && (pinCache.uncache = 1);
				i = 0;
				_triggers.forEach(t => t.pin === pin && i++);
				i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.
			}
		};

		self.enable(false, false);
		!animation || !animation.add || change ? self.refresh() : gsap.delayedCall(0.01, () => start || end || self.refresh()) && (change = 0.01) && (start = end = 0); // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If "change" is defined, we know it must be re-enabling, thus we can refresh() right away.
	}


	static register(core) {
		if (!_coreInitted) {
			gsap = core || _getGSAP();
			if (_windowExists() && window.document) {
				_win = window;
				_doc = document;
				_docEl = _doc.documentElement;
				_body = _doc.body;
			}
			if (gsap) {
				_toArray = gsap.utils.toArray;
				_clamp = gsap.utils.clamp;
				_suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;
				gsap.core.globals("ScrollTrigger", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a "name" property.
				if (_body) {
					_raf = _win.requestAnimationFrame || (f => setTimeout(f, 16));
					_addListener(_win, "wheel", _onScroll);
					_root = [_win, _doc, _docEl, _body];
					_addListener(_doc, "scroll", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!
					let bodyStyle = _body.style,
						border = bodyStyle.borderTop,
						bounds;
					bodyStyle.borderTop = "1px solid #000"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.
					bounds = _getBounds(_body);
					_vertical.m = Math.round(bounds.top + _vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding
					_horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
					border ? (bodyStyle.borderTop = border) : bodyStyle.removeProperty("border-top");
					_syncInterval = setInterval(_sync, 200);
					gsap.delayedCall(0.5, () => _startup = 0);
					_addListener(_doc, "touchcancel", _passThrough); // some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document.
					_addListener(_body, "touchstart", _passThrough); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/
					_multiListener(_addListener, _doc, "pointerdown,touchstart,mousedown", () => _pointerIsDown = 1);
					_multiListener(_addListener, _doc, "pointerup,touchend,mouseup", () => _pointerIsDown = 0);
					_transformProp = gsap.utils.checkPrefix("transform");
					_stateProps.push(_transformProp);
					_coreInitted = _getTime();
					_resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();
					_autoRefresh = [_doc, "visibilitychange", () => {
						let w = _win.innerWidth,
							h = _win.innerHeight;
						if (_doc.hidden) {
							_prevWidth = w;
							_prevHeight = h;
						} else if (_prevWidth !== w || _prevHeight !== h) {
							_onResize();
						}
					}, _doc, "DOMContentLoaded", _refreshAll, _win, "load", () => _lastScrollTime || _refreshAll(), _win, "resize", _onResize];
					_iterateAutoRefresh(_addListener);

				}
			}
		}
		return _coreInitted;
	}

	static defaults(config) {
		for (let p in config) {
			_defaults[p] = config[p];
		}
	}

	static kill() {
		_enabled = 0;
		_triggers.slice(0).forEach(trigger => trigger.kill(1));
	}

	static config(vars) {
		("limitCallbacks" in vars) && (_limitCallbacks = !!vars.limitCallbacks);
		let ms = vars.syncInterval;
		ms && clearInterval(_syncInterval) || ((_syncInterval = ms) && setInterval(_sync, ms));
		if ("autoRefreshEvents" in vars) {
			_iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || "none");
			_ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
		}
	}

	static scrollerProxy(target, vars) {
		let t = _toArray(target)[0],
			i = _scrollers.indexOf(t),
			isViewport = _isViewport(t);
		if (~i) {
			_scrollers.splice(i, isViewport ? 6 : 2);
		}
		isViewport ? _proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _proxies.unshift(t, vars);
	}

	static matchMedia(vars) { // _media is populated in the following order: mediaQueryString, onMatch, onUnmatch, isMatched. So if there are two media queries, the Array would have a length of 8
		let mq, p, i, func, result;
		for (p in vars) {
			i = _media.indexOf(p);
			func = vars[p];
			_creatingMedia = p;
			if (p === "all") {
				func();
			} else {
				mq = _win.matchMedia(p);
				if (mq) {
					mq.matches && (result = func());
					if (~i) {
						_media[i + 1] = _combineFunc(_media[i + 1], func);
						_media[i + 2] = _combineFunc(_media[i + 2], result);
					} else {
						i = _media.length;
						_media.push(p, func, result);
						mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
					}
					_media[i + 3] = mq.matches;
				}
			}
			_creatingMedia = 0;
		}
		return _media;
	}

	static clearMatchMedia(query) {
		query || (_media.length = 0);
		query = _media.indexOf(query);
		query >= 0 && _media.splice(query, 4);
	}

}

ScrollTrigger.version = "3.7.0";
ScrollTrigger.saveStyles = targets => targets ? _toArray(targets).forEach(target => { // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]
	if (target && target.style) {
		let i = _savedStyles.indexOf(target);
		i >= 0 && _savedStyles.splice(i, 5);
		_savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap.core.getCache(target), _creatingMedia);
	}
}) : _savedStyles;
ScrollTrigger.revert = (soft, media) => _revertAll(!soft, media);
ScrollTrigger.create = (vars, animation) => new ScrollTrigger(vars, animation);
ScrollTrigger.refresh = safe => safe ? _onResize() : _refreshAll(true);
ScrollTrigger.update = _updateAll;
ScrollTrigger.maxScroll = (element, horizontal) => _maxScroll(element, horizontal ? _horizontal : _vertical);
ScrollTrigger.getScrollFunc = (element, horizontal) => _getScrollFunc(_toArray(element)[0], horizontal ? _horizontal : _vertical);
ScrollTrigger.getById = id => _ids[id];
ScrollTrigger.getAll = () => _triggers.slice(0);
ScrollTrigger.isScrolling = () => !!_lastScrollTime;
ScrollTrigger.addEventListener = (type, callback) => {
	let a = _listeners[type] || (_listeners[type] = []);
	~a.indexOf(callback) || a.push(callback);
};
ScrollTrigger.removeEventListener = (type, callback) => {
	let a = _listeners[type],
		i = a && a.indexOf(callback);
	i >= 0 && a.splice(i, 1);
};
ScrollTrigger.batch = (targets, vars) => {
	let result = [],
		varsCopy = {},
		interval = vars.interval || 0.016,
		batchMax = vars.batchMax || 1e9,
		proxyCallback = (type, callback) => {
			let elements = [],
				triggers = [],
				delay = gsap.delayedCall(interval, () => {callback(elements, triggers); elements = []; triggers = [];}).pause();
			return self => {
				elements.length || delay.restart(true);
				elements.push(self.trigger);
				triggers.push(self);
				batchMax <= elements.length && delay.progress(1);
			};
		},
		p;
	for (p in vars) {
		varsCopy[p] = (p.substr(0, 2) === "on" && _isFunction(vars[p]) && p !== "onRefreshInit") ? proxyCallback(p, vars[p]) : vars[p];
	}
	if (_isFunction(batchMax)) {
		batchMax = batchMax();
		_addListener(ScrollTrigger, "refresh", () => batchMax = vars.batchMax());
	}
	_toArray(targets).forEach(target => {
		let config = {};
		for (p in varsCopy) {
			config[p] = varsCopy[p];
		}
		config.trigger = target;
		result.push(ScrollTrigger.create(config));
	});
	return result;
}
ScrollTrigger.sort = func => _triggers.sort(func || ((a, b) => (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6)));

_getGSAP() && gsap.registerPlugin(ScrollTrigger);



/***/ }),

/***/ "./node_modules/gsap/src/TextPlugin.js":
/*!*********************************************!*\
  !*** ./node_modules/gsap/src/TextPlugin.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextPlugin": function() { return /* binding */ TextPlugin; },
/* harmony export */   "default": function() { return /* binding */ TextPlugin; }
/* harmony export */ });
/* harmony import */ var _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/strings.js */ "./node_modules/gsap/src/utils/strings.js");
/*!
 * TextPlugin 3.7.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */



let gsap, _tempDiv,
	_getGSAP = () => gsap || (typeof(window) !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap);


const TextPlugin = {
	version:"3.7.0",
	name:"text",
	init(target, value, tween) {
		let i = target.nodeName.toUpperCase(),
			data = this,
			short, text, original, j, condensedText, condensedOriginal, aggregate, s;
		data.svg = (target.getBBox && (i === "TEXT" || i === "TSPAN"));
		if (!("innerHTML" in target) && !data.svg) {
			return false;
		}
		data.target = target;
		if (typeof(value) !== "object") {
			value = {value:value};
		}
		if (!("value" in value)) {
			data.text = data.original = [""];
			return;
		}
		data.delimiter = value.delimiter || "";
		original = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitInnerHTML)(target, data.delimiter);
		if (!_tempDiv) {
			_tempDiv = document.createElement("div");
		}
		_tempDiv.innerHTML = value.value;
		text = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitInnerHTML)(_tempDiv, data.delimiter);
		data.from = tween._from;
		if (data.from) {
			i = original;
			original = text;
			text = i;
		}
		data.hasClass = !!(value.newClass || value.oldClass);
		data.newClass = value.newClass;
		data.oldClass = value.oldClass;
		i = original.length - text.length;
		short = (i < 0) ? original : text;
		data.fillChar = value.fillChar || (value.padSpace ? "&nbsp;" : "");
		if (i < 0) {
			i = -i;
		}
		while (--i > -1) {
			short.push(data.fillChar);
		}
		if (value.type === "diff") {
			j = 0;
			condensedText = [];
			condensedOriginal = [];
			aggregate = "";
			for (i = 0; i < text.length; i++) {
				s = text[i];
				if (s === original[i]) {
					aggregate += s;
				} else {
					condensedText[j] = aggregate + s;
					condensedOriginal[j++] = aggregate + original[i];
					aggregate = "";
				}
			}
			text = condensedText;
			original = condensedOriginal;
			if (aggregate) {
				text.push(aggregate);
				original.push(aggregate);
			}
		}
		if (value.speed) {
			tween.duration(Math.min(0.05 / value.speed * short.length, value.maxDuration || 9999));
		}
		this.original = original;
		this.text = text;
		this._props.push("text");
	},
	render(ratio, data) {
		if (ratio > 1) {
			ratio = 1;
		} else if (ratio < 0) {
			ratio = 0;
		}
		if (data.from) {
			ratio = 1 - ratio;
		}
		let { text, hasClass, newClass, oldClass, delimiter, target, fillChar, original } = data,
			l = text.length,
			i = (ratio * l + 0.5) | 0,
			applyNew, applyOld, str;
		if (hasClass) {
			applyNew = (newClass && i);
			applyOld = (oldClass && i !== l);
			str = (applyNew ? "<span class='" + newClass + "'>" : "") + text.slice(0, i).join(delimiter) + (applyNew ? "</span>" : "") + (applyOld ? "<span class='" + oldClass + "'>" : "") + delimiter + original.slice(i).join(delimiter) + (applyOld ? "</span>" : "");
		} else {
			str = text.slice(0, i).join(delimiter) + delimiter + original.slice(i).join(delimiter);
		}
		if (data.svg) { //SVG text elements don't have an "innerHTML" in Microsoft browsers.
			target.textContent = str;
		} else {
			target.innerHTML = (fillChar === "&nbsp;" && ~str.indexOf("  ")) ? str.split("  ").join("&nbsp;&nbsp;") : str;
		}
	}
};

TextPlugin.splitInnerHTML = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitInnerHTML;
TextPlugin.emojiSafeSplit = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit;
TextPlugin.getText = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.getText;

_getGSAP() && gsap.registerPlugin(TextPlugin);



/***/ }),

/***/ "./node_modules/gsap/src/all.js":
/*!**************************************!*\
  !*** ./node_modules/gsap/src/all.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gsap": function() { return /* binding */ gsapWithCSS; },
/* harmony export */   "default": function() { return /* binding */ gsapWithCSS; },
/* harmony export */   "CSSPlugin": function() { return /* reexport safe */ _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.default; },
/* harmony export */   "TweenMax": function() { return /* binding */ TweenMaxWithCSS; },
/* harmony export */   "TweenLite": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite; },
/* harmony export */   "TimelineMax": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax; },
/* harmony export */   "TimelineLite": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite; },
/* harmony export */   "Power0": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0; },
/* harmony export */   "Power1": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1; },
/* harmony export */   "Power2": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2; },
/* harmony export */   "Power3": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3; },
/* harmony export */   "Power4": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4; },
/* harmony export */   "Linear": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear; },
/* harmony export */   "Quad": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad; },
/* harmony export */   "Cubic": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic; },
/* harmony export */   "Quart": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart; },
/* harmony export */   "Quint": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint; },
/* harmony export */   "Strong": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong; },
/* harmony export */   "Elastic": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic; },
/* harmony export */   "Back": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back; },
/* harmony export */   "SteppedEase": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase; },
/* harmony export */   "Bounce": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce; },
/* harmony export */   "Sine": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine; },
/* harmony export */   "Expo": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo; },
/* harmony export */   "Circ": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ; },
/* harmony export */   "wrap": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.wrap; },
/* harmony export */   "wrapYoyo": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.wrapYoyo; },
/* harmony export */   "distribute": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.distribute; },
/* harmony export */   "random": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.random; },
/* harmony export */   "snap": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.snap; },
/* harmony export */   "normalize": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.normalize; },
/* harmony export */   "getUnit": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit; },
/* harmony export */   "clamp": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.clamp; },
/* harmony export */   "splitColor": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.splitColor; },
/* harmony export */   "toArray": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.toArray; },
/* harmony export */   "mapRange": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.mapRange; },
/* harmony export */   "pipe": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.pipe; },
/* harmony export */   "unitize": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.unitize; },
/* harmony export */   "interpolate": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.interpolate; },
/* harmony export */   "shuffle": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.shuffle; },
/* harmony export */   "selector": function() { return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.selector; }
/* harmony export */ });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./node_modules/gsap/src/gsap-core.js");
/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ "./node_modules/gsap/src/CSSPlugin.js");
/* harmony import */ var _Draggable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Draggable.js */ "./node_modules/gsap/src/Draggable.js");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _Draggable_js__WEBPACK_IMPORTED_MODULE_2__) if(["default","gsap","CSSPlugin","TweenMax","TweenLite","TimelineMax","TimelineLite","Power0","Power1","Power2","Power3","Power4","Linear","Quad","Cubic","Quart","Quint","Strong","Elastic","Back","SteppedEase","Bounce","Sine","Expo","Circ","wrap","wrapYoyo","distribute","random","snap","normalize","getUnit","clamp","splitColor","toArray","mapRange","pipe","unitize","interpolate","shuffle","selector"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _Draggable_js__WEBPACK_IMPORTED_MODULE_2__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _CSSRulePlugin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CSSRulePlugin.js */ "./node_modules/gsap/src/CSSRulePlugin.js");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _CSSRulePlugin_js__WEBPACK_IMPORTED_MODULE_3__) if(["default","gsap","CSSPlugin","TweenMax","TweenLite","TimelineMax","TimelineLite","Power0","Power1","Power2","Power3","Power4","Linear","Quad","Cubic","Quart","Quint","Strong","Elastic","Back","SteppedEase","Bounce","Sine","Expo","Circ","wrap","wrapYoyo","distribute","random","snap","normalize","getUnit","clamp","splitColor","toArray","mapRange","pipe","unitize","interpolate","shuffle","selector"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _CSSRulePlugin_js__WEBPACK_IMPORTED_MODULE_3__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _EaselPlugin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EaselPlugin.js */ "./node_modules/gsap/src/EaselPlugin.js");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _EaselPlugin_js__WEBPACK_IMPORTED_MODULE_4__) if(["default","gsap","CSSPlugin","TweenMax","TweenLite","TimelineMax","TimelineLite","Power0","Power1","Power2","Power3","Power4","Linear","Quad","Cubic","Quart","Quint","Strong","Elastic","Back","SteppedEase","Bounce","Sine","Expo","Circ","wrap","wrapYoyo","distribute","random","snap","normalize","getUnit","clamp","splitColor","toArray","mapRange","pipe","unitize","interpolate","shuffle","selector"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _EaselPlugin_js__WEBPACK_IMPORTED_MODULE_4__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _EasePack_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EasePack.js */ "./node_modules/gsap/src/EasePack.js");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _EasePack_js__WEBPACK_IMPORTED_MODULE_5__) if(["default","gsap","CSSPlugin","TweenMax","TweenLite","TimelineMax","TimelineLite","Power0","Power1","Power2","Power3","Power4","Linear","Quad","Cubic","Quart","Quint","Strong","Elastic","Back","SteppedEase","Bounce","Sine","Expo","Circ","wrap","wrapYoyo","distribute","random","snap","normalize","getUnit","clamp","splitColor","toArray","mapRange","pipe","unitize","interpolate","shuffle","selector"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _EasePack_js__WEBPACK_IMPORTED_MODULE_5__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _MotionPathPlugin_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MotionPathPlugin.js */ "./node_modules/gsap/src/MotionPathPlugin.js");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _MotionPathPlugin_js__WEBPACK_IMPORTED_MODULE_6__) if(["default","gsap","CSSPlugin","TweenMax","TweenLite","TimelineMax","TimelineLite","Power0","Power1","Power2","Power3","Power4","Linear","Quad","Cubic","Quart","Quint","Strong","Elastic","Back","SteppedEase","Bounce","Sine","Expo","Circ","wrap","wrapYoyo","distribute","random","snap","normalize","getUnit","clamp","splitColor","toArray","mapRange","pipe","unitize","interpolate","shuffle","selector"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _MotionPathPlugin_js__WEBPACK_IMPORTED_MODULE_6__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _PixiPlugin_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PixiPlugin.js */ "./node_modules/gsap/src/PixiPlugin.js");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _PixiPlugin_js__WEBPACK_IMPORTED_MODULE_7__) if(["default","gsap","CSSPlugin","TweenMax","TweenLite","TimelineMax","TimelineLite","Power0","Power1","Power2","Power3","Power4","Linear","Quad","Cubic","Quart","Quint","Strong","Elastic","Back","SteppedEase","Bounce","Sine","Expo","Circ","wrap","wrapYoyo","distribute","random","snap","normalize","getUnit","clamp","splitColor","toArray","mapRange","pipe","unitize","interpolate","shuffle","selector"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _PixiPlugin_js__WEBPACK_IMPORTED_MODULE_7__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _ScrollToPlugin_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ScrollToPlugin.js */ "./node_modules/gsap/src/ScrollToPlugin.js");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _ScrollToPlugin_js__WEBPACK_IMPORTED_MODULE_8__) if(["default","gsap","CSSPlugin","TweenMax","TweenLite","TimelineMax","TimelineLite","Power0","Power1","Power2","Power3","Power4","Linear","Quad","Cubic","Quart","Quint","Strong","Elastic","Back","SteppedEase","Bounce","Sine","Expo","Circ","wrap","wrapYoyo","distribute","random","snap","normalize","getUnit","clamp","splitColor","toArray","mapRange","pipe","unitize","interpolate","shuffle","selector"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _ScrollToPlugin_js__WEBPACK_IMPORTED_MODULE_8__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _ScrollTrigger_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ScrollTrigger.js */ "./node_modules/gsap/src/ScrollTrigger.js");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _ScrollTrigger_js__WEBPACK_IMPORTED_MODULE_9__) if(["default","gsap","CSSPlugin","TweenMax","TweenLite","TimelineMax","TimelineLite","Power0","Power1","Power2","Power3","Power4","Linear","Quad","Cubic","Quart","Quint","Strong","Elastic","Back","SteppedEase","Bounce","Sine","Expo","Circ","wrap","wrapYoyo","distribute","random","snap","normalize","getUnit","clamp","splitColor","toArray","mapRange","pipe","unitize","interpolate","shuffle","selector"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _ScrollTrigger_js__WEBPACK_IMPORTED_MODULE_9__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _TextPlugin_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./TextPlugin.js */ "./node_modules/gsap/src/TextPlugin.js");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _TextPlugin_js__WEBPACK_IMPORTED_MODULE_10__) if(["default","gsap","CSSPlugin","TweenMax","TweenLite","TimelineMax","TimelineLite","Power0","Power1","Power2","Power3","Power4","Linear","Quad","Cubic","Quart","Quint","Strong","Elastic","Back","SteppedEase","Bounce","Sine","Expo","Circ","wrap","wrapYoyo","distribute","random","snap","normalize","getUnit","clamp","splitColor","toArray","mapRange","pipe","unitize","interpolate","shuffle","selector"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _TextPlugin_js__WEBPACK_IMPORTED_MODULE_10__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


const gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.default.registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.default) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.default, // to protect from tree shaking
	TweenMaxWithCSS = gsapWithCSS.core.Tween;














//BONUS EXPORTS
//export * from "./CustomEase.js";
//export * from "./DrawSVGPlugin.js";
//export * from "./Physics2DPlugin.js";
//export * from "./PhysicsPropsPlugin.js";
//export * from "./ScrambleTextPlugin.js";
//export * from "./CustomBounce.js";
//export * from "./CustomWiggle.js";
//export * from "./Flip.js";
//export * from "./GSDevTools.js";
//export * from "./InertiaPlugin.js";
//export * from "./MorphSVGPlugin.js";
//export * from "./MotionPathHelper.js";
//export * from "./SplitText.js";

/***/ }),

/***/ "./node_modules/gsap/src/gsap-core.js":
/*!********************************************!*\
  !*** ./node_modules/gsap/src/gsap-core.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GSCache": function() { return /* binding */ GSCache; },
/* harmony export */   "Animation": function() { return /* binding */ Animation; },
/* harmony export */   "Timeline": function() { return /* binding */ Timeline; },
/* harmony export */   "Tween": function() { return /* binding */ Tween; },
/* harmony export */   "PropTween": function() { return /* binding */ PropTween; },
/* harmony export */   "gsap": function() { return /* binding */ gsap; },
/* harmony export */   "Power0": function() { return /* binding */ Power0; },
/* harmony export */   "Power1": function() { return /* binding */ Power1; },
/* harmony export */   "Power2": function() { return /* binding */ Power2; },
/* harmony export */   "Power3": function() { return /* binding */ Power3; },
/* harmony export */   "Power4": function() { return /* binding */ Power4; },
/* harmony export */   "Linear": function() { return /* binding */ Linear; },
/* harmony export */   "Quad": function() { return /* binding */ Quad; },
/* harmony export */   "Cubic": function() { return /* binding */ Cubic; },
/* harmony export */   "Quart": function() { return /* binding */ Quart; },
/* harmony export */   "Quint": function() { return /* binding */ Quint; },
/* harmony export */   "Strong": function() { return /* binding */ Strong; },
/* harmony export */   "Elastic": function() { return /* binding */ Elastic; },
/* harmony export */   "Back": function() { return /* binding */ Back; },
/* harmony export */   "SteppedEase": function() { return /* binding */ SteppedEase; },
/* harmony export */   "Bounce": function() { return /* binding */ Bounce; },
/* harmony export */   "Sine": function() { return /* binding */ Sine; },
/* harmony export */   "Expo": function() { return /* binding */ Expo; },
/* harmony export */   "Circ": function() { return /* binding */ Circ; },
/* harmony export */   "TweenMax": function() { return /* binding */ Tween; },
/* harmony export */   "TweenLite": function() { return /* binding */ Tween; },
/* harmony export */   "TimelineMax": function() { return /* binding */ Timeline; },
/* harmony export */   "TimelineLite": function() { return /* binding */ Timeline; },
/* harmony export */   "default": function() { return /* binding */ gsap; },
/* harmony export */   "wrap": function() { return /* binding */ wrap; },
/* harmony export */   "wrapYoyo": function() { return /* binding */ wrapYoyo; },
/* harmony export */   "distribute": function() { return /* binding */ distribute; },
/* harmony export */   "random": function() { return /* binding */ random; },
/* harmony export */   "snap": function() { return /* binding */ snap; },
/* harmony export */   "normalize": function() { return /* binding */ normalize; },
/* harmony export */   "getUnit": function() { return /* binding */ getUnit; },
/* harmony export */   "clamp": function() { return /* binding */ clamp; },
/* harmony export */   "splitColor": function() { return /* binding */ splitColor; },
/* harmony export */   "toArray": function() { return /* binding */ toArray; },
/* harmony export */   "selector": function() { return /* binding */ selector; },
/* harmony export */   "mapRange": function() { return /* binding */ mapRange; },
/* harmony export */   "pipe": function() { return /* binding */ pipe; },
/* harmony export */   "unitize": function() { return /* binding */ unitize; },
/* harmony export */   "interpolate": function() { return /* binding */ interpolate; },
/* harmony export */   "shuffle": function() { return /* binding */ shuffle; },
/* harmony export */   "_getProperty": function() { return /* binding */ _getProperty; },
/* harmony export */   "_numExp": function() { return /* binding */ _numExp; },
/* harmony export */   "_numWithUnitExp": function() { return /* binding */ _numWithUnitExp; },
/* harmony export */   "_isString": function() { return /* binding */ _isString; },
/* harmony export */   "_isUndefined": function() { return /* binding */ _isUndefined; },
/* harmony export */   "_renderComplexString": function() { return /* binding */ _renderComplexString; },
/* harmony export */   "_relExp": function() { return /* binding */ _relExp; },
/* harmony export */   "_setDefaults": function() { return /* binding */ _setDefaults; },
/* harmony export */   "_removeLinkedListItem": function() { return /* binding */ _removeLinkedListItem; },
/* harmony export */   "_forEachName": function() { return /* binding */ _forEachName; },
/* harmony export */   "_sortPropTweensByPriority": function() { return /* binding */ _sortPropTweensByPriority; },
/* harmony export */   "_colorStringFilter": function() { return /* binding */ _colorStringFilter; },
/* harmony export */   "_replaceRandom": function() { return /* binding */ _replaceRandom; },
/* harmony export */   "_checkPlugin": function() { return /* binding */ _checkPlugin; },
/* harmony export */   "_plugins": function() { return /* binding */ _plugins; },
/* harmony export */   "_ticker": function() { return /* binding */ _ticker; },
/* harmony export */   "_config": function() { return /* binding */ _config; },
/* harmony export */   "_roundModifier": function() { return /* binding */ _roundModifier; },
/* harmony export */   "_round": function() { return /* binding */ _round; },
/* harmony export */   "_missingPlugin": function() { return /* binding */ _missingPlugin; },
/* harmony export */   "_getSetter": function() { return /* binding */ _getSetter; },
/* harmony export */   "_getCache": function() { return /* binding */ _getCache; },
/* harmony export */   "_colorExp": function() { return /* binding */ _colorExp; }
/* harmony export */ });
/*!
 * GSAP 3.7.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */

let _config = {
		autoSleep: 120,
		force3D: "auto",
		nullTargetWarn: 1,
		units: {lineHeight:""}
	},
	_defaults = {
		duration: .5,
		overwrite: false,
		delay: 0
	},
	_suppressOverwrites,
	_bigNum = 1e8,
	_tinyNum = 1 / _bigNum,
	_2PI = Math.PI * 2,
	_HALF_PI = _2PI / 4,
	_gsID = 0,
	_sqrt = Math.sqrt,
	_cos = Math.cos,
	_sin = Math.sin,
	_isString = value => typeof(value) === "string",
	_isFunction = value => typeof(value) === "function",
	_isNumber = value => typeof(value) === "number",
	_isUndefined = value => typeof(value) === "undefined",
	_isObject = value => typeof(value) === "object",
	_isNotFalse = value => value !== false,
	_windowExists = () => typeof(window) !== "undefined",
	_isFuncOrString = value => _isFunction(value) || _isString(value),
	_isTypedArray = (typeof ArrayBuffer === "function" && ArrayBuffer.isView) || function() {}, // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
	_isArray = Array.isArray,
	_strictNumExp = /(?:-?\.?\d|\.)+/gi, //only numbers (including negatives and decimals) but NOT relative values.
	_numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
	_numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
	_complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
	_relExp = /[+-]=-?[.\d]+/,
	_delimitedValueExp = /[^,'"\[\]\s]+/gi, // previously /[#\-+.]*\b[a-z\d\-=+%.]+/gi but didn't catch special characters.
	_unitExp = /[\d.+\-=]+(?:e[-+]\d*)*/i,
	_globalTimeline, _win, _coreInitted, _doc,
	_globals = {},
	_installScope = {},
	_coreReady,
	_install = scope => (_installScope = _merge(scope, _globals)) && gsap,
	_missingPlugin = (property, value) => console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()"),
	_warn = (message, suppress) => !suppress && console.warn(message),
	_addGlobal = (name, obj) => (name && (_globals[name] = obj) && (_installScope && (_installScope[name] = obj))) || _globals,
	_emptyFunc = () => 0,
	_reservedProps = {},
	_lazyTweens = [],
	_lazyLookup = {},
	_lastRenderedFrame,
	_plugins = {},
	_effects = {},
	_nextGCFrame = 30,
	_harnessPlugins = [],
	_callbackNames = "",
	_harness = targets => {
		let target = targets[0],
			harnessPlugin, i;
		_isObject(target) || _isFunction(target) || (targets = [targets]);
		if (!(harnessPlugin = (target._gsap || {}).harness)) { // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
			i = _harnessPlugins.length;
			while (i-- && !_harnessPlugins[i].targetTest(target)) {	}
			harnessPlugin = _harnessPlugins[i];
		}
		i = targets.length;
		while (i--) {
			(targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin)))) || targets.splice(i, 1);
		}
		return targets;
	},
	_getCache = target => target._gsap || _harness(toArray(target))[0]._gsap,
	_getProperty = (target, property, v) => (v = target[property]) && _isFunction(v) ? target[property]() : (_isUndefined(v) && target.getAttribute && target.getAttribute(property)) || v,
	_forEachName = (names, func) => ((names = names.split(",")).forEach(func)) || names, //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
	_round = value => Math.round(value * 100000) / 100000 || 0,
	_arrayContainsAny = (toSearch, toFind) => { //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
		let l = toFind.length,
			i = 0;
		for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) { }
		return (i < l);
	},
	_lazyRender = () => {
		let l = _lazyTweens.length,
			a = _lazyTweens.slice(0),
			i, tween;
		_lazyLookup = {};
		_lazyTweens.length = 0;
		for (i = 0; i < l; i++) {
			tween = a[i];
			tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
		}
	},
	_lazySafeRender = (animation, time, suppressEvents, force) => {
		_lazyTweens.length && _lazyRender();
		animation.render(time, suppressEvents, force);
		_lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
	},
	_numericIfPossible = value => {
		let n = parseFloat(value);
		return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
	},
	_passThrough = p => p,
	_setDefaults = (obj, defaults) => {
		for (let p in defaults) {
			(p in obj) || (obj[p] = defaults[p]);
		}
		return obj;
	},
	_setKeyframeDefaults = (obj, defaults) => {
		for (let p in defaults) {
			(p in obj) || p === "duration" || p === "ease" || (obj[p] = defaults[p]);
		}
	},
	_merge = (base, toMerge) => {
		for (let p in toMerge) {
			base[p] = toMerge[p];
		}
		return base;
	},
	_mergeDeep = (base, toMerge) => {
		for (let p in toMerge) {
			p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
		}
		return base;
	},
	_copyExcluding = (obj, excluding) => {
		let copy = {},
			p;
		for (p in obj) {
			(p in excluding) || (copy[p] = obj[p]);
		}
		return copy;
	},
	_inheritDefaults = vars => {
		let parent = vars.parent || _globalTimeline,
			func = vars.keyframes ? _setKeyframeDefaults : _setDefaults;
		if (_isNotFalse(vars.inherit)) {
			while (parent) {
				func(vars, parent.vars.defaults);
				parent = parent.parent || parent._dp;
			}
		}
		return vars;
	},
	_arraysMatch = (a1, a2) => {
		let i = a1.length,
			match = i === a2.length;
		while (match && i-- && a1[i] === a2[i]) { }
		return i < 0;
	},
	_addLinkedListItem = (parent, child, firstProp = "_first", lastProp = "_last", sortBy) => {
		let prev = parent[lastProp],
			t;
		if (sortBy) {
			t = child[sortBy];
			while (prev && prev[sortBy] > t) {
				prev = prev._prev;
			}
		}
		if (prev) {
			child._next = prev._next;
			prev._next = child;
		} else {
			child._next = parent[firstProp];
			parent[firstProp] = child;
		}
		if (child._next) {
			child._next._prev = child;
		} else {
			parent[lastProp] = child;
		}
		child._prev = prev;
		child.parent = child._dp = parent;
		return child;
	},
	_removeLinkedListItem = (parent, child, firstProp = "_first", lastProp = "_last") => {
		let prev = child._prev,
			next = child._next;
		if (prev) {
			prev._next = next;
		} else if (parent[firstProp] === child) {
			parent[firstProp] = next;
		}
		if (next) {
			next._prev = prev;
		} else if (parent[lastProp] === child) {
			parent[lastProp] = prev;
		}
		child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
	},
	_removeFromParent = (child, onlyIfParentHasAutoRemove) => {
		child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
		child._act = 0;
	},
	_uncache = (animation, child) => {
		if (animation && (!child || child._end > animation._dur || child._start < 0)) { // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
			let a = animation;
			while (a) {
				a._dirty = 1;
				a = a.parent;
			}
		}
		return animation;
	},
	_recacheAncestors = animation => {
		let parent = animation.parent;
		while (parent && parent.parent) { //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
			parent._dirty = 1;
			parent.totalDuration();
			parent = parent.parent;
		}
		return animation;
	},
	_hasNoPausedAncestors = animation => !animation || (animation._ts && _hasNoPausedAncestors(animation.parent)),
	_elapsedCycleDuration = animation => animation._repeat ? _animationCycle(animation._tTime, (animation = animation.duration() + animation._rDelay)) * animation : 0,
	// feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
	_animationCycle = (tTime, cycleDuration) => {
		let whole = Math.floor(tTime /= cycleDuration);
		return tTime && (whole === tTime) ? whole - 1 : whole;
	},
	_parentToChildTotalTime = (parentTime, child) => (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : (child._dirty ? child.totalDuration() : child._tDur)),
	_setEnd = animation => (animation._end = _round(animation._start + ((animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum)) || 0))),
	_alignPlayhead = (animation, totalTime) => { // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
		let parent = animation._dp;
		if (parent && parent.smoothChildTiming && animation._ts) {
			animation._start = _round(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
			_setEnd(animation);
			parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
		}
		return animation;
	},
	/*
	_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
		let cycleDuration = duration + repeatDelay,
			time = _round(clampedTotalTime % cycleDuration);
		if (time > duration) {
			time = duration;
		}
		return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
	},
	*/
	_postAddChecks = (timeline, child) => {
		let t;
		if (child._time || (child._initted && !child._dur)) { //in case, for example, the _start is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
			t = _parentToChildTotalTime(timeline.rawTime(), child);
			if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
				child.render(t, true);
			}
		}
		//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
		if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
			//in case any of the ancestors had completed but should now be enabled...
			if (timeline._dur < timeline.duration()) {
				t = timeline;
				while (t._dp) {
					(t.rawTime() >= 0) && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.
					t = t._dp;
				}
			}
			timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
		}
	},
	_addToTimeline = (timeline, child, position, skipChecks) => {
		child.parent && _removeFromParent(child);
		child._start = _round((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
		child._end = _round(child._start + ((child.totalDuration() / Math.abs(child.timeScale())) || 0));
		_addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);
		_isFromOrFromStart(child) || (timeline._recent = child);
		skipChecks || _postAddChecks(timeline, child);
		return timeline;
	},
	_scrollTrigger = (animation, trigger) => (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation),
	_attemptInitTween = (tween, totalTime, force, suppressEvents) => {
		_initTween(tween, totalTime);
		if (!tween._initted) {
			return 1;
		}
		if (!force && tween._pt && ((tween._dur && tween.vars.lazy !== false) || (!tween._dur && tween.vars.lazy)) && _lastRenderedFrame !== _ticker.frame) {
			_lazyTweens.push(tween);
			tween._lazy = [totalTime, suppressEvents];
			return 1;
		}
	},
	_parentPlayheadIsBeforeStart = ({parent}) => parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent)), // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
	_isFromOrFromStart = ({data}) => data === "isFromStart" || data === "isStart",
	_renderZeroDurationTween = (tween, totalTime, suppressEvents, force) => {
		let prevRatio = tween.ratio,
			ratio = totalTime < 0 || (!totalTime && ((!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween))) || ((tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)))) ? 0 : 1, // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the "startAt" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any "from" and "fromTo" startAt tweens are rendered the first time at a ratio of 1.
			repeatDelay = tween._rDelay,
			tTime = 0,
			pt, iteration, prevIteration;
		if (repeatDelay && tween._repeat) { // in case there's a zero-duration tween that has a repeat with a repeatDelay
			tTime = _clamp(0, tween._tDur, totalTime);
			iteration = _animationCycle(tTime, repeatDelay);
			prevIteration = _animationCycle(tween._tTime, repeatDelay);
			tween._yoyo && (iteration & 1) && (ratio = 1 - ratio);
			if (iteration !== prevIteration) {
				prevRatio = 1 - ratio;
				tween.vars.repeatRefresh && tween._initted && tween.invalidate();
			}
		}
		if (ratio !== prevRatio || force || tween._zTime === _tinyNum || (!totalTime && tween._zTime)) {
			if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) { // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
				return;
			}
			prevIteration = tween._zTime;
			tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.
			suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.
			tween.ratio = ratio;
			tween._from && (ratio = 1 - ratio);
			tween._time = 0;
			tween._tTime = tTime;
			pt = tween._pt;
			while (pt) {
				pt.r(ratio, pt.d);
				pt = pt._next;
			}
			tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);
			tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
			tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
			if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
				ratio && _removeFromParent(tween, 1);
				if (!suppressEvents) {
					_callback(tween, (ratio ? "onComplete" : "onReverseComplete"), true);
					tween._prom && tween._prom();
				}
			}
		} else if (!tween._zTime) {
			tween._zTime = totalTime;
		}
	},
	_findNextPauseTween = (animation, prevTime, time) => {
		let child;
		if (time > prevTime) {
			child = animation._first;
			while (child && child._start <= time) {
				if (!child._dur && child.data === "isPause" && child._start > prevTime) {
					return child;
				}
				child = child._next;
			}
		} else {
			child = animation._last;
			while (child && child._start >= time) {
				if (!child._dur && child.data === "isPause" && child._start < prevTime) {
					return child;
				}
				child = child._prev;
			}
		}
	},
	_setDuration = (animation, duration, skipUncache, leavePlayhead) => {
		let repeat = animation._repeat,
			dur = _round(duration) || 0,
			totalProgress = animation._tTime / animation._tDur;
		totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
		animation._dur = dur;
		animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _round(dur * (repeat + 1) + (animation._rDelay * repeat));
		totalProgress && !leavePlayhead ? _alignPlayhead(animation, (animation._tTime = animation._tDur * totalProgress)) : animation.parent && _setEnd(animation);
		skipUncache || _uncache(animation.parent, animation);
		return animation;
	},
	_onUpdateTotalDuration = animation => (animation instanceof Timeline) ? _uncache(animation) : _setDuration(animation, animation._dur),
	_zeroPosition = {_start:0, endTime:_emptyFunc, totalDuration:_emptyFunc},
	_parsePosition = (animation, position, percentAnimation) => {
		let labels = animation.labels,
			recent = animation._recent || _zeroPosition,
			clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
			i, offset, isPercent;
		if (_isString(position) && (isNaN(position) || (position in labels))) { //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
			offset = position.charAt(0);
			isPercent = position.substr(-1) === "%";
			i = position.indexOf("=");
			if (offset === "<" || offset === ">") {
				i >= 0 && (position = position.replace(/=/, ""));
				return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
			}
			if (i < 0) {
				(position in labels) || (labels[position] = clippedDuration);
				return labels[position];
			}
			offset = parseFloat(position.charAt(i-1) + position.substr(i+1));
			if (isPercent && percentAnimation) {
				offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
			}
			return (i > 1) ? _parsePosition(animation, position.substr(0, i-1), percentAnimation) + offset : clippedDuration + offset;
		}
		return (position == null) ? clippedDuration : +position;
	},
	_createTweenType = (type, params, timeline) => {
		let isLegacy = _isNumber(params[1]),
			varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
			vars = params[varsIndex],
			irVars, parent;
		isLegacy && (vars.duration = params[1]);
		vars.parent = timeline;
		if (type) {
			irVars = vars;
			parent = timeline;
			while (parent && !("immediateRender" in irVars)) { // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
				irVars = parent.vars.defaults || {};
				parent = _isNotFalse(parent.vars.inherit) && parent.parent;
			}
			vars.immediateRender = _isNotFalse(irVars.immediateRender);
			type < 2 ? (vars.runBackwards = 1) : (vars.startAt = params[varsIndex - 1]); // "from" vars
		}
		return new Tween(params[0], vars, params[varsIndex + 1]);
	},
	_conditionalReturn = (value, func) => value || value === 0 ? func(value) : func,
	_clamp = (min, max, value) => value < min ? min : value > max ? max : value,
	getUnit = value => {
		if (typeof(value) !== "string") {
			return "";
		}
		let v = _unitExp.exec(value);
		return v ? value.substr(v.index + v[0].length) : "";
	}, // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
	clamp = (min, max, value) => _conditionalReturn(value, v => _clamp(min, max, v)),
	_slice = [].slice,
	_isArrayLike = (value, nonEmpty) => value && (_isObject(value) && "length" in value && ((!nonEmpty && !value.length) || ((value.length - 1) in value && _isObject(value[0]))) && !value.nodeType && value !== _win),
	_flatten = (ar, leaveStrings, accumulator = []) => ar.forEach(value => (_isString(value) && !leaveStrings) || _isArrayLike(value, 1) ? accumulator.push(...toArray(value)) : accumulator.push(value)) || accumulator,
	//takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
	toArray = (value, scope, leaveStrings) => _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [],
	selector = value => {
		value = toArray(value)[0] || _warn("Invalid scope") || {};
		return v => {
			let el = value.current || value.nativeElement || value;
			return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
		};
	},
	shuffle = a => a.sort(() => .5 - Math.random()), // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;
	//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
	distribute = v => {
		if (_isFunction(v)) {
			return v;
		}
		let vars = _isObject(v) ? v : {each:v}, //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
			ease = _parseEase(vars.ease),
			from = vars.from || 0,
			base = parseFloat(vars.base) || 0,
			cache = {},
			isDecimal = (from > 0 && from < 1),
			ratios = isNaN(from) || isDecimal,
			axis = vars.axis,
			ratioX = from,
			ratioY = from;
		if (_isString(from)) {
			ratioX = ratioY = {center:.5, edges:.5, end:1}[from] || 0;
		} else if (!isDecimal && ratios) {
			ratioX = from[0];
			ratioY = from[1];
		}
		return (i, target, a) => {
			let l = (a || vars).length,
				distances = cache[l],
				originX, originY, x, y, d, j, max, min, wrapAt;
			if (!distances) {
				wrapAt = (vars.grid === "auto") ? 0 : (vars.grid || [1, _bigNum])[1];
				if (!wrapAt) {
					max = -_bigNum;
					while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) { }
					wrapAt--;
				}
				distances = cache[l] = [];
				originX = ratios ? (Math.min(wrapAt, l) * ratioX) - .5 : from % wrapAt;
				originY = ratios ? l * ratioY / wrapAt - .5 : (from / wrapAt) | 0;
				max = 0;
				min = _bigNum;
				for (j = 0; j < l; j++) {
					x = (j % wrapAt) - originX;
					y = originY - ((j / wrapAt) | 0);
					distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs((axis === "y") ? y : x);
					(d > max) && (max = d);
					(d < min) && (min = d);
				}
				(from === "random") && shuffle(distances);
				distances.max = max - min;
				distances.min = min;
				distances.v = l = (parseFloat(vars.amount) || (parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt)) || 0) * (from === "edges" ? -1 : 1);
				distances.b = (l < 0) ? base - l : base;
				distances.u = getUnit(vars.amount || vars.each) || 0; //unit
				ease = (ease && l < 0) ? _invertEase(ease) : ease;
			}
			l = ((distances[i] - distances.min) / distances.max) || 0;
			return _round(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
		};
	},
	_roundModifier = v => { //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
		let p = v < 1 ? Math.pow(10, (v + "").length - 2) : 1; //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed()
		return raw => {
			let n = Math.round(parseFloat(raw) / v) * v * p;
			return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
		};
	},
	snap = (snapTo, value) => {
		let isArray = _isArray(snapTo),
			radius, is2D;
		if (!isArray && _isObject(snapTo)) {
			radius = isArray = snapTo.radius || _bigNum;
			if (snapTo.values) {
				snapTo = toArray(snapTo.values);
				if ((is2D = !_isNumber(snapTo[0]))) {
					radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
				}
			} else {
				snapTo = _roundModifier(snapTo.increment);
			}
		}
		return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? raw => {is2D = snapTo(raw); return Math.abs(is2D - raw) <= radius ? is2D : raw; } : raw => {
			let x = parseFloat(is2D ? raw.x : raw),
				y = parseFloat(is2D ? raw.y : 0),
				min = _bigNum,
				closest = 0,
				i = snapTo.length,
				dx, dy;
			while (i--) {
				if (is2D) {
					dx = snapTo[i].x - x;
					dy = snapTo[i].y - y;
					dx = dx * dx + dy * dy;
				} else {
					dx = Math.abs(snapTo[i] - x);
				}
				if (dx < min) {
					min = dx;
					closest = i;
				}
			}
			closest = (!radius || min <= radius) ? snapTo[closest] : raw;
			return (is2D || closest === raw || _isNumber(raw)) ? closest : closest + getUnit(raw);
		});
	},
	random = (min, max, roundingIncrement, returnFunction) => _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, () => _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? 10 ** ((roundingIncrement + "").length - 2) : 1) && (Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction)),
	pipe = (...functions) => value => functions.reduce((v, f) => f(v), value),
	unitize = (func, unit) => value => func(parseFloat(value)) + (unit || getUnit(value)),
	normalize = (min, max, value) => mapRange(min, max, 0, 1, value),
	_wrapArray = (a, wrapper, value) => _conditionalReturn(value, index => a[~~wrapper(index)]),
	wrap = function(min, max, value) { // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
		let range = max - min;
		return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, value => ((range + (value - min) % range) % range) + min);
	},
	wrapYoyo = (min, max, value) => {
		let range = max - min,
			total = range * 2;
		return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, value => {
			value = (total + (value - min) % total) % total || 0;
			return min + ((value > range) ? (total - value) : value);
		});
	},
	_replaceRandom = value => { //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
		let prev = 0,
			s = "",
			i, nums, end, isArray;
		while (~(i = value.indexOf("random(", prev))) {
			end = value.indexOf(")", i);
			isArray = value.charAt(i + 7) === "[";
			nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
			s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
			prev = end + 1;
		}
		return s + value.substr(prev, value.length - prev);
	},
	mapRange = (inMin, inMax, outMin, outMax, value) => {
		let inRange = inMax - inMin,
			outRange = outMax - outMin;
		return _conditionalReturn(value, value => outMin + ((((value - inMin) / inRange) * outRange) || 0));
	},
	interpolate = (start, end, progress, mutate) => {
		let func = isNaN(start + end) ? 0 : p => (1 - p) * start + p * end;
		if (!func) {
			let isString = _isString(start),
				master = {},
				p, i, interpolators, l, il;
			progress === true && (mutate = 1) && (progress = null);
			if (isString) {
				start = {p: start};
				end = {p: end};

			} else if (_isArray(start) && !_isArray(end)) {
				interpolators = [];
				l = start.length;
				il = l - 2;
				for (i = 1; i < l; i++) {
					interpolators.push(interpolate(start[i-1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
				}
				l--;
				func = p => {
					p *= l;
					let i = Math.min(il, ~~p);
					return interpolators[i](p - i);
				};
				progress = end;
			} else if (!mutate) {
				start = _merge(_isArray(start) ? [] : {}, start);
			}
			if (!interpolators) {
				for (p in end) {
					_addPropTween.call(master, start, p, "get", end[p]);
				}
				func = p => _renderPropTweens(p, master) || (isString ? start.p : start);
			}
		}
		return _conditionalReturn(progress, func);
	},
	_getLabelInDirection = (timeline, fromTime, backward) => { //used for nextLabel() and previousLabel()
		let labels = timeline.labels,
			min = _bigNum,
			p, distance, label;
		for (p in labels) {
			distance = labels[p] - fromTime;
			if ((distance < 0) === !!backward && distance && min > (distance = Math.abs(distance))) {
				label = p;
				min = distance;
			}
		}
		return label;
	},
	_callback = (animation, type, executeLazyFirst) => {
		let v = animation.vars,
			callback = v[type],
			params, scope;
		if (!callback) {
			return;
		}
		params = v[type + "Params"];
		scope = v.callbackScope || animation;
		executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
		return params ? callback.apply(scope, params) : callback.call(scope);
	},
	_interrupt = animation => {
		_removeFromParent(animation);
		animation.scrollTrigger && animation.scrollTrigger.kill(false);
		animation.progress() < 1 && _callback(animation, "onInterrupt");
		return animation;
	},
	_quickTween,
	_createPlugin = config => {
		config = !config.name && config.default || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.
		let name = config.name,
			isFunc = _isFunction(config),
			Plugin = (name && !isFunc && config.init) ? function() { this._props = []; } : config, //in case someone passes in an object that's not a plugin, like CustomEase
			instanceDefaults = {init:_emptyFunc, render:_renderPropTweens, add:_addPropTween, kill:_killPropTweensOf, modifier:_addPluginModifier, rawVars:0},
			statics = {targetTest:0, get:0, getSetter:_getSetter, aliases:{}, register:0};
		_wake();
		if (config !== Plugin) {
			if (_plugins[name]) {
				return;
			}
			_setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods
			_merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods
			_plugins[(Plugin.prop = name)] = Plugin;
			if (config.targetTest) {
				_harnessPlugins.push(Plugin);
				_reservedProps[name] = 1;
			}
			name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
		}
		_addGlobal(name, Plugin);
		config.register && config.register(gsap, Plugin, PropTween);
	},
















/*
 * --------------------------------------------------------------------------------------
 * COLORS
 * --------------------------------------------------------------------------------------
 */

	_255 = 255,
	_colorLookup = {
		aqua:[0,_255,_255],
		lime:[0,_255,0],
		silver:[192,192,192],
		black:[0,0,0],
		maroon:[128,0,0],
		teal:[0,128,128],
		blue:[0,0,_255],
		navy:[0,0,128],
		white:[_255,_255,_255],
		olive:[128,128,0],
		yellow:[_255,_255,0],
		orange:[_255,165,0],
		gray:[128,128,128],
		purple:[128,0,128],
		green:[0,128,0],
		red:[_255,0,0],
		pink:[_255,192,203],
		cyan:[0,_255,_255],
		transparent:[_255,_255,_255,0]
	},
	_hue = (h, m1, m2) => {
		h = (h < 0) ? h + 1 : (h > 1) ? h - 1 : h;
		return ((((h * 6 < 1) ? m1 + (m2 - m1) * h * 6 : (h < .5) ? m2 : (h * 3 < 2) ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255) + .5) | 0;
	},
	splitColor = (v, toHSL, forceAlpha) => {
		let a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, (v >> 8) & _255, v & _255] : 0,
			r, g, b, h, s, l, max, min, d, wasHSL;
		if (!a) {
			if (v.substr(-1) === ",") { //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
				v = v.substr(0, v.length - 1);
			}
			if (_colorLookup[v]) {
				a = _colorLookup[v];
			} else if (v.charAt(0) === "#") {
				if (v.length < 6) { //for shorthand like #9F0 or #9F0F (could have alpha)
					r = v.charAt(1);
					g = v.charAt(2);
					b = v.charAt(3);
					v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
				}
				if (v.length === 9) { // hex with alpha, like #fd5e53ff
					a = parseInt(v.substr(1, 6), 16);
					return [a >> 16, (a >> 8) & _255, a & _255, parseInt(v.substr(7), 16) / 255];
				}
				v = parseInt(v.substr(1), 16);
				a = [v >> 16, (v >> 8) & _255, v & _255];
			} else if (v.substr(0, 3) === "hsl") {
				a = wasHSL = v.match(_strictNumExp);
				if (!toHSL) {
					h = (+a[0] % 360) / 360;
					s = +a[1] / 100;
					l = +a[2] / 100;
					g = (l <= .5) ? l * (s + 1) : l + s - l * s;
					r = l * 2 - g;
					a.length > 3 && (a[3] *= 1); //cast as number
					a[0] = _hue(h + 1 / 3, r, g);
					a[1] = _hue(h, r, g);
					a[2] = _hue(h - 1 / 3, r, g);
				} else if (~v.indexOf("=")) { //if relative values are found, just return the raw strings with the relative prefixes in place.
					a = v.match(_numExp);
					forceAlpha && a.length < 4 && (a[3] = 1);
					return a;
				}
			} else {
				a = v.match(_strictNumExp) || _colorLookup.transparent;
			}
			a = a.map(Number);
		}
		if (toHSL && !wasHSL) {
			r = a[0] / _255;
			g = a[1] / _255;
			b = a[2] / _255;
			max = Math.max(r, g, b);
			min = Math.min(r, g, b);
			l = (max + min) / 2;
			if (max === min) {
				h = s = 0;
			} else {
				d = max - min;
				s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
				h = (max === r) ? (g - b) / d + (g < b ? 6 : 0) : (max === g) ? (b - r) / d + 2 : (r - g) / d + 4;
				h *= 60;
			}
			a[0] = ~~(h + .5);
			a[1] = ~~(s * 100 + .5);
			a[2] = ~~(l * 100 + .5);
		}
		forceAlpha && a.length < 4 && (a[3] = 1);
		return a;
	},
	_colorOrderData = v => { // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
		let values = [],
			c = [],
			i = -1;
		v.split(_colorExp).forEach(v => {
			let a = v.match(_numWithUnitExp) || [];
			values.push(...a);
			c.push(i += a.length + 1);
		});
		values.c = c;
		return values;
	},
	_formatColors = (s, toHSL, orderMatchData) => {
		let result = "",
			colors = (s + result).match(_colorExp),
			type = toHSL ? "hsla(" : "rgba(",
			i = 0,
			c, shell, d, l;
		if (!colors) {
			return s;
		}
		colors = colors.map(color => (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")");
		if (orderMatchData) {
			d = _colorOrderData(s);
			c = orderMatchData.c;
			if (c.join(result) !== d.c.join(result)) {
				shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
				l = shell.length - 1;
				for (; i < l; i++) {
					result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
				}
			}
		}
		if (!shell) {
			shell = s.split(_colorExp);
			l = shell.length - 1;
			for (; i < l; i++) {
				result += shell[i] + colors[i];
			}
		}
		return result + shell[l];
	},
	_colorExp = (function() {
		let s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
			p;
		for (p in _colorLookup) {
			s += "|" + p + "\\b";
		}
		return new RegExp(s + ")", "gi");
	})(),
	_hslExp = /hsl[a]?\(/,
	_colorStringFilter = a => {
		let combined = a.join(" "),
			toHSL;
		_colorExp.lastIndex = 0;
		if (_colorExp.test(combined)) {
			toHSL = _hslExp.test(combined);
			a[1] = _formatColors(a[1], toHSL);
			a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.
			return true;
		}
	},
















/*
 * --------------------------------------------------------------------------------------
 * TICKER
 * --------------------------------------------------------------------------------------
 */
	_tickerActive,
	_ticker = (function() {
		let _getTime = Date.now,
			_lagThreshold = 500,
			_adjustedLag = 33,
			_startTime = _getTime(),
			_lastUpdate = _startTime,
			_gap = 1000 / 240,
			_nextTime = _gap,
			_listeners = [],
			_id, _req, _raf, _self, _delta, _i,
			_tick = v => {
				let elapsed = _getTime() - _lastUpdate,
					manual = v === true,
					overlap, dispatch, time, frame;
				elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
				_lastUpdate += elapsed;
				time = _lastUpdate - _startTime;
				overlap = time - _nextTime;
				if (overlap > 0 || manual) {
					frame = ++_self.frame;
					_delta = time - _self.time * 1000;
					_self.time = time = time / 1000;
					_nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
					dispatch = 1;
				}
				manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
				if (dispatch) {
					for (_i = 0; _i < _listeners.length; _i++) { // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
						_listeners[_i](time, _delta, frame, v);
					}
				}
			};
		_self = {
			time:0,
			frame:0,
			tick() {
				_tick(true);
			},
			deltaRatio(fps) {
				return _delta / (1000 / (fps || 60));
			},
			wake() {
				if (_coreReady) {
					if (!_coreInitted && _windowExists()) {
						_win = _coreInitted = window;
						_doc = _win.document || {};
						_globals.gsap = gsap;
						(_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
						_install(_installScope || _win.GreenSockGlobals || (!_win.gsap && _win) || {});
						_raf = _win.requestAnimationFrame;
					}
					_id && _self.sleep();
					_req = _raf || (f => setTimeout(f, (_nextTime - _self.time * 1000 + 1) | 0));
					_tickerActive = 1;
					_tick(2);
				}
			},
			sleep() {
				(_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
				_tickerActive = 0;
				_req = _emptyFunc;
			},
			lagSmoothing(threshold, adjustedLag) {
				_lagThreshold = threshold || (1 / _tinyNum); //zero should be interpreted as basically unlimited
				_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
			},
			fps(fps) {
				_gap = 1000 / (fps || 240);
				_nextTime = _self.time * 1000 + _gap;
			},
			add(callback) {
				_listeners.indexOf(callback) < 0 && _listeners.push(callback);
				_wake();
			},
			remove(callback) {
				let i;
				~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
			},
			_listeners:_listeners
		};
		return _self;
	})(),
	_wake = () => !_tickerActive && _ticker.wake(), //also ensures the core classes are initialized.














/*
* -------------------------------------------------
* EASING
* -------------------------------------------------
*/
	_easeMap = {},
	_customEaseExp = /^[\d.\-M][\d.\-,\s]/,
	_quotesExp = /["']/g,
	_parseObjectInString = value => { //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
		let obj = {},
			split = value.substr(1, value.length-3).split(":"),
			key = split[0],
			i = 1,
			l = split.length,
			index, val, parsedVal;
		for (; i < l; i++) {
			val = split[i];
			index = i !== l-1 ? val.lastIndexOf(",") : val.length;
			parsedVal = val.substr(0, index);
			obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
			key = val.substr(index+1).trim();
		}
		return obj;
	},
	_valueInParentheses = value => {
		let open = value.indexOf("(") + 1,
			close = value.indexOf(")"),
			nested = value.indexOf("(", open);
		return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
	},
	_configEaseFromString = name => { //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
		let split = (name + "").split("("),
			ease = _easeMap[split[0]];
		return (ease && split.length > 1 && ease.config) ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : (_easeMap._CE && _customEaseExp.test(name)) ? _easeMap._CE("", name) : ease;
	},
	_invertEase = ease => p => 1 - ease(1 - p),
	// allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
	_propagateYoyoEase = (timeline, isYoyo) => {
		let child = timeline._first, ease;
		while (child) {
			if (child instanceof Timeline) {
				_propagateYoyoEase(child, isYoyo);
			} else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
				if (child.timeline) {
					_propagateYoyoEase(child.timeline, isYoyo);
				} else {
					ease = child._ease;
					child._ease = child._yEase;
					child._yEase = ease;
					child._yoyo = isYoyo;
				}
			}
			child = child._next;
		}
	},
	_parseEase = (ease, defaultEase) => !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase,
	_insertEase = (names, easeIn, easeOut = p => 1 - easeIn(1 - p), easeInOut = (p => p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2)) => {
		let ease = {easeIn, easeOut, easeInOut},
			lowercaseName;
		_forEachName(names, name => {
			_easeMap[name] = _globals[name] = ease;
			_easeMap[(lowercaseName = name.toLowerCase())] = easeOut;
			for (let p in ease) {
				_easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
			}
		});
		return ease;
	},
	_easeInOutFromOut = easeOut => (p => p < .5 ? (1 - easeOut(1 - (p * 2))) / 2 : .5 + easeOut((p - .5) * 2) / 2),
	_configElastic = (type, amplitude, period) => {
		let p1 = (amplitude >= 1) ? amplitude : 1, //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
			p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
			p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
			easeOut = p => p === 1 ? 1 : p1 * (2 ** (-10 * p)) * _sin((p - p3) * p2) + 1,
			ease = (type === "out") ? easeOut : (type === "in") ? p => 1 - easeOut(1 - p) : _easeInOutFromOut(easeOut);
		p2 = _2PI / p2; //precalculate to optimize
		ease.config = (amplitude, period) => _configElastic(type, amplitude, period);
		return ease;
	},
	_configBack = (type, overshoot = 1.70158) => {
		let easeOut = p => p ? ((--p) * p * ((overshoot + 1) * p + overshoot) + 1) : 0,
			ease = (type === "out") ? easeOut : (type === "in") ? p => 1 - easeOut(1 - p) : _easeInOutFromOut(easeOut);
		ease.config = overshoot => _configBack(type, overshoot);
		return ease;
	};
	// a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
	// _weightedEase = ratio => {
	// 	let y = 0.5 + ratio / 2;
	// 	return p => (2 * (1 - p) * p * y + p * p);
	// },
	// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
	// _weightedEaseStrong = ratio => {
	// 	ratio = .5 + ratio / 2;
	// 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
	// 		b = ratio - o,
	// 		c = ratio + o;
	// 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
	// };

_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", (name, i) => {
	let power = i < 5 ? i + 1 : i;
	_insertEase(name + ",Power" + (power - 1), i ? p => p ** power : p => p, p => 1 - (1 - p) ** power, p => p < .5 ? (p * 2) ** power / 2 : 1 - ((1 - p) * 2) ** power / 2);
});
_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
((n, c) => {
	let n1 = 1 / c,
		n2 = 2 * n1,
		n3 = 2.5 * n1,
		easeOut = p => (p < n1) ? n * p * p : (p < n2) ? n * (p - 1.5 / c) ** 2 + .75 : (p < n3) ? n * (p -= 2.25 / c) * p + .9375 : n * (p - 2.625 / c) ** 2 + .984375;
	_insertEase("Bounce", p => 1 - easeOut(1 - p), easeOut);
})(7.5625, 2.75);
_insertEase("Expo", p => p ? 2 ** (10 * (p - 1)) : 0);
_insertEase("Circ", p => -(_sqrt(1 - (p * p)) - 1));
_insertEase("Sine", p => p === 1 ? 1 : -_cos(p * _HALF_PI) + 1);
_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
	config(steps = 1, immediateStart) {
		let p1 = 1 / steps,
			p2 = steps + (immediateStart ? 0 : 1),
			p3 = immediateStart ? 1 : 0,
			max = 1 - _tinyNum;
		return p => (((p2 * _clamp(0, max, p)) | 0) + p3) * p1;
	}
};
_defaults.ease = _easeMap["quad.out"];


_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", name => _callbackNames += name + "," + name + "Params,");














/*
 * --------------------------------------------------------------------------------------
 * CACHE
 * --------------------------------------------------------------------------------------
 */
class GSCache {

	constructor(target, harness) {
		this.id = _gsID++;
		target._gsap = this;
		this.target = target;
		this.harness = harness;
		this.get = harness ? harness.get : _getProperty;
		this.set = harness ? harness.getSetter : _getSetter;
	}

}















/*
 * --------------------------------------------------------------------------------------
 * ANIMATION
 * --------------------------------------------------------------------------------------
 */

class Animation {

	constructor(vars) {
		this.vars = vars;
		this._delay = +vars.delay || 0;
		if ((this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0)) { // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
			this._rDelay = vars.repeatDelay || 0;
			this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
		}
		this._ts = 1;
		_setDuration(this, +vars.duration, 1, 1);
		this.data = vars.data;
		_tickerActive || _ticker.wake();
	}

	delay(value) {
		if (value || value === 0) {
			this.parent && this.parent.smoothChildTiming && (this.startTime(this._start + value - this._delay));
			this._delay = value;
			return this;
		}
		return this._delay;
	}

	duration(value) {
		return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
	}

	totalDuration(value) {
		if (!arguments.length) {
			return this._tDur;
		}
		this._dirty = 0;
		return _setDuration(this, this._repeat < 0 ? value : (value - (this._repeat * this._rDelay)) / (this._repeat + 1));
	}

	totalTime(totalTime, suppressEvents) {
		_wake();
		if (!arguments.length) {
			return this._tTime;
		}
		let parent = this._dp;
		if (parent && parent.smoothChildTiming && this._ts) {
			_alignPlayhead(this, totalTime);
			!parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
			//in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.
			while (parent.parent) {
				if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
					parent.totalTime(parent._tTime, true);
				}
				parent = parent.parent;
			}
			if (!this.parent && this._dp.autoRemoveChildren && ((this._ts > 0 && totalTime < this._tDur) || (this._ts < 0 && totalTime > 0) || (!this._tDur && !totalTime) )) { //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
				_addToTimeline(this._dp, this, this._start - this._delay);
			}
		}
        if (this._tTime !== totalTime || (!this._dur && !suppressEvents) || (this._initted && Math.abs(this._zTime) === _tinyNum) || (!totalTime && !this._initted && (this.add || this._ptLookup))) { // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
        	this._ts || (this._pTime = totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
	        //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
		    //   this._lock = 1;
		        _lazySafeRender(this, totalTime, suppressEvents);
		    //   this._lock = 0;
	        //}
		}
		return this;
	}

	time(value, suppressEvents) {
		return arguments.length ? this.totalTime((Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % this._dur) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
	}

	totalProgress(value, suppressEvents) {
		return arguments.length ? this.totalTime( this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
	}

	progress(value, suppressEvents) {
		return arguments.length ? this.totalTime( this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : (this.duration() ? Math.min(1, this._time / this._dur) : this.ratio);
	}

	iteration(value, suppressEvents) {
		let cycleDuration = this.duration() + this._rDelay;
		return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
	}

	// potential future addition:
	// isPlayingBackwards() {
	// 	let animation = this,
	// 		orientation = 1; // 1 = forward, -1 = backward
	// 	while (animation) {
	// 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
	// 		animation = animation.parent;
	// 	}
	// 	return orientation < 0;
	// }

	timeScale(value) {
		if (!arguments.length) {
			return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
		}
		if (this._rts === value) {
			return this;
		}
		let tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.

		// future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.
		//(+value < 0 && this._rts >= 0) && _callback(this, "onReverse", true);

		// prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.
		this._rts = +value || 0;
		this._ts = (this._ps || value === -_tinyNum) ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.
		return _recacheAncestors(this.totalTime(_clamp(-this._delay, this._tDur, tTime), true));
	}

	paused(value) {
		if (!arguments.length) {
			return this._ps;
		}
		if (this._ps !== value) {
			this._ps = value;
			if (value) {
				this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.
				this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
			} else {
				_wake();
				this._ts = this._rts;
				//only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.
				this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, (this.progress() === 1) && (this._tTime -= _tinyNum) && Math.abs(this._zTime) !== _tinyNum); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
			}
		}
		return this;
	}

	startTime(value) {
		if (arguments.length) {
			this._start = value;
			let parent = this.parent || this._dp;
			parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
			return this;
		}
		return this._start;
	}

	endTime(includeRepeats) {
		return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts);
	}

	rawTime(wrapRepeats) {
		let parent = this.parent || this._dp; // _dp = detached parent
		return !parent ? this._tTime : (wrapRepeats && (!this._ts || (this._repeat && this._time && this.totalProgress() < 1))) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
	}

	globalTime(rawTime) {
		let animation = this,
			time = arguments.length ? rawTime : animation.rawTime();
		while (animation) {
			time = animation._start + time / (animation._ts || 1);
			animation = animation._dp;
		}
		return time;
	}

	repeat(value) {
		if (arguments.length) {
			this._repeat = value === Infinity ? -2 : value;
			return _onUpdateTotalDuration(this);
		}
		return this._repeat === -2 ? Infinity : this._repeat;
	}

	repeatDelay(value) {
		if (arguments.length) {
			this._rDelay = value;
			return _onUpdateTotalDuration(this);
		}
		return this._rDelay;
	}

	yoyo(value) {
		if (arguments.length) {
			this._yoyo = value;
			return this;
		}
		return this._yoyo;
	}

	seek(position, suppressEvents) {
		return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
	}

	restart(includeDelay, suppressEvents) {
		return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
	}

	play(from, suppressEvents) {
		from != null && this.seek(from, suppressEvents);
		return this.reversed(false).paused(false);
	}

	reverse(from, suppressEvents) {
		from != null && this.seek(from || this.totalDuration(), suppressEvents);
		return this.reversed(true).paused(false);
	}

	pause(atTime, suppressEvents) {
		atTime != null && this.seek(atTime, suppressEvents);
		return this.paused(true);
	}

	resume() {
		return this.paused(false);
	}

	reversed(value) {
		if (arguments.length) {
			!!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.
			return this;
		}
		return this._rts < 0;
	}

	invalidate() {
		this._initted = this._act = 0;
		this._zTime = -_tinyNum;
		return this;
	}

	isActive() {
		let parent = this.parent || this._dp,
			start = this._start,
			rawTime;
		return !!(!parent || (this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum));
	}

	eventCallback(type, callback, params) {
		let vars = this.vars;
		if (arguments.length > 1) {
			if (!callback) {
				delete vars[type];
			} else {
				vars[type] = callback;
				params && (vars[type + "Params"] = params);
				type === "onUpdate" && (this._onUpdate = callback);
			}
			return this;
		}
		return vars[type];
	}

	then(onFulfilled) {
		let self = this;
		return new Promise(resolve => {
			let f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
				_resolve = () => {
					let _then = self.then;
					self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)
					_isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
					resolve(f);
					self.then = _then;
				};
			if (self._initted && (self.totalProgress() === 1 && self._ts >= 0) || (!self._tTime && self._ts < 0)) {
				_resolve();
			} else {
				self._prom = _resolve;
			}
		});
	}

	kill() {
		_interrupt(this);
	}

}

_setDefaults(Animation.prototype, {_time:0, _start:0, _end:0, _tTime:0, _tDur:0, _dirty:0, _repeat:0, _yoyo:false, parent:null, _initted:false, _rDelay:0, _ts:1, _dp:0, ratio:0, _zTime:-_tinyNum, _prom:0, _ps:false, _rts:1});


















/*
 * -------------------------------------------------
 * TIMELINE
 * -------------------------------------------------
 */

class Timeline extends Animation {

	constructor(vars = {}, position) {
		super(vars);
		this.labels = {};
		this.smoothChildTiming = !!vars.smoothChildTiming;
		this.autoRemoveChildren = !!vars.autoRemoveChildren;
		this._sort = _isNotFalse(vars.sortChildren);
		_globalTimeline && _addToTimeline(vars.parent || _globalTimeline, this, position);
		vars.reversed && this.reverse();
		vars.paused && this.paused(true);
		vars.scrollTrigger && _scrollTrigger(this, vars.scrollTrigger);
	}

	to(targets, vars, position) {
		_createTweenType(0, arguments, this);
		return this;
	}

	from(targets, vars, position) {
		_createTweenType(1, arguments, this);
		return this;
	}

	fromTo(targets, fromVars, toVars, position) {
		_createTweenType(2, arguments, this);
		return this;
	}

	set(targets, vars, position) {
		vars.duration = 0;
		vars.parent = this;
		_inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
		vars.immediateRender = !!vars.immediateRender;
		new Tween(targets, vars, _parsePosition(this, position), 1);
		return this;
	}

	call(callback, params, position) {
		return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
	}

	//ONLY for backward compatibility! Maybe delete?
	staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
		vars.duration = duration;
		vars.stagger = vars.stagger || stagger;
		vars.onComplete = onCompleteAll;
		vars.onCompleteParams = onCompleteAllParams;
		vars.parent = this;
		new Tween(targets, vars, _parsePosition(this, position));
		return this;
	}

	staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
		vars.runBackwards = 1;
		_inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
		return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
	}

	staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
		toVars.startAt = fromVars;
		_inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
		return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
	}

	render(totalTime, suppressEvents, force) {
		let prevTime = this._time,
			tDur = this._dirty ? this.totalDuration() : this._tDur,
			dur = this._dur,
			tTime = (this !== _globalTimeline && totalTime > tDur - _tinyNum && totalTime >= 0) ? tDur : (totalTime < _tinyNum) ? 0 : totalTime,
			crossingStart = (this._zTime < 0) !== (totalTime < 0) && (this._initted || !dur),
			time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
		if (tTime !== this._tTime || force || crossingStart) {
			if (prevTime !== this._time && dur) { //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
				tTime += this._time - prevTime;
				totalTime += this._time - prevTime;
			}
			time = tTime;
			prevStart = this._start;
			timeScale = this._ts;
			prevPaused = !timeScale;
			if (crossingStart) {
				dur || (prevTime = this._zTime);
				 //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.
				(totalTime || !suppressEvents) && (this._zTime = totalTime);
			}
			if (this._repeat) { //adjust the time for repeats and yoyos
				yoyo = this._yoyo;
				cycleDuration = dur + this._rDelay;
				if (this._repeat < -1 && totalTime < 0) {
					return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
				}
				time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)
				if (tTime === tDur) { // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
					iteration = this._repeat;
					time = dur;
				} else {
					iteration = ~~(tTime / cycleDuration);
					if (iteration && iteration === tTime / cycleDuration) {
						time = dur;
						iteration--;
					}
					time > dur && (time = dur);
				}
				prevIteration = _animationCycle(this._tTime, cycleDuration);
				!prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005
				if (yoyo && (iteration & 1)) {
					time = dur - time;
					isYoyo = 1;
				}
				/*
				make sure children at the end/beginning of the timeline are rendered properly. If, for example,
				a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
				would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
				could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
				we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
				ensure that zero-duration tweens at the very beginning or end of the Timeline work.
				*/
				if (iteration !== prevIteration && !this._lock) {
					let rewinding = (yoyo && (prevIteration & 1)),
						doesWrap = (rewinding === (yoyo && (iteration & 1)));
					iteration < prevIteration && (rewinding = !rewinding);
					prevTime = rewinding ? 0 : dur;
					this._lock = 1;
					this.render(prevTime || (isYoyo ? 0 : _round(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
					this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.
					!suppressEvents && this.parent && _callback(this, "onRepeat");
					this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
					if ((prevTime && prevTime !== this._time) || prevPaused !== !this._ts || (this.vars.onRepeat && !this.parent && !this._act)) { // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.
						return this;
					}
					dur = this._dur; // in case the duration changed in the onRepeat
					tDur = this._tDur;
					if (doesWrap) {
						this._lock = 2;
						prevTime = rewinding ? dur : -0.0001;
						this.render(prevTime, true);
						this.vars.repeatRefresh && !isYoyo && this.invalidate();
					}
					this._lock = 0;
					if (!this._ts && !prevPaused) {
						return this;
					}
					//in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.
					_propagateYoyoEase(this, isYoyo);
				}
			}
			if (this._hasPause && !this._forcing && this._lock < 2) {
				pauseTween = _findNextPauseTween(this, _round(prevTime), _round(time));
				if (pauseTween) {
					tTime -= time - (time = pauseTween._start);
				}
			}

			this._tTime = tTime;
			this._time = time;
			this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

			if (!this._initted) {
				this._onUpdate = this.vars.onUpdate;
				this._initted = 1;
				this._zTime = totalTime;
				prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
			}
			if (!prevTime && time && !suppressEvents) {
				_callback(this, "onStart");
				if (this._tTime !== tTime) { // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
					return this;
				}
			}
			if (time >= prevTime && totalTime >= 0) {
				child = this._first;
				while (child) {
					next = child._next;
					if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
						if (child.parent !== this) { // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
							return this.render(totalTime, suppressEvents, force);
						}
						child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
						if (time !== this._time || (!this._ts && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
							pauseTween = 0;
							next && (tTime += (this._zTime = -_tinyNum));  // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)
							break;
						}
					}
					child = next;
				}
			} else {
				child = this._last;
				let adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.
				while (child) {
					next = child._prev;
					if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
						if (child.parent !== this) { // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
							return this.render(totalTime, suppressEvents, force);
						}
						child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);
						if (time !== this._time || (!this._ts && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
							pauseTween = 0;
							next && (tTime += (this._zTime = adjustedTime ? -_tinyNum : _tinyNum)); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)
							break;
						}
					}
					child = next;
				}
			}
			if (pauseTween && !suppressEvents) {
				this.pause();
				pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
				if (this._ts) { //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
					this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.
					_setEnd(this);
					return this.render(totalTime, suppressEvents, force);
				}
			}
			this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
			if ((tTime === tDur && tDur >= this.totalDuration()) || (!tTime && prevTime)) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
				(totalTime || !dur) && ((tTime === tDur && this._ts > 0) || (!tTime && this._ts < 0)) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.
				if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
					_callback(this, (tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete"), true);
					this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
				}
			}
		}
		return this;
	}

	add(child, position) {
		_isNumber(position) || (position = _parsePosition(this, position, child));
		if (!(child instanceof Animation)) {
			if (_isArray(child)) {
				child.forEach(obj => this.add(obj, position));
				return this;
			}
			if (_isString(child)) {
				return this.addLabel(child, position);
			}
			if (_isFunction(child)) {
				child = Tween.delayedCall(0, child);
			} else {
				return this;
			}
		}
		return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
	}

	getChildren(nested = true, tweens = true, timelines = true, ignoreBeforeTime = -_bigNum) {
		let a = [],
			child = this._first;
		while (child) {
			if (child._start >= ignoreBeforeTime) {
				if (child instanceof Tween) {
					tweens && a.push(child);
				} else {
					timelines && a.push(child);
					nested && a.push(...child.getChildren(true, tweens, timelines));
				}
			}
			child = child._next;
		}
		return a;
	}

	getById(id) {
		let animations = this.getChildren(1, 1, 1),
			i = animations.length;
		while(i--) {
			if (animations[i].vars.id === id) {
				return animations[i];
			}
		}
	}

	remove(child) {
		if (_isString(child)) {
			return this.removeLabel(child);
		}
		if (_isFunction(child)) {
			return this.killTweensOf(child);
		}
		_removeLinkedListItem(this, child);
		if (child === this._recent) {
			this._recent = this._last;
		}
		return _uncache(this);
	}

	totalTime(totalTime, suppressEvents) {
		if (!arguments.length) {
			return this._tTime;
		}
		this._forcing = 1;
		if (!this._dp && this._ts) { //special case for the global timeline (or any other that has no parent or detached parent).
			this._start = _round(_ticker.time - (this._ts > 0 ? totalTime / this._ts : (this.totalDuration() - totalTime) / -this._ts));
		}
		super.totalTime(totalTime, suppressEvents);
		this._forcing = 0;
		return this;
	}

	addLabel(label, position) {
		this.labels[label] = _parsePosition(this, position);
		return this;
	}

	removeLabel(label) {
		delete this.labels[label];
		return this;
	}

	addPause(position, callback, params) {
		let t = Tween.delayedCall(0, callback || _emptyFunc, params);
		t.data = "isPause";
		this._hasPause = 1;
		return _addToTimeline(this, t, _parsePosition(this, position));
	}

	removePause(position) {
		let child = this._first;
		position = _parsePosition(this, position);
		while (child) {
			if (child._start === position && child.data === "isPause") {
				_removeFromParent(child);
			}
			child = child._next;
		}
	}

	killTweensOf(targets, props, onlyActive) {
		let tweens = this.getTweensOf(targets, onlyActive),
			i = tweens.length;
		while (i--) {
			(_overwritingTween !== tweens[i]) && tweens[i].kill(targets, props);
		}
		return this;
	}

	getTweensOf(targets, onlyActive) {
		let a = [],
			parsedTargets = toArray(targets),
			child = this._first,
			isGlobalTime = _isNumber(onlyActive), // a number is interpreted as a global time. If the animation spans
			children;
		while (child) {
			if (child instanceof Tween) {
				if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || (child._initted && child._ts)) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) { // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
					a.push(child);
				}
			} else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
				a.push(...children);
			}
			child = child._next;
		}
		return a;
	}

	// potential future feature - targets() on timelines
	// targets() {
	// 	let result = [];
	// 	this.getChildren(true, true, false).forEach(t => result.push(...t.targets()));
	// 	return result.filter((v, i) => result.indexOf(v) === i);
	// }

	tweenTo(position, vars) {
		vars = vars || {};
		let tl = this,
			endTime = _parsePosition(tl, position),
			{ startAt, onStart, onStartParams, immediateRender } = vars,
			initted,
			tween = Tween.to(tl, _setDefaults({
				ease: vars.ease || "none",
				lazy: false,
				immediateRender: false,
				time: endTime,
				overwrite: "auto",
				duration: vars.duration || (Math.abs((endTime - ((startAt && "time" in startAt) ? startAt.time : tl._time)) / tl.timeScale())) || _tinyNum,
				onStart: () => {
					tl.pause();
					if (!initted) {
						let duration = vars.duration || Math.abs((endTime - ((startAt && "time" in startAt) ? startAt.time : tl._time)) / tl.timeScale());
						(tween._dur !== duration) && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
						initted = 1;
					}
					onStart && onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
				}
			}, vars));
		return immediateRender ? tween.render(0) : tween;
	}

	tweenFromTo(fromPosition, toPosition, vars) {
		return this.tweenTo(toPosition, _setDefaults({startAt:{time:_parsePosition(this, fromPosition)}}, vars));
	}

	recent() {
		return this._recent;
	}

	nextLabel(afterTime = this._time) {
		return _getLabelInDirection(this, _parsePosition(this, afterTime));
	}

	previousLabel(beforeTime = this._time) {
		return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
	}

	currentLabel(value) {
		return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
	}

	shiftChildren(amount, adjustLabels, ignoreBeforeTime = 0) {
		let child = this._first,
			labels = this.labels,
			p;
		while (child) {
			if (child._start >= ignoreBeforeTime) {
				child._start += amount;
				child._end += amount;
			}
			child = child._next;
		}
		if (adjustLabels) {
			for (p in labels) {
				if (labels[p] >= ignoreBeforeTime) {
					labels[p] += amount;
				}
			}
		}
		return _uncache(this);
	}

	invalidate() {
		let child = this._first;
		this._lock = 0;
		while (child) {
			child.invalidate();
			child = child._next;
		}
		return super.invalidate();
	}

	clear(includeLabels = true) {
		let child = this._first,
			next;
		while (child) {
			next = child._next;
			this.remove(child);
			child = next;
		}
		this._dp && (this._time = this._tTime = this._pTime = 0);
		includeLabels && (this.labels = {});
		return _uncache(this);
	}

	totalDuration(value) {
		let max = 0,
			self = this,
			child = self._last,
			prevStart = _bigNum,
			prev, start, parent;
		if (arguments.length) {
			return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
		}
		if (self._dirty) {
			parent = self.parent;
			while (child) {
				prev = child._prev; //record it here in case the tween changes position in the sequence...
				child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.
				start = child._start;
				if (start > prevStart && self._sort && child._ts && !self._lock) { //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
					self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().
					_addToTimeline(self, child, start - child._delay, 1)._lock = 0;
				} else {
					prevStart = start;
				}
				if (start < 0 && child._ts) { //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
					max -= start;
					if ((!parent && !self._dp) || (parent && parent.smoothChildTiming)) {
						self._start += start / self._ts;
						self._time -= start;
						self._tTime -= start;
					}
					self.shiftChildren(-start, false, -1e999);
					prevStart = 0;
				}
				child._end > max && child._ts && (max = child._end);
				child = prev;
			}
			_setDuration(self, (self === _globalTimeline && self._time > max) ? self._time : max, 1, 1);
			self._dirty = 0;
		}
		return self._tDur;
	}

	static updateRoot(time) {
		if (_globalTimeline._ts) {
			_lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
			_lastRenderedFrame = _ticker.frame;
		}
		if (_ticker.frame >= _nextGCFrame) {
			_nextGCFrame += _config.autoSleep || 120;
			let child = _globalTimeline._first;
			if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
				while (child && !child._ts) {
					child = child._next;
				}
				child || _ticker.sleep();
			}
		}
	}

}

_setDefaults(Timeline.prototype, {_lock:0, _hasPause:0, _forcing:0});




















let _addComplexStringPropTween = function(target, prop, start, end, setter, stringFilter, funcParam) { //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
		let pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
			index = 0,
			matchIndex = 0,
			result,	startNums, color, endNum, chunk, startNum, hasRandom, a;
		pt.b = start;
		pt.e = end;
		start += ""; //ensure values are strings
		end += "";
		if ((hasRandom = ~end.indexOf("random("))) {
			end = _replaceRandom(end);
		}
		if (stringFilter) {
			a = [start, end];
			stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.
			start = a[0];
			end = a[1];
		}
		startNums = start.match(_complexStringNumExp) || [];
		while ((result = _complexStringNumExp.exec(end))) {
			endNum = result[0];
			chunk = end.substring(index, result.index);
			if (color) {
				color = (color + 1) % 5;
			} else if (chunk.substr(-5) === "rgba(") {
				color = 1;
			}
			if (endNum !== startNums[matchIndex++]) {
				startNum = parseFloat(startNums[matchIndex-1]) || 0;
				//these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.
				pt._pt = {
					_next:pt._pt,
					p:(chunk || matchIndex === 1) ? chunk : ",", //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
					s:startNum,
					c:endNum.charAt(1) === "=" ? parseFloat(endNum.substr(2)) * (endNum.charAt(0) === "-" ? -1 : 1) : parseFloat(endNum) - startNum,
					m:(color && color < 4) ? Math.round : 0
				};
				index = _complexStringNumExp.lastIndex;
			}
		}
		pt.c = (index < end.length) ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
		pt.fp = funcParam;
		if (_relExp.test(end) || hasRandom) {
			pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
		}
		this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
		return pt;
	},
	_addPropTween = function(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {
		_isFunction(end) && (end = end(index || 0, target, targets));
		let currentValue = target[prop],
			parsedStart = (start !== "get") ? start : !_isFunction(currentValue) ? currentValue : (funcParam ? target[(prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)])) ? prop : "get" + prop.substr(3)](funcParam) : target[prop]()),
			setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
			pt;
		if (_isString(end)) {
			if (~end.indexOf("random(")) {
				end = _replaceRandom(end);
			}
			if (end.charAt(1) === "=") {
				pt = parseFloat(parsedStart) + parseFloat(end.substr(2)) * (end.charAt(0) === "-" ? -1 : 1) + (getUnit(parsedStart) || 0);
				if (pt || pt === 0) { // to avoid isNaN, like if someone passes in a value like "!= whatever"
					end = pt;
				}
			}
		}
		if (parsedStart !== end) {
			if (!isNaN(parsedStart * end) && end !== "") { // fun fact: any number multiplied by "" is evaluated as the number 0!
				pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof(currentValue) === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
				funcParam && (pt.fp = funcParam);
				modifier && pt.modifier(modifier, this, target);
				return (this._pt = pt);
			}
			!currentValue && !(prop in target) && _missingPlugin(prop, end);
			return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
		}
	},
	//creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
	_processVars = (vars, index, target, targets, tween) => {
		_isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
		if (!_isObject(vars) || (vars.style && vars.nodeType) || _isArray(vars) || _isTypedArray(vars)) {
			return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
		}
		let copy = {},
			p;
		for (p in vars) {
			copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
		}
		return copy;
	},
	_checkPlugin = (property, vars, tween, index, target, targets) => {
		let plugin, pt, ptLookup, i;
		if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
			tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
			if (tween !== _quickTween) {
				ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.
				i = plugin._props.length;
				while (i--) {
					ptLookup[plugin._props[i]] = pt;
				}
			}
		}
		return plugin;
	},
	_overwritingTween, //store a reference temporarily so we can avoid overwriting itself.
	_initTween = (tween, time) => {
		let vars = tween.vars,
			{ ease, startAt, immediateRender, lazy, onUpdate, onUpdateParams, callbackScope, runBackwards, yoyoEase, keyframes, autoRevert } = vars,
			dur = tween._dur,
			prevStartAt = tween._startAt,
			targets = tween._targets,
			parent = tween.parent,
			//when a stagger (or function-based duration/delay) is on a Tween instance, we create a nested timeline which means that the "targets" of that tween don't reflect the parent. This function allows us to discern when it's a nested tween and in that case, return the full targets array so that function-based values get calculated properly.
			fullTargets = (parent && parent.data === "nested") ? parent.parent._targets : targets,
			autoOverwrite = (tween._overwrite === "auto") && !_suppressOverwrites,
			tl = tween.timeline,
			cleanVars, i, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;
		tl && (!keyframes || !ease) && (ease = "none");
		tween._ease = _parseEase(ease, _defaults.ease);
		tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
		if (yoyoEase && tween._yoyo && !tween._repeat) { //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
			yoyoEase = tween._yEase;
			tween._yEase = tween._ease;
			tween._ease = yoyoEase;
		}
		tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.
		if (!tl) { //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
			harness = targets[0] ? _getCache(targets[0]).harness : 0;
			harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.
			cleanVars = _copyExcluding(vars, _reservedProps);
			prevStartAt && prevStartAt.render(-1, true).kill();
			if (startAt) {
				_removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({data: "isStart", overwrite: false, parent: parent, immediateRender: true, lazy: _isNotFalse(lazy), startAt: null, delay: 0, onUpdate: onUpdate, onUpdateParams: onUpdateParams, callbackScope: callbackScope, stagger: 0}, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);
				(time < 0 && !immediateRender && !autoRevert) && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.
				if (immediateRender) {
					(time > 0) && !autoRevert && (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
					if (dur && time <= 0) {
						time && (tween._zTime = time);
						return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
					}
					// if (time > 0) {
					// 	autoRevert || (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
					// } else if (dur && !(time < 0 && prevStartAt)) {
					// 	time && (tween._zTime = time);
					// 	return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
					// }
				} else if (autoRevert === false) {
					tween._startAt = 0;
				}
			} else if (runBackwards && dur) {
				//from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
				if (prevStartAt) {
					!autoRevert && (tween._startAt = 0);
				} else {
					time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
					p = _setDefaults({
						overwrite: false,
						data: "isFromStart", //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
						lazy: immediateRender && _isNotFalse(lazy),
						immediateRender: immediateRender, //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
						stagger: 0,
						parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})
					}, cleanVars);
					harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})
					_removeFromParent(tween._startAt = Tween.set(targets, p));
					(time < 0) && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted from() tween.
					if (!immediateRender) {
						_initTween(tween._startAt, _tinyNum); //ensures that the initial values are recorded
					} else if (!time) {
						return;
					}
				}
			}
			tween._pt = 0;
			lazy = (dur && _isNotFalse(lazy)) || (lazy && !dur);
			for (i = 0; i < targets.length; i++) {
				target = targets[i];
				gsData = target._gsap || _harness(targets)[i]._gsap;
				tween._ptLookup[i] = ptLookup = {};
				_lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
				index = fullTargets === targets ? i : fullTargets.indexOf(target);
				if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
					tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
					plugin._props.forEach(name => {ptLookup[name] = pt;});
					plugin.priority && (hasPriority = 1);
				}
				if (!harness || harnessVars) {
					for (p in cleanVars) {
						if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
							plugin.priority && (hasPriority = 1);
						} else {
							ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
						}
					}
				}
				tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
				if (autoOverwrite && tween._pt) {
					_overwritingTween = tween;
					_globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(0)); //Also make sure the overwriting doesn't overwrite THIS tween!!!
					overwritten = !tween.parent;
					_overwritingTween = 0;
				}
				tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
			}
			hasPriority && _sortPropTweensByPriority(tween);
			tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
		}
		tween._onUpdate = onUpdate;
		tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.
	},
	_addAliasesToVars = (targets, vars) => {
		let harness = targets[0] ? _getCache(targets[0]).harness : 0,
			propertyAliases = (harness && harness.aliases),
			copy, p, i, aliases;
		if (!propertyAliases) {
			return vars;
		}
		copy = _merge({}, vars);
		for (p in propertyAliases) {
			if (p in copy) {
				aliases = propertyAliases[p].split(",");
				i = aliases.length;
				while(i--) {
					copy[aliases[i]] = copy[p];
				}
			}

		}
		return copy;
	},
	_parseFuncOrString = (value, tween, i, target, targets) => (_isFunction(value) ? value.call(tween, i, target, targets) : (_isString(value) && ~value.indexOf("random(")) ? _replaceRandom(value) : value),
	_staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
	_staggerPropsToSkip = (_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger").split(",");























/*
 * --------------------------------------------------------------------------------------
 * TWEEN
 * --------------------------------------------------------------------------------------
 */

class Tween extends Animation {

	constructor(targets, vars, position, skipInherit) {
		if (typeof(vars) === "number") {
			position.duration = vars;
			vars = position;
			position = null;
		}
		super(skipInherit ? vars : _inheritDefaults(vars));
		let { duration, delay, immediateRender, stagger, overwrite, keyframes, defaults, scrollTrigger, yoyoEase } = this.vars,
			parent = vars.parent || _globalTimeline,
			parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : ("length" in vars)) ? [targets] : toArray(targets), // edge case: someone might try animating the "length" of an object with a "length" property that's initially set to 0 so don't interpret that as an empty Array-like object.
			tl, i, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge;
		this._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
		this._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property
		this._overwrite = overwrite;
		if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
			vars = this.vars;
			tl = this.timeline = new Timeline({data:"nested", defaults:defaults || {}});
			tl.kill();
			tl.parent = tl._dp = this;
			tl._start = 0;
			if (keyframes) {
				_setDefaults(tl.vars.defaults, {ease:"none"});
				stagger ? parsedTargets.forEach((t, i) => keyframes.forEach((frame, j) => tl.to(t, frame, j ? ">" : i * stagger))) : keyframes.forEach(frame => tl.to(parsedTargets, frame, ">"));
			} else {
				l = parsedTargets.length;
				staggerFunc = stagger ? distribute(stagger) : _emptyFunc;
				if (_isObject(stagger)) { //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
					for (p in stagger) {
						if (~_staggerTweenProps.indexOf(p)) {
							staggerVarsToMerge || (staggerVarsToMerge = {});
							staggerVarsToMerge[p] = stagger[p];
						}
					}
				}
				for (i = 0; i < l; i++) {
					copy = {};
					for (p in vars) {
						if (_staggerPropsToSkip.indexOf(p) < 0) {
							copy[p] = vars[p];
						}
					}
					copy.stagger = 0;
					yoyoEase && (copy.yoyoEase = yoyoEase);
					staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
					curTarget = parsedTargets[i];
					//don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.
					copy.duration = +_parseFuncOrString(duration, this, i, curTarget, parsedTargets);
					copy.delay = (+_parseFuncOrString(delay, this, i, curTarget, parsedTargets) || 0) - this._delay;
					if (!stagger && l === 1 && copy.delay) { // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
						this._delay = delay = copy.delay;
						this._start += delay;
						copy.delay = 0;
					}
					tl.to(curTarget, copy, staggerFunc(i, curTarget, parsedTargets));
				}
				tl.duration() ? (duration = delay = 0) : (this.timeline = 0); // if the timeline's duration is 0, we don't need a timeline internally!
			}
			duration || this.duration((duration = tl.duration()));

		} else {
			this.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
		}

		if (overwrite === true && !_suppressOverwrites) {
			_overwritingTween = this;
			_globalTimeline.killTweensOf(parsedTargets);
			_overwritingTween = 0;
		}
		_addToTimeline(parent, this, position);
		vars.reversed && this.reverse();
		vars.paused && this.paused(true);
		if (immediateRender || (!duration && !keyframes && this._start === _round(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(this) && parent.data !== "nested")) {
			this._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
			this.render(Math.max(0, -delay)); //in case delay is negative
		}
		scrollTrigger && _scrollTrigger(this, scrollTrigger);
	}

	render(totalTime, suppressEvents, force) {
		let prevTime = this._time,
			tDur = this._tDur,
			dur = this._dur,
			tTime = (totalTime > tDur - _tinyNum && totalTime >= 0) ? tDur : (totalTime < _tinyNum) ? 0 : totalTime,
			time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline, yoyoEase;
		if (!dur) {
			_renderZeroDurationTween(this, totalTime, suppressEvents, force);
		} else if (tTime !== this._tTime || !totalTime || force || (!this._initted && this._tTime) || (this._startAt && (this._zTime < 0) !== (totalTime < 0))) { //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
			time = tTime;
			timeline = this.timeline;
			if (this._repeat) { //adjust the time for repeats and yoyos
				cycleDuration = dur + this._rDelay;
				if (this._repeat < -1 && totalTime < 0) {
					return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
				}
				time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)
				if (tTime === tDur) { // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
					iteration = this._repeat;
					time = dur;
				} else {
					iteration = ~~(tTime / cycleDuration);
					if (iteration && iteration === tTime / cycleDuration) {
						time = dur;
						iteration--;
					}
					time > dur && (time = dur);
				}
				isYoyo = this._yoyo && (iteration & 1);
				if (isYoyo) {
					yoyoEase = this._yEase;
					time = dur - time;
				}
				prevIteration = _animationCycle(this._tTime, cycleDuration);
				if (time === prevTime && !force && this._initted) {
					//could be during the repeatDelay part. No need to render and fire callbacks.
					return this;
				}
				if (iteration !== prevIteration) {
					timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo);
					//repeatRefresh functionality
					if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
						this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.
						this.render(_round(cycleDuration * iteration), true).invalidate()._lock = 0;
					}
				}
			}

			if (!this._initted) {
				if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {
					this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.
					return this;
				}
				if (dur !== this._dur) { // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
					return this.render(totalTime, suppressEvents, force);
				}
			}

			this._tTime = tTime;
			this._time = time;

			if (!this._act && this._ts) {
				this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.
				this._lazy = 0;
			}

			this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
			if (this._from) {
				this.ratio = ratio = 1 - ratio;
			}

			time && !prevTime && !suppressEvents && _callback(this, "onStart");
			if (time && !prevTime && !suppressEvents) {
				_callback(this, "onStart");
				if (this._tTime !== tTime) { // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
					return this;
				}
			}

			pt = this._pt;
			while (pt) {
				pt.r(ratio, pt.d);
				pt = pt._next;
			}

			(timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * ratio, suppressEvents, force)) || (this._startAt && (this._zTime = totalTime));

			if (this._onUpdate && !suppressEvents) {
				totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				_callback(this, "onUpdate");
			}

			this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");

			if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
				totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);
				(totalTime || !dur) && ((tTime === this._tDur && this._ts > 0) || (!tTime && this._ts < 0)) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.
			    if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) { // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
					_callback(this, (tTime === tDur ? "onComplete" : "onReverseComplete"), true);
					this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
				}
			}

		}
		return this;
	}

	targets() {
		return this._targets;
	}

	invalidate() {
		this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;
		this._ptLookup = [];
		this.timeline && this.timeline.invalidate();
		return super.invalidate();
	}

	kill(targets, vars = "all") {
		if (!targets && (!vars || vars === "all")) {
			this._lazy = this._pt = 0;
			return this.parent ? _interrupt(this) : this;
		}
		if (this.timeline) {
			let tDur = this.timeline.totalDuration();
			this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.
			this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.
			return this;
		}
		let parsedTargets = this._targets,
			killingTargets = targets ? toArray(targets) : parsedTargets,
			propTweenLookup = this._ptLookup,
			firstPT = this._pt,
			overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i;
		if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
			vars === "all" && (this._pt = 0);
			return _interrupt(this);
		}
		overwrittenProps = this._op = this._op || [];
		if (vars !== "all") { //so people can pass in a comma-delimited list of property names
			if (_isString(vars)) {
				p = {};
				_forEachName(vars, name => p[name] = 1);
				vars = p;
			}
			vars = _addAliasesToVars(parsedTargets, vars);
		}
		i = parsedTargets.length;
		while (i--) {
			if (~killingTargets.indexOf(parsedTargets[i])) {
				curLookup = propTweenLookup[i];
				if (vars === "all") {
					overwrittenProps[i] = vars;
					props = curLookup;
					curOverwriteProps = {};
				} else {
					curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
					props = vars;
				}
				for (p in props) {
					pt = curLookup && curLookup[p];
					if (pt) {
						if (!("kill" in pt.d) || pt.d.kill(p) === true) {
							_removeLinkedListItem(this, pt, "_pt");
						}
						delete curLookup[p];
					}
					if (curOverwriteProps !== "all") {
						curOverwriteProps[p] = 1;
					}
				}
			}
		}
		this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
		return this;
	}


	static to(targets, vars) {
		return new Tween(targets, vars, arguments[2]);
	}

	static from(targets, vars) {
		return _createTweenType(1, arguments);
	}

	static delayedCall(delay, callback, params, scope) {
		return new Tween(callback, 0, {immediateRender:false, lazy:false, overwrite:false, delay:delay, onComplete:callback, onReverseComplete:callback, onCompleteParams:params, onReverseCompleteParams:params, callbackScope:scope});
	}

	static fromTo(targets, fromVars, toVars) {
		return _createTweenType(2, arguments);
	}

	static set(targets, vars) {
		vars.duration = 0;
		vars.repeatDelay || (vars.repeat = 0);
		return new Tween(targets, vars);
	}

	static killTweensOf(targets, props, onlyActive) {
		return _globalTimeline.killTweensOf(targets, props, onlyActive);
	}
}

_setDefaults(Tween.prototype, {_targets:[], _lazy:0, _startAt:0, _op:0, _onInit:0});

//add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
// 	Tween.prototype[name] = function() {
// 		let tl = new Timeline();
// 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
// 	}
// });

//for backward compatibility. Leverage the timeline calls.
_forEachName("staggerTo,staggerFrom,staggerFromTo", name => {
	Tween[name] = function() {
		let tl = new Timeline(),
			params = _slice.call(arguments, 0);
		params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
		return tl[name].apply(tl, params);
	}
});
















/*
 * --------------------------------------------------------------------------------------
 * PROPTWEEN
 * --------------------------------------------------------------------------------------
 */
let _setterPlain = (target, property, value) => target[property] = value,
	_setterFunc = (target, property, value) => target[property](value),
	_setterFuncWithParam = (target, property, value, data) => target[property](data.fp, value),
	_setterAttribute = (target, property, value) => target.setAttribute(property, value),
	_getSetter = (target, property) => _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain,
	_renderPlain = (ratio, data) => data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data),
	_renderBoolean = (ratio, data) => data.set(data.t, data.p, !!(data.s + data.c * ratio), data),
	_renderComplexString = function(ratio, data) {
		let pt = data._pt,
			s = "";
		if (!ratio && data.b) { //b = beginning string
			s = data.b;
		} else if (ratio === 1 && data.e) { //e = ending string
			s = data.e;
		} else {
			while (pt) {
				s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : (Math.round((pt.s + pt.c * ratio) * 10000) / 10000)) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.
				pt = pt._next;
			}
			s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
		}
		data.set(data.t, data.p, s, data);
	},
	_renderPropTweens = function(ratio, data) {
		let pt = data._pt;
		while (pt) {
			pt.r(ratio, pt.d);
			pt = pt._next;
		}
	},
	_addPluginModifier = function(modifier, tween, target, property) {
		let pt = this._pt,
			next;
		while (pt) {
			next = pt._next;
			pt.p === property && pt.modifier(modifier, tween, target);
			pt = next;
		}
	},
	_killPropTweensOf = function(property) {
		let pt = this._pt,
			hasNonDependentRemaining, next;
		while (pt) {
			next = pt._next;
			if ((pt.p === property && !pt.op) || pt.op === property) {
				_removeLinkedListItem(this, pt, "_pt");
			} else if (!pt.dep) {
				hasNonDependentRemaining = 1;
			}
			pt = next;
		}
		return !hasNonDependentRemaining;
	},
	_setterWithModifier = (target, property, value, data) => {
		data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
	},
	_sortPropTweensByPriority = parent => {
		let pt = parent._pt,
			next, pt2, first, last;
		//sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)
		while (pt) {
			next = pt._next;
			pt2 = first;
			while (pt2 && pt2.pr > pt.pr) {
				pt2 = pt2._next;
			}
			if ((pt._prev = pt2 ? pt2._prev : last)) {
				pt._prev._next = pt;
			} else {
				first = pt;
			}
			if ((pt._next = pt2)) {
				pt2._prev = pt;
			} else {
				last = pt;
			}
			pt = next;
		}
		parent._pt = first;
	};

//PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)
class PropTween {

	constructor(next, target, prop, start, change, renderer, data, setter, priority) {
		this.t = target;
		this.s = start;
		this.c = change;
		this.p = prop;
		this.r = renderer || _renderPlain;
		this.d = data || this;
		this.set = setter || _setterPlain;
		this.pr = priority || 0;
		this._next = next;
		if (next) {
			next._prev = this;
		}
	}

	modifier(func, tween, target) {
		this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)
		this.set = _setterWithModifier;
		this.m = func;
		this.mt = target; //modifier target
		this.tween = tween;
	}
}



//Initialization tasks
_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", name => _reservedProps[name] = 1);
_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({sortChildren: false, defaults: _defaults, autoRemoveChildren: true, id:"root", smoothChildTiming: true});
_config.stringFilter = _colorStringFilter;

















/*
 * --------------------------------------------------------------------------------------
 * GSAP
 * --------------------------------------------------------------------------------------
 */
const _gsap = {
	registerPlugin(...args) {
		args.forEach(config => _createPlugin(config));
	},
	timeline(vars) {
		return new Timeline(vars);
	},
	getTweensOf(targets, onlyActive) {
		return _globalTimeline.getTweensOf(targets, onlyActive);
	},
	getProperty(target, property, unit, uncache) {
		_isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in
		let getter = _getCache(target || {}).get,
			format = unit ? _passThrough : _numericIfPossible;
		unit === "native" && (unit = "");
		return !target ? target : !property ? (property, unit, uncache) => format(((_plugins[property] && _plugins[property].get) || getter)(target, property, unit, uncache)) : format(((_plugins[property] && _plugins[property].get) || getter)(target, property, unit, uncache));
	},
	quickSetter(target, property, unit) {
		target = toArray(target);
		if (target.length > 1) {
			let setters = target.map(t => gsap.quickSetter(t, property, unit)),
				l = setters.length;
			return value => {
				let i = l;
				while(i--) {
					setters[i](value);
				}
			}
		}
		target = target[0] || {};
		let Plugin = _plugins[property],
			cache = _getCache(target),
			p = (cache.harness && (cache.harness.aliases || {})[property]) || property, // in case it's an alias, like "rotate" for "rotation".
			setter = Plugin ? value => {
				let p = new Plugin();
				_quickTween._pt = 0;
				p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
				p.render(1, p);
				_quickTween._pt && _renderPropTweens(1, _quickTween);
			} : cache.set(target, p);
		return Plugin ? setter : value => setter(target, p, unit ? value + unit : value, cache, 1);
	},
	isTweening(targets) {
		return _globalTimeline.getTweensOf(targets, true).length > 0;
	},
	defaults(value) {
		value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
		return _mergeDeep(_defaults, value || {});
	},
	config(value) {
		return _mergeDeep(_config, value || {});
	},
	registerEffect({name, effect, plugins, defaults, extendTimeline}) {
		(plugins || "").split(",").forEach(pluginName => pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin."));
		_effects[name] = (targets, vars, tl) => effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
		if (extendTimeline) {
			Timeline.prototype[name] = function(targets, vars, position) {
				return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
			};
		}
	},
	registerEase(name, ease) {
		_easeMap[name] = _parseEase(ease);
	},
	parseEase(ease, defaultEase) {
		return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
	},
	getById(id) {
		return _globalTimeline.getById(id);
	},
	exportRoot(vars = {}, includeDelayedCalls) {
		let tl = new Timeline(vars),
			child, next;
		tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
		_globalTimeline.remove(tl);
		tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).
		tl._time = tl._tTime = _globalTimeline._time;
		child = _globalTimeline._first;
		while (child) {
			next = child._next;
			if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
				_addToTimeline(tl, child, child._start - child._delay);
			}
			child = next;
		}
		_addToTimeline(_globalTimeline, tl, 0);
		return tl;
	},
	utils: { wrap, wrapYoyo, distribute, random, snap, normalize, getUnit, clamp, splitColor, toArray, selector, mapRange, pipe, unitize, interpolate, shuffle },
	install: _install,
	effects: _effects,
	ticker: _ticker,
	updateRoot: Timeline.updateRoot,
	plugins: _plugins,
	globalTimeline: _globalTimeline,
	core: {PropTween, globals: _addGlobal, Tween, Timeline, Animation, getCache: _getCache, _removeLinkedListItem, suppressOverwrites: value => _suppressOverwrites = value}
};

_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", name => _gsap[name] = Tween[name]);
_ticker.add(Timeline.updateRoot);
_quickTween = _gsap.to({}, {duration:0});




// ---- EXTRA PLUGINS --------------------------------------------------------


let _getPluginPropTween = (plugin, prop) => {
		let pt = plugin._pt;
		while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
			pt = pt._next;
		}
		return pt;
	},
	_addModifiers = (tween, modifiers) => {
			let	targets = tween._targets,
				p, i, pt;
			for (p in modifiers) {
				i = targets.length;
				while (i--) {
					pt = tween._ptLookup[i][p];
					if (pt && (pt = pt.d)) {
						if (pt._pt) { // is a plugin
							pt = _getPluginPropTween(pt, p);
						}
						pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
					}
				}
			}
	},
	_buildModifierPlugin = (name, modifier) => {
		return {
			name: name,
			rawVars: 1, //don't pre-process function-based values or "random()" strings.
			init(target, vars, tween) {
				tween._onInit = tween => {
					let temp, p;
					if (_isString(vars)) {
						temp = {};
						_forEachName(vars, name => temp[name] = 1); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.
						vars = temp;
					}
					if (modifier) {
						temp = {};
						for (p in vars) {
							temp[p] = modifier(vars[p]);
						}
						vars = temp;
					}
					_addModifiers(tween, vars);
				};
			}
		};
	};

//register core plugins
const gsap = _gsap.registerPlugin({
		name:"attr",
		init(target, vars, tween, index, targets) {
			let p, pt;
			for (p in vars) {
				pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p);
				pt && (pt.op = p);
				this._props.push(p);
			}
		}
	}, {
		name:"endArray",
		init(target, value) {
			let i = value.length;
			while (i--) {
				this.add(target, i, target[i] || 0, value[i]);
			}
		}
	},
	_buildModifierPlugin("roundProps", _roundModifier),
	_buildModifierPlugin("modifiers"),
	_buildModifierPlugin("snap", snap)
) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.

Tween.version = Timeline.version = gsap.version = "3.7.0";
_coreReady = 1;
_windowExists() && _wake();

const { Power0, Power1, Power2, Power3, Power4, Linear, Quad, Cubic, Quart, Quint, Strong, Elastic, Back, SteppedEase, Bounce, Sine, Expo, Circ } = _easeMap;

//export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.


/***/ }),

/***/ "./node_modules/gsap/src/utils/matrix.js":
/*!***********************************************!*\
  !*** ./node_modules/gsap/src/utils/matrix.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Matrix2D": function() { return /* binding */ Matrix2D; },
/* harmony export */   "getGlobalMatrix": function() { return /* binding */ getGlobalMatrix; },
/* harmony export */   "_getDocScrollTop": function() { return /* binding */ _getDocScrollTop; },
/* harmony export */   "_getDocScrollLeft": function() { return /* binding */ _getDocScrollLeft; },
/* harmony export */   "_setDoc": function() { return /* binding */ _setDoc; }
/* harmony export */ });
/*!
 * matrix 3.7.0
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */

let _doc, _win, _docElement, _body,	_divContainer, _svgContainer, _identityMatrix,
	_transformProp = "transform",
	_transformOriginProp = _transformProp + "Origin",
	_hasOffsetBug,
	_setDoc = element => {
		let doc = element.ownerDocument || element;
		if (!(_transformProp in element.style) && "msTransform" in element.style) { //to improve compatibility with old Microsoft browsers
			_transformProp = "msTransform";
			_transformOriginProp = _transformProp + "Origin";
		}
		while (doc.parentNode && (doc = doc.parentNode)) {	}
		_win = window;
		_identityMatrix = new Matrix2D();
		if (doc) {
			_doc = doc;
			_docElement = doc.documentElement;
			_body = doc.body;
			// now test for the offset reporting bug. Use feature detection instead of browser sniffing to make things more bulletproof and future-proof. Hopefully Safari will fix their bug soon but it's 2020 and it's still not fixed.
			let d1 = doc.createElement("div"),
				d2 = doc.createElement("div");
			_body.appendChild(d1);
			d1.appendChild(d2);
			d1.style.position = "static";
			d1.style[_transformProp] = "translate3d(0,0,1px)";
			_hasOffsetBug = (d2.offsetParent !== d1);
			_body.removeChild(d1);
		}
		return doc;
	},
	_forceNonZeroScale = e => { // walks up the element's ancestors and finds any that had their scale set to 0 via GSAP, and changes them to 0.0001 to ensure that measurements work. Firefox has a bug that causes it to incorrectly report getBoundingClientRect() when scale is 0.
		let a, cache;
		while (e && e !== _body) {
			cache = e._gsap;
			cache && cache.uncache && cache.get(e, "x"); // force re-parsing of transforms if necessary
			if (cache && !cache.scaleX && !cache.scaleY && cache.renderTransform) {
				cache.scaleX = cache.scaleY = 1e-4;
				cache.renderTransform(1, cache);
				a ? a.push(cache) : (a = [cache]);
			}
			e = e.parentNode;
		}
		return a;
	},
	// possible future addition: pass an element to _forceDisplay() and it'll walk up all its ancestors and make sure anything with display: none is set to display: block, and if there's no parentNode, it'll add it to the body. It returns an Array that you can then feed to _revertDisplay() to have it revert all the changes it made.
	// _forceDisplay = e => {
	// 	let a = [],
	// 		parent;
	// 	while (e && e !== _body) {
	// 		parent = e.parentNode;
	// 		(_win.getComputedStyle(e).display === "none" || !parent) && a.push(e, e.style.display, parent) && (e.style.display = "block");
	// 		parent || _body.appendChild(e);
	// 		e = parent;
	// 	}
	// 	return a;
	// },
	// _revertDisplay = a => {
	// 	for (let i = 0; i < a.length; i+=3) {
	// 		a[i+1] ? (a[i].style.display = a[i+1]) : a[i].style.removeProperty("display");
	// 		a[i+2] || a[i].parentNode.removeChild(a[i]);
	// 	}
	// },
	_svgTemps = [], //we create 3 elements for SVG, and 3 for other DOM elements and cache them for performance reasons. They get nested in _divContainer and _svgContainer so that just one element is added to the DOM on each successive attempt. Again, performance is key.
	_divTemps = [],
	_getDocScrollTop = () => _win.pageYOffset  || _doc.scrollTop || _docElement.scrollTop || _body.scrollTop || 0,
	_getDocScrollLeft = () => _win.pageXOffset || _doc.scrollLeft || _docElement.scrollLeft || _body.scrollLeft || 0,
	_svgOwner = element => element.ownerSVGElement || ((element.tagName + "").toLowerCase() === "svg" ? element : null),
	_isFixed = element => {
		if (_win.getComputedStyle(element).position === "fixed") {
			return true;
		}
		element = element.parentNode;
		if (element && element.nodeType === 1) { // avoid document fragments which will throw an error.
			return _isFixed(element);
		}
	},
	_createSibling = (element, i) => {
		if (element.parentNode && (_doc || _setDoc(element))) {
			let svg = _svgOwner(element),
				ns = svg ? (svg.getAttribute("xmlns") || "http://www.w3.org/2000/svg") : "http://www.w3.org/1999/xhtml",
				type = svg ? (i ? "rect" : "g") : "div",
				x = i !== 2 ? 0 : 100,
				y = i === 3 ? 100 : 0,
				css = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;",
				e = _doc.createElementNS ? _doc.createElementNS(ns.replace(/^https/, "http"), type) : _doc.createElement(type);
			if (i) {
				if (!svg) {
					if (!_divContainer) {
						_divContainer = _createSibling(element);
						_divContainer.style.cssText = css;
					}
					e.style.cssText = css + "width:0.1px;height:0.1px;top:" + y + "px;left:" + x + "px";
					_divContainer.appendChild(e);

				} else {
					_svgContainer || (_svgContainer = _createSibling(element));
					e.setAttribute("width", 0.01);
					e.setAttribute("height", 0.01);
					e.setAttribute("transform", "translate(" + x + "," + y + ")");
					_svgContainer.appendChild(e);
				}
			}
			return e;
		}
		throw "Need document and parent.";
	},
	_consolidate = m => { // replaces SVGTransformList.consolidate() because a bug in Firefox causes it to break pointer events. See https://greensock.com/forums/topic/23248-touch-is-not-working-on-draggable-in-firefox-windows-v324/?tab=comments#comment-109800
		let c = new Matrix2D(),
			i = 0;
		for (; i < m.numberOfItems; i++) {
			c.multiply(m.getItem(i).matrix);
		}
		return c;
	},
	_placeSiblings = (element, adjustGOffset) => {
		let svg = _svgOwner(element),
			isRootSVG = element === svg,
			siblings = svg ? _svgTemps : _divTemps,
			parent = element.parentNode,
			container, m, b, x, y, cs;
		if (element === _win) {
			return element;
		}
		siblings.length || siblings.push(_createSibling(element, 1), _createSibling(element, 2), _createSibling(element, 3));
		container = svg ? _svgContainer : _divContainer;
		if (svg) {
			b = isRootSVG ? {x:0, y:0} : element.getBBox();
			m = element.transform ? element.transform.baseVal : {}; // IE11 doesn't follow the spec.
			if (m.numberOfItems) {
				m = m.numberOfItems > 1 ? _consolidate(m) : m.getItem(0).matrix; // don't call m.consolidate().matrix because a bug in Firefox makes pointer events not work when consolidate() is called on the same tick as getBoundingClientRect()! See https://greensock.com/forums/topic/23248-touch-is-not-working-on-draggable-in-firefox-windows-v324/?tab=comments#comment-109800
				x = m.a * b.x + m.c * b.y;
				y = m.b * b.x + m.d * b.y;
			} else {
				m = _identityMatrix;
				x = b.x;
				y = b.y;
			}
			if (adjustGOffset && element.tagName.toLowerCase() === "g") {
				x = y = 0;
			}
			(isRootSVG ? svg : parent).appendChild(container);
			container.setAttribute("transform", "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + (m.e + x) + "," + (m.f + y) + ")");
		} else {
			x = y = 0;
			if (_hasOffsetBug) { // some browsers (like Safari) have a bug that causes them to misreport offset values. When an ancestor element has a transform applied, it's supposed to treat it as if it's position: relative (new context). Safari botches this, so we need to find the closest ancestor (between the element and its offsetParent) that has a transform applied and if one is found, grab its offsetTop/Left and subtract them to compensate.
				m = element.offsetParent;
				b = element;
				while (b && (b = b.parentNode) && b !== m && b.parentNode) {
					if ((_win.getComputedStyle(b)[_transformProp] + "").length > 4) {
						x = b.offsetLeft;
						y = b.offsetTop;
						b = 0;
					}
				}
			}
			cs = _win.getComputedStyle(element);
			if (cs.position !== "absolute") {
				m = element.offsetParent;
				while (parent && parent !== m) { // if there's an ancestor element between the element and its offsetParent that's scrolled, we must factor that in.
					x += parent.scrollLeft || 0;
					y += parent.scrollTop || 0;
					parent = parent.parentNode;
				}
			}
			b = container.style;
			b.top = (element.offsetTop - y) + "px";
			b.left = (element.offsetLeft - x) + "px";
			b[_transformProp] = cs[_transformProp];
			b[_transformOriginProp] = cs[_transformOriginProp];
			// b.border = m.border;
			// b.borderLeftStyle = m.borderLeftStyle;
			// b.borderTopStyle = m.borderTopStyle;
			// b.borderLeftWidth = m.borderLeftWidth;
			// b.borderTopWidth = m.borderTopWidth;
			b.position = cs.position === "fixed" ? "fixed" : "absolute";
			element.parentNode.appendChild(container);
		}
		return container;
	},
	_setMatrix = (m, a, b, c, d, e, f) => {
		m.a = a;
		m.b = b;
		m.c = c;
		m.d = d;
		m.e = e;
		m.f = f;
		return m;
	};

class Matrix2D {
	constructor(a=1, b=0, c=0, d=1, e=0, f=0) {
		_setMatrix(this, a, b, c, d, e, f);
	}

	inverse() {
		let {a, b, c, d, e, f} = this,
			determinant = (a * d - b * c) || 1e-10;
		return _setMatrix(
			this,
			d / determinant,
			-b / determinant,
			-c / determinant,
			a / determinant,
			(c * f - d * e) / determinant,
			-(a * f - b * e) / determinant
		);
	}

	multiply(matrix) {
		let {a, b, c, d, e, f} = this,
			a2 = matrix.a,
			b2 = matrix.c,
			c2 = matrix.b,
			d2 = matrix.d,
			e2 = matrix.e,
			f2 = matrix.f;
		return _setMatrix(this,
			a2 * a + c2 * c,
			a2 * b + c2 * d,
			b2 * a + d2 * c,
			b2 * b + d2 * d,
			e + e2 * a + f2 * c,
			f + e2 * b + f2 * d);
	}

	clone() {
		return new Matrix2D(this.a, this.b, this.c, this.d, this.e, this.f);
	}

	equals(matrix) {
		let {a, b, c, d, e, f} = this;
		return (a === matrix.a && b === matrix.b && c === matrix.c && d === matrix.d && e === matrix.e && f === matrix.f);
	}

	apply(point, decoratee={}) {
		let {x, y} = point,
			{a, b, c, d, e, f} = this;
		decoratee.x = (x * a + y * c + e) || 0;
		decoratee.y = (x * b + y * d + f) || 0;
		return decoratee;
	}

}

// Feed in an element and it'll return a 2D matrix (optionally inverted) so that you can translate between coordinate spaces.
// Inverting lets you translate a global point into a local coordinate space. No inverting lets you go the other way.
// We needed this to work around various browser bugs, like Firefox doesn't accurately report getScreenCTM() when there
// are transforms applied to ancestor elements.
// The matrix math to convert any x/y coordinate is as follows, which is wrapped in a convenient apply() method of Matrix2D above:
//     tx = m.a * x + m.c * y + m.e
//     ty = m.b * x + m.d * y + m.f
function getGlobalMatrix(element, inverse, adjustGOffset, includeScrollInFixed) { // adjustGOffset is typically used only when grabbing an element's PARENT's global matrix, and it ignores the x/y offset of any SVG <g> elements because they behave in a special way.
	if (!element || !element.parentNode || (_doc || _setDoc(element)).documentElement === element) {
		return new Matrix2D();
	}
	let zeroScales = _forceNonZeroScale(element),
		svg = _svgOwner(element),
		temps = svg ? _svgTemps : _divTemps,
		container = _placeSiblings(element, adjustGOffset),
		b1 = temps[0].getBoundingClientRect(),
		b2 = temps[1].getBoundingClientRect(),
		b3 = temps[2].getBoundingClientRect(),
		parent = container.parentNode,
		isFixed = !includeScrollInFixed && _isFixed(element),
		m = new Matrix2D(
			(b2.left - b1.left) / 100,
			(b2.top - b1.top) / 100,
			(b3.left - b1.left) / 100,
			(b3.top - b1.top) / 100,
			b1.left + (isFixed ? 0 : _getDocScrollLeft()),
			b1.top + (isFixed ? 0 : _getDocScrollTop())
		);
	parent.removeChild(container);
	if (zeroScales) {
		b1 = zeroScales.length;
		while (b1--) {
			b2 = zeroScales[b1];
			b2.scaleX = b2.scaleY = 0;
			b2.renderTransform(1, b2);
		}
	}
	return inverse ? m.inverse() : m;
}



// export function getMatrix(element) {
// 	_doc || _setDoc(element);
// 	let m = (_win.getComputedStyle(element)[_transformProp] + "").substr(7).match(/[-.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g),
// 		is2D = m && m.length === 6;
// 	return !m || m.length < 6 ? new Matrix2D() : new Matrix2D(+m[0], +m[1], +m[is2D ? 2 : 4], +m[is2D ? 3 : 5], +m[is2D ? 4 : 12], +m[is2D ? 5 : 13]);
// }

/***/ }),

/***/ "./node_modules/gsap/src/utils/paths.js":
/*!**********************************************!*\
  !*** ./node_modules/gsap/src/utils/paths.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getRawPath": function() { return /* binding */ getRawPath; },
/* harmony export */   "copyRawPath": function() { return /* binding */ copyRawPath; },
/* harmony export */   "reverseSegment": function() { return /* binding */ reverseSegment; },
/* harmony export */   "convertToPath": function() { return /* binding */ convertToPath; },
/* harmony export */   "getRotationAtProgress": function() { return /* binding */ getRotationAtProgress; },
/* harmony export */   "sliceRawPath": function() { return /* binding */ sliceRawPath; },
/* harmony export */   "cacheRawPathMeasurements": function() { return /* binding */ cacheRawPathMeasurements; },
/* harmony export */   "subdivideSegment": function() { return /* binding */ subdivideSegment; },
/* harmony export */   "getPositionOnPath": function() { return /* binding */ getPositionOnPath; },
/* harmony export */   "transformRawPath": function() { return /* binding */ transformRawPath; },
/* harmony export */   "stringToRawPath": function() { return /* binding */ stringToRawPath; },
/* harmony export */   "bezierToPoints": function() { return /* binding */ bezierToPoints; },
/* harmony export */   "flatPointsToSegment": function() { return /* binding */ flatPointsToSegment; },
/* harmony export */   "pointsToSegment": function() { return /* binding */ pointsToSegment; },
/* harmony export */   "simplifyPoints": function() { return /* binding */ simplifyPoints; },
/* harmony export */   "getClosestData": function() { return /* binding */ getClosestData; },
/* harmony export */   "subdivideSegmentNear": function() { return /* binding */ subdivideSegmentNear; },
/* harmony export */   "rawPathToString": function() { return /* binding */ rawPathToString; }
/* harmony export */ });
/*!
 * paths 3.7.0
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */

let _svgPathExp = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
	_numbersExp = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
	_scientific = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig,
	_selectorExp = /(^[#\.][a-z]|[a-y][a-z])/i,
	_DEG2RAD = Math.PI / 180,
	_RAD2DEG = 180 / Math.PI,
	_sin = Math.sin,
	_cos = Math.cos,
	_abs = Math.abs,
	_sqrt = Math.sqrt,
	_atan2 = Math.atan2,
	_largeNum = 1e8,
	_isString = value => typeof(value) === "string",
	_isNumber = value => typeof(value) === "number",
	_isUndefined = value => typeof(value) === "undefined",
	_temp = {},
	_temp2 = {},
	_roundingNum = 1e5,
	_wrapProgress = progress => (Math.round((progress + _largeNum) % 1 * _roundingNum) / _roundingNum) || ((progress < 0) ? 0 : 1), //if progress lands on 1, the % will make it 0 which is why we || 1, but not if it's negative because it makes more sense for motion to end at 0 in that case.
	_round = value => (Math.round(value * _roundingNum) / _roundingNum) || 0,
	_roundPrecise = value => (Math.round(value * 1e10) / 1e10) || 0,
	_splitSegment = (rawPath, segIndex, i, t) => {
		let segment = rawPath[segIndex],
			shift = t === 1 ? 6 : subdivideSegment(segment, i, t);
		if (shift && shift + i + 2 < segment.length) {
			rawPath.splice(segIndex, 0, segment.slice(0, i + shift + 2));
			segment.splice(0, i + shift);
			return 1;
		}
	},
	_reverseRawPath = (rawPath, skipOuter) => {
		let i = rawPath.length;
		skipOuter || rawPath.reverse();
		while (i--) {
			rawPath[i].reversed || reverseSegment(rawPath[i]);
		}
	},
	_copyMetaData = (source, copy) => {
		copy.totalLength = source.totalLength;
		if (source.samples) { //segment
			copy.samples = source.samples.slice(0);
			copy.lookup = source.lookup.slice(0);
			copy.minLength = source.minLength;
			copy.resolution = source.resolution;
		} else if (source.totalPoints) { //rawPath
			copy.totalPoints = source.totalPoints;
		}
		return copy;
	},
	//pushes a new segment into a rawPath, but if its starting values match the ending values of the last segment, it'll merge it into that same segment (to reduce the number of segments)
	_appendOrMerge = (rawPath, segment) => {
		let index = rawPath.length,
			prevSeg = rawPath[index - 1] || [],
			l = prevSeg.length;
		if (index && segment[0] === prevSeg[l-2] && segment[1] === prevSeg[l-1]) {
			segment = prevSeg.concat(segment.slice(2));
			index--;
		}
		rawPath[index] = segment;
	},
	_bestDistance;

/* TERMINOLOGY
 - RawPath - an array of arrays, one for each Segment. A single RawPath could have multiple "M" commands, defining Segments (paths aren't always connected).
 - Segment - an array containing a sequence of Cubic Bezier coordinates in alternating x, y, x, y format. Starting anchor, then control point 1, control point 2, and ending anchor, then the next control point 1, control point 2, anchor, etc. Uses less memory than an array with a bunch of {x, y} points.
 - Bezier - a single cubic Bezier with a starting anchor, two control points, and an ending anchor.
 - the variable "t" is typically the position along an individual Bezier path (time) and it's NOT linear, meaning it could accelerate/decelerate based on the control points whereas the "p" or "progress" value is linearly mapped to the whole path, so it shouldn't really accelerate/decelerate based on control points. So a progress of 0.2 would be almost exactly 20% along the path. "t" is ONLY in an individual Bezier piece.
 */

//accepts basic selector text, a path instance, a RawPath instance, or a Segment and returns a RawPath (makes it easy to homogenize things). If an element or selector text is passed in, it'll also cache the value so that if it's queried again, it'll just take the path data from there instead of parsing it all over again (as long as the path data itself hasn't changed - it'll check).
function getRawPath(value) {
	value = (_isString(value) && _selectorExp.test(value)) ? document.querySelector(value) || value : value;
	let e = value.getAttribute ? value : 0,
		rawPath;
	if (e && (value = value.getAttribute("d"))) {
		//implements caching
		if (!e._gsPath) {
			e._gsPath = {};
		}
		rawPath = e._gsPath[value];
		return (rawPath && !rawPath._dirty) ? rawPath : (e._gsPath[value] = stringToRawPath(value));
	}
	return !value ? console.warn("Expecting a <path> element or an SVG path data string") : _isString(value) ? stringToRawPath(value) : (_isNumber(value[0])) ? [value] : value;
}

//copies a RawPath WITHOUT the length meta data (for speed)
function copyRawPath(rawPath) {
	let a = [],
		i = 0;
	for (; i < rawPath.length; i++) {
		a[i] = _copyMetaData(rawPath[i], rawPath[i].slice(0));
	}
	return _copyMetaData(rawPath, a);
}

function reverseSegment(segment) {
	let i = 0,
		y;
	segment.reverse(); //this will invert the order y, x, y, x so we must flip it back.
	for (; i < segment.length; i += 2) {
		y = segment[i];
		segment[i] = segment[i+1];
		segment[i+1] = y;
	}
	segment.reversed = !segment.reversed;
}



let _createPath = (e, ignore) => {
		let path = document.createElementNS("http://www.w3.org/2000/svg", "path"),
			attr = [].slice.call(e.attributes),
			i = attr.length,
			name;
		ignore = "," + ignore + ",";
		while (--i > -1) {
			name = attr[i].nodeName.toLowerCase(); //in Microsoft Edge, if you don't set the attribute with a lowercase name, it doesn't render correctly! Super weird.
			if (ignore.indexOf("," + name + ",") < 0) {
				path.setAttributeNS(null, name, attr[i].nodeValue);
			}
		}
		return path;
	},
	_typeAttrs = {
		rect:"rx,ry,x,y,width,height",
		circle:"r,cx,cy",
		ellipse:"rx,ry,cx,cy",
		line:"x1,x2,y1,y2"
	},
	_attrToObj = (e, attrs) => {
		let props = attrs ? attrs.split(",") : [],
			obj = {},
			i = props.length;
		while (--i > -1) {
			obj[props[i]] = +e.getAttribute(props[i]) || 0;
		}
		return obj;
	};

//converts an SVG shape like <circle>, <rect>, <polygon>, <polyline>, <ellipse>, etc. to a <path>, swapping it in and copying the attributes to match.
function convertToPath(element, swap) {
	let type = element.tagName.toLowerCase(),
		circ = 0.552284749831,
		data, x, y, r, ry, path, rcirc, rycirc, points, w, h, x2, x3, x4, x5, x6, y2, y3, y4, y5, y6, attr;
	if (type === "path" || !element.getBBox) {
		return element;
	}
	path = _createPath(element, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points");
	attr = _attrToObj(element, _typeAttrs[type]);
	if (type === "rect") {
		r = attr.rx;
		ry = attr.ry || r;
		x = attr.x;
		y = attr.y;
		w = attr.width - r * 2;
		h = attr.height - ry * 2;
		if (r || ry) { //if there are rounded corners, render cubic beziers
			x2 = x + r * (1 - circ);
			x3 = x + r;
			x4 = x3 + w;
			x5 = x4 + r * circ;
			x6 = x4 + r;
			y2 = y + ry * (1 - circ);
			y3 = y + ry;
			y4 = y3 + h;
			y5 = y4 + ry * circ;
			y6 = y4 + ry;
			data = "M" + x6 + "," + y3 + " V" + y4 + " C" + [x6, y5, x5, y6, x4, y6, x4 - (x4 - x3) / 3, y6, x3 + (x4 - x3) / 3, y6, x3, y6, x2, y6, x, y5, x, y4, x, y4 - (y4 - y3) / 3, x, y3 + (y4 - y3) / 3, x, y3, x, y2, x2, y, x3, y, x3 + (x4 - x3) / 3, y, x4 - (x4 - x3) / 3, y, x4, y, x5, y, x6, y2, x6, y3].join(",") + "z";
		} else {
			data = "M" + (x + w) + "," + y + " v" + h + " h" + (-w) + " v" + (-h) + " h" + w + "z";
		}

	} else if (type === "circle" || type === "ellipse") {
		if (type === "circle") {
			r = ry = attr.r;
			rycirc = r * circ;
		} else {
			r = attr.rx;
			ry = attr.ry;
			rycirc = ry * circ;
		}
		x = attr.cx;
		y = attr.cy;
		rcirc = r * circ;
		data = "M" + (x+r) + "," + y + " C" + [x+r, y + rycirc, x + rcirc, y + ry, x, y + ry, x - rcirc, y + ry, x - r, y + rycirc, x - r, y, x - r, y - rycirc, x - rcirc, y - ry, x, y - ry, x + rcirc, y - ry, x + r, y - rycirc, x + r, y].join(",") + "z";
	} else if (type === "line") {
		data = "M" + attr.x1 + "," + attr.y1 + " L" + attr.x2 + "," + attr.y2; //previously, we just converted to "Mx,y Lx,y" but Safari has bugs that cause that not to render properly when using a stroke-dasharray that's not fully visible! Using a cubic bezier fixes that issue.
	} else if (type === "polyline" || type === "polygon") {
		points = (element.getAttribute("points") + "").match(_numbersExp) || [];
		x = points.shift();
		y = points.shift();
		data = "M" + x + "," + y + " L" + points.join(",");
		if (type === "polygon") {
			data += "," + x + "," + y + "z";
		}
	}
	path.setAttribute("d", rawPathToString(path._gsRawPath = stringToRawPath(data)));
	if (swap && element.parentNode) {
		element.parentNode.insertBefore(path, element);
		element.parentNode.removeChild(element);
	}
	return path;
}



//returns the rotation (in degrees) at a particular progress on a rawPath (the slope of the tangent)
function getRotationAtProgress(rawPath, progress) {
	let d = getProgressData(rawPath, progress >= 1 ? 1 - 1e-9 : progress ? progress : 1e-9);
	return getRotationAtBezierT(d.segment, d.i, d.t);
}

function getRotationAtBezierT(segment, i, t) {
	let a = segment[i],
		b = segment[i+2],
		c = segment[i+4],
		x;
	a += (b - a) * t;
	b += (c - b) * t;
	a += (b - a) * t;
	x = b + ((c + (segment[i+6] - c) * t) - b) * t - a;
	a = segment[i+1];
	b = segment[i+3];
	c = segment[i+5];
	a += (b - a) * t;
	b += (c - b) * t;
	a += (b - a) * t;
	return _round(_atan2(b + ((c + (segment[i+7] - c) * t) - b) * t - a, x) * _RAD2DEG);
}

function sliceRawPath(rawPath, start, end) {
	end = _isUndefined(end) ? 1 : _roundPrecise(end) || 0; // we must round to avoid issues like 4.15 / 8 = 0.8300000000000001 instead of 0.83 or 2.8 / 5 = 0.5599999999999999 instead of 0.56 and if someone is doing a loop like start: 2.8 / 0.5, end: 2.8 / 0.5 + 1.
	start = _roundPrecise(start) || 0;
	let loops = Math.max(0, ~~(_abs(end - start) - 1e-8)),
		path = copyRawPath(rawPath);
	if (start > end) {
		start = 1 - start;
		end = 1 - end;
		_reverseRawPath(path);
		path.totalLength = 0;
	}
	if (start < 0 || end < 0) {
		let offset = Math.abs(~~Math.min(start, end)) + 1;
		start += offset;
		end += offset;
	}
	path.totalLength || cacheRawPathMeasurements(path);
	let wrap = (end > 1),
		s = getProgressData(path, start, _temp, true),
		e = getProgressData(path, end, _temp2),
		eSeg = e.segment,
		sSeg = s.segment,
		eSegIndex = e.segIndex,
		sSegIndex = s.segIndex,
		ei = e.i,
		si = s.i,
		sameSegment = (sSegIndex === eSegIndex),
		sameBezier = (ei === si && sameSegment),
		wrapsBehind, sShift, eShift, i, copy, totalSegments, l, j;
	if (wrap || loops) {
		wrapsBehind = eSegIndex < sSegIndex || (sameSegment && ei < si) || (sameBezier && e.t < s.t);
		if (_splitSegment(path, sSegIndex, si, s.t)) {
			sSegIndex++;
			if (!wrapsBehind) {
				eSegIndex++;
				if (sameBezier) {
					e.t = (e.t - s.t) / (1 - s.t);
					ei = 0;
				} else if (sameSegment) {
					ei -= si;
				}
			}
		}
		if (1 - (end - start) < 1e-5) {
			eSegIndex = sSegIndex - 1;
		} else if (!e.t && eSegIndex) {
			eSegIndex--;
		} else if (_splitSegment(path, eSegIndex, ei, e.t) && wrapsBehind) {
			sSegIndex++;
		}
		if (s.t === 1) {
			sSegIndex = (sSegIndex + 1) % path.length;
		}
		copy = [];
		totalSegments = path.length;
		l = 1 + totalSegments * loops;
		j = sSegIndex;
		l += ((totalSegments - sSegIndex) + eSegIndex) % totalSegments;
		for (i = 0; i < l; i++) {
			_appendOrMerge(copy, path[j++ % totalSegments]);
		}
		path = copy;
	} else {
		eShift = e.t === 1 ? 6 : subdivideSegment(eSeg, ei, e.t);
		if (start !== end) {
			sShift = subdivideSegment(sSeg, si, sameBezier ? s.t / e.t : s.t);
			sameSegment && (eShift += sShift);
			eSeg.splice(ei + eShift + 2);
			(sShift || si) && sSeg.splice(0, si + sShift);
			i = path.length;
			while (i--) {
				//chop off any extra segments
				(i < sSegIndex || i > eSegIndex) &&	path.splice(i, 1);
			}
		} else {
			eSeg.angle = getRotationAtBezierT(eSeg, ei + eShift, 0); //record the value before we chop because it'll be impossible to determine the angle after its length is 0!
			ei += eShift;
			s = eSeg[ei];
			e = eSeg[ei+1];
			eSeg.length = eSeg.totalLength = 0;
			eSeg.totalPoints = path.totalPoints = 8;
			eSeg.push(s, e, s, e, s, e, s, e);
		}
	}
	path.totalLength = 0;
	return path;
}

//measures a Segment according to its resolution (so if segment.resolution is 6, for example, it'll take 6 samples equally across each Bezier) and create/populate a "samples" Array that has the length up to each of those sample points (always increasing from the start) as well as a "lookup" array that's broken up according to the smallest distance between 2 samples. This gives us a very fast way of looking up a progress position rather than looping through all the points/Beziers. You can optionally have it only measure a subset, starting at startIndex and going for a specific number of beziers (remember, there are 3 x/y pairs each, for a total of 6 elements for each Bezier). It will also populate a "totalLength" property, but that's not generally super accurate because by default it'll only take 6 samples per Bezier. But for performance reasons, it's perfectly adequate for measuring progress values along the path. If you need a more accurate totalLength, either increase the resolution or use the more advanced bezierToPoints() method which keeps adding points until they don't deviate by more than a certain precision value.
function measureSegment(segment, startIndex, bezierQty) {
	startIndex = startIndex || 0;
	if (!segment.samples) {
		segment.samples = [];
		segment.lookup = [];
	}
	let resolution = ~~segment.resolution || 12,
		inc = 1 / resolution,
		endIndex = bezierQty ? startIndex + bezierQty * 6 + 1 : segment.length,
		x1 = segment[startIndex],
		y1 = segment[startIndex + 1],
		samplesIndex = startIndex ? (startIndex / 6) * resolution : 0,
		samples = segment.samples,
		lookup = segment.lookup,
		min = (startIndex ? segment.minLength : _largeNum) || _largeNum,
		prevLength = samples[samplesIndex + bezierQty * resolution - 1],
		length = startIndex ? samples[samplesIndex-1] : 0,
		i, j, x4, x3, x2, xd, xd1, y4, y3, y2, yd, yd1, inv, t, lengthIndex, l, segLength;
	samples.length = lookup.length = 0;
	for (j = startIndex + 2; j < endIndex; j += 6) {
		x4 = segment[j + 4] - x1;
		x3 = segment[j + 2] - x1;
		x2 = segment[j] - x1;
		y4 = segment[j + 5] - y1;
		y3 = segment[j + 3] - y1;
		y2 = segment[j + 1] - y1;
		xd = xd1 = yd = yd1 = 0;
		if (_abs(x4) < 1e-5 && _abs(y4) < 1e-5 && _abs(x2) + _abs(y2) < 1e-5) { //dump points that are sufficiently close (basically right on top of each other, making a bezier super tiny or 0 length)
			if (segment.length > 8) {
				segment.splice(j, 6);
				j -= 6;
				endIndex -= 6;
			}
		} else {
			for (i = 1; i <= resolution; i++) {
				t = inc * i;
				inv = 1 - t;
				xd = xd1 - (xd1 = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t);
				yd = yd1 - (yd1 = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t);
				l = _sqrt(yd * yd + xd * xd);
				if (l < min) {
					min = l;
				}
				length += l;
				samples[samplesIndex++] = length;
			}
		}
		x1 += x4;
		y1 += y4;
	}
	if (prevLength) {
		prevLength -= length;
		for (; samplesIndex < samples.length; samplesIndex++) {
			samples[samplesIndex] += prevLength;
		}
	}
	if (samples.length && min) {
		segment.totalLength = segLength = samples[samples.length-1] || 0;
		segment.minLength = min;
		l = lengthIndex = 0;
		for (i = 0; i < segLength; i += min) {
			lookup[l++] = (samples[lengthIndex] < i) ? ++lengthIndex : lengthIndex;
		}
	} else {
		segment.totalLength = samples[0] = 0;
	}
	return startIndex ? length - samples[startIndex / 2 - 1] : length;
}

function cacheRawPathMeasurements(rawPath, resolution) {
	let pathLength, points, i;
	for (i = pathLength = points = 0; i < rawPath.length; i++) {
		rawPath[i].resolution = ~~resolution || 12; //steps per Bezier curve (anchor, 2 control points, to anchor)
		points += rawPath[i].length;
		pathLength += measureSegment(rawPath[i]);
	}
	rawPath.totalPoints = points;
	rawPath.totalLength = pathLength;
	return rawPath;
}

//divide segment[i] at position t (value between 0 and 1, progress along that particular cubic bezier segment that starts at segment[i]). Returns how many elements were spliced into the segment array (either 0 or 6)
function subdivideSegment(segment, i, t) {
	if (t <= 0 || t >= 1) {
		return 0;
	}
	let ax = segment[i],
		ay = segment[i+1],
		cp1x = segment[i+2],
		cp1y = segment[i+3],
		cp2x = segment[i+4],
		cp2y = segment[i+5],
		bx = segment[i+6],
		by = segment[i+7],
		x1a = ax + (cp1x - ax) * t,
		x2 = cp1x + (cp2x - cp1x) * t,
		y1a = ay + (cp1y - ay) * t,
		y2 = cp1y + (cp2y - cp1y) * t,
		x1 = x1a + (x2 - x1a) * t,
		y1 = y1a + (y2 - y1a) * t,
		x2a = cp2x + (bx - cp2x) * t,
		y2a = cp2y + (by - cp2y) * t;
	x2 += (x2a - x2) * t;
	y2 += (y2a - y2) * t;
	segment.splice(i + 2, 4,
		_round(x1a),                  //first control point
		_round(y1a),
		_round(x1),                   //second control point
		_round(y1),
		_round(x1 + (x2 - x1) * t),   //new fabricated anchor on line
		_round(y1 + (y2 - y1) * t),
		_round(x2),                   //third control point
		_round(y2),
		_round(x2a),                  //fourth control point
		_round(y2a)
	);
	segment.samples && segment.samples.splice(((i / 6) * segment.resolution) | 0, 0, 0, 0, 0, 0, 0, 0);
	return 6;
}

// returns an object {path, segment, segIndex, i, t}
function getProgressData(rawPath, progress, decoratee, pushToNextIfAtEnd) {
	decoratee = decoratee || {};
	rawPath.totalLength || cacheRawPathMeasurements(rawPath);
	if (progress < 0 || progress > 1) {
		progress = _wrapProgress(progress);
	}
	let segIndex = 0,
		segment = rawPath[0],
		samples, resolution, length, min, max, i, t;
	if (!progress) {
		t = i = segIndex = 0;
		segment = rawPath[0];
	} else if (progress === 1) {
		t = 1;
		segIndex = rawPath.length - 1;
		segment = rawPath[segIndex];
		i = segment.length - 8;
	} else {
		if (rawPath.length > 1) { //speed optimization: most of the time, there's only one segment so skip the recursion.
			length = rawPath.totalLength * progress;
			max = i = 0;
			while ((max += rawPath[i++].totalLength) < length) {
				segIndex = i;
			}
			segment = rawPath[segIndex];
			min = max - segment.totalLength;
			progress = ((length - min) / (max - min)) || 0;
		}
		samples = segment.samples;
		resolution = segment.resolution; //how many samples per cubic bezier chunk
		length = segment.totalLength * progress;
		i = segment.lookup[~~(length / segment.minLength)] || 0;
		min = i ? samples[i-1] : 0;
		max = samples[i];
		if (max < length) {
			min = max;
			max = samples[++i];
		}
		t = (1 / resolution) * (((length - min) / (max - min)) + ((i % resolution)));
		i = ~~(i / resolution) * 6;
		if (pushToNextIfAtEnd && t === 1) {
			if (i + 6 < segment.length) {
				i += 6;
				t = 0;
			} else if (segIndex + 1 < rawPath.length) {
				i = t = 0;
				segment = rawPath[++segIndex];
			}
		}
	}
	decoratee.t = t;
	decoratee.i = i;
	decoratee.path = rawPath;
	decoratee.segment = segment;
	decoratee.segIndex = segIndex;
	return decoratee;
}

function getPositionOnPath(rawPath, progress, includeAngle, point) {
	let segment = rawPath[0],
		result = point || {},
		samples, resolution, length, min, max, i, t, a, inv;
	if (progress < 0 || progress > 1) {
		progress = _wrapProgress(progress);
	}
	if (rawPath.length > 1) { //speed optimization: most of the time, there's only one segment so skip the recursion.
		length = rawPath.totalLength * progress;
		max = i = 0;
		while ((max += rawPath[i++].totalLength) < length) {
			segment = rawPath[i];
		}
		min = max - segment.totalLength;
		progress = ((length - min) / (max - min)) || 0;
	}
	samples = segment.samples;
	resolution = segment.resolution;
	length = segment.totalLength * progress;
	i = segment.lookup[progress < 1 ? ~~(length / segment.minLength) : segment.lookup.length - 1] || 0;
	min = i ? samples[i-1] : 0;
	max = samples[i];
	if (max < length) {
		min = max;
		max = samples[++i];
	}
	t = ((1 / resolution) * (((length - min) / (max - min)) + ((i % resolution)))) || 0;
	inv = 1 - t;
	i = ~~(i / resolution) * 6;
	a = segment[i];
	result.x = _round((t * t * (segment[i + 6] - a) + 3 * inv * (t * (segment[i + 4] - a) + inv * (segment[i + 2] - a))) * t + a);
	result.y = _round((t * t * (segment[i + 7] - (a = segment[i+1])) + 3 * inv * (t * (segment[i + 5] - a) + inv * (segment[i + 3] - a))) * t + a);
	if (includeAngle) {
		result.angle = segment.totalLength ? getRotationAtBezierT(segment, i, t >= 1 ? 1 - 1e-9 : t ? t : 1e-9) : segment.angle || 0;
	}
	return result;
}



//applies a matrix transform to RawPath (or a segment in a RawPath) and returns whatever was passed in (it transforms the values in the array(s), not a copy).
function transformRawPath(rawPath, a, b, c, d, tx, ty) {
	let j = rawPath.length,
		segment, l, i, x, y;
	while (--j > -1) {
		segment = rawPath[j];
		l = segment.length;
		for (i = 0; i < l; i += 2) {
			x = segment[i];
			y = segment[i+1];
			segment[i] = x * a + y * c + tx;
			segment[i+1] = x * b + y * d + ty;
		}
	}
	rawPath._dirty = 1;
	return rawPath;
}



// translates SVG arc data into a segment (cubic beziers). Angle is in degrees.
function arcToSegment(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {
	if (lastX === x && lastY === y) {
		return;
	}
	rx = _abs(rx);
	ry = _abs(ry);
	let angleRad = (angle % 360) * _DEG2RAD,
		cosAngle = _cos(angleRad),
		sinAngle = _sin(angleRad),
		PI = Math.PI,
		TWOPI = PI * 2,
		dx2 = (lastX - x) / 2,
		dy2 = (lastY - y) / 2,
		x1 = (cosAngle * dx2 + sinAngle * dy2),
		y1 = (-sinAngle * dx2 + cosAngle * dy2),
		x1_sq = x1 * x1,
		y1_sq = y1 * y1,
		radiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);
	if (radiiCheck > 1) {
		rx = _sqrt(radiiCheck) * rx;
		ry = _sqrt(radiiCheck) * ry;
	}
	let rx_sq = rx * rx,
		ry_sq = ry * ry,
		sq = ((rx_sq * ry_sq) - (rx_sq * y1_sq) - (ry_sq * x1_sq)) / ((rx_sq * y1_sq) + (ry_sq * x1_sq));
	if (sq < 0) {
		sq = 0;
	}
	let coef = ((largeArcFlag === sweepFlag) ? -1 : 1) * _sqrt(sq),
		cx1 = coef * ((rx * y1) / ry),
		cy1 = coef * -((ry * x1) / rx),
		sx2 = (lastX + x) / 2,
		sy2 = (lastY + y) / 2,
		cx = sx2 + (cosAngle * cx1 - sinAngle * cy1),
		cy = sy2 + (sinAngle * cx1 + cosAngle * cy1),
		ux = (x1 - cx1) / rx,
		uy = (y1 - cy1) / ry,
		vx = (-x1 - cx1) / rx,
		vy = (-y1 - cy1) / ry,
		temp = ux * ux + uy * uy,
		angleStart = ((uy < 0) ? -1 : 1) * Math.acos(ux / _sqrt(temp)),
		angleExtent = ((ux * vy - uy * vx < 0) ? -1 : 1) * Math.acos((ux * vx + uy * vy) / _sqrt(temp * (vx * vx + vy * vy)));
	isNaN(angleExtent) && (angleExtent = PI); //rare edge case. Math.cos(-1) is NaN.
	if (!sweepFlag && angleExtent > 0) {
		angleExtent -= TWOPI;
	} else if (sweepFlag && angleExtent < 0) {
		angleExtent += TWOPI;
	}
	angleStart %= TWOPI;
	angleExtent %= TWOPI;
	let segments = Math.ceil(_abs(angleExtent) / (TWOPI / 4)),
		rawPath = [],
		angleIncrement = angleExtent / segments,
		controlLength = 4 / 3 * _sin(angleIncrement / 2) / (1 + _cos(angleIncrement / 2)),
		ma = cosAngle * rx,
		mb = sinAngle * rx,
		mc = sinAngle * -ry,
		md = cosAngle * ry,
		i;
	for (i = 0; i < segments; i++) {
		angle = angleStart + i * angleIncrement;
		x1 = _cos(angle);
		y1 = _sin(angle);
		ux = _cos(angle += angleIncrement);
		uy = _sin(angle);
		rawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);
	}
	//now transform according to the actual size of the ellipse/arc (the beziers were noramlized, between 0 and 1 on a circle).
	for (i = 0; i < rawPath.length; i+=2) {
		x1 = rawPath[i];
		y1 = rawPath[i+1];
		rawPath[i] = x1 * ma + y1 * mc + cx;
		rawPath[i+1] = x1 * mb + y1 * md + cy;
	}
	rawPath[i-2] = x; //always set the end to exactly where it's supposed to be
	rawPath[i-1] = y;
	return rawPath;
}

//Spits back a RawPath with absolute coordinates. Each segment starts with a "moveTo" command (x coordinate, then y) and then 2 control points (x, y, x, y), then anchor. The goal is to minimize memory and maximize speed.
function stringToRawPath(d) {
	let a = (d + "").replace(_scientific, m => { let n = +m; return (n < 0.0001 && n > -0.0001) ? 0 : n; }).match(_svgPathExp) || [], //some authoring programs spit out very small numbers in scientific notation like "1e-5", so make sure we round that down to 0 first.
		path = [],
		relativeX = 0,
		relativeY = 0,
		twoThirds = 2 / 3,
		elements = a.length,
		points = 0,
		errorMessage = "ERROR: malformed path: " + d,
		i, j, x, y, command, isRelative, segment, startX, startY, difX, difY, beziers, prevCommand, flag1, flag2,
		line = function(sx, sy, ex, ey) {
			difX = (ex - sx) / 3;
			difY = (ey - sy) / 3;
			segment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);
		};
	if (!d || !isNaN(a[0]) || isNaN(a[1])) {
		console.log(errorMessage);
		return path;
	}
	for (i = 0; i < elements; i++) {
		prevCommand = command;
		if (isNaN(a[i])) {
			command = a[i].toUpperCase();
			isRelative = (command !== a[i]); //lower case means relative
		} else { //commands like "C" can be strung together without any new command characters between.
			i--;
		}
		x = +a[i + 1];
		y = +a[i + 2];
		if (isRelative) {
			x += relativeX;
			y += relativeY;
		}
		if (!i) {
			startX = x;
			startY = y;
		}

		// "M" (move)
		if (command === "M") {
			if (segment) {
				if (segment.length < 8) { //if the path data was funky and just had a M with no actual drawing anywhere, skip it.
					path.length -= 1;
				} else {
					points += segment.length;
				}
			}
			relativeX = startX = x;
			relativeY = startY = y;
			segment = [x, y];
			path.push(segment);
			i += 2;
			command = "L"; //an "M" with more than 2 values gets interpreted as "lineTo" commands ("L").

		// "C" (cubic bezier)
		} else if (command === "C") {
			if (!segment) {
				segment = [0, 0];
			}
			if (!isRelative) {
				relativeX = relativeY = 0;
			}
			//note: "*1" is just a fast/short way to cast the value as a Number. WAAAY faster in Chrome, slightly slower in Firefox.
			segment.push(x,	y, relativeX + a[i + 3] * 1, relativeY + a[i + 4] * 1, (relativeX += a[i + 5] * 1),	(relativeY += a[i + 6] * 1));
			i += 6;

		// "S" (continuation of cubic bezier)
		} else if (command === "S") {
			difX = relativeX;
			difY = relativeY;
			if (prevCommand === "C" || prevCommand === "S") {
				difX += relativeX - segment[segment.length - 4];
				difY += relativeY - segment[segment.length - 3];
			}
			if (!isRelative) {
				relativeX = relativeY = 0;
			}
			segment.push(difX, difY, x,	y, (relativeX += a[i + 3] * 1), (relativeY += a[i + 4] * 1));
			i += 4;

		// "Q" (quadratic bezier)
		} else if (command === "Q") {
			difX = relativeX + (x - relativeX) * twoThirds;
			difY = relativeY + (y - relativeY) * twoThirds;
			if (!isRelative) {
				relativeX = relativeY = 0;
			}
			relativeX += a[i + 3] * 1;
			relativeY += a[i + 4] * 1;
			segment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);
			i += 4;

		// "T" (continuation of quadratic bezier)
		} else if (command === "T") {
			difX = relativeX - segment[segment.length - 4];
			difY = relativeY - segment[segment.length - 3];
			segment.push(relativeX + difX, relativeY + difY, x + ((relativeX + difX * 1.5) - x) * twoThirds, y + ((relativeY + difY * 1.5) - y) * twoThirds, (relativeX = x), (relativeY = y));
			i += 2;

		// "H" (horizontal line)
		} else if (command === "H") {
			line(relativeX, relativeY, (relativeX = x), relativeY);
			i += 1;

		// "V" (vertical line)
		} else if (command === "V") {
			//adjust values because the first (and only one) isn't x in this case, it's y.
			line(relativeX, relativeY, relativeX, (relativeY = x + (isRelative ? relativeY - relativeX : 0)));
			i += 1;

		// "L" (line) or "Z" (close)
		} else if (command === "L" || command === "Z") {
			if (command === "Z") {
				x = startX;
				y = startY;
				segment.closed = true;
			}
			if (command === "L" || _abs(relativeX - x) > 0.5 || _abs(relativeY - y) > 0.5) {
				line(relativeX, relativeY, x, y);
				if (command === "L") {
					i += 2;
				}
			}
			relativeX = x;
			relativeY = y;

		// "A" (arc)
		} else if (command === "A") {
			flag1 = a[i+4];
			flag2 = a[i+5];
			difX = a[i+6];
			difY = a[i+7];
			j = 7;
			if (flag1.length > 1) { // for cases when the flags are merged, like "a8 8 0 018 8" (the 0 and 1 flags are WITH the x value of 8, but it could also be "a8 8 0 01-8 8" so it may include x or not)
				if (flag1.length < 3) {
					difY = difX;
					difX = flag2;
					j--;
				} else {
					difY = flag2;
					difX = flag1.substr(2);
					j-=2;
				}
				flag2 = flag1.charAt(1);
				flag1 = flag1.charAt(0);
			}
			beziers = arcToSegment(relativeX, relativeY, +a[i+1], +a[i+2], +a[i+3], +flag1, +flag2, (isRelative ? relativeX : 0) + difX*1, (isRelative ? relativeY : 0) + difY*1);
			i += j;
			if (beziers) {
				for (j = 0; j < beziers.length; j++) {
					segment.push(beziers[j]);
				}
			}
			relativeX = segment[segment.length-2];
			relativeY = segment[segment.length-1];

		} else {
			console.log(errorMessage);
		}
	}
	i = segment.length;
	if (i < 6) { //in case there's odd SVG like a M0,0 command at the very end.
		path.pop();
		i = 0;
	} else if (segment[0] === segment[i-2] && segment[1] === segment[i-1]) {
		segment.closed = true;
	}
	path.totalPoints = points + i;
	return path;
}

//populates the points array in alternating x/y values (like [x, y, x, y...] instead of individual point objects [{x, y}, {x, y}...] to conserve memory and stay in line with how we're handling segment arrays
function bezierToPoints(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {
	let x12 = (x1 + x2) / 2,
		y12 = (y1 + y2) / 2,
		x23 = (x2 + x3) / 2,
		y23 = (y2 + y3) / 2,
		x34 = (x3 + x4) / 2,
		y34 = (y3 + y4) / 2,
		x123 = (x12 + x23) / 2,
		y123 = (y12 + y23) / 2,
		x234 = (x23 + x34) / 2,
		y234 = (y23 + y34) / 2,
		x1234 = (x123 + x234) / 2,
		y1234 = (y123 + y234) / 2,
		dx = x4 - x1,
		dy = y4 - y1,
		d2 = _abs((x2 - x4) * dy - (y2 - y4) * dx),
		d3 = _abs((x3 - x4) * dy - (y3 - y4) * dx),
		length;
	if (!points) {
		points = [x1, y1, x4, y4];
		index = 2;
	}
	points.splice(index || points.length - 2, 0, x1234, y1234);
	if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {
		length = points.length;
		bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);
		bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 2 + (points.length - length));
	}
	return points;
}

/*
function getAngleBetweenPoints(x0, y0, x1, y1, x2, y2) { //angle between 3 points in radians
	var dx1 = x1 - x0,
		dy1 = y1 - y0,
		dx2 = x2 - x1,
		dy2 = y2 - y1,
		dx3 = x2 - x0,
		dy3 = y2 - y0,
		a = dx1 * dx1 + dy1 * dy1,
		b = dx2 * dx2 + dy2 * dy2,
		c = dx3 * dx3 + dy3 * dy3;
	return Math.acos( (a + b - c) / _sqrt(4 * a * b) );
},
*/

//pointsToSegment() doesn't handle flat coordinates (where y is always 0) the way we need (the resulting control points are always right on top of the anchors), so this function basically makes the control points go directly up and down, varying in length based on the curviness (more curvy, further control points)
function flatPointsToSegment(points, curviness=1) {
	let x = points[0],
		y = 0,
		segment = [x, y],
		i = 2;
	for (; i < points.length; i+=2) {
		segment.push(
			x,
			y,
			points[i],
			(y = (points[i] - x) * curviness / 2),
			(x = points[i]),
			-y
		);
	}
	return segment;
}

//points is an array of x/y points, like [x, y, x, y, x, y]
function pointsToSegment(points, curviness, cornerThreshold) {
	//points = simplifyPoints(points, tolerance);
	_abs(points[0] - points[2]) < 1e-4 && _abs(points[1] - points[3]) < 1e-4 && (points = points.slice(2)); // if the first two points are super close, dump the first one.
	let l = points.length-2,
		x = +points[0],
		y = +points[1],
		nextX = +points[2],
		nextY = +points[3],
		segment = [x, y, x, y],
		dx2 = nextX - x,
		dy2 = nextY - y,
		closed = Math.abs(points[l] - x) < 0.001 && Math.abs(points[l+1] - y) < 0.001,
		prevX, prevY, angle, slope, i, dx1, dx3, dy1, dy3, d1, d2, a, b, c;
	if (isNaN(cornerThreshold)) {
		cornerThreshold = Math.PI / 10;
	}
	if (closed) { // if the start and end points are basically on top of each other, close the segment by adding the 2nd point to the end, and the 2nd-to-last point to the beginning (we'll remove them at the end, but this allows the curvature to look perfect)
		points.push(nextX, nextY);
		nextX = x;
		nextY = y;
		x = points[l-2];
		y = points[l-1];
		points.unshift(x, y);
		l+=4;
	}
	curviness = (curviness || curviness === 0) ? +curviness : 1;
	for (i = 2; i < l; i+=2) {
		prevX = x;
		prevY = y;
		x = nextX;
		y = nextY;
		nextX = +points[i+2];
		nextY = +points[i+3];
		if (x === nextX && y === nextY) {
			continue;
		}
		dx1 = dx2;
		dy1 = dy2;
		dx2 = nextX - x;
		dy2 = nextY - y;
		dx3 = nextX - prevX;
		dy3 = nextY - prevY;
		a = dx1 * dx1 + dy1 * dy1;
		b = dx2 * dx2 + dy2 * dy2;
		c = dx3 * dx3 + dy3 * dy3;
		angle = Math.acos( (a + b - c) / _sqrt(4 * a * b) ); //angle between the 3 points
		d2 = (angle / Math.PI) * curviness; //temporary precalculation for speed (reusing d2 variable)
		d1 = _sqrt(a) * d2; //the tighter the angle, the shorter we make the handles in proportion.
		d2 *= _sqrt(b);
		if (x !== prevX || y !== prevY) {
			if (angle > cornerThreshold) {
				slope = _atan2(dy3, dx3);
				segment.push(
					_round(x - _cos(slope) * d1),   //first control point
					_round(y - _sin(slope) * d1),
					_round(x),                      //anchor
					_round(y),
					_round(x + _cos(slope) * d2),   //second control point
					_round(y + _sin(slope) * d2)
				);
			} else {
				slope = _atan2(dy1, dx1);
				segment.push(
					_round(x - _cos(slope) * d1),   //first control point
					_round(y - _sin(slope) * d1));
				slope = _atan2(dy2, dx2);
				segment.push(
					_round(x),                      //anchor
					_round(y),
					_round(x + _cos(slope) * d2),   //second control point
					_round(y + _sin(slope) * d2)
				);
			}
		}
	}
	x !== nextX || y !== nextY || segment.length < 4 ? segment.push(_round(nextX), _round(nextY), _round(nextX), _round(nextY)) : segment.length -= 2;
	if (closed) {
		segment.splice(0, 6);
		segment.length = segment.length - 6;
	}
	return segment;
}

//returns the squared distance between an x/y coordinate and a segment between x1/y1 and x2/y2
function pointToSegDist(x, y, x1, y1, x2, y2) {
	let dx = x2 - x1,
		dy = y2 - y1,
		t;
	if (dx || dy) {
		t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
		if (t > 1) {
			x1 = x2;
			y1 = y2;
		} else if (t > 0) {
			x1 += dx * t;
			y1 += dy * t;
		}
	}
	return (x - x1) ** 2 + (y - y1) ** 2;
}

function simplifyStep(points, first, last, tolerance, simplified) {
	let maxSqDist = tolerance,
		firstX = points[first],
		firstY = points[first+1],
		lastX = points[last],
		lastY = points[last+1],
		index, i, d;
	for (i = first + 2; i < last; i += 2) {
		d = pointToSegDist(points[i], points[i+1], firstX, firstY, lastX, lastY);
		if (d > maxSqDist) {
			index = i;
			maxSqDist = d;
		}
	}
	if (maxSqDist > tolerance) {
		index - first > 2 && simplifyStep(points, first, index, tolerance, simplified);
		simplified.push(points[index], points[index+1]);
		last - index > 2 && simplifyStep(points, index, last, tolerance, simplified);
	}
}

//points is an array of x/y values like [x, y, x, y, x, y]
function simplifyPoints(points, tolerance) {
	let prevX = parseFloat(points[0]),
		prevY = parseFloat(points[1]),
		temp = [prevX, prevY],
		l = points.length - 2,
		i, x, y, dx, dy, result, last;
	tolerance = (tolerance || 1) ** 2;
	for (i = 2; i < l; i += 2) {
		x = parseFloat(points[i]);
		y = parseFloat(points[i+1]);
		dx = prevX - x;
		dy = prevY - y;
		if (dx * dx + dy * dy > tolerance) {
			temp.push(x, y);
			prevX = x;
			prevY = y;
		}
	}
	temp.push(parseFloat(points[l]), parseFloat(points[l+1]));
	last = temp.length - 2;
	result = [temp[0], temp[1]];
	simplifyStep(temp, 0, last, tolerance, result);
	result.push(temp[last], temp[last+1]);
	return result;
}

function getClosestProgressOnBezier(iterations, px, py, start, end, slices, x0, y0, x1, y1, x2, y2, x3, y3) {
	let inc = (end - start) / slices,
		best = 0,
		t = start,
		x, y, d, dx, dy, inv;
	_bestDistance = _largeNum;
	while (t <= end) {
		inv = 1 - t;
		x = inv * inv * inv * x0 + 3 * inv * inv * t * x1 + 3 * inv * t * t * x2 + t * t * t * x3;
		y = inv * inv * inv * y0 + 3 * inv * inv * t * y1 + 3 * inv * t * t * y2 + t * t * t * y3;
		dx = x - px;
		dy = y - py;
		d = dx * dx + dy * dy;
		if (d < _bestDistance) {
			_bestDistance = d;
			best = t;
		}
		t += inc;
	}
	return (iterations > 1) ? getClosestProgressOnBezier(iterations - 1, px, py, Math.max(best - inc, 0), Math.min(best + inc, 1), slices, x0, y0, x1, y1, x2, y2, x3, y3) : best;
}

function getClosestData(rawPath, x, y, slices) { //returns an object with the closest j, i, and t (j is the segment index, i is the index of the point in that segment, and t is the time/progress along that bezier)
	let closest = {j:0, i:0, t:0},
		bestDistance = _largeNum,
		i, j, t, segment;
	for (j = 0; j < rawPath.length; j++) {
		segment = rawPath[j];
		for (i = 0; i < segment.length; i+=6) {
			t = getClosestProgressOnBezier(1, x, y, 0, 1, slices || 20, segment[i], segment[i+1], segment[i+2], segment[i+3], segment[i+4], segment[i+5], segment[i+6], segment[i+7]);
			if (bestDistance > _bestDistance) {
				bestDistance = _bestDistance;
				closest.j = j;
				closest.i = i;
				closest.t = t;
			}
		}
	}
	return closest;
}

//subdivide a Segment closest to a specific x,y coordinate
function subdivideSegmentNear(x, y, segment, slices, iterations) {
	let l = segment.length,
		bestDistance = _largeNum,
		bestT = 0,
		bestSegmentIndex = 0,
		t, i;
	slices = slices || 20;
	iterations = iterations || 3;
	for (i = 0; i < l; i += 6) {
		t = getClosestProgressOnBezier(1, x, y, 0, 1, slices, segment[i], segment[i+1], segment[i+2], segment[i+3], segment[i+4], segment[i+5], segment[i+6], segment[i+7]);
		if (bestDistance > _bestDistance) {
			bestDistance = _bestDistance;
			bestT = t;
			bestSegmentIndex = i;
		}
	}
	t = getClosestProgressOnBezier(iterations, x, y, bestT - 0.05, bestT + 0.05, slices, segment[bestSegmentIndex], segment[bestSegmentIndex+1], segment[bestSegmentIndex+2], segment[bestSegmentIndex+3], segment[bestSegmentIndex+4], segment[bestSegmentIndex+5], segment[bestSegmentIndex+6], segment[bestSegmentIndex+7]);
	subdivideSegment(segment, bestSegmentIndex, t);
	return bestSegmentIndex + 6;
}

/*
Takes any of the following and converts it to an all Cubic Bezier SVG data string:
- A <path> data string like "M0,0 L2,4 v20,15 H100"
- A RawPath, like [[x, y, x, y, x, y, x, y][[x, y, x, y, x, y, x, y]]
- A Segment, like [x, y, x, y, x, y, x, y]

Note: all numbers are rounded down to the closest 0.001 to minimize memory, maximize speed, and avoid odd numbers like 1e-13
*/
function rawPathToString(rawPath) {
	if (_isNumber(rawPath[0])) { //in case a segment is passed in instead
		rawPath = [rawPath];
	}
	let result = "",
		l = rawPath.length,
		sl, s, i, segment;
	for (s = 0; s < l; s++) {
		segment = rawPath[s];
		result += "M" + _round(segment[0]) + "," + _round(segment[1]) + " C";
		sl = segment.length;
		for (i = 2; i < sl; i++) {
			result += _round(segment[i++]) + "," + _round(segment[i++]) + " " + _round(segment[i++]) + "," + _round(segment[i++]) + " " + _round(segment[i++]) + "," + _round(segment[i]) + " ";
		}
		if (segment.closed) {
			result += "z";
		}
	}
	return result;
}

/*
// takes a segment with coordinates [x, y, x, y, ...] and converts the control points into angles and lengths [x, y, angle, length, angle, length, x, y, angle, length, ...] so that it animates more cleanly and avoids odd breaks/kinks. For example, if you animate from 1 o'clock to 6 o'clock, it'd just go directly/linearly rather than around. So the length would be very short in the middle of the tween.
export function cpCoordsToAngles(segment, copy) {
	var result = copy ? segment.slice(0) : segment,
		x, y, i;
	for (i = 0; i < segment.length; i+=6) {
		x = segment[i+2] - segment[i];
		y = segment[i+3] - segment[i+1];
		result[i+2] = Math.atan2(y, x);
		result[i+3] = Math.sqrt(x * x + y * y);
		x = segment[i+6] - segment[i+4];
		y = segment[i+7] - segment[i+5];
		result[i+4] = Math.atan2(y, x);
		result[i+5] = Math.sqrt(x * x + y * y);
	}
	return result;
}

// takes a segment that was converted with cpCoordsToAngles() to have angles and lengths instead of coordinates for the control points, and converts it BACK into coordinates.
export function cpAnglesToCoords(segment, copy) {
	var result = copy ? segment.slice(0) : segment,
		length = segment.length,
		rnd = 1000,
		angle, l, i, j;
	for (i = 0; i < length; i+=6) {
		angle = segment[i+2];
		l = segment[i+3]; //length
		result[i+2] = (((segment[i] + Math.cos(angle) * l) * rnd) | 0) / rnd;
		result[i+3] = (((segment[i+1] + Math.sin(angle) * l) * rnd) | 0) / rnd;
		angle = segment[i+4];
		l = segment[i+5]; //length
		result[i+4] = (((segment[i+6] - Math.cos(angle) * l) * rnd) | 0) / rnd;
		result[i+5] = (((segment[i+7] - Math.sin(angle) * l) * rnd) | 0) / rnd;
	}
	return result;
}

//adds an "isSmooth" array to each segment and populates it with a boolean value indicating whether or not it's smooth (the control points have basically the same slope). For any smooth control points, it converts the coordinates into angle (x, in radians) and length (y) and puts them into the same index value in a smoothData array.
export function populateSmoothData(rawPath) {
	let j = rawPath.length,
		smooth, segment, x, y, x2, y2, i, l, a, a2, isSmooth, smoothData;
	while (--j > -1) {
		segment = rawPath[j];
		isSmooth = segment.isSmooth = segment.isSmooth || [0, 0, 0, 0];
		smoothData = segment.smoothData = segment.smoothData || [0, 0, 0, 0];
		isSmooth.length = 4;
		l = segment.length - 2;
		for (i = 6; i < l; i += 6) {
			x = segment[i] - segment[i - 2];
			y = segment[i + 1] - segment[i - 1];
			x2 = segment[i + 2] - segment[i];
			y2 = segment[i + 3] - segment[i + 1];
			a = _atan2(y, x);
			a2 = _atan2(y2, x2);
			smooth = (Math.abs(a - a2) < 0.09);
			if (smooth) {
				smoothData[i - 2] = a;
				smoothData[i + 2] = a2;
				smoothData[i - 1] = _sqrt(x * x + y * y);
				smoothData[i + 3] = _sqrt(x2 * x2 + y2 * y2);
			}
			isSmooth.push(smooth, smooth, 0, 0, smooth, smooth);
		}
		//if the first and last points are identical, check to see if there's a smooth transition. We must handle this a bit differently due to their positions in the array.
		if (segment[l] === segment[0] && segment[l+1] === segment[1]) {
			x = segment[0] - segment[l-2];
			y = segment[1] - segment[l-1];
			x2 = segment[2] - segment[0];
			y2 = segment[3] - segment[1];
			a = _atan2(y, x);
			a2 = _atan2(y2, x2);
			if (Math.abs(a - a2) < 0.09) {
				smoothData[l-2] = a;
				smoothData[2] = a2;
				smoothData[l-1] = _sqrt(x * x + y * y);
				smoothData[3] = _sqrt(x2 * x2 + y2 * y2);
				isSmooth[l-2] = isSmooth[l-1] = true; //don't change indexes 2 and 3 because we'll trigger everything from the END, and this will optimize file size a bit.
			}
		}
	}
	return rawPath;
}
export function pointToScreen(svgElement, point) {
	if (arguments.length < 2) { //by default, take the first set of coordinates in the path as the point
		let rawPath = getRawPath(svgElement);
		point = svgElement.ownerSVGElement.createSVGPoint();
		point.x = rawPath[0][0];
		point.y = rawPath[0][1];
	}
	return point.matrixTransform(svgElement.getScreenCTM());
}

*/

/***/ }),

/***/ "./node_modules/gsap/src/utils/strings.js":
/*!************************************************!*\
  !*** ./node_modules/gsap/src/utils/strings.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "emojiExp": function() { return /* binding */ emojiExp; },
/* harmony export */   "getText": function() { return /* binding */ getText; },
/* harmony export */   "splitInnerHTML": function() { return /* binding */ splitInnerHTML; },
/* harmony export */   "emojiSafeSplit": function() { return /* binding */ emojiSafeSplit; }
/* harmony export */ });
/*!
 * strings: 3.7.0
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */

let _trimExp = /(^\s+|\s+$)/g;

const emojiExp = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;

function getText(e) {
	let type = e.nodeType,
		result = "";
	if (type === 1 || type === 9 || type === 11) {
		if (typeof(e.textContent) === "string") {
			return e.textContent;
		} else {
			for (e = e.firstChild; e; e = e.nextSibling ) {
				result += getText(e);
			}
		}
	} else if (type === 3 || type === 4) {
		return e.nodeValue;
	}
	return result;
}

function splitInnerHTML(element, delimiter, trim) {
	let node = element.firstChild,
		result = [];
	while (node) {
		if (node.nodeType === 3) {
			result.push(...emojiSafeSplit((node.nodeValue + "").replace(/^\n+/g, "").replace(/\s+/g, " "), delimiter, trim));
		} else if ((node.nodeName + "").toLowerCase() === "br") {
			result[result.length-1] += "<br>";
		} else {
			result.push(node.outerHTML);
		}
		node = node.nextSibling;
	}
	return result;
}

/*
//smaller kb version that only handles the simpler emoji's, which is often perfectly adequate.

let _emoji = "[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2694-\u2697]|\uD83E[\uDD10-\uDD5D]|[\uD800-\uDBFF][\uDC00-\uDFFF]",
	_emojiExp = new RegExp(_emoji),
	_emojiAndCharsExp = new RegExp(_emoji + "|.", "g"),
	_emojiSafeSplit = (text, delimiter, trim) => {
		if (trim) {
			text = text.replace(_trimExp, "");
		}
		return ((delimiter === "" || !delimiter) && _emojiExp.test(text)) ? text.match(_emojiAndCharsExp) : text.split(delimiter || "");
	};
 */
function emojiSafeSplit(text, delimiter, trim) {
	text += ""; // make sure it's cast as a string. Someone may pass in a number.
	if (trim) {
		text = text.replace(_trimExp, "");
	}
	if (delimiter && delimiter !== "") {
		return text.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(delimiter);
	}
	let result = [],
		l = text.length,
		i = 0,
		j, character;
	for (; i < l; i++) {
		character = text.charAt(i);
		if ((character.charCodeAt(0) >= 0xD800 && character.charCodeAt(0) <= 0xDBFF) || (text.charCodeAt(i+1) >= 0xFE00 && text.charCodeAt(i+1) <= 0xFE0F)) { //special emoji characters use 2 or 4 unicode characters that we must keep together.
			j = ((text.substr(i, 12).split(emojiExp) || [])[1] || "").length || 2;
			character = text.substr(i, j);
			result.emoji = 1;
			i += j - 1;
		}
		result.push(character === ">" ? "&gt;" : (character === "<") ? "&lt;" : character);
	}
	return result;
}

/***/ })

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbnRhaW5lcnMvSG9tZUNvbXAvaW5kZXgudHN4Iiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3NhcC9zcmMvQ1NTUGx1Z2luLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3NhcC9zcmMvQ1NTUnVsZVBsdWdpbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dzYXAvc3JjL0RyYWdnYWJsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dzYXAvc3JjL0Vhc2VQYWNrLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3NhcC9zcmMvRWFzZWxQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nc2FwL3NyYy9Nb3Rpb25QYXRoUGx1Z2luLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3NhcC9zcmMvUGl4aVBsdWdpbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dzYXAvc3JjL1Njcm9sbFRvUGx1Z2luLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3NhcC9zcmMvU2Nyb2xsVHJpZ2dlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dzYXAvc3JjL1RleHRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nc2FwL3NyYy9hbGwuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nc2FwL3NyYy9nc2FwLWNvcmUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nc2FwL3NyYy91dGlscy9tYXRyaXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nc2FwL3NyYy91dGlscy9wYXRocy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dzYXAvc3JjL3V0aWxzL3N0cmluZ3MuanMiXSwibmFtZXMiOlsiSG9tZUNvbXAiLCJ1c2VFZmZlY3QiLCJldGhGaWVsZCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsIkFycmF5IiwiZm9yRWFjaCIsImV0aCIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJzdHlsZSIsImhlaWdodCIsIm9wYWNpdHkiLCJnc2FwIiwiYXV0b0FscGhhIiwieCIsInJhbmRvbSIsImR1cmF0aW9uIiwiY29uc29sZSIsImxvZyIsImFwcGVuZENoaWxkIiwibW9iaWxlWHMiLCJ0YWJsZXRNZCIsIkRvY3VtZW50YXRpb25CdXR0b24iLCJzdHlsZWQiLCJCb3giLCJwcm9wcyIsIkV0aEZpZWxkIiwicHJvcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFNQSxRQUFRLEdBQUcsU0FBWEEsUUFBVyxHQUFNO0FBQUE7O0FBRW5CQyxrREFBUyxDQUFDLFlBQU07QUFDWixjQUFxQjtBQUNqQixVQUFNQyxRQUFRLEdBQUdDLFFBQVEsQ0FBQ0Msc0JBQVQsQ0FBZ0MsVUFBaEMsRUFBNEMsQ0FBNUMsQ0FBakI7O0FBRUEsa0lBQUlDLEtBQUssQ0FBQyxFQUFELENBQVQsRUFBZUMsT0FBZixDQUF1QixZQUFNO0FBQ3pCLFlBQU1DLEdBQUcsR0FBR0osUUFBUSxDQUFDSyxhQUFULENBQXVCLEtBQXZCLENBQVo7QUFDQUQsV0FBRyxDQUFDRSxZQUFKLENBQWlCLEtBQWpCLEVBQXdCLFVBQXhCO0FBQ0FGLFdBQUcsQ0FBQ0UsWUFBSixDQUFpQixPQUFqQixFQUEwQixNQUExQjtBQUNBRixXQUFHLENBQUNHLEtBQUosQ0FBVUMsTUFBVixHQUFtQixNQUFuQjtBQUNBSixXQUFHLENBQUNHLEtBQUosQ0FBVUUsT0FBVixHQUFvQixLQUFwQjtBQUNBQyxxREFBQSxDQUFZTixHQUFaLEVBQWlCO0FBQUVPLG1CQUFTLEVBQUUsQ0FBYjtBQUFn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QUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvUUFBb1E7QUFDcFE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtREFBbUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsU0FBUyx5Q0FBeUM7QUFDbEc7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0EsR0FBRztBQUNILHlCQUF5QixHQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sT0FBTztBQUNkO0FBQ0EsdUpBQXVKO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsK0JBQStCO0FBQ3RFO0FBQ0E7QUFDQSxDIiwiZmlsZSI6InN0YXRpYy93ZWJwYWNrL3BhZ2VzL2luZGV4LjhlYjE2N2FkNDI5MjNkNGIyNTNhLmhvdC11cGRhdGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IEJveCBmcm9tICdAL2NvbXBvbmVudHMvQm94JztcbmltcG9ydCBOYXZCYXIgZnJvbSAnQC9jb21wb25lbnRzL05hdkJhcic7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJztcbmltcG9ydCB7IGdzYXAgfSBmcm9tICdnc2FwJztcbmltcG9ydCB7IHJhbmRvbSB9IGZyb20gJ2dzYXAvc3JjL2FsbCc7XG5cbmNvbnN0IEhvbWVDb21wID0gKCkgPT4ge1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xuICAgICAgICAgICAgY29uc3QgZXRoRmllbGQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZXRoRmllbGRcIilbMF07XG5cbiAgICAgICAgICAgIFsuLi5BcnJheSg4MCldLmZvckVhY2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgICAgICAgICAgZXRoLnNldEF0dHJpYnV0ZShcInNyY1wiLCBcIi9ldGgucG5nXCIpO1xuICAgICAgICAgICAgICAgIGV0aC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInN0YXJcIik7XG4gICAgICAgICAgICAgICAgZXRoLnN0eWxlLmhlaWdodCA9IFwiNHJlbVwiO1xuICAgICAgICAgICAgICAgIGV0aC5zdHlsZS5vcGFjaXR5ID0gXCIwLjJcIjtcbiAgICAgICAgICAgICAgICBnc2FwLmZyb21UbyhldGgsIHsgYXV0b0FscGhhOiAwLCB4OiByYW5kb20oMCwgMTAwKSB9LCB7IGF1dG9BbHBoYTogMC4yLCBkdXJhdGlvbjogMSB9KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImhlbGxvXCIpO1xuICAgICAgICAgICAgICAgIGV0aEZpZWxkLmFwcGVuZENoaWxkKGV0aCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJveD5cbiAgICAgICAgICAgIDxFdGhGaWVsZCBjbGFzc05hbWU9XCJldGhGaWVsZFwiIHpJbmRleD17MX0gLz5cbiAgICAgICAgICAgIDxOYXZCYXIgLz5cbiAgICAgICAgICAgIDxCb3ggY29sdW1uIGNlbnRlciB0ZXh0QWxpZ249XCJjZW50ZXJcIiBteD1cIjEuOHJlbVwiPlxuICAgICAgICAgICAgICAgIDxCb3hcbiAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg9XCIxMTByZW1cIlxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZT17eyBtb2JpbGVYczogXCIzLjJyZW1cIiwgdGFibGV0TWQ6IFwiNi44cmVtXCIgfX1cbiAgICAgICAgICAgICAgICAgICAgbXQ9e1tcIjE0cmVtXCIsIFwiMjZyZW1cIl19XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yPVwicHVycGxlLXRleHRcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgSW50ZXJhY3QgWW91ciBBcHBzIHdpdGggdGhlIEV0aGVyZXVtIEJsb2NrY2hhaW5cbiAgICAgICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICAgICAgICA8Qm94XG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplPXt7IG1vYmlsZVhzOiBcIjEuNnJlbVwiLCB0YWJsZXRNZDogXCIyLjRyZW1cIiB9fVxuICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aD1cIjYwcmVtXCJcbiAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodD1cIjYwMDBcIlxuICAgICAgICAgICAgICAgICAgICBtdD17eyBtb2JpbGVYczogXCIycmVtXCIsIHRhYmxldE1kOiBcIjVyZW1cIiB9fVxuICAgICAgICAgICAgICAgICAgICBjb2xvcj1cInB1cnBsZS01MFwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICBXZWIzLmpzIGlzIGEgY29sbGVjdGlvbiBvZiBsaWJyYXJpZXMgdGhhdCBhbGxvdyB5b3UgdG8gaW50ZXJhY3Qgd2l0aCBhIGxvY2FsIG9yIHJlbW90ZSBldGhlcmV1bSBub2RlIHVzaW5nIEhUVFAsIElQQyBvciBXZWJTb2NrZXQuXG4gICAgICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cImh0dHBzOi8vd2ViM2pzLnJlYWR0aGVkb2NzLmlvL2VuL3YxLjMuNC9cIiB0YXJnZXQ9XCJfc2VsZlwiPlxuICAgICAgICAgICAgICAgICAgICA8RG9jdW1lbnRhdGlvbkJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgYXM9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgYmc9XCJwdXJwbGUtdGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZT17eyBtb2JpbGVYczogXCIxLjZyZW1cIiwgdGFibGV0TWQ6IFwiMnJlbVwiIH19XG4gICAgICAgICAgICAgICAgICAgICAgICBwPXt7IG1vYmlsZVhzOiBcIjFyZW1cIiwgdGFibGV0TWQ6IFwiMnJlbVwiIH19XG4gICAgICAgICAgICAgICAgICAgICAgICBtdD17eyBtb2JpbGVYczogXCIycmVtXCIsIHRhYmxldE1kOiBcIjRyZW1cIiB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM9XCIwLjVyZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I9XCJ3aGl0ZS0xMDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yPVwicG9pbnRlclwiXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIERvY3VtZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgPC9Eb2N1bWVudGF0aW9uQnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgIDwvQm94PlxuICAgICAgICA8L0JveCA+XG4gICAgKTtcbn1cblxuXG5jb25zdCBEb2N1bWVudGF0aW9uQnV0dG9uID0gc3R5bGVkKEJveCkocHJvcHMgPT4gYFxuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSBlYXNlLWluIDE1MG1zO1xuICAgIHRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XG4gICAgXG4gICAgJjpob3ZlciB7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMS4wNSk7XG4gICAgfVxuYClcblxuY29uc3QgRXRoRmllbGQgPSBzdHlsZWQoQm94KShwcm9zID0+IGBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG5cbmApO1xuZXhwb3J0IGRlZmF1bHQgSG9tZUNvbXA7IiwiLyohXG4gKiBDU1NQbHVnaW4gMy43LjBcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5pbXBvcnQge2dzYXAsIF9nZXRQcm9wZXJ0eSwgX251bUV4cCwgX251bVdpdGhVbml0RXhwLCBnZXRVbml0LCBfaXNTdHJpbmcsIF9pc1VuZGVmaW5lZCwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIF9yZWxFeHAsIF9mb3JFYWNoTmFtZSwgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSwgX2NvbG9yU3RyaW5nRmlsdGVyLCBfY2hlY2tQbHVnaW4sIF9yZXBsYWNlUmFuZG9tLCBfcGx1Z2lucywgR1NDYWNoZSwgUHJvcFR3ZWVuLCBfY29uZmlnLCBfdGlja2VyLCBfcm91bmQsIF9taXNzaW5nUGx1Z2luLCBfZ2V0U2V0dGVyLCBfZ2V0Q2FjaGUsIF9jb2xvckV4cCxcblx0X3NldERlZmF1bHRzLCBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0gLy9mb3IgdGhlIGNvbW1lbnRlZC1vdXQgY2xhc3NOYW1lIGZlYXR1cmUuXG59IGZyb20gXCIuL2dzYXAtY29yZS5qc1wiO1xuXG5sZXQgX3dpbiwgX2RvYywgX2RvY0VsZW1lbnQsIF9wbHVnaW5Jbml0dGVkLCBfdGVtcERpdiwgX3RlbXBEaXZTdHlsZXIsIF9yZWNlbnRTZXR0ZXJQbHVnaW4sXG5cdF93aW5kb3dFeGlzdHMgPSAoKSA9PiB0eXBlb2Yod2luZG93KSAhPT0gXCJ1bmRlZmluZWRcIixcblx0X3RyYW5zZm9ybVByb3BzID0ge30sXG5cdF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcblx0X0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuXHRfYXRhbjIgPSBNYXRoLmF0YW4yLFxuXHRfYmlnTnVtID0gMWU4LFxuXHRfY2Fwc0V4cCA9IC8oW0EtWl0pL2csXG5cdF9ob3Jpem9udGFsRXhwID0gLyg/OmxlZnR8cmlnaHR8d2lkdGh8bWFyZ2lufHBhZGRpbmd8eCkvaSxcblx0X2NvbXBsZXhFeHAgPSAvW1xccyxcXChdXFxTLyxcblx0X3Byb3BlcnR5QWxpYXNlcyA9IHthdXRvQWxwaGE6XCJvcGFjaXR5LHZpc2liaWxpdHlcIiwgc2NhbGU6XCJzY2FsZVgsc2NhbGVZXCIsIGFscGhhOlwib3BhY2l0eVwifSxcblx0X3JlbmRlckNTU1Byb3AgPSAocmF0aW8sIGRhdGEpID0+IGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCAoTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDApICsgZGF0YS51LCBkYXRhKSxcblx0X3JlbmRlclByb3BXaXRoRW5kID0gKHJhdGlvLCBkYXRhKSA9PiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPT09IDEgPyBkYXRhLmUgOiAoTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDApICsgZGF0YS51LCBkYXRhKSxcblx0X3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nID0gKHJhdGlvLCBkYXRhKSA9PiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPyAoTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDApICsgZGF0YS51IDogZGF0YS5iLCBkYXRhKSwgLy9pZiB1bml0cyBjaGFuZ2UsIHdlIG5lZWQgYSB3YXkgdG8gcmVuZGVyIHRoZSBvcmlnaW5hbCB1bml0L3ZhbHVlIHdoZW4gdGhlIHR3ZWVuIGdvZXMgYWxsIHRoZSB3YXkgYmFjayB0byB0aGUgYmVnaW5uaW5nIChyYXRpbzowKVxuXHRfcmVuZGVyUm91bmRlZENTU1Byb3AgPSAocmF0aW8sIGRhdGEpID0+IHtcblx0XHRsZXQgdmFsdWUgPSBkYXRhLnMgKyBkYXRhLmMgKiByYXRpbztcblx0XHRkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgfn4odmFsdWUgKyAodmFsdWUgPCAwID8gLS41IDogLjUpKSArIGRhdGEudSwgZGF0YSk7XG5cdH0sXG5cdF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlID0gKHJhdGlvLCBkYXRhKSA9PiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPyBkYXRhLmUgOiBkYXRhLmIsIGRhdGEpLFxuXHRfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA9IChyYXRpbywgZGF0YSkgPT4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvICE9PSAxID8gZGF0YS5iIDogZGF0YS5lLCBkYXRhKSxcblx0X3NldHRlckNTU1N0eWxlID0gKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSA9PiB0YXJnZXQuc3R5bGVbcHJvcGVydHldID0gdmFsdWUsXG5cdF9zZXR0ZXJDU1NQcm9wID0gKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSA9PiB0YXJnZXQuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKSxcblx0X3NldHRlclRyYW5zZm9ybSA9ICh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkgPT4gdGFyZ2V0Ll9nc2FwW3Byb3BlcnR5XSA9IHZhbHVlLFxuXHRfc2V0dGVyU2NhbGUgPSAodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpID0+IHRhcmdldC5fZ3NhcC5zY2FsZVggPSB0YXJnZXQuX2dzYXAuc2NhbGVZID0gdmFsdWUsXG5cdF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIgPSAodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEsIHJhdGlvKSA9PiB7XG5cdFx0bGV0IGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuXHRcdGNhY2hlLnNjYWxlWCA9IGNhY2hlLnNjYWxlWSA9IHZhbHVlO1xuXHRcdGNhY2hlLnJlbmRlclRyYW5zZm9ybShyYXRpbywgY2FjaGUpO1xuXHR9LFxuXHRfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlciA9ICh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSwgcmF0aW8pID0+IHtcblx0XHRsZXQgY2FjaGUgPSB0YXJnZXQuX2dzYXA7XG5cdFx0Y2FjaGVbcHJvcGVydHldID0gdmFsdWU7XG5cdFx0Y2FjaGUucmVuZGVyVHJhbnNmb3JtKHJhdGlvLCBjYWNoZSk7XG5cdH0sXG5cdF90cmFuc2Zvcm1Qcm9wID0gXCJ0cmFuc2Zvcm1cIixcblx0X3RyYW5zZm9ybU9yaWdpblByb3AgPSBfdHJhbnNmb3JtUHJvcCArIFwiT3JpZ2luXCIsXG5cdF9zdXBwb3J0czNELFxuXHRfY3JlYXRlRWxlbWVudCA9ICh0eXBlLCBucykgPT4ge1xuXHRcdGxldCBlID0gX2RvYy5jcmVhdGVFbGVtZW50TlMgPyBfZG9jLmNyZWF0ZUVsZW1lbnROUygobnMgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIpLnJlcGxhY2UoL15odHRwcy8sIFwiaHR0cFwiKSwgdHlwZSkgOiBfZG9jLmNyZWF0ZUVsZW1lbnQodHlwZSk7IC8vc29tZSBzZXJ2ZXJzIHN3YXAgaW4gaHR0cHMgZm9yIGh0dHAgaW4gdGhlIG5hbWVzcGFjZSB3aGljaCBjYW4gYnJlYWsgdGhpbmdzLCBtYWtpbmcgXCJzdHlsZVwiIGluYWNjZXNzaWJsZS5cblx0XHRyZXR1cm4gZS5zdHlsZSA/IGUgOiBfZG9jLmNyZWF0ZUVsZW1lbnQodHlwZSk7IC8vc29tZSBlbnZpcm9ubWVudHMgd29uJ3QgYWxsb3cgYWNjZXNzIHRvIHRoZSBlbGVtZW50J3Mgc3R5bGUgd2hlbiBjcmVhdGVkIHdpdGggYSBuYW1lc3BhY2UgaW4gd2hpY2ggY2FzZSB3ZSBkZWZhdWx0IHRvIHRoZSBzdGFuZGFyZCBjcmVhdGVFbGVtZW50KCkgdG8gd29yayBhcm91bmQgdGhlIGlzc3VlLiBBbHNvIG5vdGUgdGhhdCB3aGVuIEdTQVAgaXMgZW1iZWRkZWQgZGlyZWN0bHkgaW5zaWRlIGFuIFNWRyBmaWxlLCBjcmVhdGVFbGVtZW50KCkgd29uJ3QgYWxsb3cgYWNjZXNzIHRvIHRoZSBzdHlsZSBvYmplY3QgaW4gRmlyZWZveCAoc2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjAyMTUtcHJvYmxlbS11c2luZy10d2Vlbm1heC1pbi1zdGFuZGFsb25lLXNlbGYtY29udGFpbmluZy1zdmctZmlsZS1lcnItY2Fubm90LXNldC1wcm9wZXJ0eS1jc3N0ZXh0LW9mLXVuZGVmaW5lZC8pLlxuXHR9LFxuXHRfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSA9ICh0YXJnZXQsIHByb3BlcnR5LCBza2lwUHJlZml4RmFsbGJhY2spID0+IHtcblx0XHRsZXQgY3MgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG5cdFx0cmV0dXJuIGNzW3Byb3BlcnR5XSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5LnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpIHx8IGNzLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpIHx8ICghc2tpcFByZWZpeEZhbGxiYWNrICYmIF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX2NoZWNrUHJvcFByZWZpeChwcm9wZXJ0eSkgfHwgcHJvcGVydHksIDEpKSB8fCBcIlwiOyAvL2NzcyB2YXJpYWJsZXMgbWF5IG5vdCBuZWVkIGNhcHMgc3dhcHBlZCBvdXQgZm9yIGRhc2hlcyBhbmQgbG93ZXJjYXNlLlxuXHR9LFxuXHRfcHJlZml4ZXMgPSBcIk8sTW96LG1zLE1zLFdlYmtpdFwiLnNwbGl0KFwiLFwiKSxcblx0X2NoZWNrUHJvcFByZWZpeCA9IChwcm9wZXJ0eSwgZWxlbWVudCwgcHJlZmVyUHJlZml4KSA9PiB7XG5cdFx0bGV0IGUgPSBlbGVtZW50IHx8IF90ZW1wRGl2LFxuXHRcdFx0cyA9IGUuc3R5bGUsXG5cdFx0XHRpID0gNTtcblx0XHRpZiAocHJvcGVydHkgaW4gcyAmJiAhcHJlZmVyUHJlZml4KSB7XG5cdFx0XHRyZXR1cm4gcHJvcGVydHk7XG5cdFx0fVxuXHRcdHByb3BlcnR5ID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zdWJzdHIoMSk7XG5cdFx0d2hpbGUgKGktLSAmJiAhKChfcHJlZml4ZXNbaV0rcHJvcGVydHkpIGluIHMpKSB7IH1cblx0XHRyZXR1cm4gKGkgPCAwKSA/IG51bGwgOiAoKGkgPT09IDMpID8gXCJtc1wiIDogKGkgPj0gMCkgPyBfcHJlZml4ZXNbaV0gOiBcIlwiKSArIHByb3BlcnR5O1xuXHR9LFxuXHRfaW5pdENvcmUgPSAoKSA9PiB7XG5cdFx0aWYgKF93aW5kb3dFeGlzdHMoKSAmJiB3aW5kb3cuZG9jdW1lbnQpIHtcblx0XHRcdF93aW4gPSB3aW5kb3c7XG5cdFx0XHRfZG9jID0gX3dpbi5kb2N1bWVudDtcblx0XHRcdF9kb2NFbGVtZW50ID0gX2RvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHRfdGVtcERpdiA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpIHx8IHtzdHlsZTp7fX07XG5cdFx0XHRfdGVtcERpdlN0eWxlciA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdFx0X3RyYW5zZm9ybVByb3AgPSBfY2hlY2tQcm9wUHJlZml4KF90cmFuc2Zvcm1Qcm9wKTtcblx0XHRcdF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiO1xuXHRcdFx0X3RlbXBEaXYuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyLXdpZHRoOjA7bGluZS1oZWlnaHQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtwYWRkaW5nOjBcIjsgLy9tYWtlIHN1cmUgdG8gb3ZlcnJpZGUgY2VydGFpbiBwcm9wZXJ0aWVzIHRoYXQgbWF5IGNvbnRhbWluYXRlIG1lYXN1cmVtZW50cywgaW4gY2FzZSB0aGUgdXNlciBoYXMgb3ZlcnJlYWNoaW5nIHN0eWxlIHNoZWV0cy5cblx0XHRcdF9zdXBwb3J0czNEID0gISFfY2hlY2tQcm9wUHJlZml4KFwicGVyc3BlY3RpdmVcIik7XG5cdFx0XHRfcGx1Z2luSW5pdHRlZCA9IDE7XG5cdFx0fVxuXHR9LFxuXHRfZ2V0QkJveEhhY2sgPSBmdW5jdGlvbihzd2FwSWZQb3NzaWJsZSkgeyAvL3dvcmtzIGFyb3VuZCBpc3N1ZXMgaW4gc29tZSBicm93c2VycyAobGlrZSBGaXJlZm94KSB0aGF0IGRvbid0IGNvcnJlY3RseSByZXBvcnQgZ2V0QkJveCgpIG9uIFNWRyBlbGVtZW50cyBpbnNpZGUgYSA8ZGVmcz4gZWxlbWVudCBhbmQvb3IgPG1hc2s+LiBXZSB0cnkgY3JlYXRpbmcgYW4gU1ZHLCBhZGRpbmcgaXQgdG8gdGhlIGRvY3VtZW50RWxlbWVudCBhbmQgdG9zcyB0aGUgZWxlbWVudCBpbiB0aGVyZSBzbyB0aGF0IGl0J3MgZGVmaW5pdGVseSBwYXJ0IG9mIHRoZSByZW5kZXJpbmcgdHJlZSwgdGhlbiBncmFiIHRoZSBiYm94IGFuZCBpZiBpdCB3b3Jrcywgd2UgYWN0dWFsbHkgc3dhcCBvdXQgdGhlIG9yaWdpbmFsIGdldEJCb3goKSBtZXRob2QgZm9yIG91ciBvd24gdGhhdCBkb2VzIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW5ldmVyIGdldEJCb3ggaXMgbmVlZGVkLiBUaGlzIGhlbHBzIGVuc3VyZSB0aGF0IHBlcmZvcm1hbmNlIGlzIG9wdGltYWwgKG9ubHkgZG8gYWxsIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW4gYWJzb2x1dGVseSBuZWNlc3NhcnkuLi5tb3N0IGVsZW1lbnRzIGRvbid0IG5lZWQgaXQpLlxuXHRcdGxldCBzdmcgPSBfY3JlYXRlRWxlbWVudChcInN2Z1wiLCAodGhpcy5vd25lclNWR0VsZW1lbnQgJiYgdGhpcy5vd25lclNWR0VsZW1lbnQuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikpIHx8IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiksXG5cdFx0XHRvbGRQYXJlbnQgPSB0aGlzLnBhcmVudE5vZGUsXG5cdFx0XHRvbGRTaWJsaW5nID0gdGhpcy5uZXh0U2libGluZyxcblx0XHRcdG9sZENTUyA9IHRoaXMuc3R5bGUuY3NzVGV4dCxcblx0XHRcdGJib3g7XG5cdFx0X2RvY0VsZW1lbnQuYXBwZW5kQ2hpbGQoc3ZnKTtcblx0XHRzdmcuYXBwZW5kQ2hpbGQodGhpcyk7XG5cdFx0dGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXHRcdGlmIChzd2FwSWZQb3NzaWJsZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YmJveCA9IHRoaXMuZ2V0QkJveCgpO1xuXHRcdFx0XHR0aGlzLl9nc2FwQkJveCA9IHRoaXMuZ2V0QkJveDsgLy9zdG9yZSB0aGUgb3JpZ2luYWxcblx0XHRcdFx0dGhpcy5nZXRCQm94ID0gX2dldEJCb3hIYWNrO1xuXHRcdFx0fSBjYXRjaCAoZSkgeyB9XG5cdFx0fSBlbHNlIGlmICh0aGlzLl9nc2FwQkJveCkge1xuXHRcdFx0YmJveCA9IHRoaXMuX2dzYXBCQm94KCk7XG5cdFx0fVxuXHRcdGlmIChvbGRQYXJlbnQpIHtcblx0XHRcdGlmIChvbGRTaWJsaW5nKSB7XG5cdFx0XHRcdG9sZFBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgb2xkU2libGluZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGRQYXJlbnQuYXBwZW5kQ2hpbGQodGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHN2Zyk7XG5cdFx0dGhpcy5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTO1xuXHRcdHJldHVybiBiYm94O1xuXHR9LFxuXHRfZ2V0QXR0cmlidXRlRmFsbGJhY2tzID0gKHRhcmdldCwgYXR0cmlidXRlc0FycmF5KSA9PiB7XG5cdFx0bGV0IGkgPSBhdHRyaWJ1dGVzQXJyYXkubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGlmICh0YXJnZXQuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZXNBcnJheVtpXSkpIHtcblx0XHRcdFx0cmV0dXJuIHRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlc0FycmF5W2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdF9nZXRCQm94ID0gdGFyZ2V0ID0+IHtcblx0XHRsZXQgYm91bmRzO1xuXHRcdHRyeSB7XG5cdFx0XHRib3VuZHMgPSB0YXJnZXQuZ2V0QkJveCgpOyAvL0ZpcmVmb3ggdGhyb3dzIGVycm9ycyBpZiB5b3UgdHJ5IGNhbGxpbmcgZ2V0QkJveCgpIG9uIGFuIFNWRyBlbGVtZW50IHRoYXQncyBub3QgcmVuZGVyZWQgKGxpa2UgaW4gYSA8c3ltYm9sPiBvciA8ZGVmcz4pLiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02MTIxMThcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Ym91bmRzID0gX2dldEJCb3hIYWNrLmNhbGwodGFyZ2V0LCB0cnVlKTtcblx0XHR9XG5cdFx0KGJvdW5kcyAmJiAoYm91bmRzLndpZHRoIHx8IGJvdW5kcy5oZWlnaHQpKSB8fCB0YXJnZXQuZ2V0QkJveCA9PT0gX2dldEJCb3hIYWNrIHx8IChib3VuZHMgPSBfZ2V0QkJveEhhY2suY2FsbCh0YXJnZXQsIHRydWUpKTtcblx0XHQvL3NvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgbWlzcmVwb3J0IHRoZSBib3VuZHMgaWYgdGhlIGVsZW1lbnQgaGFzIHplcm8gd2lkdGggYW5kIGhlaWdodCAoaXQganVzdCBhc3N1bWVzIGl0J3MgYXQgeDowLCB5OjApLCB0aHVzIHdlIG5lZWQgdG8gbWFudWFsbHkgZ3JhYiB0aGUgcG9zaXRpb24gaW4gdGhhdCBjYXNlLlxuXHRcdHJldHVybiAoYm91bmRzICYmICFib3VuZHMud2lkdGggJiYgIWJvdW5kcy54ICYmICFib3VuZHMueSkgPyB7eDogK19nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBbXCJ4XCIsXCJjeFwiLFwieDFcIl0pIHx8IDAsIHk6K19nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBbXCJ5XCIsXCJjeVwiLFwieTFcIl0pIHx8IDAsIHdpZHRoOjAsIGhlaWdodDowfSA6IGJvdW5kcztcblx0fSxcblx0X2lzU1ZHID0gZSA9PiAhIShlLmdldENUTSAmJiAoIWUucGFyZW50Tm9kZSB8fCBlLm93bmVyU1ZHRWxlbWVudCkgJiYgX2dldEJCb3goZSkpLCAvL3JlcG9ydHMgaWYgdGhlIGVsZW1lbnQgaXMgYW4gU1ZHIG9uIHdoaWNoIGdldEJCb3goKSBhY3R1YWxseSB3b3Jrc1xuXHRfcmVtb3ZlUHJvcGVydHkgPSAodGFyZ2V0LCBwcm9wZXJ0eSkgPT4ge1xuXHRcdGlmIChwcm9wZXJ0eSkge1xuXHRcdFx0bGV0IHN0eWxlID0gdGFyZ2V0LnN0eWxlO1xuXHRcdFx0aWYgKHByb3BlcnR5IGluIF90cmFuc2Zvcm1Qcm9wcyAmJiBwcm9wZXJ0eSAhPT0gX3RyYW5zZm9ybU9yaWdpblByb3ApIHtcblx0XHRcdFx0cHJvcGVydHkgPSBfdHJhbnNmb3JtUHJvcDtcblx0XHRcdH1cblx0XHRcdGlmIChzdHlsZS5yZW1vdmVQcm9wZXJ0eSkge1xuXHRcdFx0XHRpZiAocHJvcGVydHkuc3Vic3RyKDAsMikgPT09IFwibXNcIiB8fCBwcm9wZXJ0eS5zdWJzdHIoMCw2KSA9PT0gXCJ3ZWJraXRcIikgeyAvL01pY3Jvc29mdCBhbmQgc29tZSBXZWJraXQgYnJvd3NlcnMgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3RhbmRhcmQgb2YgY2FwaXRhbGl6aW5nIHRoZSBmaXJzdCBwcmVmaXggY2hhcmFjdGVyLCBzbyB3ZSBhZGp1c3Qgc28gdGhhdCB3aGVuIHdlIHByZWZpeCB0aGUgY2FwcyB3aXRoIGEgZGFzaCwgaXQncyBjb3JyZWN0IChvdGhlcndpc2UgaXQnZCBiZSBcIm1zLXRyYW5zZm9ybVwiIGluc3RlYWQgb2YgXCItbXMtdHJhbnNmb3JtXCIgZm9yIElFOSwgZm9yIGV4YW1wbGUpXG5cdFx0XHRcdFx0cHJvcGVydHkgPSBcIi1cIiArIHByb3BlcnR5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3BlcnR5LnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuXHRcdFx0fSBlbHNlIHsgLy9ub3RlOiBvbGQgdmVyc2lvbnMgb2YgSUUgdXNlIFwicmVtb3ZlQXR0cmlidXRlKClcIiBpbnN0ZWFkIG9mIFwicmVtb3ZlUHJvcGVydHkoKVwiXG5cdFx0XHRcdHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRfYWRkTm9uVHdlZW5pbmdQVCA9IChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGJlZ2lubmluZywgZW5kLCBvbmx5U2V0QXRFbmQpID0+IHtcblx0XHRsZXQgcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIDAsIDEsIG9ubHlTZXRBdEVuZCA/IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kIDogX3JlbmRlck5vblR3ZWVuaW5nVmFsdWUpO1xuXHRcdHBsdWdpbi5fcHQgPSBwdDtcblx0XHRwdC5iID0gYmVnaW5uaW5nO1xuXHRcdHB0LmUgPSBlbmQ7XG5cdFx0cGx1Z2luLl9wcm9wcy5wdXNoKHByb3BlcnR5KTtcblx0XHRyZXR1cm4gcHQ7XG5cdH0sXG5cdF9ub25Db252ZXJ0aWJsZVVuaXRzID0ge2RlZzoxLCByYWQ6MSwgdHVybjoxfSxcblx0Ly90YWtlcyBhIHNpbmdsZSB2YWx1ZSBsaWtlIDIwcHggYW5kIGNvbnZlcnRzIGl0IHRvIHRoZSB1bml0IHNwZWNpZmllZCwgbGlrZSBcIiVcIiwgcmV0dXJuaW5nIG9ubHkgdGhlIG51bWVyaWMgYW1vdW50LlxuXHRfY29udmVydFRvVW5pdCA9ICh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgdW5pdCkgPT4ge1xuXHRcdGxldCBjdXJWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpIHx8IDAsXG5cdFx0XHRjdXJVbml0ID0gKHZhbHVlICsgXCJcIikudHJpbSgpLnN1YnN0cigoY3VyVmFsdWUgKyBcIlwiKS5sZW5ndGgpIHx8IFwicHhcIiwgLy8gc29tZSBicm93c2VycyBsZWF2ZSBleHRyYSB3aGl0ZXNwYWNlIGF0IHRoZSBiZWdpbm5pbmcgb2YgQ1NTIHZhcmlhYmxlcywgaGVuY2UgdGhlIG5lZWQgdG8gdHJpbSgpXG5cdFx0XHRzdHlsZSA9IF90ZW1wRGl2LnN0eWxlLFxuXHRcdFx0aG9yaXpvbnRhbCA9IF9ob3Jpem9udGFsRXhwLnRlc3QocHJvcGVydHkpLFxuXHRcdFx0aXNSb290U1ZHID0gdGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzdmdcIixcblx0XHRcdG1lYXN1cmVQcm9wZXJ0eSA9IChpc1Jvb3RTVkcgPyBcImNsaWVudFwiIDogXCJvZmZzZXRcIikgKyAoaG9yaXpvbnRhbCA/IFwiV2lkdGhcIiA6IFwiSGVpZ2h0XCIpLFxuXHRcdFx0YW1vdW50ID0gMTAwLFxuXHRcdFx0dG9QaXhlbHMgPSB1bml0ID09PSBcInB4XCIsXG5cdFx0XHR0b1BlcmNlbnQgPSB1bml0ID09PSBcIiVcIixcblx0XHRcdHB4LCBwYXJlbnQsIGNhY2hlLCBpc1NWRztcblx0XHRpZiAodW5pdCA9PT0gY3VyVW5pdCB8fCAhY3VyVmFsdWUgfHwgX25vbkNvbnZlcnRpYmxlVW5pdHNbdW5pdF0gfHwgX25vbkNvbnZlcnRpYmxlVW5pdHNbY3VyVW5pdF0pIHtcblx0XHRcdHJldHVybiBjdXJWYWx1ZTtcblx0XHR9XG5cdFx0KGN1clVuaXQgIT09IFwicHhcIiAmJiAhdG9QaXhlbHMpICYmIChjdXJWYWx1ZSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBcInB4XCIpKTtcblx0XHRpc1NWRyA9IHRhcmdldC5nZXRDVE0gJiYgX2lzU1ZHKHRhcmdldCk7XG5cdFx0aWYgKCh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldIHx8IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikpKSB7XG5cdFx0XHRweCA9IGlzU1ZHID8gdGFyZ2V0LmdldEJCb3goKVtob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gOiB0YXJnZXRbbWVhc3VyZVByb3BlcnR5XTtcblx0XHRcdHJldHVybiBfcm91bmQodG9QZXJjZW50ID8gY3VyVmFsdWUgLyBweCAqIGFtb3VudCA6IGN1clZhbHVlIC8gMTAwICogcHgpO1xuXHRcdH1cblx0XHRzdHlsZVtob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gPSBhbW91bnQgKyAodG9QaXhlbHMgPyBjdXJVbml0IDogdW5pdCk7XG5cdFx0cGFyZW50ID0gKH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikgfHwgKHVuaXQgPT09IFwiZW1cIiAmJiB0YXJnZXQuYXBwZW5kQ2hpbGQgJiYgIWlzUm9vdFNWRykpID8gdGFyZ2V0IDogdGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0aWYgKGlzU1ZHKSB7XG5cdFx0XHRwYXJlbnQgPSAodGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCB8fCB7fSkucGFyZW50Tm9kZTtcblx0XHR9XG5cdFx0aWYgKCFwYXJlbnQgfHwgcGFyZW50ID09PSBfZG9jIHx8ICFwYXJlbnQuYXBwZW5kQ2hpbGQpIHtcblx0XHRcdHBhcmVudCA9IF9kb2MuYm9keTtcblx0XHR9XG5cdFx0Y2FjaGUgPSBwYXJlbnQuX2dzYXA7XG5cdFx0aWYgKGNhY2hlICYmIHRvUGVyY2VudCAmJiBjYWNoZS53aWR0aCAmJiBob3Jpem9udGFsICYmIGNhY2hlLnRpbWUgPT09IF90aWNrZXIudGltZSkge1xuXHRcdFx0cmV0dXJuIF9yb3VuZChjdXJWYWx1ZSAvIGNhY2hlLndpZHRoICogYW1vdW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0KHRvUGVyY2VudCB8fCBjdXJVbml0ID09PSBcIiVcIikgJiYgKHN0eWxlLnBvc2l0aW9uID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBcInBvc2l0aW9uXCIpKTtcblx0XHRcdChwYXJlbnQgPT09IHRhcmdldCkgJiYgKHN0eWxlLnBvc2l0aW9uID0gXCJzdGF0aWNcIik7IC8vIGxpa2UgZm9yIGJvcmRlclJhZGl1cywgaWYgaXQncyBhICUgd2UgbXVzdCBoYXZlIGl0IHJlbGF0aXZlIHRvIHRoZSB0YXJnZXQgaXRzZWxmIGJ1dCB0aGF0IG1heSBub3QgaGF2ZSBwb3NpdGlvbjogcmVsYXRpdmUgb3IgcG9zaXRpb246IGFic29sdXRlIGluIHdoaWNoIGNhc2UgaXQnZCBnbyB1cCB0aGUgY2hhaW4gdW50aWwgaXQgZmluZHMgaXRzIG9mZnNldFBhcmVudCAoYmFkKS4gcG9zaXRpb246IHN0YXRpYyBwcm90ZWN0cyBhZ2FpbnN0IHRoYXQuXG5cdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoX3RlbXBEaXYpO1xuXHRcdFx0cHggPSBfdGVtcERpdlttZWFzdXJlUHJvcGVydHldO1xuXHRcdFx0cGFyZW50LnJlbW92ZUNoaWxkKF90ZW1wRGl2KTtcblx0XHRcdHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdFx0aWYgKGhvcml6b250YWwgJiYgdG9QZXJjZW50KSB7XG5cdFx0XHRcdGNhY2hlID0gX2dldENhY2hlKHBhcmVudCk7XG5cdFx0XHRcdGNhY2hlLnRpbWUgPSBfdGlja2VyLnRpbWU7XG5cdFx0XHRcdGNhY2hlLndpZHRoID0gcGFyZW50W21lYXN1cmVQcm9wZXJ0eV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfcm91bmQodG9QaXhlbHMgPyBweCAqIGN1clZhbHVlIC8gYW1vdW50IDogcHggJiYgY3VyVmFsdWUgPyBhbW91bnQgLyBweCAqIGN1clZhbHVlIDogMCk7XG5cdH0sXG5cdF9nZXQgPSAodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkgPT4ge1xuXHRcdGxldCB2YWx1ZTtcblx0XHRfcGx1Z2luSW5pdHRlZCB8fCBfaW5pdENvcmUoKTtcblx0XHRpZiAoKHByb3BlcnR5IGluIF9wcm9wZXJ0eUFsaWFzZXMpICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG5cdFx0XHRwcm9wZXJ0eSA9IF9wcm9wZXJ0eUFsaWFzZXNbcHJvcGVydHldO1xuXHRcdFx0aWYgKH5wcm9wZXJ0eS5pbmRleE9mKFwiLFwiKSkge1xuXHRcdFx0XHRwcm9wZXJ0eSA9IHByb3BlcnR5LnNwbGl0KFwiLFwiKVswXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKF90cmFuc2Zvcm1Qcm9wc1twcm9wZXJ0eV0gJiYgcHJvcGVydHkgIT09IFwidHJhbnNmb3JtXCIpIHtcblx0XHRcdHZhbHVlID0gX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgdW5jYWNoZSk7XG5cdFx0XHR2YWx1ZSA9IChwcm9wZXJ0eSAhPT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIikgPyB2YWx1ZVtwcm9wZXJ0eV0gOiB2YWx1ZS5zdmcgPyB2YWx1ZS5vcmlnaW4gOiBfZmlyc3RUd29Pbmx5KF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybU9yaWdpblByb3ApKSArIFwiIFwiICsgdmFsdWUuek9yaWdpbiArIFwicHhcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsdWUgPSB0YXJnZXQuc3R5bGVbcHJvcGVydHldO1xuXHRcdFx0aWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJhdXRvXCIgfHwgdW5jYWNoZSB8fCB+KHZhbHVlICsgXCJcIikuaW5kZXhPZihcImNhbGMoXCIpKSB7XG5cdFx0XHRcdHZhbHVlID0gKF9zcGVjaWFsUHJvcHNbcHJvcGVydHldICYmIF9zcGVjaWFsUHJvcHNbcHJvcGVydHldKHRhcmdldCwgcHJvcGVydHksIHVuaXQpKSB8fCBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB8fCBfZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSkgfHwgKHByb3BlcnR5ID09PSBcIm9wYWNpdHlcIiA/IDEgOiAwKTsgLy8gbm90ZTogc29tZSBicm93c2VycywgbGlrZSBGaXJlZm94LCBkb24ndCByZXBvcnQgYm9yZGVyUmFkaXVzIGNvcnJlY3RseSEgSW5zdGVhZCwgaXQgb25seSByZXBvcnRzIGV2ZXJ5IGNvcm5lciBsaWtlICBib3JkZXJUb3BMZWZ0UmFkaXVzXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB1bml0ICYmICF+KHZhbHVlICsgXCJcIikudHJpbSgpLmluZGV4T2YoXCIgXCIpID8gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHVuaXQpICsgdW5pdCA6IHZhbHVlO1xuXG5cdH0sXG5cdF90d2VlbkNvbXBsZXhDU1NTdHJpbmcgPSBmdW5jdGlvbih0YXJnZXQsIHByb3AsIHN0YXJ0LCBlbmQpIHsgLy9ub3RlOiB3ZSBjYWxsIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcuY2FsbChwbHVnaW5JbnN0YW5jZS4uLikgdG8gZW5zdXJlIHRoYXQgaXQncyBzY29wZWQgcHJvcGVybHkuIFdlIG1heSBjYWxsIGl0IGZyb20gd2l0aGluIGEgcGx1Z2luIHRvbywgdGh1cyBcInRoaXNcIiB3b3VsZCByZWZlciB0byB0aGUgcGx1Z2luLlxuXHRcdGlmICghc3RhcnQgfHwgc3RhcnQgPT09IFwibm9uZVwiKSB7IC8vIHNvbWUgYnJvd3NlcnMgbGlrZSBTYWZhcmkgYWN0dWFsbHkgUFJFRkVSIHRoZSBwcmVmaXhlZCBwcm9wZXJ0eSBhbmQgbWlzLXJlcG9ydCB0aGUgdW5wcmVmaXhlZCB2YWx1ZSBsaWtlIGNsaXBQYXRoIChCVUcpLiBJbiBvdGhlciB3b3JkcywgZXZlbiB0aG91Z2ggY2xpcFBhdGggZXhpc3RzIGluIHRoZSBzdHlsZSAoXCJjbGlwUGF0aFwiIGluIHRhcmdldC5zdHlsZSkgYW5kIGl0J3Mgc2V0IGluIHRoZSBDU1MgcHJvcGVybHkgKGFsb25nIHdpdGggLXdlYmtpdC1jbGlwLXBhdGgpLCBTYWZhcmkgcmVwb3J0cyBjbGlwUGF0aCBhcyBcIm5vbmVcIiB3aGVyZWFzIFdlYmtpdENsaXBQYXRoIHJlcG9ydHMgYWNjdXJhdGVseSBsaWtlIFwiZWxsaXBzZSgxMDAlIDAlIGF0IDUwJSAwJSlcIiwgc28gaW4gdGhpcyBjYXNlIHdlIG11c3QgU1dJVENIIHRvIHVzaW5nIHRoZSBwcmVmaXhlZCBwcm9wZXJ0eSBpbnN0ZWFkLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8xODMxMC1jbGlwcGF0aC1kb2VzbnQtd29yay1vbi1pb3MvXG5cdFx0XHRsZXQgcCA9IF9jaGVja1Byb3BQcmVmaXgocHJvcCwgdGFyZ2V0LCAxKSxcblx0XHRcdFx0cyA9IHAgJiYgX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwLCAxKTtcblx0XHRcdGlmIChzICYmIHMgIT09IHN0YXJ0KSB7XG5cdFx0XHRcdHByb3AgPSBwO1xuXHRcdFx0XHRzdGFydCA9IHM7XG5cdFx0XHR9IGVsc2UgaWYgKHByb3AgPT09IFwiYm9yZGVyQ29sb3JcIikge1xuXHRcdFx0XHRzdGFydCA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgXCJib3JkZXJUb3BDb2xvclwiKTsgLy8gRmlyZWZveCBidWc6IGFsd2F5cyByZXBvcnRzIFwiYm9yZGVyQ29sb3JcIiBhcyBcIlwiLCBzbyB3ZSBtdXN0IGZhbGwgYmFjayB0byBib3JkZXJUb3BDb2xvci4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjQ1ODMtaG93LXRvLXJldHVybi1jb2xvcnMtdGhhdC1pLWhhZC1hZnRlci1yZXZlcnNlL1xuXHRcdFx0fVxuXHRcdH1cblx0XHRsZXQgcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQuc3R5bGUsIHByb3AsIDAsIDEsIF9yZW5kZXJDb21wbGV4U3RyaW5nKSxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdG1hdGNoSW5kZXggPSAwLFxuXHRcdFx0YSwgcmVzdWx0LFx0c3RhcnRWYWx1ZXMsIHN0YXJ0TnVtLCBjb2xvciwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGVuZE51bSwgY2h1bmssIGVuZFVuaXQsIHN0YXJ0VW5pdCwgcmVsYXRpdmUsIGVuZFZhbHVlcztcblx0XHRwdC5iID0gc3RhcnQ7XG5cdFx0cHQuZSA9IGVuZDtcblx0XHRzdGFydCArPSBcIlwiOyAvL2Vuc3VyZSB2YWx1ZXMgYXJlIHN0cmluZ3Ncblx0XHRlbmQgKz0gXCJcIjtcblx0XHRpZiAoZW5kID09PSBcImF1dG9cIikge1xuXHRcdFx0dGFyZ2V0LnN0eWxlW3Byb3BdID0gZW5kO1xuXHRcdFx0ZW5kID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB8fCBlbmQ7XG5cdFx0XHR0YXJnZXQuc3R5bGVbcHJvcF0gPSBzdGFydDtcblx0XHR9XG5cdFx0YSA9IFtzdGFydCwgZW5kXTtcblx0XHRfY29sb3JTdHJpbmdGaWx0ZXIoYSk7IC8vcGFzcyBhbiBhcnJheSB3aXRoIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHZhbHVlcyBhbmQgbGV0IHRoZSBmaWx0ZXIgZG8gd2hhdGV2ZXIgaXQgbmVlZHMgdG8gdGhlIHZhbHVlcy4gSWYgY29sb3JzIGFyZSBmb3VuZCwgaXQgcmV0dXJucyB0cnVlIGFuZCB0aGVuIHdlIG11c3QgbWF0Y2ggd2hlcmUgdGhlIGNvbG9yIHNob3dzIHVwIG9yZGVyLXdpc2UgYmVjYXVzZSBmb3IgdGhpbmdzIGxpa2UgYm94U2hhZG93LCBzb21ldGltZXMgdGhlIGJyb3dzZXIgcHJvdmlkZXMgdGhlIGNvbXB1dGVkIHZhbHVlcyB3aXRoIHRoZSBjb2xvciBGSVJTVCwgYnV0IHRoZSB1c2VyIHByb3ZpZGVzIGl0IHdpdGggdGhlIGNvbG9yIExBU1QsIHNvIGZsaXAgdGhlbSBpZiBuZWNlc3NhcnkuIFNhbWUgZm9yIGRyb3Atc2hhZG93KCkuXG5cdFx0c3RhcnQgPSBhWzBdO1xuXHRcdGVuZCA9IGFbMV07XG5cdFx0c3RhcnRWYWx1ZXMgPSBzdGFydC5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xuXHRcdGVuZFZhbHVlcyA9IGVuZC5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xuXHRcdGlmIChlbmRWYWx1ZXMubGVuZ3RoKSB7XG5cdFx0XHR3aGlsZSAoKHJlc3VsdCA9IF9udW1XaXRoVW5pdEV4cC5leGVjKGVuZCkpKSB7XG5cdFx0XHRcdGVuZFZhbHVlID0gcmVzdWx0WzBdO1xuXHRcdFx0XHRjaHVuayA9IGVuZC5zdWJzdHJpbmcoaW5kZXgsIHJlc3VsdC5pbmRleCk7XG5cdFx0XHRcdGlmIChjb2xvcikge1xuXHRcdFx0XHRcdGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNodW5rLnN1YnN0cigtNSkgPT09IFwicmdiYShcIiB8fCBjaHVuay5zdWJzdHIoLTUpID09PSBcImhzbGEoXCIpIHtcblx0XHRcdFx0XHRjb2xvciA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZFZhbHVlICE9PSAoc3RhcnRWYWx1ZSA9IHN0YXJ0VmFsdWVzW21hdGNoSW5kZXgrK10gfHwgXCJcIikpIHtcblx0XHRcdFx0XHRzdGFydE51bSA9IHBhcnNlRmxvYXQoc3RhcnRWYWx1ZSkgfHwgMDtcblx0XHRcdFx0XHRzdGFydFVuaXQgPSBzdGFydFZhbHVlLnN1YnN0cigoc3RhcnROdW0gKyBcIlwiKS5sZW5ndGgpO1xuXHRcdFx0XHRcdHJlbGF0aXZlID0gKGVuZFZhbHVlLmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gKyhlbmRWYWx1ZS5jaGFyQXQoMCkgKyBcIjFcIikgOiAwO1xuXHRcdFx0XHRcdGlmIChyZWxhdGl2ZSkge1xuXHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBlbmRWYWx1ZS5zdWJzdHIoMik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuXHRcdFx0XHRcdGVuZFVuaXQgPSBlbmRWYWx1ZS5zdWJzdHIoKGVuZE51bSArIFwiXCIpLmxlbmd0aCk7XG5cdFx0XHRcdFx0aW5kZXggPSBfbnVtV2l0aFVuaXRFeHAubGFzdEluZGV4IC0gZW5kVW5pdC5sZW5ndGg7XG5cdFx0XHRcdFx0aWYgKCFlbmRVbml0KSB7IC8vaWYgc29tZXRoaW5nIGxpa2UgXCJwZXJzcGVjdGl2ZTozMDBcIiBpcyBwYXNzZWQgaW4gYW5kIHdlIG11c3QgYWRkIGEgdW5pdCB0byB0aGUgZW5kXG5cdFx0XHRcdFx0XHRlbmRVbml0ID0gZW5kVW5pdCB8fCBfY29uZmlnLnVuaXRzW3Byb3BdIHx8IHN0YXJ0VW5pdDtcblx0XHRcdFx0XHRcdGlmIChpbmRleCA9PT0gZW5kLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRlbmQgKz0gZW5kVW5pdDtcblx0XHRcdFx0XHRcdFx0cHQuZSArPSBlbmRVbml0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoc3RhcnRVbml0ICE9PSBlbmRVbml0KSB7XG5cdFx0XHRcdFx0XHRzdGFydE51bSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkgfHwgMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly90aGVzZSBuZXN0ZWQgUHJvcFR3ZWVucyBhcmUgaGFuZGxlZCBpbiBhIHNwZWNpYWwgd2F5IC0gd2UnbGwgbmV2ZXIgYWN0dWFsbHkgY2FsbCBhIHJlbmRlciBvciBzZXR0ZXIgbWV0aG9kIG9uIHRoZW0uIFdlJ2xsIGp1c3QgbG9vcCB0aHJvdWdoIHRoZW0gaW4gdGhlIHBhcmVudCBjb21wbGV4IHN0cmluZyBQcm9wVHdlZW4ncyByZW5kZXIgbWV0aG9kLlxuXHRcdFx0XHRcdHB0Ll9wdCA9IHtcblx0XHRcdFx0XHRcdF9uZXh0OnB0Ll9wdCxcblx0XHRcdFx0XHRcdHA6KGNodW5rIHx8IChtYXRjaEluZGV4ID09PSAxKSkgPyBjaHVuayA6IFwiLFwiLCAvL25vdGU6IFNWRyBzcGVjIGFsbG93cyBvbWlzc2lvbiBvZiBjb21tYS9zcGFjZSB3aGVuIGEgbmVnYXRpdmUgc2lnbiBpcyB3ZWRnZWQgYmV0d2VlbiB0d28gbnVtYmVycywgbGlrZSAyLjUtNS4zIGluc3RlYWQgb2YgMi41LC01LjMgYnV0IHdoZW4gdHdlZW5pbmcsIHRoZSBuZWdhdGl2ZSB2YWx1ZSBtYXkgc3dpdGNoIHRvIHBvc2l0aXZlLCBzbyB3ZSBpbnNlcnQgdGhlIGNvbW1hIGp1c3QgaW4gY2FzZS5cblx0XHRcdFx0XHRcdHM6c3RhcnROdW0sXG5cdFx0XHRcdFx0XHRjOnJlbGF0aXZlID8gcmVsYXRpdmUgKiBlbmROdW0gOiBlbmROdW0gLSBzdGFydE51bSxcblx0XHRcdFx0XHRcdG06KGNvbG9yICYmIGNvbG9yIDwgNCkgfHwgcHJvcCA9PT0gXCJ6SW5kZXhcIiA/IE1hdGgucm91bmQgOiAwXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cHQuYyA9IChpbmRleCA8IGVuZC5sZW5ndGgpID8gZW5kLnN1YnN0cmluZyhpbmRleCwgZW5kLmxlbmd0aCkgOiBcIlwiOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgcGFydCBvZiB0aGUgc3RyaW5nIChhZnRlciB0aGUgbGFzdCBudW1iZXIpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHB0LnIgPSBwcm9wID09PSBcImRpc3BsYXlcIiAmJiBlbmQgPT09IFwibm9uZVwiID8gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQgOiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZTtcblx0XHR9XG5cdFx0X3JlbEV4cC50ZXN0KGVuZCkgJiYgKHB0LmUgPSAwKTsgLy9pZiB0aGUgZW5kIHN0cmluZyBjb250YWlucyByZWxhdGl2ZSB2YWx1ZXMgb3IgZHluYW1pYyByYW5kb20oLi4uKSB2YWx1ZXMsIGRlbGV0ZSB0aGUgZW5kIGl0IHNvIHRoYXQgb24gdGhlIGZpbmFsIHJlbmRlciB3ZSBkb24ndCBhY3R1YWxseSBzZXQgaXQgdG8gdGhlIHN0cmluZyB3aXRoICs9IG9yIC09IGNoYXJhY3RlcnMgKGZvcmNlcyBpdCB0byB1c2UgdGhlIGNhbGN1bGF0ZWQgdmFsdWUpLlxuXHRcdHRoaXMuX3B0ID0gcHQ7IC8vc3RhcnQgdGhlIGxpbmtlZCBsaXN0IHdpdGggdGhpcyBuZXcgUHJvcFR3ZWVuLiBSZW1lbWJlciwgd2UgY2FsbCBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwocGx1Z2luSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhbm90aGVyIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblx0XHRyZXR1cm4gcHQ7XG5cdH0sXG5cdF9rZXl3b3JkVG9QZXJjZW50ID0ge3RvcDpcIjAlXCIsIGJvdHRvbTpcIjEwMCVcIiwgbGVmdDpcIjAlXCIsIHJpZ2h0OlwiMTAwJVwiLCBjZW50ZXI6XCI1MCVcIn0sXG5cdF9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzID0gdmFsdWUgPT4ge1xuXHRcdGxldCBzcGxpdCA9IHZhbHVlLnNwbGl0KFwiIFwiKSxcblx0XHRcdHggPSBzcGxpdFswXSxcblx0XHRcdHkgPSBzcGxpdFsxXSB8fCBcIjUwJVwiO1xuXHRcdGlmICh4ID09PSBcInRvcFwiIHx8IHggPT09IFwiYm90dG9tXCIgfHwgeSA9PT0gXCJsZWZ0XCIgfHwgeSA9PT0gXCJyaWdodFwiKSB7IC8vdGhlIHVzZXIgcHJvdmlkZWQgdGhlbSBpbiB0aGUgd3Jvbmcgb3JkZXIsIHNvIGZsaXAgdGhlbVxuXHRcdFx0dmFsdWUgPSB4O1xuXHRcdFx0eCA9IHk7XG5cdFx0XHR5ID0gdmFsdWU7XG5cdFx0fVxuXHRcdHNwbGl0WzBdID0gX2tleXdvcmRUb1BlcmNlbnRbeF0gfHwgeDtcblx0XHRzcGxpdFsxXSA9IF9rZXl3b3JkVG9QZXJjZW50W3ldIHx8IHk7XG5cdFx0cmV0dXJuIHNwbGl0LmpvaW4oXCIgXCIpO1xuXHR9LFxuXHRfcmVuZGVyQ2xlYXJQcm9wcyA9IChyYXRpbywgZGF0YSkgPT4ge1xuXHRcdGlmIChkYXRhLnR3ZWVuICYmIGRhdGEudHdlZW4uX3RpbWUgPT09IGRhdGEudHdlZW4uX2R1cikge1xuXHRcdFx0bGV0IHRhcmdldCA9IGRhdGEudCxcblx0XHRcdFx0c3R5bGUgPSB0YXJnZXQuc3R5bGUsXG5cdFx0XHRcdHByb3BzID0gZGF0YS51LFxuXHRcdFx0XHRjYWNoZSA9IHRhcmdldC5fZ3NhcCxcblx0XHRcdFx0cHJvcCwgY2xlYXJUcmFuc2Zvcm1zLCBpO1xuXHRcdFx0aWYgKHByb3BzID09PSBcImFsbFwiIHx8IHByb3BzID09PSB0cnVlKSB7XG5cdFx0XHRcdHN0eWxlLmNzc1RleHQgPSBcIlwiO1xuXHRcdFx0XHRjbGVhclRyYW5zZm9ybXMgPSAxO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHJvcHMgPSBwcm9wcy5zcGxpdChcIixcIik7XG5cdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHByb3AgPSBwcm9wc1tpXTtcblx0XHRcdFx0XHRpZiAoX3RyYW5zZm9ybVByb3BzW3Byb3BdKSB7XG5cdFx0XHRcdFx0XHRjbGVhclRyYW5zZm9ybXMgPSAxO1xuXHRcdFx0XHRcdFx0cHJvcCA9IChwcm9wID09PSBcInRyYW5zZm9ybU9yaWdpblwiKSA/IF90cmFuc2Zvcm1PcmlnaW5Qcm9wIDogX3RyYW5zZm9ybVByb3A7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xlYXJUcmFuc2Zvcm1zKSB7XG5cdFx0XHRcdF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKTtcblx0XHRcdFx0aWYgKGNhY2hlKSB7XG5cdFx0XHRcdFx0Y2FjaGUuc3ZnICYmIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG5cdFx0XHRcdFx0X3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSk7IC8vIGZvcmNlIGFsbCB0aGUgY2FjaGVkIHZhbHVlcyBiYWNrIHRvIFwibm9ybWFsXCIvaWRlbnRpdHksIG90aGVyd2lzZSBpZiB0aGVyZSdzIGFub3RoZXIgdHdlZW4gdGhhdCdzIGFscmVhZHkgc2V0IHRvIHJlbmRlciB0cmFuc2Zvcm1zIG9uIHRoaXMgZWxlbWVudCwgaXQgY291bGQgZGlzcGxheSB0aGUgd3JvbmcgdmFsdWVzLlxuXHRcdFx0XHRcdGNhY2hlLnVuY2FjaGUgPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHQvLyBub3RlOiBzcGVjaWFsUHJvcHMgc2hvdWxkIHJldHVybiAxIGlmIChhbmQgb25seSBpZikgdGhleSBoYXZlIGEgbm9uLXplcm8gcHJpb3JpdHkuIEl0IGluZGljYXRlcyB3ZSBuZWVkIHRvIHNvcnQgdGhlIGxpbmtlZCBsaXN0LlxuXHRfc3BlY2lhbFByb3BzID0ge1xuXHRcdGNsZWFyUHJvcHMocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBlbmRWYWx1ZSwgdHdlZW4pIHtcblx0XHRcdGlmICh0d2Vlbi5kYXRhICE9PSBcImlzRnJvbVN0YXJ0XCIpIHtcblx0XHRcdFx0bGV0IHB0ID0gcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgMCwgMCwgX3JlbmRlckNsZWFyUHJvcHMpO1xuXHRcdFx0XHRwdC51ID0gZW5kVmFsdWU7XG5cdFx0XHRcdHB0LnByID0gLTEwO1xuXHRcdFx0XHRwdC50d2VlbiA9IHR3ZWVuO1xuXHRcdFx0XHRwbHVnaW4uX3Byb3BzLnB1c2gocHJvcGVydHkpO1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0LyogY2xhc3NOYW1lIGZlYXR1cmUgKGFib3V0IDAuNGtiIGd6aXBwZWQpLlxuXHRcdCwgY2xhc3NOYW1lKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XG5cdFx0XHRsZXQgX3JlbmRlckNsYXNzTmFtZSA9IChyYXRpbywgZGF0YSkgPT4ge1xuXHRcdFx0XHRcdGRhdGEuY3NzLnJlbmRlcihyYXRpbywgZGF0YS5jc3MpO1xuXHRcdFx0XHRcdGlmICghcmF0aW8gfHwgcmF0aW8gPT09IDEpIHtcblx0XHRcdFx0XHRcdGxldCBpbmxpbmUgPSBkYXRhLnJtdixcblx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gZGF0YS50LFxuXHRcdFx0XHRcdFx0XHRwO1xuXHRcdFx0XHRcdFx0dGFyZ2V0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHJhdGlvID8gZGF0YS5lIDogZGF0YS5iKTtcblx0XHRcdFx0XHRcdGZvciAocCBpbiBpbmxpbmUpIHtcblx0XHRcdFx0XHRcdFx0X3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfZ2V0QWxsU3R5bGVzID0gKHRhcmdldCkgPT4ge1xuXHRcdFx0XHRcdGxldCBzdHlsZXMgPSB7fSxcblx0XHRcdFx0XHRcdGNvbXB1dGVkID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLFxuXHRcdFx0XHRcdFx0cDtcblx0XHRcdFx0XHRmb3IgKHAgaW4gY29tcHV0ZWQpIHtcblx0XHRcdFx0XHRcdGlmIChpc05hTihwKSAmJiBwICE9PSBcImNzc1RleHRcIiAmJiBwICE9PSBcImxlbmd0aFwiKSB7XG5cdFx0XHRcdFx0XHRcdHN0eWxlc1twXSA9IGNvbXB1dGVkW3BdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfc2V0RGVmYXVsdHMoc3R5bGVzLCBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKSk7XG5cdFx0XHRcdFx0cmV0dXJuIHN0eWxlcztcblx0XHRcdFx0fSxcblx0XHRcdFx0c3RhcnRDbGFzc0xpc3QgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIiksXG5cdFx0XHRcdHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuXHRcdFx0XHRjc3NUZXh0ID0gc3R5bGUuY3NzVGV4dCxcblx0XHRcdFx0Y2FjaGUgPSB0YXJnZXQuX2dzYXAsXG5cdFx0XHRcdGNsYXNzUFQgPSBjYWNoZS5jbGFzc1BULFxuXHRcdFx0XHRpbmxpbmVUb1JlbW92ZUF0RW5kID0ge30sXG5cdFx0XHRcdGRhdGEgPSB7dDp0YXJnZXQsIHBsdWdpbjpwbHVnaW4sIHJtdjppbmxpbmVUb1JlbW92ZUF0RW5kLCBiOnN0YXJ0Q2xhc3NMaXN0LCBlOihlbmRWYWx1ZS5jaGFyQXQoMSkgIT09IFwiPVwiKSA/IGVuZFZhbHVlIDogc3RhcnRDbGFzc0xpc3QucmVwbGFjZShuZXcgUmVnRXhwKFwiKD86XFxcXHN8XilcIiArIGVuZFZhbHVlLnN1YnN0cigyKSArIFwiKD8hW1xcXFx3LV0pXCIpLCBcIlwiKSArICgoZW5kVmFsdWUuY2hhckF0KDApID09PSBcIitcIikgPyBcIiBcIiArIGVuZFZhbHVlLnN1YnN0cigyKSA6IFwiXCIpfSxcblx0XHRcdFx0Y2hhbmdpbmdWYXJzID0ge30sXG5cdFx0XHRcdHN0YXJ0VmFycyA9IF9nZXRBbGxTdHlsZXModGFyZ2V0KSxcblx0XHRcdFx0dHJhbnNmb3JtUmVsYXRlZCA9IC8odHJhbnNmb3JtfHBlcnNwZWN0aXZlKS9pLFxuXHRcdFx0XHRlbmRWYXJzLCBwO1xuXHRcdFx0aWYgKGNsYXNzUFQpIHtcblx0XHRcdFx0Y2xhc3NQVC5yKDEsIGNsYXNzUFQuZCk7XG5cdFx0XHRcdF9yZW1vdmVMaW5rZWRMaXN0SXRlbShjbGFzc1BULmQucGx1Z2luLCBjbGFzc1BULCBcIl9wdFwiKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBkYXRhLmUpO1xuXHRcdFx0ZW5kVmFycyA9IF9nZXRBbGxTdHlsZXModGFyZ2V0LCB0cnVlKTtcblx0XHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBzdGFydENsYXNzTGlzdCk7XG5cdFx0XHRmb3IgKHAgaW4gZW5kVmFycykge1xuXHRcdFx0XHRpZiAoZW5kVmFyc1twXSAhPT0gc3RhcnRWYXJzW3BdICYmICF0cmFuc2Zvcm1SZWxhdGVkLnRlc3QocCkpIHtcblx0XHRcdFx0XHRjaGFuZ2luZ1ZhcnNbcF0gPSBlbmRWYXJzW3BdO1xuXHRcdFx0XHRcdGlmICghc3R5bGVbcF0gJiYgc3R5bGVbcF0gIT09IFwiMFwiKSB7XG5cdFx0XHRcdFx0XHRpbmxpbmVUb1JlbW92ZUF0RW5kW3BdID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhY2hlLmNsYXNzUFQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIFwiY2xhc3NOYW1lXCIsIDAsIDAsIF9yZW5kZXJDbGFzc05hbWUsIGRhdGEsIDAsIC0xMSk7XG5cdFx0XHRpZiAoc3R5bGUuY3NzVGV4dCAhPT0gY3NzVGV4dCkgeyAvL29ubHkgYXBwbHkgaWYgdGhpbmdzIGNoYW5nZS4gT3RoZXJ3aXNlLCBpbiBjYXNlcyBsaWtlIGEgYmFja2dyb3VuZC1pbWFnZSB0aGF0J3MgcHVsbGVkIGR5bmFtaWNhbGx5LCBpdCBjb3VsZCBjYXVzZSBhIHJlZnJlc2guIFNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIwMzY4LXBvc3NpYmxlLWdzYXAtYnVnLXN3aXRjaGluZy1jbGFzc25hbWVzLWluLWNocm9tZS8uXG5cdFx0XHRcdHN0eWxlLmNzc1RleHQgPSBjc3NUZXh0OyAvL3dlIHJlY29yZGVkIGNzc1RleHQgYmVmb3JlIHdlIHN3YXBwZWQgY2xhc3NlcyBhbmQgcmFuIF9nZXRBbGxTdHlsZXMoKSBiZWNhdXNlIGluIGNhc2VzIHdoZW4gYSBjbGFzc05hbWUgdHdlZW4gaXMgb3ZlcndyaXR0ZW4sIHdlIHJlbW92ZSBhbGwgdGhlIHJlbGF0ZWQgdHdlZW5pbmcgcHJvcGVydGllcyBmcm9tIHRoYXQgY2xhc3MgY2hhbmdlIChvdGhlcndpc2UgY2xhc3Mtc3BlY2lmaWMgc3R1ZmYgY2FuJ3Qgb3ZlcnJpZGUgcHJvcGVydGllcyB3ZSd2ZSBkaXJlY3RseSBzZXQgb24gdGhlIHRhcmdldCdzIHN0eWxlIG9iamVjdCBkdWUgdG8gc3BlY2lmaWNpdHkpLlxuXHRcdFx0fVxuXHRcdFx0X3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgdHJ1ZSk7IC8vdG8gY2xlYXIgdGhlIGNhY2hpbmcgb2YgdHJhbnNmb3Jtc1xuXHRcdFx0ZGF0YS5jc3MgPSBuZXcgZ3NhcC5wbHVnaW5zLmNzcygpO1xuXHRcdFx0ZGF0YS5jc3MuaW5pdCh0YXJnZXQsIGNoYW5naW5nVmFycywgdHdlZW4pO1xuXHRcdFx0cGx1Z2luLl9wcm9wcy5wdXNoKC4uLmRhdGEuY3NzLl9wcm9wcyk7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0Ki9cblx0fSxcblxuXG5cblxuXG5cdC8qXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqIFRSQU5TRk9STVNcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICovXG5cdF9pZGVudGl0eTJETWF0cml4ID0gWzEsMCwwLDEsMCwwXSxcblx0X3JvdGF0aW9uYWxQcm9wZXJ0aWVzID0ge30sXG5cdF9pc051bGxUcmFuc2Zvcm0gPSB2YWx1ZSA9PiAodmFsdWUgPT09IFwibWF0cml4KDEsIDAsIDAsIDEsIDAsIDApXCIgfHwgdmFsdWUgPT09IFwibm9uZVwiIHx8ICF2YWx1ZSksXG5cdF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkgPSB0YXJnZXQgPT4ge1xuXHRcdGxldCBtYXRyaXhTdHJpbmcgPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKTtcblx0XHRyZXR1cm4gX2lzTnVsbFRyYW5zZm9ybShtYXRyaXhTdHJpbmcpID8gX2lkZW50aXR5MkRNYXRyaXggOiBtYXRyaXhTdHJpbmcuc3Vic3RyKDcpLm1hdGNoKF9udW1FeHApLm1hcChfcm91bmQpO1xuXHR9LFxuXHRfZ2V0TWF0cml4ID0gKHRhcmdldCwgZm9yY2UyRCkgPT4ge1xuXHRcdGxldCBjYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBfZ2V0Q2FjaGUodGFyZ2V0KSxcblx0XHRcdHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuXHRcdFx0bWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpLFxuXHRcdFx0cGFyZW50LCBuZXh0U2libGluZywgdGVtcCwgYWRkZWRUb0RPTTtcblx0XHRpZiAoY2FjaGUuc3ZnICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikpIHtcblx0XHRcdHRlbXAgPSB0YXJnZXQudHJhbnNmb3JtLmJhc2VWYWwuY29uc29saWRhdGUoKS5tYXRyaXg7IC8vZW5zdXJlcyB0aGF0IGV2ZW4gY29tcGxleCB2YWx1ZXMgbGlrZSBcInRyYW5zbGF0ZSg1MCw2MCkgcm90YXRlKDEzNSwwLDApXCIgYXJlIHBhcnNlZCBiZWNhdXNlIGl0IG1hc2hlcyBpdCBpbnRvIGEgbWF0cml4LlxuXHRcdFx0bWF0cml4ID0gW3RlbXAuYSwgdGVtcC5iLCB0ZW1wLmMsIHRlbXAuZCwgdGVtcC5lLCB0ZW1wLmZdO1xuXHRcdFx0cmV0dXJuIChtYXRyaXguam9pbihcIixcIikgPT09IFwiMSwwLDAsMSwwLDBcIikgPyBfaWRlbnRpdHkyRE1hdHJpeCA6IG1hdHJpeDtcblx0XHR9IGVsc2UgaWYgKG1hdHJpeCA9PT0gX2lkZW50aXR5MkRNYXRyaXggJiYgIXRhcmdldC5vZmZzZXRQYXJlbnQgJiYgdGFyZ2V0ICE9PSBfZG9jRWxlbWVudCAmJiAhY2FjaGUuc3ZnKSB7IC8vbm90ZTogaWYgb2Zmc2V0UGFyZW50IGlzIG51bGwsIHRoYXQgbWVhbnMgdGhlIGVsZW1lbnQgaXNuJ3QgaW4gdGhlIG5vcm1hbCBkb2N1bWVudCBmbG93LCBsaWtlIGlmIGl0IGhhcyBkaXNwbGF5Om5vbmUgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIGRpc3BsYXk6bm9uZSkuIEZpcmVmb3ggcmV0dXJucyBudWxsIGZvciBnZXRDb21wdXRlZFN0eWxlKCkgaWYgdGhlIGVsZW1lbnQgaXMgaW4gYW4gaWZyYW1lIHRoYXQgaGFzIGRpc3BsYXk6bm9uZS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG5cdFx0XHQvL2Jyb3dzZXJzIGRvbid0IHJlcG9ydCB0cmFuc2Zvcm1zIGFjY3VyYXRlbHkgdW5sZXNzIHRoZSBlbGVtZW50IGlzIGluIHRoZSBET00gYW5kIGhhcyBhIGRpc3BsYXkgdmFsdWUgdGhhdCdzIG5vdCBcIm5vbmVcIi4gRmlyZWZveCBhbmQgTWljcm9zb2Z0IGJyb3dzZXJzIGhhdmUgYSBwYXJ0aWFsIGJ1ZyB3aGVyZSB0aGV5J2xsIHJlcG9ydCB0cmFuc2Zvcm1zIGV2ZW4gaWYgZGlzcGxheTpub25lIEJVVCBub3QgYW55IHBlcmNlbnRhZ2UtYmFzZWQgdmFsdWVzIGxpa2UgdHJhbnNsYXRlKC01MCUsIDhweCkgd2lsbCBiZSByZXBvcnRlZCBhcyBpZiBpdCdzIHRyYW5zbGF0ZSgwLCA4cHgpLlxuXHRcdFx0dGVtcCA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXHRcdFx0cGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIXBhcmVudCB8fCAhdGFyZ2V0Lm9mZnNldFBhcmVudCkgeyAvLyBub3RlOiBpbiAzLjMuMCB3ZSBzd2l0Y2hlZCB0YXJnZXQub2Zmc2V0UGFyZW50IHRvIF9kb2MuYm9keS5jb250YWlucyh0YXJnZXQpIHRvIGF2b2lkIFtzb21ldGltZXMgdW5uZWNlc3NhcnldIE11dGF0aW9uT2JzZXJ2ZXIgY2FsbHMgYnV0IHRoYXQgd2Fzbid0IGFkZXF1YXRlIGJlY2F1c2UgdGhlcmUgYXJlIGVkZ2UgY2FzZXMgd2hlcmUgbmVzdGVkIHBvc2l0aW9uOiBmaXhlZCBlbGVtZW50cyBuZWVkIHRvIGdldCByZXBhcmVudGVkIHRvIGFjY3VyYXRlbHkgc2Vuc2UgdHJhbnNmb3Jtcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbnNvY2svR1NBUC9pc3N1ZXMvMzg4IGFuZCBodHRwczovL2dpdGh1Yi5jb20vZ3JlZW5zb2NrL0dTQVAvaXNzdWVzLzM3NVxuXHRcdFx0XHRhZGRlZFRvRE9NID0gMTsgLy9mbGFnXG5cdFx0XHRcdG5leHRTaWJsaW5nID0gdGFyZ2V0Lm5leHRTaWJsaW5nO1xuXHRcdFx0XHRfZG9jRWxlbWVudC5hcHBlbmRDaGlsZCh0YXJnZXQpOyAvL3dlIG11c3QgYWRkIGl0IHRvIHRoZSBET00gaW4gb3JkZXIgdG8gZ2V0IHZhbHVlcyBwcm9wZXJseVxuXHRcdFx0fVxuXHRcdFx0bWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpO1xuXHRcdFx0dGVtcCA/IChzdHlsZS5kaXNwbGF5ID0gdGVtcCkgOiBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBcImRpc3BsYXlcIik7XG5cdFx0XHRpZiAoYWRkZWRUb0RPTSkge1xuXHRcdFx0XHRuZXh0U2libGluZyA/IHBhcmVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LCBuZXh0U2libGluZykgOiBwYXJlbnQgPyBwYXJlbnQuYXBwZW5kQ2hpbGQodGFyZ2V0KSA6IF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHRhcmdldCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAoZm9yY2UyRCAmJiBtYXRyaXgubGVuZ3RoID4gNikgPyBbbWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFs0XSwgbWF0cml4WzVdLCBtYXRyaXhbMTJdLCBtYXRyaXhbMTNdXSA6IG1hdHJpeDtcblx0fSxcblx0X2FwcGx5U1ZHT3JpZ2luID0gKHRhcmdldCwgb3JpZ2luLCBvcmlnaW5Jc0Fic29sdXRlLCBzbW9vdGgsIG1hdHJpeEFycmF5LCBwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykgPT4ge1xuXHRcdGxldCBjYWNoZSA9IHRhcmdldC5fZ3NhcCxcblx0XHRcdG1hdHJpeCA9IG1hdHJpeEFycmF5IHx8IF9nZXRNYXRyaXgodGFyZ2V0LCB0cnVlKSxcblx0XHRcdHhPcmlnaW5PbGQgPSBjYWNoZS54T3JpZ2luIHx8IDAsXG5cdFx0XHR5T3JpZ2luT2xkID0gY2FjaGUueU9yaWdpbiB8fCAwLFxuXHRcdFx0eE9mZnNldE9sZCA9IGNhY2hlLnhPZmZzZXQgfHwgMCxcblx0XHRcdHlPZmZzZXRPbGQgPSBjYWNoZS55T2Zmc2V0IHx8IDAsXG5cdFx0XHRhID0gbWF0cml4WzBdLFxuXHRcdFx0YiA9IG1hdHJpeFsxXSxcblx0XHRcdGMgPSBtYXRyaXhbMl0sXG5cdFx0XHRkID0gbWF0cml4WzNdLFxuXHRcdFx0dHggPSBtYXRyaXhbNF0sXG5cdFx0XHR0eSA9IG1hdHJpeFs1XSxcblx0XHRcdG9yaWdpblNwbGl0ID0gb3JpZ2luLnNwbGl0KFwiIFwiKSxcblx0XHRcdHhPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpblNwbGl0WzBdKSB8fCAwLFxuXHRcdFx0eU9yaWdpbiA9IHBhcnNlRmxvYXQob3JpZ2luU3BsaXRbMV0pIHx8IDAsXG5cdFx0XHRib3VuZHMsIGRldGVybWluYW50LCB4LCB5O1xuXHRcdGlmICghb3JpZ2luSXNBYnNvbHV0ZSkge1xuXHRcdFx0Ym91bmRzID0gX2dldEJCb3godGFyZ2V0KTtcblx0XHRcdHhPcmlnaW4gPSBib3VuZHMueCArICh+b3JpZ2luU3BsaXRbMF0uaW5kZXhPZihcIiVcIikgPyB4T3JpZ2luIC8gMTAwICogYm91bmRzLndpZHRoIDogeE9yaWdpbik7XG5cdFx0XHR5T3JpZ2luID0gYm91bmRzLnkgKyAofigob3JpZ2luU3BsaXRbMV0gfHwgb3JpZ2luU3BsaXRbMF0pLmluZGV4T2YoXCIlXCIpKSA/IHlPcmlnaW4gLyAxMDAgKiBib3VuZHMuaGVpZ2h0IDogeU9yaWdpbik7XG5cdFx0fSBlbHNlIGlmIChtYXRyaXggIT09IF9pZGVudGl0eTJETWF0cml4ICYmIChkZXRlcm1pbmFudCA9IChhICogZCAtIGIgKiBjKSkpIHsgLy9pZiBpdCdzIHplcm8gKGxpa2UgaWYgc2NhbGVYIGFuZCBzY2FsZVkgYXJlIHplcm8pLCBza2lwIGl0IHRvIGF2b2lkIGVycm9ycyB3aXRoIGRpdmlkaW5nIGJ5IHplcm8uXG5cdFx0XHR4ID0geE9yaWdpbiAqIChkIC8gZGV0ZXJtaW5hbnQpICsgeU9yaWdpbiAqICgtYyAvIGRldGVybWluYW50KSArICgoYyAqIHR5IC0gZCAqIHR4KSAvIGRldGVybWluYW50KTtcblx0XHRcdHkgPSB4T3JpZ2luICogKC1iIC8gZGV0ZXJtaW5hbnQpICsgeU9yaWdpbiAqIChhIC8gZGV0ZXJtaW5hbnQpIC0gKChhICogdHkgLSBiICogdHgpIC8gZGV0ZXJtaW5hbnQpO1xuXHRcdFx0eE9yaWdpbiA9IHg7XG5cdFx0XHR5T3JpZ2luID0geTtcblx0XHR9XG5cdFx0aWYgKHNtb290aCB8fCAoc21vb3RoICE9PSBmYWxzZSAmJiBjYWNoZS5zbW9vdGgpKSB7XG5cdFx0XHR0eCA9IHhPcmlnaW4gLSB4T3JpZ2luT2xkO1xuXHRcdFx0dHkgPSB5T3JpZ2luIC0geU9yaWdpbk9sZDtcblx0XHRcdGNhY2hlLnhPZmZzZXQgPSB4T2Zmc2V0T2xkICsgKHR4ICogYSArIHR5ICogYykgLSB0eDtcblx0XHRcdGNhY2hlLnlPZmZzZXQgPSB5T2Zmc2V0T2xkICsgKHR4ICogYiArIHR5ICogZCkgLSB0eTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FjaGUueE9mZnNldCA9IGNhY2hlLnlPZmZzZXQgPSAwO1xuXHRcdH1cblx0XHRjYWNoZS54T3JpZ2luID0geE9yaWdpbjtcblx0XHRjYWNoZS55T3JpZ2luID0geU9yaWdpbjtcblx0XHRjYWNoZS5zbW9vdGggPSAhIXNtb290aDtcblx0XHRjYWNoZS5vcmlnaW4gPSBvcmlnaW47XG5cdFx0Y2FjaGUub3JpZ2luSXNBYnNvbHV0ZSA9ICEhb3JpZ2luSXNBYnNvbHV0ZTtcblx0XHR0YXJnZXQuc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdID0gXCIwcHggMHB4XCI7IC8vb3RoZXJ3aXNlLCBpZiBzb21lb25lIHNldHMgIGFuIG9yaWdpbiB2aWEgQ1NTLCBpdCB3aWxsIGxpa2VseSBpbnRlcmZlcmUgd2l0aCB0aGUgU1ZHIHRyYW5zZm9ybSBhdHRyaWJ1dGUgb25lcyAoYmVjYXVzZSByZW1lbWJlciwgd2UncmUgYmFraW5nIHRoZSBvcmlnaW4gaW50byB0aGUgbWF0cml4KCkgdmFsdWUpLlxuXHRcdGlmIChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykge1xuXHRcdFx0X2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInhPcmlnaW5cIiwgeE9yaWdpbk9sZCwgeE9yaWdpbik7XG5cdFx0XHRfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieU9yaWdpblwiLCB5T3JpZ2luT2xkLCB5T3JpZ2luKTtcblx0XHRcdF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ4T2Zmc2V0XCIsIHhPZmZzZXRPbGQsIGNhY2hlLnhPZmZzZXQpO1xuXHRcdFx0X2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInlPZmZzZXRcIiwgeU9mZnNldE9sZCwgY2FjaGUueU9mZnNldCk7XG5cdFx0fVxuXHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIiwgeE9yaWdpbiArIFwiIFwiICsgeU9yaWdpbik7XG5cdH0sXG5cdF9wYXJzZVRyYW5zZm9ybSA9ICh0YXJnZXQsIHVuY2FjaGUpID0+IHtcblx0XHRsZXQgY2FjaGUgPSB0YXJnZXQuX2dzYXAgfHwgbmV3IEdTQ2FjaGUodGFyZ2V0KTtcblx0XHRpZiAoXCJ4XCIgaW4gY2FjaGUgJiYgIXVuY2FjaGUgJiYgIWNhY2hlLnVuY2FjaGUpIHtcblx0XHRcdHJldHVybiBjYWNoZTtcblx0XHR9XG5cdFx0bGV0IHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuXHRcdFx0aW52ZXJ0ZWRTY2FsZVggPSBjYWNoZS5zY2FsZVggPCAwLFxuXHRcdFx0cHggPSBcInB4XCIsXG5cdFx0XHRkZWcgPSBcImRlZ1wiLFxuXHRcdFx0b3JpZ2luID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtT3JpZ2luUHJvcCkgfHwgXCIwXCIsXG5cdFx0XHR4LCB5LCB6LCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHJvdGF0aW9uWCwgcm90YXRpb25ZLCBza2V3WCwgc2tld1ksIHBlcnNwZWN0aXZlLCB4T3JpZ2luLCB5T3JpZ2luLFxuXHRcdFx0bWF0cml4LCBhbmdsZSwgY29zLCBzaW4sIGEsIGIsIGMsIGQsIGExMiwgYTIyLCB0MSwgdDIsIHQzLCBhMTMsIGEyMywgYTMzLCBhNDIsIGE0MywgYTMyO1xuXHRcdHggPSB5ID0geiA9IHJvdGF0aW9uID0gcm90YXRpb25YID0gcm90YXRpb25ZID0gc2tld1ggPSBza2V3WSA9IHBlcnNwZWN0aXZlID0gMDtcblx0XHRzY2FsZVggPSBzY2FsZVkgPSAxO1xuXHRcdGNhY2hlLnN2ZyA9ICEhKHRhcmdldC5nZXRDVE0gJiYgX2lzU1ZHKHRhcmdldCkpO1xuXHRcdG1hdHJpeCA9IF9nZXRNYXRyaXgodGFyZ2V0LCBjYWNoZS5zdmcpO1xuXHRcdGlmIChjYWNoZS5zdmcpIHtcblx0XHRcdHQxID0gKCFjYWNoZS51bmNhY2hlIHx8IG9yaWdpbiA9PT0gXCIwcHggMHB4XCIpICYmICF1bmNhY2hlICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIik7IC8vIGlmIG9yaWdpbiBpcyAwLDAgYW5kIGNhY2hlLnVuY2FjaGUgaXMgdHJ1ZSwgbGV0IHRoZSByZWNvcmRlZCBkYXRhLXN2Zy1vcmlnaW4gc3RheS4gT3RoZXJ3aXNlLCB3aGVuZXZlciB3ZSBzZXQgY2FjaGUudW5jYWNoZSB0byB0cnVlLCB3ZSdkIG5lZWQgdG8gc2V0IGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gKGNhY2hlLnhPcmlnaW4gLSBiYm94LngpICsgXCJweCBcIiArIChjYWNoZS55T3JpZ2luIC0gYmJveC55KSArIFwicHhcIi4gUmVtZW1iZXIsIHRvIHdvcmsgYXJvdW5kIGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzIHdlIGFsd2F5cyBmb3JjZSBTVkcgZWxlbWVudHMnIHRyYW5zZm9ybU9yaWdpbiB0byAwLDAgYW5kIG9mZnNldCB0aGUgdHJhbnNsYXRpb24gYWNjb3JkaW5nbHkuXG5cdFx0XHRfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCB0MSB8fCBvcmlnaW4sICEhdDEgfHwgY2FjaGUub3JpZ2luSXNBYnNvbHV0ZSwgY2FjaGUuc21vb3RoICE9PSBmYWxzZSwgbWF0cml4KTtcblx0XHR9XG5cdFx0eE9yaWdpbiA9IGNhY2hlLnhPcmlnaW4gfHwgMDtcblx0XHR5T3JpZ2luID0gY2FjaGUueU9yaWdpbiB8fCAwO1xuXHRcdGlmIChtYXRyaXggIT09IF9pZGVudGl0eTJETWF0cml4KSB7XG5cdFx0XHRhID0gbWF0cml4WzBdOyAvL2ExMVxuXHRcdFx0YiA9IG1hdHJpeFsxXTsgLy9hMjFcblx0XHRcdGMgPSBtYXRyaXhbMl07IC8vYTMxXG5cdFx0XHRkID0gbWF0cml4WzNdOyAvL2E0MVxuXHRcdFx0eCA9IGExMiA9IG1hdHJpeFs0XTtcblx0XHRcdHkgPSBhMjIgPSBtYXRyaXhbNV07XG5cblx0XHRcdC8vMkQgbWF0cml4XG5cdFx0XHRpZiAobWF0cml4Lmxlbmd0aCA9PT0gNikge1xuXHRcdFx0XHRzY2FsZVggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG5cdFx0XHRcdHNjYWxlWSA9IE1hdGguc3FydChkICogZCArIGMgKiBjKTtcblx0XHRcdFx0cm90YXRpb24gPSAoYSB8fCBiKSA/IF9hdGFuMihiLCBhKSAqIF9SQUQyREVHIDogMDsgLy9ub3RlOiBpZiBzY2FsZVggaXMgMCwgd2UgY2Fubm90IGFjY3VyYXRlbHkgbWVhc3VyZSByb3RhdGlvbi4gU2FtZSBmb3Igc2tld1ggd2l0aCBhIHNjYWxlWSBvZiAwLiBUaGVyZWZvcmUsIHdlIGRlZmF1bHQgdG8gdGhlIHByZXZpb3VzbHkgcmVjb3JkZWQgdmFsdWUgKG9yIHplcm8gaWYgdGhhdCBkb2Vzbid0IGV4aXN0KS5cblx0XHRcdFx0c2tld1ggPSAoYyB8fCBkKSA/IF9hdGFuMihjLCBkKSAqIF9SQUQyREVHICsgcm90YXRpb24gOiAwO1xuXHRcdFx0XHRza2V3WCAmJiAoc2NhbGVZICo9IE1hdGguYWJzKE1hdGguY29zKHNrZXdYICogX0RFRzJSQUQpKSk7XG5cdFx0XHRcdGlmIChjYWNoZS5zdmcpIHtcblx0XHRcdFx0XHR4IC09IHhPcmlnaW4gLSAoeE9yaWdpbiAqIGEgKyB5T3JpZ2luICogYyk7XG5cdFx0XHRcdFx0eSAtPSB5T3JpZ2luIC0gKHhPcmlnaW4gKiBiICsgeU9yaWdpbiAqIGQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vM0QgbWF0cml4XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhMzIgPSBtYXRyaXhbNl07XG5cdFx0XHRcdGE0MiA9IG1hdHJpeFs3XTtcblx0XHRcdFx0YTEzID0gbWF0cml4WzhdO1xuXHRcdFx0XHRhMjMgPSBtYXRyaXhbOV07XG5cdFx0XHRcdGEzMyA9IG1hdHJpeFsxMF07XG5cdFx0XHRcdGE0MyA9IG1hdHJpeFsxMV07XG5cdFx0XHRcdHggPSBtYXRyaXhbMTJdO1xuXHRcdFx0XHR5ID0gbWF0cml4WzEzXTtcblx0XHRcdFx0eiA9IG1hdHJpeFsxNF07XG5cblx0XHRcdFx0YW5nbGUgPSBfYXRhbjIoYTMyLCBhMzMpO1xuXHRcdFx0XHRyb3RhdGlvblggPSBhbmdsZSAqIF9SQUQyREVHO1xuXHRcdFx0XHQvL3JvdGF0aW9uWFxuXHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuXHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG5cdFx0XHRcdFx0dDEgPSBhMTIqY29zK2ExMypzaW47XG5cdFx0XHRcdFx0dDIgPSBhMjIqY29zK2EyMypzaW47XG5cdFx0XHRcdFx0dDMgPSBhMzIqY29zK2EzMypzaW47XG5cdFx0XHRcdFx0YTEzID0gYTEyKi1zaW4rYTEzKmNvcztcblx0XHRcdFx0XHRhMjMgPSBhMjIqLXNpbithMjMqY29zO1xuXHRcdFx0XHRcdGEzMyA9IGEzMiotc2luK2EzMypjb3M7XG5cdFx0XHRcdFx0YTQzID0gYTQyKi1zaW4rYTQzKmNvcztcblx0XHRcdFx0XHRhMTIgPSB0MTtcblx0XHRcdFx0XHRhMjIgPSB0Mjtcblx0XHRcdFx0XHRhMzIgPSB0Mztcblx0XHRcdFx0fVxuXHRcdFx0XHQvL3JvdGF0aW9uWVxuXHRcdFx0XHRhbmdsZSA9IF9hdGFuMigtYywgYTMzKTtcblx0XHRcdFx0cm90YXRpb25ZID0gYW5nbGUgKiBfUkFEMkRFRztcblx0XHRcdFx0aWYgKGFuZ2xlKSB7XG5cdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcblx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuXHRcdFx0XHRcdHQxID0gYSpjb3MtYTEzKnNpbjtcblx0XHRcdFx0XHR0MiA9IGIqY29zLWEyMypzaW47XG5cdFx0XHRcdFx0dDMgPSBjKmNvcy1hMzMqc2luO1xuXHRcdFx0XHRcdGE0MyA9IGQqc2luK2E0Mypjb3M7XG5cdFx0XHRcdFx0YSA9IHQxO1xuXHRcdFx0XHRcdGIgPSB0Mjtcblx0XHRcdFx0XHRjID0gdDM7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9yb3RhdGlvblpcblx0XHRcdFx0YW5nbGUgPSBfYXRhbjIoYiwgYSk7XG5cdFx0XHRcdHJvdGF0aW9uID0gYW5nbGUgKiBfUkFEMkRFRztcblx0XHRcdFx0aWYgKGFuZ2xlKSB7XG5cdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHRcdFx0XHR0MSA9IGEqY29zK2Iqc2luO1xuXHRcdFx0XHRcdHQyID0gYTEyKmNvcythMjIqc2luO1xuXHRcdFx0XHRcdGIgPSBiKmNvcy1hKnNpbjtcblx0XHRcdFx0XHRhMjIgPSBhMjIqY29zLWExMipzaW47XG5cdFx0XHRcdFx0YSA9IHQxO1xuXHRcdFx0XHRcdGExMiA9IHQyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHJvdGF0aW9uWCAmJiBNYXRoLmFicyhyb3RhdGlvblgpICsgTWF0aC5hYnMocm90YXRpb24pID4gMzU5LjkpIHsgLy93aGVuIHJvdGF0aW9uWSBpcyBzZXQsIGl0IHdpbGwgb2Z0ZW4gYmUgcGFyc2VkIGFzIDE4MCBkZWdyZWVzIGRpZmZlcmVudCB0aGFuIGl0IHNob3VsZCBiZSwgYW5kIHJvdGF0aW9uWCBhbmQgcm90YXRpb24gYm90aCBiZWluZyAxODAgKGl0IGxvb2tzIHRoZSBzYW1lKSwgc28gd2UgYWRqdXN0IGZvciB0aGF0IGhlcmUuXG5cdFx0XHRcdFx0cm90YXRpb25YID0gcm90YXRpb24gPSAwO1xuXHRcdFx0XHRcdHJvdGF0aW9uWSA9IDE4MCAtIHJvdGF0aW9uWTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzY2FsZVggPSBfcm91bmQoTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIgKyBjICogYykpO1xuXHRcdFx0XHRzY2FsZVkgPSBfcm91bmQoTWF0aC5zcXJ0KGEyMiAqIGEyMiArIGEzMiAqIGEzMikpO1xuXHRcdFx0XHRhbmdsZSA9IF9hdGFuMihhMTIsIGEyMik7XG5cdFx0XHRcdHNrZXdYID0gKE1hdGguYWJzKGFuZ2xlKSA+IDAuMDAwMikgPyBhbmdsZSAqIF9SQUQyREVHIDogMDtcblx0XHRcdFx0cGVyc3BlY3RpdmUgPSBhNDMgPyAxIC8gKChhNDMgPCAwKSA/IC1hNDMgOiBhNDMpIDogMDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNhY2hlLnN2ZykgeyAvL3NlbnNlIGlmIHRoZXJlIGFyZSBDU1MgdHJhbnNmb3JtcyBhcHBsaWVkIG9uIGFuIFNWRyBlbGVtZW50IGluIHdoaWNoIGNhc2Ugd2UgbXVzdCBvdmVyd3JpdGUgdGhlbSB3aGVuIHJlbmRlcmluZy4gVGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUgaXMgbW9yZSByZWxpYWJsZSBjcm9zcy1icm93c2VyLCBidXQgd2UgY2FuJ3QganVzdCByZW1vdmUgdGhlIENTUyBvbmVzIGJlY2F1c2UgdGhleSBtYXkgYmUgYXBwbGllZCBpbiBhIENTUyBydWxlIHNvbWV3aGVyZSAobm90IGp1c3QgaW5saW5lKS5cblx0XHRcdFx0dDEgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuXHRcdFx0XHRjYWNoZS5mb3JjZUNTUyA9IHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJcIikgfHwgKCFfaXNOdWxsVHJhbnNmb3JtKF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApKSk7XG5cdFx0XHRcdHQxICYmIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdDEpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChNYXRoLmFicyhza2V3WCkgPiA5MCAmJiBNYXRoLmFicyhza2V3WCkgPCAyNzApIHtcblx0XHRcdGlmIChpbnZlcnRlZFNjYWxlWCkge1xuXHRcdFx0XHRzY2FsZVggKj0gLTE7XG5cdFx0XHRcdHNrZXdYICs9IChyb3RhdGlvbiA8PSAwKSA/IDE4MCA6IC0xODA7XG5cdFx0XHRcdHJvdGF0aW9uICs9IChyb3RhdGlvbiA8PSAwKSA/IDE4MCA6IC0xODA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzY2FsZVkgKj0gLTE7XG5cdFx0XHRcdHNrZXdYICs9IChza2V3WCA8PSAwKSA/IDE4MCA6IC0xODA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhY2hlLnggPSB4IC0gKChjYWNoZS54UGVyY2VudCA9IHggJiYgKGNhY2hlLnhQZXJjZW50IHx8IChNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRXaWR0aCAvIDIpID09PSBNYXRoLnJvdW5kKC14KSA/IC01MCA6IDApKSkgPyB0YXJnZXQub2Zmc2V0V2lkdGggKiBjYWNoZS54UGVyY2VudCAvIDEwMCA6IDApICsgcHg7XG5cdFx0Y2FjaGUueSA9IHkgLSAoKGNhY2hlLnlQZXJjZW50ID0geSAmJiAoY2FjaGUueVBlcmNlbnQgfHwgKE1hdGgucm91bmQodGFyZ2V0Lm9mZnNldEhlaWdodCAvIDIpID09PSBNYXRoLnJvdW5kKC15KSA/IC01MCA6IDApKSkgPyB0YXJnZXQub2Zmc2V0SGVpZ2h0ICogY2FjaGUueVBlcmNlbnQgLyAxMDAgOiAwKSArIHB4O1xuXHRcdGNhY2hlLnogPSB6ICsgcHg7XG5cdFx0Y2FjaGUuc2NhbGVYID0gX3JvdW5kKHNjYWxlWCk7XG5cdFx0Y2FjaGUuc2NhbGVZID0gX3JvdW5kKHNjYWxlWSk7XG5cdFx0Y2FjaGUucm90YXRpb24gPSBfcm91bmQocm90YXRpb24pICsgZGVnO1xuXHRcdGNhY2hlLnJvdGF0aW9uWCA9IF9yb3VuZChyb3RhdGlvblgpICsgZGVnO1xuXHRcdGNhY2hlLnJvdGF0aW9uWSA9IF9yb3VuZChyb3RhdGlvblkpICsgZGVnO1xuXHRcdGNhY2hlLnNrZXdYID0gc2tld1ggKyBkZWc7XG5cdFx0Y2FjaGUuc2tld1kgPSBza2V3WSArIGRlZztcblx0XHRjYWNoZS50cmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IHBlcnNwZWN0aXZlICsgcHg7XG5cdFx0aWYgKChjYWNoZS56T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW4uc3BsaXQoXCIgXCIpWzJdKSB8fCAwKSkge1xuXHRcdFx0c3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdID0gX2ZpcnN0VHdvT25seShvcmlnaW4pO1xuXHRcdH1cblx0XHRjYWNoZS54T2Zmc2V0ID0gY2FjaGUueU9mZnNldCA9IDA7XG5cdFx0Y2FjaGUuZm9yY2UzRCA9IF9jb25maWcuZm9yY2UzRDtcblx0XHRjYWNoZS5yZW5kZXJUcmFuc2Zvcm0gPSBjYWNoZS5zdmcgPyBfcmVuZGVyU1ZHVHJhbnNmb3JtcyA6IF9zdXBwb3J0czNEID8gX3JlbmRlckNTU1RyYW5zZm9ybXMgOiBfcmVuZGVyTm9uM0RUcmFuc2Zvcm1zO1xuXHRcdGNhY2hlLnVuY2FjaGUgPSAwO1xuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0X2ZpcnN0VHdvT25seSA9IHZhbHVlID0+ICh2YWx1ZSA9IHZhbHVlLnNwbGl0KFwiIFwiKSlbMF0gKyBcIiBcIiArIHZhbHVlWzFdLCAvL2ZvciBoYW5kbGluZyB0cmFuc2Zvcm1PcmlnaW4gdmFsdWVzLCBzdHJpcHBpbmcgb3V0IHRoZSAzcmQgZGltZW5zaW9uXG5cdF9hZGRQeFRyYW5zbGF0ZSA9ICh0YXJnZXQsIHN0YXJ0LCB2YWx1ZSkgPT4ge1xuXHRcdGxldCB1bml0ID0gZ2V0VW5pdChzdGFydCk7XG5cdFx0cmV0dXJuIF9yb3VuZChwYXJzZUZsb2F0KHN0YXJ0KSArIHBhcnNlRmxvYXQoX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBcInhcIiwgdmFsdWUgKyBcInB4XCIsIHVuaXQpKSkgKyB1bml0O1xuXHR9LFxuXHRfcmVuZGVyTm9uM0RUcmFuc2Zvcm1zID0gKHJhdGlvLCBjYWNoZSkgPT4ge1xuXHRcdGNhY2hlLnogPSBcIjBweFwiO1xuXHRcdGNhY2hlLnJvdGF0aW9uWSA9IGNhY2hlLnJvdGF0aW9uWCA9IFwiMGRlZ1wiO1xuXHRcdGNhY2hlLmZvcmNlM0QgPSAwO1xuXHRcdF9yZW5kZXJDU1NUcmFuc2Zvcm1zKHJhdGlvLCBjYWNoZSk7XG5cdH0sXG5cdF96ZXJvRGVnID0gXCIwZGVnXCIsXG5cdF96ZXJvUHggPSBcIjBweFwiLFxuXHRfZW5kUGFyZW50aGVzaXMgPSBcIikgXCIsXG5cdF9yZW5kZXJDU1NUcmFuc2Zvcm1zID0gZnVuY3Rpb24ocmF0aW8sIGNhY2hlKSB7XG5cdFx0bGV0IHt4UGVyY2VudCwgeVBlcmNlbnQsIHgsIHksIHosIHJvdGF0aW9uLCByb3RhdGlvblksIHJvdGF0aW9uWCwgc2tld1gsIHNrZXdZLCBzY2FsZVgsIHNjYWxlWSwgdHJhbnNmb3JtUGVyc3BlY3RpdmUsIGZvcmNlM0QsIHRhcmdldCwgek9yaWdpbn0gPSBjYWNoZSB8fCB0aGlzLFxuXHRcdFx0dHJhbnNmb3JtcyA9IFwiXCIsXG5cdFx0XHR1c2UzRCA9IChmb3JjZTNEID09PSBcImF1dG9cIiAmJiByYXRpbyAmJiByYXRpbyAhPT0gMSkgfHwgZm9yY2UzRCA9PT0gdHJ1ZTtcblxuXHRcdC8vIFNhZmFyaSBoYXMgYSBidWcgdGhhdCBjYXVzZXMgaXQgbm90IHRvIHJlbmRlciAzRCB0cmFuc2Zvcm0tb3JpZ2luIHZhbHVlcyBwcm9wZXJseSwgc28gd2UgZm9yY2UgdGhlIHogb3JpZ2luIHRvIDAsIHJlY29yZCBpdCBpbiB0aGUgY2FjaGUsIGFuZCB0aGVuIGRvIHRoZSBtYXRoIGhlcmUgdG8gb2Zmc2V0IHRoZSB0cmFuc2xhdGUgdmFsdWVzIGFjY29yZGluZ2x5IChiYXNpY2FsbHkgZG8gdGhlIDNEIHRyYW5zZm9ybS1vcmlnaW4gcGFydCBtYW51YWxseSlcblx0XHRpZiAoek9yaWdpbiAmJiAocm90YXRpb25YICE9PSBfemVyb0RlZyB8fCByb3RhdGlvblkgIT09IF96ZXJvRGVnKSkge1xuXHRcdFx0bGV0IGFuZ2xlID0gcGFyc2VGbG9hdChyb3RhdGlvblkpICogX0RFRzJSQUQsXG5cdFx0XHRcdGExMyA9IE1hdGguc2luKGFuZ2xlKSxcblx0XHRcdFx0YTMzID0gTWF0aC5jb3MoYW5nbGUpLFxuXHRcdFx0XHRjb3M7XG5cdFx0XHRhbmdsZSA9IHBhcnNlRmxvYXQocm90YXRpb25YKSAqIF9ERUcyUkFEO1xuXHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdFx0eCA9IF9hZGRQeFRyYW5zbGF0ZSh0YXJnZXQsIHgsIGExMyAqIGNvcyAqIC16T3JpZ2luKTtcblx0XHRcdHkgPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB5LCAtTWF0aC5zaW4oYW5nbGUpICogLXpPcmlnaW4pO1xuXHRcdFx0eiA9IF9hZGRQeFRyYW5zbGF0ZSh0YXJnZXQsIHosIGEzMyAqIGNvcyAqIC16T3JpZ2luICsgek9yaWdpbik7XG5cdFx0fVxuXG5cdFx0aWYgKHRyYW5zZm9ybVBlcnNwZWN0aXZlICE9PSBfemVyb1B4KSB7XG5cdFx0XHR0cmFuc2Zvcm1zICs9IFwicGVyc3BlY3RpdmUoXCIgKyB0cmFuc2Zvcm1QZXJzcGVjdGl2ZSArIF9lbmRQYXJlbnRoZXNpcztcblx0XHR9XG5cdFx0aWYgKHhQZXJjZW50IHx8IHlQZXJjZW50KSB7XG5cdFx0XHR0cmFuc2Zvcm1zICs9IFwidHJhbnNsYXRlKFwiICsgeFBlcmNlbnQgKyBcIiUsIFwiICsgeVBlcmNlbnQgKyBcIiUpIFwiO1xuXHRcdH1cblx0XHRpZiAodXNlM0QgfHwgeCAhPT0gX3plcm9QeCB8fCB5ICE9PSBfemVyb1B4IHx8IHogIT09IF96ZXJvUHgpIHtcblx0XHRcdHRyYW5zZm9ybXMgKz0gKHogIT09IF96ZXJvUHggfHwgdXNlM0QpID8gXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcIiwgXCIgKyB5ICsgXCIsIFwiICsgeiArIFwiKSBcIiA6IFwidHJhbnNsYXRlKFwiICsgeCArIFwiLCBcIiArIHkgKyBfZW5kUGFyZW50aGVzaXM7XG5cdFx0fVxuXHRcdGlmIChyb3RhdGlvbiAhPT0gX3plcm9EZWcpIHtcblx0XHRcdHRyYW5zZm9ybXMgKz0gXCJyb3RhdGUoXCIgKyByb3RhdGlvbiArIF9lbmRQYXJlbnRoZXNpcztcblx0XHR9XG5cdFx0aWYgKHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpIHtcblx0XHRcdHRyYW5zZm9ybXMgKz0gXCJyb3RhdGVZKFwiICsgcm90YXRpb25ZICsgX2VuZFBhcmVudGhlc2lzO1xuXHRcdH1cblx0XHRpZiAocm90YXRpb25YICE9PSBfemVyb0RlZykge1xuXHRcdFx0dHJhbnNmb3JtcyArPSBcInJvdGF0ZVgoXCIgKyByb3RhdGlvblggKyBfZW5kUGFyZW50aGVzaXM7XG5cdFx0fVxuXHRcdGlmIChza2V3WCAhPT0gX3plcm9EZWcgfHwgc2tld1kgIT09IF96ZXJvRGVnKSB7XG5cdFx0XHR0cmFuc2Zvcm1zICs9IFwic2tldyhcIiArIHNrZXdYICsgXCIsIFwiICsgc2tld1kgKyBfZW5kUGFyZW50aGVzaXM7XG5cdFx0fVxuXHRcdGlmIChzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxKSB7XG5cdFx0XHR0cmFuc2Zvcm1zICs9IFwic2NhbGUoXCIgKyBzY2FsZVggKyBcIiwgXCIgKyBzY2FsZVkgKyBfZW5kUGFyZW50aGVzaXM7XG5cdFx0fVxuXHRcdHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1zIHx8IFwidHJhbnNsYXRlKDAsIDApXCI7XG5cdH0sXG5cdF9yZW5kZXJTVkdUcmFuc2Zvcm1zID0gZnVuY3Rpb24ocmF0aW8sIGNhY2hlKSB7XG5cdFx0bGV0IHt4UGVyY2VudCwgeVBlcmNlbnQsIHgsIHksIHJvdGF0aW9uLCBza2V3WCwgc2tld1ksIHNjYWxlWCwgc2NhbGVZLCB0YXJnZXQsIHhPcmlnaW4sIHlPcmlnaW4sIHhPZmZzZXQsIHlPZmZzZXQsIGZvcmNlQ1NTfSA9IGNhY2hlIHx8IHRoaXMsXG5cdFx0XHR0eCA9IHBhcnNlRmxvYXQoeCksXG5cdFx0XHR0eSA9IHBhcnNlRmxvYXQoeSksXG5cdFx0XHRhMTEsIGEyMSwgYTEyLCBhMjIsIHRlbXA7XG5cdFx0cm90YXRpb24gPSBwYXJzZUZsb2F0KHJvdGF0aW9uKTtcblx0XHRza2V3WCA9IHBhcnNlRmxvYXQoc2tld1gpO1xuXHRcdHNrZXdZID0gcGFyc2VGbG9hdChza2V3WSk7XG5cdFx0aWYgKHNrZXdZKSB7IC8vZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIGNvbWJpbmUgYWxsIHNrZXdpbmcgaW50byB0aGUgc2tld1ggYW5kIHJvdGF0aW9uIHZhbHVlcy4gUmVtZW1iZXIsIGEgc2tld1kgb2YgMTAgZGVncmVlcyBsb29rcyB0aGUgc2FtZSBhcyBhIHJvdGF0aW9uIG9mIDEwIGRlZ3JlZXMgcGx1cyBhIHNrZXdYIG9mIDEwIGRlZ3JlZXMuXG5cdFx0XHRza2V3WSA9IHBhcnNlRmxvYXQoc2tld1kpO1xuXHRcdFx0c2tld1ggKz0gc2tld1k7XG5cdFx0XHRyb3RhdGlvbiArPSBza2V3WTtcblx0XHR9XG5cdFx0aWYgKHJvdGF0aW9uIHx8IHNrZXdYKSB7XG5cdFx0XHRyb3RhdGlvbiAqPSBfREVHMlJBRDtcblx0XHRcdHNrZXdYICo9IF9ERUcyUkFEO1xuXHRcdFx0YTExID0gTWF0aC5jb3Mocm90YXRpb24pICogc2NhbGVYO1xuXHRcdFx0YTIxID0gTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGVYO1xuXHRcdFx0YTEyID0gTWF0aC5zaW4ocm90YXRpb24gLSBza2V3WCkgKiAtc2NhbGVZO1xuXHRcdFx0YTIyID0gTWF0aC5jb3Mocm90YXRpb24gLSBza2V3WCkgKiBzY2FsZVk7XG5cdFx0XHRpZiAoc2tld1gpIHtcblx0XHRcdFx0c2tld1kgKj0gX0RFRzJSQUQ7XG5cdFx0XHRcdHRlbXAgPSBNYXRoLnRhbihza2V3WCAtIHNrZXdZKTtcblx0XHRcdFx0dGVtcCA9IE1hdGguc3FydCgxICsgdGVtcCAqIHRlbXApO1xuXHRcdFx0XHRhMTIgKj0gdGVtcDtcblx0XHRcdFx0YTIyICo9IHRlbXA7XG5cdFx0XHRcdGlmIChza2V3WSkge1xuXHRcdFx0XHRcdHRlbXAgPSBNYXRoLnRhbihza2V3WSk7XG5cdFx0XHRcdFx0dGVtcCA9IE1hdGguc3FydCgxICsgdGVtcCAqIHRlbXApO1xuXHRcdFx0XHRcdGExMSAqPSB0ZW1wO1xuXHRcdFx0XHRcdGEyMSAqPSB0ZW1wO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRhMTEgPSBfcm91bmQoYTExKTtcblx0XHRcdGEyMSA9IF9yb3VuZChhMjEpO1xuXHRcdFx0YTEyID0gX3JvdW5kKGExMik7XG5cdFx0XHRhMjIgPSBfcm91bmQoYTIyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YTExID0gc2NhbGVYO1xuXHRcdFx0YTIyID0gc2NhbGVZO1xuXHRcdFx0YTIxID0gYTEyID0gMDtcblx0XHR9XG5cdFx0aWYgKCh0eCAmJiAhfih4ICsgXCJcIikuaW5kZXhPZihcInB4XCIpKSB8fCAodHkgJiYgIX4oeSArIFwiXCIpLmluZGV4T2YoXCJweFwiKSkpIHtcblx0XHRcdHR4ID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBcInhcIiwgeCwgXCJweFwiKTtcblx0XHRcdHR5ID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBcInlcIiwgeSwgXCJweFwiKTtcblx0XHR9XG5cdFx0aWYgKHhPcmlnaW4gfHwgeU9yaWdpbiB8fCB4T2Zmc2V0IHx8IHlPZmZzZXQpIHtcblx0XHRcdHR4ID0gX3JvdW5kKHR4ICsgeE9yaWdpbiAtICh4T3JpZ2luICogYTExICsgeU9yaWdpbiAqIGExMikgKyB4T2Zmc2V0KTtcblx0XHRcdHR5ID0gX3JvdW5kKHR5ICsgeU9yaWdpbiAtICh4T3JpZ2luICogYTIxICsgeU9yaWdpbiAqIGEyMikgKyB5T2Zmc2V0KTtcblx0XHR9XG5cdFx0aWYgKHhQZXJjZW50IHx8IHlQZXJjZW50KSB7XG5cdFx0XHQvL1RoZSBTVkcgc3BlYyBkb2Vzbid0IHN1cHBvcnQgcGVyY2VudGFnZS1iYXNlZCB0cmFuc2xhdGlvbiBpbiB0aGUgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUsIHNvIHdlIG1lcmdlIGl0IGludG8gdGhlIHRyYW5zbGF0aW9uIHRvIHNpbXVsYXRlIGl0LlxuXHRcdFx0dGVtcCA9IHRhcmdldC5nZXRCQm94KCk7XG5cdFx0XHR0eCA9IF9yb3VuZCh0eCArIHhQZXJjZW50IC8gMTAwICogdGVtcC53aWR0aCk7XG5cdFx0XHR0eSA9IF9yb3VuZCh0eSArIHlQZXJjZW50IC8gMTAwICogdGVtcC5oZWlnaHQpO1xuXHRcdH1cblx0XHR0ZW1wID0gXCJtYXRyaXgoXCIgKyBhMTEgKyBcIixcIiArIGEyMSArIFwiLFwiICsgYTEyICsgXCIsXCIgKyBhMjIgKyBcIixcIiArIHR4ICsgXCIsXCIgKyB0eSArIFwiKVwiO1xuXHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdGVtcCk7XG5cdFx0Zm9yY2VDU1MgJiYgKHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0ZW1wKTsgLy9zb21lIGJyb3dzZXJzIHByaW9yaXRpemUgQ1NTIHRyYW5zZm9ybXMgb3ZlciB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZS4gV2hlbiB3ZSBzZW5zZSB0aGF0IHRoZSB1c2VyIGhhcyBDU1MgdHJhbnNmb3JtcyBhcHBsaWVkLCB3ZSBtdXN0IG92ZXJ3cml0ZSB0aGVtIHRoaXMgd2F5IChvdGhlcndpc2Ugc29tZSBicm93c2VyIHNpbXBseSB3b24ndCByZW5kZXIgdGhlICB0cmFuc2Zvcm0gYXR0cmlidXRlIGNoYW5nZXMhKVxuXHR9LFxuXHRfYWRkUm90YXRpb25hbFByb3BUd2VlbiA9IGZ1bmN0aW9uKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnROdW0sIGVuZFZhbHVlLCByZWxhdGl2ZSkge1xuXHRcdGxldCBjYXAgPSAzNjAsXG5cdFx0XHRpc1N0cmluZyA9IF9pc1N0cmluZyhlbmRWYWx1ZSksXG5cdFx0XHRlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKSAqICgoaXNTdHJpbmcgJiYgfmVuZFZhbHVlLmluZGV4T2YoXCJyYWRcIikpID8gX1JBRDJERUcgOiAxKSxcblx0XHRcdGNoYW5nZSA9IHJlbGF0aXZlID8gZW5kTnVtICogcmVsYXRpdmUgOiBlbmROdW0gLSBzdGFydE51bSxcblx0XHRcdGZpbmFsVmFsdWUgPSAoc3RhcnROdW0gKyBjaGFuZ2UpICsgXCJkZWdcIixcblx0XHRcdGRpcmVjdGlvbiwgcHQ7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHRkaXJlY3Rpb24gPSBlbmRWYWx1ZS5zcGxpdChcIl9cIilbMV07XG5cdFx0XHRpZiAoZGlyZWN0aW9uID09PSBcInNob3J0XCIpIHtcblx0XHRcdFx0Y2hhbmdlICU9IGNhcDtcblx0XHRcdFx0aWYgKGNoYW5nZSAhPT0gY2hhbmdlICUgKGNhcCAvIDIpKSB7XG5cdFx0XHRcdFx0Y2hhbmdlICs9IChjaGFuZ2UgPCAwKSA/IGNhcCA6IC1jYXA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChkaXJlY3Rpb24gPT09IFwiY3dcIiAmJiBjaGFuZ2UgPCAwKSB7XG5cdFx0XHRcdGNoYW5nZSA9ICgoY2hhbmdlICsgY2FwICogX2JpZ051bSkgJSBjYXApIC0gfn4oY2hhbmdlIC8gY2FwKSAqIGNhcDtcblx0XHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcImNjd1wiICYmIGNoYW5nZSA+IDApIHtcblx0XHRcdFx0Y2hhbmdlID0gKChjaGFuZ2UgLSBjYXAgKiBfYmlnTnVtKSAlIGNhcCkgLSB+fihjaGFuZ2UgLyBjYXApICogY2FwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRwbHVnaW4uX3B0ID0gcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIHN0YXJ0TnVtLCBjaGFuZ2UsIF9yZW5kZXJQcm9wV2l0aEVuZCk7XG5cdFx0cHQuZSA9IGZpbmFsVmFsdWU7XG5cdFx0cHQudSA9IFwiZGVnXCI7XG5cdFx0cGx1Z2luLl9wcm9wcy5wdXNoKHByb3BlcnR5KTtcblx0XHRyZXR1cm4gcHQ7XG5cdH0sXG5cdF9hc3NpZ24gPSAodGFyZ2V0LCBzb3VyY2UpID0+IHsgLy8gSW50ZXJuZXQgRXhwbG9yZXIgZG9lc24ndCBoYXZlIE9iamVjdC5hc3NpZ24oKSwgc28gd2UgcmVjcmVhdGUgaXQgaGVyZS5cblx0XHRmb3IgKGxldCBwIGluIHNvdXJjZSkge1xuXHRcdFx0dGFyZ2V0W3BdID0gc291cmNlW3BdO1xuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9LFxuXHRfYWRkUmF3VHJhbnNmb3JtUFRzID0gKHBsdWdpbiwgdHJhbnNmb3JtcywgdGFyZ2V0KSA9PiB7IC8vZm9yIGhhbmRsaW5nIGNhc2VzIHdoZXJlIHNvbWVvbmUgcGFzc2VzIGluIGEgd2hvbGUgdHJhbnNmb3JtIHN0cmluZywgbGlrZSB0cmFuc2Zvcm06IFwic2NhbGUoMiwgMykgcm90YXRlKDIwZGVnKSB0cmFuc2xhdGVZKDMwZW0pXCJcblx0XHRsZXQgc3RhcnRDYWNoZSA9IF9hc3NpZ24oe30sIHRhcmdldC5fZ3NhcCksXG5cdFx0XHRleGNsdWRlID0gXCJwZXJzcGVjdGl2ZSxmb3JjZTNELHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW5cIixcblx0XHRcdHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuXHRcdFx0ZW5kQ2FjaGUsIHAsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBzdGFydE51bSwgZW5kTnVtLCBzdGFydFVuaXQsIGVuZFVuaXQ7XG5cdFx0aWYgKHN0YXJ0Q2FjaGUuc3ZnKSB7XG5cdFx0XHRzdGFydFZhbHVlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcblx0XHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJcIik7XG5cdFx0XHRzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1zO1xuXHRcdFx0ZW5kQ2FjaGUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKTtcblx0XHRcdF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKTtcblx0XHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgc3RhcnRWYWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YXJ0VmFsdWUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldClbX3RyYW5zZm9ybVByb3BdO1xuXHRcdFx0c3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3Jtcztcblx0XHRcdGVuZENhY2hlID0gX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSk7XG5cdFx0XHRzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSBzdGFydFZhbHVlO1xuXHRcdH1cblx0XHRmb3IgKHAgaW4gX3RyYW5zZm9ybVByb3BzKSB7XG5cdFx0XHRzdGFydFZhbHVlID0gc3RhcnRDYWNoZVtwXTtcblx0XHRcdGVuZFZhbHVlID0gZW5kQ2FjaGVbcF07XG5cdFx0XHRpZiAoc3RhcnRWYWx1ZSAhPT0gZW5kVmFsdWUgJiYgZXhjbHVkZS5pbmRleE9mKHApIDwgMCkgeyAvL3R3ZWVuaW5nIHRvIG5vIHBlcnNwZWN0aXZlIGdpdmVzIHZlcnkgdW5pbnR1aXRpdmUgcmVzdWx0cyAtIGp1c3Qga2VlcCB0aGUgc2FtZSBwZXJzcGVjdGl2ZSBpbiB0aGF0IGNhc2UuXG5cdFx0XHRcdHN0YXJ0VW5pdCA9IGdldFVuaXQoc3RhcnRWYWx1ZSk7XG5cdFx0XHRcdGVuZFVuaXQgPSBnZXRVbml0KGVuZFZhbHVlKTtcblx0XHRcdFx0c3RhcnROdW0gPSAoc3RhcnRVbml0ICE9PSBlbmRVbml0KSA/IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkgOiBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpO1xuXHRcdFx0XHRlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKTtcblx0XHRcdFx0cGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgZW5kQ2FjaGUsIHAsIHN0YXJ0TnVtLCBlbmROdW0gLSBzdGFydE51bSwgX3JlbmRlckNTU1Byb3ApO1xuXHRcdFx0XHRwbHVnaW4uX3B0LnUgPSBlbmRVbml0IHx8IDA7XG5cdFx0XHRcdHBsdWdpbi5fcHJvcHMucHVzaChwKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0X2Fzc2lnbihlbmRDYWNoZSwgc3RhcnRDYWNoZSk7XG5cdH07XG5cbi8vIGhhbmRsZSBzcGxpdHRpbmcgYXBhcnQgcGFkZGluZywgbWFyZ2luLCBib3JkZXJXaWR0aCwgYW5kIGJvcmRlclJhZGl1cyBpbnRvIHRoZWlyIDQgY29tcG9uZW50cy4gRmlyZWZveCwgZm9yIGV4YW1wbGUsIHdvbid0IHJlcG9ydCBib3JkZXJSYWRpdXMgY29ycmVjdGx5IC0gaXQgd2lsbCBvbmx5IGRvIGJvcmRlclRvcExlZnRSYWRpdXMgYW5kIHRoZSBvdGhlciBjb3JuZXJzLiBXZSBhbHNvIHdhbnQgdG8gaGFuZGxlIHBhZGRpbmdUb3AsIG1hcmdpbkxlZnQsIGJvcmRlclJpZ2h0V2lkdGgsIGV0Yy5cbl9mb3JFYWNoTmFtZShcInBhZGRpbmcsbWFyZ2luLFdpZHRoLFJhZGl1c1wiLCAobmFtZSwgaW5kZXgpID0+IHtcblx0bGV0IHQgPSBcIlRvcFwiLFxuXHRcdHIgPSBcIlJpZ2h0XCIsXG5cdFx0YiA9IFwiQm90dG9tXCIsXG5cdFx0bCA9IFwiTGVmdFwiLFxuXHRcdHByb3BzID0gKGluZGV4IDwgMyA/IFt0LHIsYixsXSA6IFt0K2wsIHQrciwgYityLCBiK2xdKS5tYXAoc2lkZSA9PiBpbmRleCA8IDIgPyBuYW1lICsgc2lkZSA6IFwiYm9yZGVyXCIgKyBzaWRlICsgbmFtZSk7XG5cdF9zcGVjaWFsUHJvcHNbKGluZGV4ID4gMSA/IFwiYm9yZGVyXCIgKyBuYW1lIDogbmFtZSldID0gZnVuY3Rpb24ocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBlbmRWYWx1ZSwgdHdlZW4pIHtcblx0XHRsZXQgYSwgdmFycztcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpIHsgLy8gZ2V0dGVyLCBwYXNzZWQgdGFyZ2V0LCBwcm9wZXJ0eSwgYW5kIHVuaXQgKGZyb20gX2dldCgpKVxuXHRcdFx0YSA9IHByb3BzLm1hcChwcm9wID0+IF9nZXQocGx1Z2luLCBwcm9wLCBwcm9wZXJ0eSkpO1xuXHRcdFx0dmFycyA9IGEuam9pbihcIiBcIik7XG5cdFx0XHRyZXR1cm4gdmFycy5zcGxpdChhWzBdKS5sZW5ndGggPT09IDUgPyBhWzBdIDogdmFycztcblx0XHR9XG5cdFx0YSA9IChlbmRWYWx1ZSArIFwiXCIpLnNwbGl0KFwiIFwiKTtcblx0XHR2YXJzID0ge307XG5cdFx0cHJvcHMuZm9yRWFjaCgocHJvcCwgaSkgPT4gdmFyc1twcm9wXSA9IGFbaV0gPSBhW2ldIHx8IGFbKCgoaSAtIDEpIC8gMikgfCAwKV0pO1xuXHRcdHBsdWdpbi5pbml0KHRhcmdldCwgdmFycywgdHdlZW4pO1xuXHR9XG59KTtcblxuXG5leHBvcnQgY29uc3QgQ1NTUGx1Z2luID0ge1xuXHRuYW1lOiBcImNzc1wiLFxuXHRyZWdpc3RlcjogX2luaXRDb3JlLFxuXHR0YXJnZXRUZXN0KHRhcmdldCkge1xuXHRcdHJldHVybiB0YXJnZXQuc3R5bGUgJiYgdGFyZ2V0Lm5vZGVUeXBlO1xuXHR9LFxuXHRpbml0KHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG5cdFx0bGV0IHByb3BzID0gdGhpcy5fcHJvcHMsXG5cdFx0XHRzdHlsZSA9IHRhcmdldC5zdHlsZSxcblx0XHRcdHN0YXJ0QXQgPSB0d2Vlbi52YXJzLnN0YXJ0QXQsXG5cdFx0XHRzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZW5kTnVtLCBzdGFydE51bSwgdHlwZSwgc3BlY2lhbFByb3AsIHAsIHN0YXJ0VW5pdCwgZW5kVW5pdCwgcmVsYXRpdmUsIGlzVHJhbnNmb3JtUmVsYXRlZCwgdHJhbnNmb3JtUHJvcFR3ZWVuLCBjYWNoZSwgc21vb3RoLCBoYXNQcmlvcml0eTtcblx0XHRfcGx1Z2luSW5pdHRlZCB8fCBfaW5pdENvcmUoKTtcblx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0aWYgKHAgPT09IFwiYXV0b1JvdW5kXCIpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRlbmRWYWx1ZSA9IHZhcnNbcF07XG5cdFx0XHRpZiAoX3BsdWdpbnNbcF0gJiYgX2NoZWNrUGx1Z2luKHAsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSkgeyAvLyBwbHVnaW5zXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0dHlwZSA9IHR5cGVvZihlbmRWYWx1ZSk7XG5cdFx0XHRzcGVjaWFsUHJvcCA9IF9zcGVjaWFsUHJvcHNbcF07XG5cdFx0XHRpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGVuZFZhbHVlID0gZW5kVmFsdWUuY2FsbCh0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cyk7XG5cdFx0XHRcdHR5cGUgPSB0eXBlb2YoZW5kVmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgfmVuZFZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG5cdFx0XHRcdGVuZFZhbHVlID0gX3JlcGxhY2VSYW5kb20oZW5kVmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHNwZWNpYWxQcm9wKSB7XG5cdFx0XHRcdHNwZWNpYWxQcm9wKHRoaXMsIHRhcmdldCwgcCwgZW5kVmFsdWUsIHR3ZWVuKSAmJiAoaGFzUHJpb3JpdHkgPSAxKTtcblx0XHRcdH0gZWxzZSBpZiAocC5zdWJzdHIoMCwyKSA9PT0gXCItLVwiKSB7IC8vQ1NTIHZhcmlhYmxlXG5cdFx0XHRcdHN0YXJ0VmFsdWUgPSAoZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmdldFByb3BlcnR5VmFsdWUocCkgKyBcIlwiKS50cmltKCk7XG5cdFx0XHRcdGVuZFZhbHVlICs9IFwiXCI7XG5cdFx0XHRcdF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXHRcdFx0XHRpZiAoIV9jb2xvckV4cC50ZXN0KHN0YXJ0VmFsdWUpKSB7IC8vIGNvbG9ycyBkb24ndCBoYXZlIHVuaXRzXG5cdFx0XHRcdFx0c3RhcnRVbml0ID0gZ2V0VW5pdChzdGFydFZhbHVlKTtcblx0XHRcdFx0XHRlbmRVbml0ID0gZ2V0VW5pdChlbmRWYWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZW5kVW5pdCA/IHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCAmJiAoc3RhcnRWYWx1ZSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkgKyBlbmRVbml0KSA6IHN0YXJ0VW5pdCAmJiAoZW5kVmFsdWUgKz0gc3RhcnRVbml0KTtcblx0XHRcdFx0dGhpcy5hZGQoc3R5bGUsIFwic2V0UHJvcGVydHlcIiwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGluZGV4LCB0YXJnZXRzLCAwLCAwLCBwKTtcblx0XHRcdFx0cHJvcHMucHVzaChwKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0XHRpZiAoc3RhcnRBdCAmJiBwIGluIHN0YXJ0QXQpIHsgLy8gaW4gY2FzZSBzb21lb25lIGhhcmQtY29kZXMgYSBjb21wbGV4IHZhbHVlIGFzIHRoZSBzdGFydCwgbGlrZSB0b3A6IFwiY2FsYygydmggLyAyKVwiLiBXaXRob3V0IHRoaXMsIGl0J2QgdXNlIHRoZSBjb21wdXRlZCB2YWx1ZSAoYWx3YXlzIGluIHB4KVxuXHRcdFx0XHRcdHN0YXJ0VmFsdWUgPSB0eXBlb2Yoc3RhcnRBdFtwXSkgPT09IFwiZnVuY3Rpb25cIiA/IHN0YXJ0QXRbcF0uY2FsbCh0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykgOiBzdGFydEF0W3BdO1xuXHRcdFx0XHRcdChwIGluIF9jb25maWcudW5pdHMpICYmICFnZXRVbml0KHN0YXJ0VmFsdWUpICYmIChzdGFydFZhbHVlICs9IF9jb25maWcudW5pdHNbcF0pOyAvLyBmb3IgY2FzZXMgd2hlbiBzb21lb25lIHBhc3NlcyBpbiBhIHVuaXRsZXNzIHZhbHVlIGxpa2Uge3g6IDEwMH07IGlmIHdlIHRyeSBzZXR0aW5nIHRyYW5zbGF0ZSgxMDAsIDBweCkgaXQgd29uJ3Qgd29yay5cblx0XHRcdFx0XHQoc3RhcnRWYWx1ZSArIFwiXCIpLmNoYXJBdCgxKSA9PT0gXCI9XCIgJiYgKHN0YXJ0VmFsdWUgPSBfZ2V0KHRhcmdldCwgcCkpOyAvLyBjYW4ndCB3b3JrIHdpdGggcmVsYXRpdmUgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhcnRWYWx1ZSA9IF9nZXQodGFyZ2V0LCBwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFydE51bSA9IHBhcnNlRmxvYXQoc3RhcnRWYWx1ZSk7XG5cdFx0XHRcdHJlbGF0aXZlID0gKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgZW5kVmFsdWUuY2hhckF0KDEpID09PSBcIj1cIikgPyArKGVuZFZhbHVlLmNoYXJBdCgwKSArIFwiMVwiKSA6IDA7XG5cdFx0XHRcdHJlbGF0aXZlICYmIChlbmRWYWx1ZSA9IGVuZFZhbHVlLnN1YnN0cigyKSk7XG5cdFx0XHRcdGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuXHRcdFx0XHRpZiAocCBpbiBfcHJvcGVydHlBbGlhc2VzKSB7XG5cdFx0XHRcdFx0aWYgKHAgPT09IFwiYXV0b0FscGhhXCIpIHsgLy9zcGVjaWFsIGNhc2Ugd2hlcmUgd2UgY29udHJvbCB0aGUgdmlzaWJpbGl0eSBhbG9uZyB3aXRoIG9wYWNpdHkuIFdlIHN0aWxsIGFsbG93IHRoZSBvcGFjaXR5IHZhbHVlIHRvIHBhc3MgdGhyb3VnaCBhbmQgZ2V0IHR3ZWVuZWQuXG5cdFx0XHRcdFx0XHRpZiAoc3RhcnROdW0gPT09IDEgJiYgX2dldCh0YXJnZXQsIFwidmlzaWJpbGl0eVwiKSA9PT0gXCJoaWRkZW5cIiAmJiBlbmROdW0pIHsgLy9pZiB2aXNpYmlsaXR5IGlzIGluaXRpYWxseSBzZXQgdG8gXCJoaWRkZW5cIiwgd2Ugc2hvdWxkIGludGVycHJldCB0aGF0IGFzIGludGVudCB0byBtYWtlIG9wYWNpdHkgMCAoYSBjb252ZW5pZW5jZSlcblx0XHRcdFx0XHRcdFx0c3RhcnROdW0gPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0X2FkZE5vblR3ZWVuaW5nUFQodGhpcywgc3R5bGUsIFwidmlzaWJpbGl0eVwiLCBzdGFydE51bSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiwgZW5kTnVtID8gXCJpbmhlcml0XCIgOiBcImhpZGRlblwiLCAhZW5kTnVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHAgIT09IFwic2NhbGVcIiAmJiBwICE9PSBcInRyYW5zZm9ybVwiKSB7XG5cdFx0XHRcdFx0XHRwID0gX3Byb3BlcnR5QWxpYXNlc1twXTtcblx0XHRcdFx0XHRcdH5wLmluZGV4T2YoXCIsXCIpICYmIChwID0gcC5zcGxpdChcIixcIilbMF0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlzVHJhbnNmb3JtUmVsYXRlZCA9IChwIGluIF90cmFuc2Zvcm1Qcm9wcyk7XG5cblx0XHRcdFx0Ly8tLS0gVFJBTlNGT1JNLVJFTEFURUQgLS0tXG5cdFx0XHRcdGlmIChpc1RyYW5zZm9ybVJlbGF0ZWQpIHtcblx0XHRcdFx0XHRpZiAoIXRyYW5zZm9ybVByb3BUd2Vlbikge1xuXHRcdFx0XHRcdFx0Y2FjaGUgPSB0YXJnZXQuX2dzYXA7XG5cdFx0XHRcdFx0XHQoY2FjaGUucmVuZGVyVHJhbnNmb3JtICYmICF2YXJzLnBhcnNlVHJhbnNmb3JtKSB8fCBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB2YXJzLnBhcnNlVHJhbnNmb3JtKTsgLy8gaWYsIGZvciBleGFtcGxlLCBnc2FwLnNldCguLi4ge3RyYW5zZm9ybTpcInRyYW5zbGF0ZVgoNTB2dylcIn0pLCB0aGUgX2dldCgpIGNhbGwgZG9lc24ndCBwYXJzZSB0aGUgdHJhbnNmb3JtLCB0aHVzIGNhY2hlLnJlbmRlclRyYW5zZm9ybSB3b24ndCBiZSBzZXQgeWV0IHNvIGZvcmNlIHRoZSBwYXJzaW5nIG9mIHRoZSB0cmFuc2Zvcm0gaGVyZS5cblx0XHRcdFx0XHRcdHNtb290aCA9ICh2YXJzLnNtb290aE9yaWdpbiAhPT0gZmFsc2UgJiYgY2FjaGUuc21vb3RoKTtcblx0XHRcdFx0XHRcdHRyYW5zZm9ybVByb3BUd2VlbiA9IHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgc3R5bGUsIF90cmFuc2Zvcm1Qcm9wLCAwLCAxLCBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0sIGNhY2hlLCAwLCAtMSk7IC8vdGhlIGZpcnN0IHRpbWUgdGhyb3VnaCwgY3JlYXRlIHRoZSByZW5kZXJpbmcgUHJvcFR3ZWVuIHNvIHRoYXQgaXQgcnVucyBMQVNUIChpbiB0aGUgbGlua2VkIGxpc3QsIHdlIGtlZXAgYWRkaW5nIHRvIHRoZSBiZWdpbm5pbmcpXG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm1Qcm9wVHdlZW4uZGVwID0gMTsgLy9mbGFnIGl0IGFzIGRlcGVuZGVudCBzbyB0aGF0IGlmIHRoaW5ncyBnZXQga2lsbGVkL292ZXJ3cml0dGVuIGFuZCB0aGlzIGlzIHRoZSBvbmx5IFByb3BUd2VlbiBsZWZ0LCB3ZSBjYW4gc2FmZWx5IGtpbGwgdGhlIHdob2xlIHR3ZWVuLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocCA9PT0gXCJzY2FsZVwiKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9wdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIGNhY2hlLCBcInNjYWxlWVwiLCBjYWNoZS5zY2FsZVksIChyZWxhdGl2ZSA/IHJlbGF0aXZlICogZW5kTnVtIDogZW5kTnVtIC0gY2FjaGUuc2NhbGVZKSB8fCAwKTtcblx0XHRcdFx0XHRcdHByb3BzLnB1c2goXCJzY2FsZVlcIiwgcCk7XG5cdFx0XHRcdFx0XHRwICs9IFwiWFwiO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIikge1xuXHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyhlbmRWYWx1ZSk7IC8vaW4gY2FzZSBzb21ldGhpbmcgbGlrZSBcImxlZnQgdG9wXCIgb3IgXCJib3R0b20gcmlnaHRcIiBpcyBwYXNzZWQgaW4uIENvbnZlcnQgdG8gcGVyY2VudGFnZXMuXG5cdFx0XHRcdFx0XHRpZiAoY2FjaGUuc3ZnKSB7XG5cdFx0XHRcdFx0XHRcdF9hcHBseVNWR09yaWdpbih0YXJnZXQsIGVuZFZhbHVlLCAwLCBzbW9vdGgsIDAsIHRoaXMpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZW5kVW5pdCA9IHBhcnNlRmxvYXQoZW5kVmFsdWUuc3BsaXQoXCIgXCIpWzJdKSB8fCAwOyAvL2hhbmRsZSB0aGUgek9yaWdpbiBzZXBhcmF0ZWx5IVxuXHRcdFx0XHRcdFx0XHRlbmRVbml0ICE9PSBjYWNoZS56T3JpZ2luICYmIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIGNhY2hlLCBcInpPcmlnaW5cIiwgY2FjaGUuek9yaWdpbiwgZW5kVW5pdCk7XG5cdFx0XHRcdFx0XHRcdF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIHN0eWxlLCBwLCBfZmlyc3RUd29Pbmx5KHN0YXJ0VmFsdWUpLCBfZmlyc3RUd29Pbmx5KGVuZFZhbHVlKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHAgPT09IFwic3ZnT3JpZ2luXCIpIHtcblx0XHRcdFx0XHRcdF9hcHBseVNWR09yaWdpbih0YXJnZXQsIGVuZFZhbHVlLCAxLCBzbW9vdGgsIDAsIHRoaXMpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwIGluIF9yb3RhdGlvbmFsUHJvcGVydGllcykge1xuXHRcdFx0XHRcdFx0X2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4odGhpcywgY2FjaGUsIHAsIHN0YXJ0TnVtLCBlbmRWYWx1ZSwgcmVsYXRpdmUpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHAgPT09IFwic21vb3RoT3JpZ2luXCIpIHtcblx0XHRcdFx0XHRcdF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIGNhY2hlLCBcInNtb290aFwiLCBjYWNoZS5zbW9vdGgsIGVuZFZhbHVlKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocCA9PT0gXCJmb3JjZTNEXCIpIHtcblx0XHRcdFx0XHRcdGNhY2hlW3BdID0gZW5kVmFsdWU7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHAgPT09IFwidHJhbnNmb3JtXCIpIHtcblx0XHRcdFx0XHRcdF9hZGRSYXdUcmFuc2Zvcm1QVHModGhpcywgZW5kVmFsdWUsIHRhcmdldCk7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoIShwIGluIHN0eWxlKSkge1xuXHRcdFx0XHRcdHAgPSBfY2hlY2tQcm9wUHJlZml4KHApIHx8IHA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNUcmFuc2Zvcm1SZWxhdGVkIHx8ICgoZW5kTnVtIHx8IGVuZE51bSA9PT0gMCkgJiYgKHN0YXJ0TnVtIHx8IHN0YXJ0TnVtID09PSAwKSAmJiAhX2NvbXBsZXhFeHAudGVzdChlbmRWYWx1ZSkgJiYgKHAgaW4gc3R5bGUpKSkge1xuXHRcdFx0XHRcdHN0YXJ0VW5pdCA9IChzdGFydFZhbHVlICsgXCJcIikuc3Vic3RyKChzdGFydE51bSArIFwiXCIpLmxlbmd0aCk7XG5cdFx0XHRcdFx0ZW5kTnVtIHx8IChlbmROdW0gPSAwKTsgLy8gcHJvdGVjdCBhZ2FpbnN0IE5hTlxuXHRcdFx0XHRcdGVuZFVuaXQgPSBnZXRVbml0KGVuZFZhbHVlKSB8fCAoKHAgaW4gX2NvbmZpZy51bml0cykgPyBfY29uZmlnLnVuaXRzW3BdIDogc3RhcnRVbml0KTtcblx0XHRcdFx0XHRzdGFydFVuaXQgIT09IGVuZFVuaXQgJiYgKHN0YXJ0TnVtID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwLCBzdGFydFZhbHVlLCBlbmRVbml0KSk7XG5cdFx0XHRcdFx0dGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBpc1RyYW5zZm9ybVJlbGF0ZWQgPyBjYWNoZSA6IHN0eWxlLCBwLCBzdGFydE51bSwgcmVsYXRpdmUgPyByZWxhdGl2ZSAqIGVuZE51bSA6IGVuZE51bSAtIHN0YXJ0TnVtLCAoIWlzVHJhbnNmb3JtUmVsYXRlZCAmJiAoZW5kVW5pdCA9PT0gXCJweFwiIHx8IHAgPT09IFwiekluZGV4XCIpICYmIHZhcnMuYXV0b1JvdW5kICE9PSBmYWxzZSkgPyBfcmVuZGVyUm91bmRlZENTU1Byb3AgOiBfcmVuZGVyQ1NTUHJvcCk7XG5cdFx0XHRcdFx0dGhpcy5fcHQudSA9IGVuZFVuaXQgfHwgMDtcblx0XHRcdFx0XHRpZiAoc3RhcnRVbml0ICE9PSBlbmRVbml0KSB7IC8vd2hlbiB0aGUgdHdlZW4gZ29lcyBhbGwgdGhlIHdheSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcsIHdlIG5lZWQgdG8gcmV2ZXJ0IGl0IHRvIHRoZSBPTEQvT1JJR0lOQUwgdmFsdWUgKHdpdGggdGhvc2UgdW5pdHMpLiBXZSByZWNvcmQgdGhhdCBhcyBhIFwiYlwiIChiZWdpbm5pbmcpIHByb3BlcnR5IGFuZCBwb2ludCB0byBhIHJlbmRlciBtZXRob2QgdGhhdCBoYW5kbGVzIHRoYXQuIChwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24pXG5cdFx0XHRcdFx0XHR0aGlzLl9wdC5iID0gc3RhcnRWYWx1ZTtcblx0XHRcdFx0XHRcdHRoaXMuX3B0LnIgPSBfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCEocCBpbiBzdHlsZSkpIHtcblx0XHRcdFx0XHRpZiAocCBpbiB0YXJnZXQpIHsgLy9tYXliZSBpdCdzIG5vdCBhIHN0eWxlIC0gaXQgY291bGQgYmUgYSBwcm9wZXJ0eSBhZGRlZCBkaXJlY3RseSB0byBhbiBlbGVtZW50IGluIHdoaWNoIGNhc2Ugd2UnbGwgdHJ5IHRvIGFuaW1hdGUgdGhhdC5cblx0XHRcdFx0XHRcdHRoaXMuYWRkKHRhcmdldCwgcCwgc3RhcnRWYWx1ZSB8fCB0YXJnZXRbcF0sIGVuZFZhbHVlLCBpbmRleCwgdGFyZ2V0cyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdF9taXNzaW5nUGx1Z2luKHAsIGVuZFZhbHVlKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwodGhpcywgdGFyZ2V0LCBwLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJvcHMucHVzaChwKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aGFzUHJpb3JpdHkgJiYgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSh0aGlzKTtcblxuXHR9LFxuXHRnZXQ6IF9nZXQsXG5cdGFsaWFzZXM6IF9wcm9wZXJ0eUFsaWFzZXMsXG5cdGdldFNldHRlcih0YXJnZXQsIHByb3BlcnR5LCBwbHVnaW4pIHsgLy9yZXR1cm5zIGEgc2V0dGVyIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSBhbmQgYXBwbGllcyBpdCBhY2NvcmRpbmdseS4gUmVtZW1iZXIsIHByb3BlcnRpZXMgbGlrZSBcInhcIiBhcmVuJ3QgYXMgc2ltcGxlIGFzIHRhcmdldC5zdHlsZS5wcm9wZXJ0eSA9IHZhbHVlIGJlY2F1c2UgdGhleSd2ZSBnb3QgdG8gYmUgYXBwbGllZCB0byBhIHByb3h5IG9iamVjdCBhbmQgdGhlbiBtZXJnZWQgaW50byBhIHRyYW5zZm9ybSBzdHJpbmcgaW4gYSByZW5kZXJlci5cblx0XHRsZXQgcCA9IF9wcm9wZXJ0eUFsaWFzZXNbcHJvcGVydHldO1xuXHRcdChwICYmIHAuaW5kZXhPZihcIixcIikgPCAwKSAmJiAocHJvcGVydHkgPSBwKTtcblx0XHRyZXR1cm4gKHByb3BlcnR5IGluIF90cmFuc2Zvcm1Qcm9wcyAmJiBwcm9wZXJ0eSAhPT0gX3RyYW5zZm9ybU9yaWdpblByb3AgJiYgKHRhcmdldC5fZ3NhcC54IHx8IF9nZXQodGFyZ2V0LCBcInhcIikpKSA/IChwbHVnaW4gJiYgX3JlY2VudFNldHRlclBsdWdpbiA9PT0gcGx1Z2luID8gKHByb3BlcnR5ID09PSBcInNjYWxlXCIgPyBfc2V0dGVyU2NhbGUgOiBfc2V0dGVyVHJhbnNmb3JtKSA6IChfcmVjZW50U2V0dGVyUGx1Z2luID0gcGx1Z2luIHx8IHt9KSAmJiAocHJvcGVydHkgPT09IFwic2NhbGVcIiA/IF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIgOiBfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlcikpIDogdGFyZ2V0LnN0eWxlICYmICFfaXNVbmRlZmluZWQodGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSkgPyBfc2V0dGVyQ1NTU3R5bGUgOiB+cHJvcGVydHkuaW5kZXhPZihcIi1cIikgPyBfc2V0dGVyQ1NTUHJvcCA6IF9nZXRTZXR0ZXIodGFyZ2V0LCBwcm9wZXJ0eSk7XG5cdH0sXG5cdGNvcmU6IHsgX3JlbW92ZVByb3BlcnR5LCBfZ2V0TWF0cml4IH1cblxufTtcblxuZ3NhcC51dGlscy5jaGVja1ByZWZpeCA9IF9jaGVja1Byb3BQcmVmaXg7XG4oZnVuY3Rpb24ocG9zaXRpb25BbmRTY2FsZSwgcm90YXRpb24sIG90aGVycywgYWxpYXNlcykge1xuXHRsZXQgYWxsID0gX2ZvckVhY2hOYW1lKHBvc2l0aW9uQW5kU2NhbGUgKyBcIixcIiArIHJvdGF0aW9uICsgXCIsXCIgKyBvdGhlcnMsIG5hbWUgPT4ge190cmFuc2Zvcm1Qcm9wc1tuYW1lXSA9IDF9KTtcblx0X2ZvckVhY2hOYW1lKHJvdGF0aW9uLCBuYW1lID0+IHtfY29uZmlnLnVuaXRzW25hbWVdID0gXCJkZWdcIjsgX3JvdGF0aW9uYWxQcm9wZXJ0aWVzW25hbWVdID0gMX0pO1xuXHRfcHJvcGVydHlBbGlhc2VzW2FsbFsxM11dID0gcG9zaXRpb25BbmRTY2FsZSArIFwiLFwiICsgcm90YXRpb247XG5cdF9mb3JFYWNoTmFtZShhbGlhc2VzLCBuYW1lID0+IHtcblx0XHRsZXQgc3BsaXQgPSBuYW1lLnNwbGl0KFwiOlwiKTtcblx0XHRfcHJvcGVydHlBbGlhc2VzW3NwbGl0WzFdXSA9IGFsbFtzcGxpdFswXV07XG5cdH0pO1xufSkoXCJ4LHkseixzY2FsZSxzY2FsZVgsc2NhbGVZLHhQZXJjZW50LHlQZXJjZW50XCIsIFwicm90YXRpb24scm90YXRpb25YLHJvdGF0aW9uWSxza2V3WCxza2V3WVwiLCBcInRyYW5zZm9ybSx0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luLGZvcmNlM0Qsc21vb3RoT3JpZ2luLHRyYW5zZm9ybVBlcnNwZWN0aXZlXCIsIFwiMDp0cmFuc2xhdGVYLDE6dHJhbnNsYXRlWSwyOnRyYW5zbGF0ZVosODpyb3RhdGUsODpyb3RhdGlvblosODpyb3RhdGVaLDk6cm90YXRlWCwxMDpyb3RhdGVZXCIpO1xuX2ZvckVhY2hOYW1lKFwieCx5LHosdG9wLHJpZ2h0LGJvdHRvbSxsZWZ0LHdpZHRoLGhlaWdodCxmb250U2l6ZSxwYWRkaW5nLG1hcmdpbixwZXJzcGVjdGl2ZVwiLCBuYW1lID0+IHtfY29uZmlnLnVuaXRzW25hbWVdID0gXCJweFwifSk7XG5cbmdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUGx1Z2luKTtcblxuZXhwb3J0IHsgQ1NTUGx1Z2luIGFzIGRlZmF1bHQsIF9nZXRCQm94LCBfY3JlYXRlRWxlbWVudCwgX2NoZWNrUHJvcFByZWZpeCBhcyBjaGVja1ByZWZpeCB9OyIsIi8qIVxuICogQ1NTUnVsZVBsdWdpbiAzLjcuMFxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyMSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbmxldCBnc2FwLCBfY29yZUluaXR0ZWQsIF93aW4sIF9kb2MsIENTU1BsdWdpbixcblx0X3dpbmRvd0V4aXN0cyA9ICgpID0+IHR5cGVvZih3aW5kb3cpICE9PSBcInVuZGVmaW5lZFwiLFxuXHRfZ2V0R1NBUCA9ICgpID0+IGdzYXAgfHwgKF93aW5kb3dFeGlzdHMoKSAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXApLFxuXHRfY2hlY2tSZWdpc3RlciA9ICgpID0+IHtcblx0XHRpZiAoIV9jb3JlSW5pdHRlZCkge1xuXHRcdFx0X2luaXRDb3JlKCk7XG5cdFx0XHRpZiAoIUNTU1BsdWdpbikge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oXCJQbGVhc2UgZ3NhcC5yZWdpc3RlclBsdWdpbihDU1NQbHVnaW4sIENTU1J1bGVQbHVnaW4pXCIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX2NvcmVJbml0dGVkO1xuXHR9LFxuXHRfaW5pdENvcmUgPSBjb3JlID0+IHtcblx0XHRnc2FwID0gY29yZSB8fCBfZ2V0R1NBUCgpO1xuXHRcdGlmIChfd2luZG93RXhpc3RzKCkpIHtcblx0XHRcdF93aW4gPSB3aW5kb3c7XG5cdFx0XHRfZG9jID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHRcdGlmIChnc2FwKSB7XG5cdFx0XHRDU1NQbHVnaW4gPSBnc2FwLnBsdWdpbnMuY3NzO1xuXHRcdFx0aWYgKENTU1BsdWdpbikge1xuXHRcdFx0XHRfY29yZUluaXR0ZWQgPSAxO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXG5leHBvcnQgY29uc3QgQ1NTUnVsZVBsdWdpbiA9IHtcblx0dmVyc2lvbjogXCIzLjcuMFwiLFxuXHRuYW1lOiBcImNzc1J1bGVcIixcblx0aW5pdCh0YXJnZXQsIHZhbHVlLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcblx0XHRpZiAoIV9jaGVja1JlZ2lzdGVyKCkgfHwgdHlwZW9mKHRhcmdldC5jc3NUZXh0KSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRsZXQgZGl2ID0gdGFyZ2V0Ll9nc1Byb3h5ID0gdGFyZ2V0Ll9nc1Byb3h5IHx8IF9kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHR0aGlzLnNzID0gdGFyZ2V0O1xuXHRcdHRoaXMuc3R5bGUgPSBkaXYuc3R5bGU7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPSB0YXJnZXQuY3NzVGV4dDtcblx0XHRDU1NQbHVnaW4ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBkaXYsIHZhbHVlLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpOyAvL3dlIGp1c3Qgb2ZmbG9hZCBhbGwgdGhlIHdvcmsgdG8gdGhlIHJlZ3VsYXIgQ1NTUGx1Z2luIGFuZCB0aGVuIGNvcHkgdGhlIGNzc1RleHQgYmFjayBvdmVyIHRvIHRoZSBydWxlIGluIHRoZSByZW5kZXIoKSBtZXRob2QuIFRoaXMgYWxsb3dzIHVzIHRvIGhhdmUgYWxsIG9mIHRoZSB1cGRhdGVzIHRvIENTU1BsdWdpbiBhdXRvbWF0aWNhbGx5IGZsb3cgdGhyb3VnaCB0byBDU1NSdWxlUGx1Z2luIGluc3RlYWQgb2YgaGF2aW5nIHRvIG1haW50YWluIGJvdGhcblx0fSxcblx0cmVuZGVyKHJhdGlvLCBkYXRhKSB7XG5cdFx0bGV0IHB0ID0gZGF0YS5fcHQsXG5cdFx0XHRzdHlsZSA9IGRhdGEuc3R5bGUsXG5cdFx0XHRzcyA9IGRhdGEuc3MsXG5cdFx0XHRpO1xuXHRcdHdoaWxlIChwdCkge1xuXHRcdFx0cHQucihyYXRpbywgcHQuZCk7XG5cdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdH1cblx0XHRpID0gc3R5bGUubGVuZ3RoO1xuXHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0c3Nbc3R5bGVbaV1dID0gc3R5bGVbc3R5bGVbaV1dO1xuXHRcdH1cblx0fSxcblx0Z2V0UnVsZShzZWxlY3Rvcikge1xuXHRcdF9jaGVja1JlZ2lzdGVyKCk7XG5cdFx0bGV0IHJ1bGVQcm9wID0gX2RvYy5hbGwgPyBcInJ1bGVzXCIgOiBcImNzc1J1bGVzXCIsXG5cdFx0XHRzdHlsZVNoZWV0cyA9IF9kb2Muc3R5bGVTaGVldHMsXG5cdFx0XHRpID0gc3R5bGVTaGVldHMubGVuZ3RoLFxuXHRcdFx0cHNldWRvID0gKHNlbGVjdG9yLmNoYXJBdCgwKSA9PT0gXCI6XCIpLFxuXHRcdFx0aiwgY3VyU1MsIGNzLCBhO1xuXHRcdHNlbGVjdG9yID0gKHBzZXVkbyA/IFwiXCIgOiBcIixcIikgKyBzZWxlY3Rvci5zcGxpdChcIjo6XCIpLmpvaW4oXCI6XCIpLnRvTG93ZXJDYXNlKCkgKyBcIixcIjsgLy9ub3RlOiBvbGQgdmVyc2lvbnMgb2YgSUUgcmVwb3J0IHRhZyBuYW1lIHNlbGVjdG9ycyBhcyB1cHBlciBjYXNlLCBzbyB3ZSBqdXN0IGNoYW5nZSBldmVyeXRoaW5nIHRvIGxvd2VyY2FzZS5cblx0XHRpZiAocHNldWRvKSB7XG5cdFx0XHRhID0gW107XG5cdFx0fVxuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdC8vRmlyZWZveCBtYXkgdGhyb3cgaW5zZWN1cmUgb3BlcmF0aW9uIGVycm9ycyB3aGVuIGNzcyBpcyBsb2FkZWQgZnJvbSBvdGhlciBkb21haW5zLCBzbyB0cnkvY2F0Y2guXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjdXJTUyA9IHN0eWxlU2hlZXRzW2ldW3J1bGVQcm9wXTtcblx0XHRcdFx0aWYgKCFjdXJTUykge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGogPSBjdXJTUy5sZW5ndGg7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybihlKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoLS1qID4gLTEpIHtcblx0XHRcdFx0Y3MgPSBjdXJTU1tqXTtcblx0XHRcdFx0aWYgKGNzLnNlbGVjdG9yVGV4dCAmJiAoXCIsXCIgKyBjcy5zZWxlY3RvclRleHQuc3BsaXQoXCI6OlwiKS5qb2luKFwiOlwiKS50b0xvd2VyQ2FzZSgpICsgXCIsXCIpLmluZGV4T2Yoc2VsZWN0b3IpICE9PSAtMSkgeyAvL25vdGU6IElFIGFkZHMgYW4gZXh0cmEgXCI6XCIgdG8gcHNldWRvIHNlbGVjdG9ycywgc28gLm15Q2xhc3M6YWZ0ZXIgYmVjb21lcyAubXlDbGFzczo6YWZ0ZXIsIHNvIHdlIG5lZWQgdG8gc3RyaXAgdGhlIGV4dHJhIG9uZSBvdXQuXG5cdFx0XHRcdFx0aWYgKHBzZXVkbykge1xuXHRcdFx0XHRcdFx0YS5wdXNoKGNzLnN0eWxlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNzLnN0eWxlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYTtcblx0fSxcblx0cmVnaXN0ZXI6IF9pbml0Q29yZVxufTtcblxuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1J1bGVQbHVnaW4pO1xuXG5leHBvcnQgeyBDU1NSdWxlUGx1Z2luIGFzIGRlZmF1bHQgfTsiLCIvKiFcbiAqIERyYWdnYWJsZSAzLjcuMFxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyMSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5pbXBvcnQgeyBnZXRHbG9iYWxNYXRyaXgsIE1hdHJpeDJEIH0gZnJvbSBcIi4vdXRpbHMvbWF0cml4LmpzXCI7XG5cbmxldCBnc2FwLCBfd2luLCBfZG9jLCBfZG9jRWxlbWVudCwgX2JvZHksIF90ZW1wRGl2LCBfcGxhY2Vob2xkZXJEaXYsIF9jb3JlSW5pdHRlZCwgX2NoZWNrUHJlZml4LCBfdG9BcnJheSwgX3N1cHBvcnRzUGFzc2l2ZSwgX2lzVG91Y2hEZXZpY2UsIF90b3VjaEV2ZW50TG9va3VwLCBfZHJhZ0NvdW50LCBfaXNNdWx0aVRvdWNoaW5nLCBfaXNBbmRyb2lkLCBJbmVydGlhUGx1Z2luLCBfZGVmYXVsdEN1cnNvciwgX3N1cHBvcnRzUG9pbnRlcixcblx0X3dpbmRvd0V4aXN0cyA9ICgpID0+IHR5cGVvZih3aW5kb3cpICE9PSBcInVuZGVmaW5lZFwiLFxuXHRfZ2V0R1NBUCA9ICgpID0+IGdzYXAgfHwgKF93aW5kb3dFeGlzdHMoKSAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXApLFxuXHRfaXNGdW5jdGlvbiA9IHZhbHVlID0+IHR5cGVvZih2YWx1ZSkgPT09IFwiZnVuY3Rpb25cIixcblx0X2lzT2JqZWN0ID0gdmFsdWUgPT4gdHlwZW9mKHZhbHVlKSA9PT0gXCJvYmplY3RcIixcblx0X2lzVW5kZWZpbmVkID0gdmFsdWUgPT4gdHlwZW9mKHZhbHVlKSA9PT0gXCJ1bmRlZmluZWRcIixcblx0X2VtcHR5RnVuYyA9ICgpID0+IGZhbHNlLFxuXHRfdHJhbnNmb3JtUHJvcCA9IFwidHJhbnNmb3JtXCIsXG5cdF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gXCJ0cmFuc2Zvcm1PcmlnaW5cIixcblx0X3JvdW5kID0gdmFsdWUgPT4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMDAwKSAvIDEwMDAwLFxuXHRfaXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG5cdF9jcmVhdGVFbGVtZW50ID0gKHR5cGUsIG5zKSA9PiB7XG5cdFx0bGV0IGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyA/IF9kb2MuY3JlYXRlRWxlbWVudE5TKChucyB8fCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIikucmVwbGFjZSgvXmh0dHBzLywgXCJodHRwXCIpLCB0eXBlKSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIHNlcnZlcnMgc3dhcCBpbiBodHRwcyBmb3IgaHR0cCBpbiB0aGUgbmFtZXNwYWNlIHdoaWNoIGNhbiBicmVhayB0aGluZ3MsIG1ha2luZyBcInN0eWxlXCIgaW5hY2Nlc3NpYmxlLlxuXHRcdHJldHVybiBlLnN0eWxlID8gZSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIGVudmlyb25tZW50cyB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIGVsZW1lbnQncyBzdHlsZSB3aGVuIGNyZWF0ZWQgd2l0aCBhIG5hbWVzcGFjZSBpbiB3aGljaCBjYXNlIHdlIGRlZmF1bHQgdG8gdGhlIHN0YW5kYXJkIGNyZWF0ZUVsZW1lbnQoKSB0byB3b3JrIGFyb3VuZCB0aGUgaXNzdWUuIEFsc28gbm90ZSB0aGF0IHdoZW4gR1NBUCBpcyBlbWJlZGRlZCBkaXJlY3RseSBpbnNpZGUgYW4gU1ZHIGZpbGUsIGNyZWF0ZUVsZW1lbnQoKSB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIHN0eWxlIG9iamVjdCBpbiBGaXJlZm94IChzZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMDIxNS1wcm9ibGVtLXVzaW5nLXR3ZWVubWF4LWluLXN0YW5kYWxvbmUtc2VsZi1jb250YWluaW5nLXN2Zy1maWxlLWVyci1jYW5ub3Qtc2V0LXByb3BlcnR5LWNzc3RleHQtb2YtdW5kZWZpbmVkLykuXG5cdH0sXG5cdF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcblx0X2JpZ051bSA9IDFlMjAsXG5cdF9pZGVudGl0eU1hdHJpeCA9IG5ldyBNYXRyaXgyRCgpLFxuXHRfZ2V0VGltZSA9IERhdGUubm93IHx8ICgoKSA9PiBuZXcgRGF0ZSgpLmdldFRpbWUoKSksXG5cdF9yZW5kZXJRdWV1ZSA9IFtdLFxuXHRfbG9va3VwID0ge30sIC8vd2hlbiBhIERyYWdnYWJsZSBpcyBjcmVhdGVkLCB0aGUgdGFyZ2V0IGdldHMgYSB1bmlxdWUgX2dzRHJhZ0lEIHByb3BlcnR5IHRoYXQgYWxsb3dzIGdldHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBEcmFnZ2FibGUgaW5zdGFuY2UgZm9yIHF1aWNrIGxvb2t1cHMgaW4gRHJhZ2dhYmxlLmdldCgpLiBUaGlzIGF2b2lkcyBjaXJjdWxhciByZWZlcmVuY2VzIHRoYXQgY291bGQgY2F1c2UgZ2MgcHJvYmxlbXMuXG5cdF9sb29rdXBDb3VudCA9IDAsXG5cdF9jbGlja2FibGVUYWdFeHAgPSAvXig/OmF8aW5wdXR8dGV4dGFyZWF8YnV0dG9ufHNlbGVjdCkkL2ksXG5cdF9sYXN0RHJhZ1RpbWUgPSAwLFxuXHRfdGVtcDEgPSB7fSwgLy8gYSBzaW1wbGUgb2JqZWN0IHdlIHJldXNlIGFuZCBwb3B1bGF0ZSAodXN1YWxseSB4L3kgcHJvcGVydGllcykgdG8gY29uc2VydmUgbWVtb3J5IGFuZCBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuXHRfd2luZG93UHJveHkgPSB7fSwgLy9tZW1vcnkvcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIC0gd2UgcmV1c2UgdGhpcyBvYmplY3QgZHVyaW5nIGF1dG9TY3JvbGwgdG8gc3RvcmUgd2luZG93LXJlbGF0ZWQgYm91bmRzL29mZnNldHMuXG5cdF9jb3B5ID0gKG9iaiwgZmFjdG9yKSA9PiB7XG5cdFx0bGV0IGNvcHkgPSB7fSwgcDtcblx0XHRmb3IgKHAgaW4gb2JqKSB7XG5cdFx0XHRjb3B5W3BdID0gZmFjdG9yID8gb2JqW3BdICogZmFjdG9yIDogb2JqW3BdO1xuXHRcdH1cblx0XHRyZXR1cm4gY29weTtcblx0fSxcblx0X2V4dGVuZCA9IChvYmosIGRlZmF1bHRzKSA9PiB7XG5cdFx0Zm9yIChsZXQgcCBpbiBkZWZhdWx0cykge1xuXHRcdFx0aWYgKCEocCBpbiBvYmopKSB7XG5cdFx0XHRcdG9ialtwXSA9IGRlZmF1bHRzW3BdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXHRfc2V0VG91Y2hBY3Rpb25Gb3JBbGxEZXNjZW5kYW50cyA9IChlbGVtZW50cywgdmFsdWUpID0+IHtcblx0XHRsZXQgaSA9IGVsZW1lbnRzLmxlbmd0aCxcblx0XHRcdGNoaWxkcmVuO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdHZhbHVlID8gKGVsZW1lbnRzW2ldLnN0eWxlLnRvdWNoQWN0aW9uID0gdmFsdWUpIDogZWxlbWVudHNbaV0uc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0b3VjaC1hY3Rpb25cIik7XG5cdFx0XHRjaGlsZHJlbiA9IGVsZW1lbnRzW2ldLmNoaWxkcmVuO1xuXHRcdFx0Y2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoICYmIF9zZXRUb3VjaEFjdGlvbkZvckFsbERlc2NlbmRhbnRzKGNoaWxkcmVuLCB2YWx1ZSk7XG5cdFx0fVxuXHR9LFxuXHRfcmVuZGVyUXVldWVUaWNrID0gKCkgPT4gX3JlbmRlclF1ZXVlLmZvckVhY2goZnVuYyA9PiBmdW5jKCkpLFxuXHRfYWRkVG9SZW5kZXJRdWV1ZSA9IGZ1bmMgPT4ge1xuXHRcdF9yZW5kZXJRdWV1ZS5wdXNoKGZ1bmMpO1xuXHRcdGlmIChfcmVuZGVyUXVldWUubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRnc2FwLnRpY2tlci5hZGQoX3JlbmRlclF1ZXVlVGljayk7XG5cdFx0fVxuXHR9LFxuXHRfcmVuZGVyUXVldWVUaW1lb3V0ID0gKCkgPT4gIV9yZW5kZXJRdWV1ZS5sZW5ndGggJiYgZ3NhcC50aWNrZXIucmVtb3ZlKF9yZW5kZXJRdWV1ZVRpY2spLFxuXHRfcmVtb3ZlRnJvbVJlbmRlclF1ZXVlID0gZnVuYyA9PiB7XG5cdFx0bGV0IGkgPSBfcmVuZGVyUXVldWUubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGlmIChfcmVuZGVyUXVldWVbaV0gPT09IGZ1bmMpIHtcblx0XHRcdFx0X3JlbmRlclF1ZXVlLnNwbGljZShpLCAxKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Z3NhcC50byhfcmVuZGVyUXVldWVUaW1lb3V0LCB7b3ZlcndyaXRlOnRydWUsIGRlbGF5OjE1LCBkdXJhdGlvbjowLCBvbkNvbXBsZXRlOl9yZW5kZXJRdWV1ZVRpbWVvdXQsIGRhdGE6XCJfZHJhZ2dhYmxlXCJ9KTsgLy9yZW1vdmUgdGhlIFwidGlja1wiIGxpc3RlbmVyIG9ubHkgYWZ0ZXIgdGhlIHJlbmRlciBxdWV1ZSBpcyBlbXB0eSBmb3IgMTUgc2Vjb25kcyAodG8gaW1wcm92ZSBwZXJmb3JtYW5jZSkuIEFkZGluZy9yZW1vdmluZyBpdCBjb25zdGFudGx5IGZvciBldmVyeSBjbGljay90b3VjaCB3b3VsZG4ndCBkZWxpdmVyIG9wdGltYWwgc3BlZWQsIGFuZCB3ZSBhbHNvIGRvbid0IHdhbnQgdGhlIHRpY2tlciB0byBrZWVwIGNhbGxpbmcgdGhlIHJlbmRlciBtZXRob2Qgd2hlbiB0aGluZ3MgYXJlIGlkbGUgZm9yIGxvbmcgcGVyaW9kcyBvZiB0aW1lICh3ZSB3YW50IHRvIGltcHJvdmUgYmF0dGVyeSBsaWZlIG9uIG1vYmlsZSBkZXZpY2VzKS5cblx0fSxcblx0X3NldERlZmF1bHRzID0gKG9iaiwgZGVmYXVsdHMpID0+IHtcblx0XHRmb3IgKGxldCBwIGluIGRlZmF1bHRzKSB7XG5cdFx0XHRpZiAoIShwIGluIG9iaikpIHtcblx0XHRcdFx0b2JqW3BdID0gZGVmYXVsdHNbcF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cdF9hZGRMaXN0ZW5lciA9IChlbGVtZW50LCB0eXBlLCBmdW5jLCBjYXB0dXJlKSA9PiB7XG5cdFx0aWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0bGV0IHRvdWNoVHlwZSA9IF90b3VjaEV2ZW50TG9va3VwW3R5cGVdO1xuXHRcdFx0Y2FwdHVyZSA9IGNhcHR1cmUgfHwgKF9zdXBwb3J0c1Bhc3NpdmUgPyB7cGFzc2l2ZTogZmFsc2V9IDogbnVsbCk7XG5cdFx0XHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodG91Y2hUeXBlIHx8IHR5cGUsIGZ1bmMsIGNhcHR1cmUpO1xuXHRcdFx0KHRvdWNoVHlwZSAmJiB0eXBlICE9PSB0b3VjaFR5cGUpICYmIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jLCBjYXB0dXJlKTsvL3NvbWUgYnJvd3NlcnMgYWN0dWFsbHkgc3VwcG9ydCBib3RoLCBzbyBtdXN0IHdlLiBCdXQgcG9pbnRlciBldmVudHMgY292ZXIgYWxsLlxuXHRcdH1cblx0fSxcblx0X3JlbW92ZUxpc3RlbmVyID0gKGVsZW1lbnQsIHR5cGUsIGZ1bmMpID0+IHtcblx0XHRpZiAoZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG5cdFx0XHRsZXQgdG91Y2hUeXBlID0gX3RvdWNoRXZlbnRMb29rdXBbdHlwZV07XG5cdFx0XHRlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodG91Y2hUeXBlIHx8IHR5cGUsIGZ1bmMpO1xuXHRcdFx0KHRvdWNoVHlwZSAmJiB0eXBlICE9PSB0b3VjaFR5cGUpICYmIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jKTtcblx0XHR9XG5cdH0sXG5cdF9wcmV2ZW50RGVmYXVsdCA9IGV2ZW50ID0+IHtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGV2ZW50LnByZXZlbnRNYW5pcHVsYXRpb24gJiYgZXZlbnQucHJldmVudE1hbmlwdWxhdGlvbigpOyAgLy9mb3Igc29tZSBNaWNyb3NvZnQgYnJvd3NlcnNcblx0fSxcblx0X2hhc1RvdWNoSUQgPSAobGlzdCwgSUQpID0+IHtcblx0XHRsZXQgaSA9IGxpc3QubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGlmIChsaXN0W2ldLmlkZW50aWZpZXIgPT09IElEKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0X29uTXVsdGlUb3VjaERvY3VtZW50RW5kID0gZXZlbnQgPT4ge1xuXHRcdF9pc011bHRpVG91Y2hpbmcgPSAoZXZlbnQudG91Y2hlcyAmJiBfZHJhZ0NvdW50IDwgZXZlbnQudG91Y2hlcy5sZW5ndGgpO1xuXHRcdF9yZW1vdmVMaXN0ZW5lcihldmVudC50YXJnZXQsIFwidG91Y2hlbmRcIiwgX29uTXVsdGlUb3VjaERvY3VtZW50RW5kKTtcblx0fSxcblxuXHRfb25NdWx0aVRvdWNoRG9jdW1lbnQgPSBldmVudCA9PiB7XG5cdFx0X2lzTXVsdGlUb3VjaGluZyA9IChldmVudC50b3VjaGVzICYmIF9kcmFnQ291bnQgPCBldmVudC50b3VjaGVzLmxlbmd0aCk7XG5cdFx0X2FkZExpc3RlbmVyKGV2ZW50LnRhcmdldCwgXCJ0b3VjaGVuZFwiLCBfb25NdWx0aVRvdWNoRG9jdW1lbnRFbmQpO1xuXHR9LFxuXHRfZ2V0RG9jU2Nyb2xsVG9wID0gZG9jID0+IF93aW4ucGFnZVlPZmZzZXQgIHx8IGRvYy5zY3JvbGxUb3AgfHwgZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jLmJvZHkuc2Nyb2xsVG9wIHx8IDAsXG5cdF9nZXREb2NTY3JvbGxMZWZ0ID0gZG9jID0+IF93aW4ucGFnZVhPZmZzZXQgfHwgZG9jLnNjcm9sbExlZnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvYy5ib2R5LnNjcm9sbExlZnQgfHwgMCxcblx0X2FkZFNjcm9sbExpc3RlbmVyID0gKGUsIGNhbGxiYWNrKSA9PiB7XG5cdFx0X2FkZExpc3RlbmVyKGUsIFwic2Nyb2xsXCIsIGNhbGxiYWNrKTtcblx0XHRpZiAoIV9pc1Jvb3QoZS5wYXJlbnROb2RlKSkge1xuXHRcdFx0X2FkZFNjcm9sbExpc3RlbmVyKGUucGFyZW50Tm9kZSwgY2FsbGJhY2spO1xuXHRcdH1cblx0fSxcblx0X3JlbW92ZVNjcm9sbExpc3RlbmVyID0gKGUsIGNhbGxiYWNrKSA9PiB7XG5cdFx0X3JlbW92ZUxpc3RlbmVyKGUsIFwic2Nyb2xsXCIsIGNhbGxiYWNrKTtcblx0XHRpZiAoIV9pc1Jvb3QoZS5wYXJlbnROb2RlKSkge1xuXHRcdFx0X3JlbW92ZVNjcm9sbExpc3RlbmVyKGUucGFyZW50Tm9kZSwgY2FsbGJhY2spO1xuXHRcdH1cblx0fSxcblx0X2lzUm9vdCA9IGUgPT4gISEoIWUgfHwgZSA9PT0gX2RvY0VsZW1lbnQgfHwgZS5ub2RlVHlwZSA9PT0gOSB8fCBlID09PSBfZG9jLmJvZHkgfHwgZSA9PT0gX3dpbiB8fCAhZS5ub2RlVHlwZSB8fCAhZS5wYXJlbnROb2RlKSxcblx0X2dldE1heFNjcm9sbCA9IChlbGVtZW50LCBheGlzKSA9PiB7XG5cdFx0bGV0IGRpbSA9IChheGlzID09PSBcInhcIikgPyBcIldpZHRoXCIgOiBcIkhlaWdodFwiLFxuXHRcdFx0c2Nyb2xsID0gXCJzY3JvbGxcIiArIGRpbSxcblx0XHRcdGNsaWVudCA9IFwiY2xpZW50XCIgKyBkaW07XG5cdFx0cmV0dXJuIE1hdGgubWF4KDAsIF9pc1Jvb3QoZWxlbWVudCkgPyBNYXRoLm1heChfZG9jRWxlbWVudFtzY3JvbGxdLCBfYm9keVtzY3JvbGxdKSAtIChfd2luW1wiaW5uZXJcIiArIGRpbV0gfHwgX2RvY0VsZW1lbnRbY2xpZW50XSB8fCBfYm9keVtjbGllbnRdKSA6IGVsZW1lbnRbc2Nyb2xsXSAtIGVsZW1lbnRbY2xpZW50XSk7XG5cdH0sXG5cdF9yZWNvcmRNYXhTY3JvbGxzID0gKGUsIHNraXBDdXJyZW50KSA9PiB7IC8vcmVjb3JkcyBfZ3NNYXhTY3JvbGxYIGFuZCBfZ3NNYXhTY3JvbGxZIHByb3BlcnRpZXMgZm9yIHRoZSBlbGVtZW50IGFuZCBhbGwgYW5jZXN0b3JzIHVwIHRoZSBjaGFpbiBzbyB0aGF0IHdlIGNhbiBjYXAgaXQsIG90aGVyd2lzZSBkcmFnZ2luZyBiZXlvbmQgdGhlIGVkZ2VzIHdpdGggYXV0b1Njcm9sbCBvbiBjYW4gZW5kbGVzc2x5IHNjcm9sbC5cblx0XHRsZXQgeCA9IF9nZXRNYXhTY3JvbGwoZSwgXCJ4XCIpLFxuXHRcdFx0eSA9IF9nZXRNYXhTY3JvbGwoZSwgXCJ5XCIpO1xuXHRcdGlmIChfaXNSb290KGUpKSB7XG5cdFx0XHRlID0gX3dpbmRvd1Byb3h5O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRfcmVjb3JkTWF4U2Nyb2xscyhlLnBhcmVudE5vZGUsIHNraXBDdXJyZW50KTtcblx0XHR9XG5cdFx0ZS5fZ3NNYXhTY3JvbGxYID0geDtcblx0XHRlLl9nc01heFNjcm9sbFkgPSB5O1xuXHRcdGlmICghc2tpcEN1cnJlbnQpIHtcblx0XHRcdGUuX2dzU2Nyb2xsWCA9IGUuc2Nyb2xsTGVmdCB8fCAwO1xuXHRcdFx0ZS5fZ3NTY3JvbGxZID0gZS5zY3JvbGxUb3AgfHwgMDtcblx0XHR9XG5cdH0sXG5cdF9zZXRTdHlsZSA9IChlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpID0+IHtcblx0XHRsZXQgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuXHRcdGlmICghc3R5bGUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKF9pc1VuZGVmaW5lZChzdHlsZVtwcm9wZXJ0eV0pKSB7XG5cdFx0XHRwcm9wZXJ0eSA9IF9jaGVja1ByZWZpeChwcm9wZXJ0eSwgZWxlbWVudCkgfHwgcHJvcGVydHk7XG5cdFx0fVxuXHRcdGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVQcm9wZXJ0eSAmJiBzdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eS5yZXBsYWNlKC8oW0EtWl0pL2csIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcblx0XHR9XG5cdH0sXG5cdF9nZXRDb21wdXRlZFN0eWxlID0gZWxlbWVudCA9PiBfd2luLmdldENvbXB1dGVkU3R5bGUoKGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSA/IGVsZW1lbnQgOiBlbGVtZW50Lmhvc3QgfHwgKGVsZW1lbnQucGFyZW50Tm9kZSB8fCB7fSkuaG9zdCB8fCBlbGVtZW50KSwgLy90aGUgXCJob3N0XCIgc3R1ZmYgaGVscHMgdG8gYWNjb21tb2RhdGUgU2hhZG93RG9tIG9iamVjdHMuXG5cblx0X3RlbXBSZWN0ID0ge30sIC8vcmV1c2UgdG8gcmVkdWNlIGdhcmJhZ2UgY29sbGVjdGlvbiB0YXNrc1xuXHRfcGFyc2VSZWN0ID0gZSA9PiB7IC8vYWNjZXB0cyBhIERPTSBlbGVtZW50LCBhIG1vdXNlIGV2ZW50LCBvciBhIHJlY3RhbmdsZSBvYmplY3QgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVjdGFuZ2xlIHdpdGggbGVmdCwgcmlnaHQsIHdpZHRoLCBoZWlnaHQsIHRvcCwgYW5kIGJvdHRvbSBwcm9wZXJ0aWVzXG5cdFx0aWYgKGUgPT09IF93aW4pIHtcblx0XHRcdF90ZW1wUmVjdC5sZWZ0ID0gX3RlbXBSZWN0LnRvcCA9IDA7XG5cdFx0XHRfdGVtcFJlY3Qud2lkdGggPSBfdGVtcFJlY3QucmlnaHQgPSBfZG9jRWxlbWVudC5jbGllbnRXaWR0aCB8fCBlLmlubmVyV2lkdGggfHwgX2JvZHkuY2xpZW50V2lkdGggfHwgMDtcblx0XHRcdF90ZW1wUmVjdC5oZWlnaHQgPSBfdGVtcFJlY3QuYm90dG9tID0gKChlLmlubmVySGVpZ2h0IHx8IDApIC0gMjAgPCBfZG9jRWxlbWVudC5jbGllbnRIZWlnaHQpID8gX2RvY0VsZW1lbnQuY2xpZW50SGVpZ2h0IDogZS5pbm5lckhlaWdodCB8fCBfYm9keS5jbGllbnRIZWlnaHQgfHwgMDtcblx0XHRcdHJldHVybiBfdGVtcFJlY3Q7XG5cdFx0fVxuXHRcdGxldCBkb2MgPSBlLm93bmVyRG9jdW1lbnQgfHwgX2RvYyxcblx0XHRcdHIgPSAhX2lzVW5kZWZpbmVkKGUucGFnZVgpID8ge2xlZnQ6IGUucGFnZVggLSBfZ2V0RG9jU2Nyb2xsTGVmdChkb2MpLCB0b3A6IGUucGFnZVkgLSBfZ2V0RG9jU2Nyb2xsVG9wKGRvYyksIHJpZ2h0OiBlLnBhZ2VYIC0gX2dldERvY1Njcm9sbExlZnQoZG9jKSArIDEsIGJvdHRvbTogZS5wYWdlWSAtIF9nZXREb2NTY3JvbGxUb3AoZG9jKSArIDF9IDogKCFlLm5vZGVUeXBlICYmICFfaXNVbmRlZmluZWQoZS5sZWZ0KSAmJiAhX2lzVW5kZWZpbmVkKGUudG9wKSkgPyBlIDogX3RvQXJyYXkoZSlbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0aWYgKF9pc1VuZGVmaW5lZChyLnJpZ2h0KSAmJiAhX2lzVW5kZWZpbmVkKHIud2lkdGgpKSB7XG5cdFx0XHRyLnJpZ2h0ID0gci5sZWZ0ICsgci53aWR0aDtcblx0XHRcdHIuYm90dG9tID0gci50b3AgKyByLmhlaWdodDtcblx0XHR9IGVsc2UgaWYgKF9pc1VuZGVmaW5lZChyLndpZHRoKSkgeyAvL3NvbWUgYnJvd3NlcnMgZG9uJ3QgaW5jbHVkZSB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXMuIFdlIGNhbid0IGp1c3Qgc2V0IHRoZW0gZGlyZWN0bHkgb24gciBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgdGhyb3cgZXJyb3JzLCBzbyBjcmVhdGUgYSBuZXcgZ2VuZXJpYyBvYmplY3QuXG5cdFx0XHRyID0ge3dpZHRoOiByLnJpZ2h0IC0gci5sZWZ0LCBoZWlnaHQ6IHIuYm90dG9tIC0gci50b3AsIHJpZ2h0OiByLnJpZ2h0LCBsZWZ0OiByLmxlZnQsIGJvdHRvbTogci5ib3R0b20sIHRvcDogci50b3B9O1xuXHRcdH1cblx0XHRyZXR1cm4gcjtcblx0fSxcblxuXHRfZGlzcGF0Y2hFdmVudCA9ICh0YXJnZXQsIHR5cGUsIGNhbGxiYWNrTmFtZSkgPT4ge1xuXHRcdGxldCB2YXJzID0gdGFyZ2V0LnZhcnMsXG5cdFx0XHRjYWxsYmFjayA9IHZhcnNbY2FsbGJhY2tOYW1lXSxcblx0XHRcdGxpc3RlbmVycyA9IHRhcmdldC5fbGlzdGVuZXJzW3R5cGVdLFxuXHRcdFx0cmVzdWx0O1xuXHRcdGlmIChfaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcblx0XHRcdHJlc3VsdCA9IGNhbGxiYWNrLmFwcGx5KHZhcnMuY2FsbGJhY2tTY29wZSB8fCB0YXJnZXQsIHZhcnNbY2FsbGJhY2tOYW1lICsgXCJQYXJhbXNcIl0gfHwgW3RhcmdldC5wb2ludGVyRXZlbnRdKTtcblx0XHR9XG5cdFx0aWYgKGxpc3RlbmVycyAmJiB0YXJnZXQuZGlzcGF0Y2hFdmVudCh0eXBlKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJlc3VsdCA9IGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXHRfZ2V0Qm91bmRzID0gKHRhcmdldCwgY29udGV4dCkgPT4geyAvL2FjY2VwdHMgYW55IG9mIHRoZSBmb2xsb3dpbmc6IGEgRE9NIGVsZW1lbnQsIGpRdWVyeSBvYmplY3QsIHNlbGVjdG9yIHRleHQsIG9yIGFuIG9iamVjdCBkZWZpbmluZyBib3VuZHMgYXMge3RvcCwgbGVmdCwgd2lkdGgsIGhlaWdodH0gb3Ige21pblgsIG1heFgsIG1pblksIG1heFl9LiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGxlZnQsIHRvcCwgd2lkdGgsIGFuZCBoZWlnaHQgcHJvcGVydGllcy5cblx0XHRsZXQgZSA9IF90b0FycmF5KHRhcmdldClbMF0sXG5cdFx0XHR0b3AsIGxlZnQsIG9mZnNldDtcblx0XHRpZiAoIWUubm9kZVR5cGUgJiYgZSAhPT0gX3dpbikge1xuXHRcdFx0aWYgKCFfaXNVbmRlZmluZWQodGFyZ2V0LmxlZnQpKSB7XG5cdFx0XHRcdG9mZnNldCA9IHt4OjAsIHk6MH07IC8vX2dldE9mZnNldFRyYW5zZm9ybU9yaWdpbihjb250ZXh0KTsgLy90aGUgYm91bmRzIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgb3JpZ2luXG5cdFx0XHRcdHJldHVybiB7bGVmdDogdGFyZ2V0LmxlZnQgLSBvZmZzZXQueCwgdG9wOiB0YXJnZXQudG9wIC0gb2Zmc2V0LnksIHdpZHRoOiB0YXJnZXQud2lkdGgsIGhlaWdodDogdGFyZ2V0LmhlaWdodH07XG5cdFx0XHR9XG5cdFx0XHRsZWZ0ID0gdGFyZ2V0Lm1pbiB8fCB0YXJnZXQubWluWCB8fCB0YXJnZXQubWluUm90YXRpb24gfHwgMDtcblx0XHRcdHRvcCA9IHRhcmdldC5taW4gfHwgdGFyZ2V0Lm1pblkgfHwgMDtcblx0XHRcdHJldHVybiB7bGVmdDpsZWZ0LCB0b3A6dG9wLCB3aWR0aDoodGFyZ2V0Lm1heCB8fCB0YXJnZXQubWF4WCB8fCB0YXJnZXQubWF4Um90YXRpb24gfHwgMCkgLSBsZWZ0LCBoZWlnaHQ6KHRhcmdldC5tYXggfHwgdGFyZ2V0Lm1heFkgfHwgMCkgLSB0b3B9O1xuXHRcdH1cblx0XHRyZXR1cm4gX2dldEVsZW1lbnRCb3VuZHMoZSwgY29udGV4dCk7XG5cdH0sXG5cdF9wb2ludDEgPSB7fSwgLy93ZSByZXVzZSB0byBtaW5pbWl6ZSBnYXJiYWdlIGNvbGxlY3Rpb24gdGFza3MuXG5cdF9nZXRFbGVtZW50Qm91bmRzID0gKGVsZW1lbnQsIGNvbnRleHQpID0+IHtcblx0XHRjb250ZXh0ID0gX3RvQXJyYXkoY29udGV4dClbMF07XG5cdFx0bGV0IGlzU1ZHID0gKGVsZW1lbnQuZ2V0QkJveCAmJiBlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCksXG5cdFx0XHRkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgX2RvYyxcblx0XHRcdGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbWF0cml4LCBwMSwgcDIsIHAzLCBwNCwgYmJveCwgd2lkdGgsIGhlaWdodCwgY3MsIGNvbnRleHRQYXJlbnQ7XG5cdFx0aWYgKGVsZW1lbnQgPT09IF93aW4pIHtcblx0XHRcdHRvcCA9IF9nZXREb2NTY3JvbGxUb3AoZG9jKTtcblx0XHRcdGxlZnQgPSBfZ2V0RG9jU2Nyb2xsTGVmdChkb2MpO1xuXHRcdFx0cmlnaHQgPSBsZWZ0ICsgKGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgZWxlbWVudC5pbm5lcldpZHRoIHx8IGRvYy5ib2R5LmNsaWVudFdpZHRoIHx8IDApO1xuXHRcdFx0Ym90dG9tID0gdG9wICsgKCgoZWxlbWVudC5pbm5lckhlaWdodCB8fCAwKSAtIDIwIDwgZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpID8gZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgOiBlbGVtZW50LmlubmVySGVpZ2h0IHx8IGRvYy5ib2R5LmNsaWVudEhlaWdodCB8fCAwKTsgLy9zb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpIGlnbm9yZSBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgZWxlbWVudHMsIGFuZCBjb2xsYXBzZSB0aGUgaGVpZ2h0IG9mIHRoZSBkb2N1bWVudEVsZW1lbnQsIHNvIGl0IGNvdWxkIGJlIDhweCwgZm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIGp1c3QgYW4gYWJzb2x1dGVseSBwb3NpdGlvbmVkIGRpdi4gSW4gdGhhdCBjYXNlLCB3ZSB1c2UgdGhlIGlubmVySGVpZ2h0IHRvIHJlc29sdmUgdGhpcy5cblx0XHR9IGVsc2UgaWYgKGNvbnRleHQgPT09IF93aW4gfHwgX2lzVW5kZWZpbmVkKGNvbnRleHQpKSB7XG5cdFx0XHRyZXR1cm4gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGVmdCA9IHRvcCA9ICAwO1xuXHRcdFx0aWYgKGlzU1ZHKSB7XG5cdFx0XHRcdGJib3ggPSBlbGVtZW50LmdldEJCb3goKTtcblx0XHRcdFx0d2lkdGggPSBiYm94LndpZHRoO1xuXHRcdFx0XHRoZWlnaHQgPSBiYm94LmhlaWdodDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChlbGVtZW50LnZpZXdCb3ggJiYgKGJib3ggPSBlbGVtZW50LnZpZXdCb3guYmFzZVZhbCkpIHtcblx0XHRcdFx0XHRsZWZ0ID0gYmJveC54IHx8IDA7XG5cdFx0XHRcdFx0dG9wID0gYmJveC55IHx8IDA7XG5cdFx0XHRcdFx0d2lkdGggPSBiYm94LndpZHRoO1xuXHRcdFx0XHRcdGhlaWdodCA9IGJib3guaGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghd2lkdGgpIHtcblx0XHRcdFx0XHRjcyA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXHRcdFx0XHRcdGJib3ggPSBjcy5ib3hTaXppbmcgPT09IFwiYm9yZGVyLWJveFwiO1xuXHRcdFx0XHRcdHdpZHRoID0gKHBhcnNlRmxvYXQoY3Mud2lkdGgpIHx8IGVsZW1lbnQuY2xpZW50V2lkdGggfHwgMCkgKyAoYmJveCA/IDAgOiBwYXJzZUZsb2F0KGNzLmJvcmRlckxlZnRXaWR0aCkgKyBwYXJzZUZsb2F0KGNzLmJvcmRlclJpZ2h0V2lkdGgpKTtcblx0XHRcdFx0XHRoZWlnaHQgPSAocGFyc2VGbG9hdChjcy5oZWlnaHQpIHx8IGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IDApICsgKGJib3ggPyAwIDogcGFyc2VGbG9hdChjcy5ib3JkZXJUb3BXaWR0aCkgKyBwYXJzZUZsb2F0KGNzLmJvcmRlckJvdHRvbVdpZHRoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJpZ2h0ID0gd2lkdGg7XG5cdFx0XHRib3R0b20gPSBoZWlnaHQ7XG5cdFx0fVxuXHRcdGlmIChlbGVtZW50ID09PSBjb250ZXh0KSB7XG5cdFx0XHRyZXR1cm4ge2xlZnQ6bGVmdCwgdG9wOnRvcCwgd2lkdGg6IHJpZ2h0IC0gbGVmdCwgaGVpZ2h0OiBib3R0b20gLSB0b3B9O1xuXHRcdH1cblx0XHRtYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoY29udGV4dCwgdHJ1ZSkubXVsdGlwbHkoZ2V0R2xvYmFsTWF0cml4KGVsZW1lbnQpKTtcblx0XHRwMSA9IG1hdHJpeC5hcHBseSh7eDpsZWZ0LCB5OnRvcH0pO1xuXHRcdHAyID0gbWF0cml4LmFwcGx5KHt4OnJpZ2h0LCB5OnRvcH0pO1xuXHRcdHAzID0gbWF0cml4LmFwcGx5KHt4OnJpZ2h0LCB5OmJvdHRvbX0pO1xuXHRcdHA0ID0gbWF0cml4LmFwcGx5KHt4OmxlZnQsIHk6Ym90dG9tfSk7XG5cdFx0bGVmdCA9IE1hdGgubWluKHAxLngsIHAyLngsIHAzLngsIHA0LngpO1xuXHRcdHRvcCA9IE1hdGgubWluKHAxLnksIHAyLnksIHAzLnksIHA0LnkpO1xuXHRcdGNvbnRleHRQYXJlbnQgPSBjb250ZXh0LnBhcmVudE5vZGUgfHwge307XG5cdFx0cmV0dXJuIHtsZWZ0OiBsZWZ0ICsgKGNvbnRleHRQYXJlbnQuc2Nyb2xsTGVmdCB8fCAwKSwgdG9wOiB0b3AgKyAoY29udGV4dFBhcmVudC5zY3JvbGxUb3AgfHwgMCksIHdpZHRoOiBNYXRoLm1heChwMS54LCBwMi54LCBwMy54LCBwNC54KSAtIGxlZnQsIGhlaWdodDogTWF0aC5tYXgocDEueSwgcDIueSwgcDMueSwgcDQueSkgLSB0b3B9O1xuXHR9LFxuXHRfcGFyc2VJbmVydGlhID0gKGRyYWdnYWJsZSwgc25hcCwgbWF4LCBtaW4sIGZhY3RvciwgZm9yY2VaZXJvVmVsb2NpdHkpID0+IHtcblx0XHRsZXQgdmFycyA9IHt9LFxuXHRcdFx0YSwgaSwgbDtcblx0XHRpZiAoc25hcCkge1xuXHRcdFx0aWYgKGZhY3RvciAhPT0gMSAmJiBzbmFwIGluc3RhbmNlb2YgQXJyYXkpIHsgLy9zb21lIGRhdGEgbXVzdCBiZSBhbHRlcmVkIHRvIG1ha2Ugc2Vuc2UsIGxpa2UgaWYgdGhlIHVzZXIgcGFzc2VzIGluIGFuIGFycmF5IG9mIHJvdGF0aW9uYWwgdmFsdWVzIGluIGRlZ3JlZXMsIHdlIG11c3QgY29udmVydCBpdCB0byByYWRpYW5zLiBPciBmb3Igc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wLCB3ZSBpbnZlcnQgdGhlIHZhbHVlcy5cblx0XHRcdFx0dmFycy5lbmQgPSBhID0gW107XG5cdFx0XHRcdGwgPSBzbmFwLmxlbmd0aDtcblx0XHRcdFx0aWYgKF9pc09iamVjdChzbmFwWzBdKSkgeyAvL2lmIHRoZSBhcnJheSBpcyBwb3B1bGF0ZWQgd2l0aCBvYmplY3RzLCBsaWtlIHBvaW50cyAoe3g6MTAwLCB5OjIwMH0pLCBtYWtlIGNvcGllcyBiZWZvcmUgbXVsdGlwbHlpbmcgYnkgdGhlIGZhY3Rvciwgb3RoZXJ3aXNlIHdlJ2xsIG1lc3MgdXAgdGhlIG9yaWdpbmFscyBhbmQgdGhlIHVzZXIgbWF5IHJldXNlIGl0IGVsc2V3aGVyZS5cblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRhW2ldID0gX2NvcHkoc25hcFtpXSwgZmFjdG9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0YVtpXSA9IHNuYXBbaV0gKiBmYWN0b3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdG1heCArPSAxLjE7IC8vYWxsb3cgMS4xIHBpeGVscyBvZiB3aWdnbGUgcm9vbSB3aGVuIHNuYXBwaW5nIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kIHNvbWUgYnJvd3NlciBpbmNvbnNpc3RlbmNpZXMgaW4gdGhlIHdheSBib3VuZHMgYXJlIHJlcG9ydGVkIHdoaWNoIGNhbiBtYWtlIHRoZW0gcm91Z2hseSBhIHBpeGVsIG9mZi4gRm9yIGV4YW1wbGUsIGlmIFwic25hcDpbLSQoJyNtZW51Jykud2lkdGgoKSwgMF1cIiB3YXMgZGVmaW5lZCBhbmQgI21lbnUgaGFkIGEgd3JhcHBlciB0aGF0IHdhcyB1c2VkIGFzIHRoZSBib3VuZHMsIHNvbWUgYnJvd3NlcnMgd291bGQgYmUgb25lIHBpeGVsIG9mZiwgbWFraW5nIHRoZSBtaW5pbXVtIC03NTIgZm9yIGV4YW1wbGUgd2hlbiBzbmFwIHdhcyBbLTc1MywwXSwgdGh1cyBpbnN0ZWFkIG9mIHNuYXBwaW5nIHRvIC03NTMsIGl0IHdvdWxkIHNuYXAgdG8gMCBzaW5jZSAtNzUzIHdhcyBiZWxvdyB0aGUgbWluaW11bS5cblx0XHRcdFx0bWluIC09IDEuMTtcblx0XHRcdH0gZWxzZSBpZiAoX2lzRnVuY3Rpb24oc25hcCkpIHtcblx0XHRcdFx0dmFycy5lbmQgPSB2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0bGV0IHJlc3VsdCA9IHNuYXAuY2FsbChkcmFnZ2FibGUsIHZhbHVlKSxcblx0XHRcdFx0XHRcdGNvcHksIHA7XG5cdFx0XHRcdFx0aWYgKGZhY3RvciAhPT0gMSkge1xuXHRcdFx0XHRcdFx0aWYgKF9pc09iamVjdChyZXN1bHQpKSB7XG5cdFx0XHRcdFx0XHRcdGNvcHkgPSB7fTtcblx0XHRcdFx0XHRcdFx0Zm9yIChwIGluIHJlc3VsdCkge1xuXHRcdFx0XHRcdFx0XHRcdGNvcHlbcF0gPSByZXN1bHRbcF0gKiBmYWN0b3I7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmVzdWx0ID0gY29weTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdCAqPSBmYWN0b3I7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7IC8vd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB3ZSBjYW4gc2NvcGUgdGhlIGZ1bmN0aW9uIGNhbGwgdG8gdGhlIERyYWdnYWJsZSBpbnN0YW5jZSBpdHNlbGYgc28gdGhhdCB1c2VycyBjYW4gYWNjZXNzIGltcG9ydGFudCB2YWx1ZXMgbGlrZSBtYXhYLCBtaW5YLCBtYXhZLCBtaW5ZLCB4LCBhbmQgeSBmcm9tIHdpdGhpbiB0aGF0IGZ1bmN0aW9uLlxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFycy5lbmQgPSBzbmFwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobWF4IHx8IG1heCA9PT0gMCkge1xuXHRcdFx0dmFycy5tYXggPSBtYXg7XG5cdFx0fVxuXHRcdGlmIChtaW4gfHwgbWluID09PSAwKSB7XG5cdFx0XHR2YXJzLm1pbiA9IG1pbjtcblx0XHR9XG5cdFx0aWYgKGZvcmNlWmVyb1ZlbG9jaXR5KSB7XG5cdFx0XHR2YXJzLnZlbG9jaXR5ID0gMDtcblx0XHR9XG5cdFx0cmV0dXJuIHZhcnM7XG5cdH0sXG5cdF9pc0NsaWNrYWJsZSA9IGVsZW1lbnQgPT4geyAvL3NvbWV0aW1lcyBpdCdzIGNvbnZlbmllbnQgdG8gbWFyayBhbiBlbGVtZW50IGFzIGNsaWNrYWJsZSBieSBhZGRpbmcgYSBkYXRhLWNsaWNrYWJsZT1cInRydWVcIiBhdHRyaWJ1dGUgKGluIHdoaWNoIGNhc2Ugd2Ugd29uJ3QgcHJldmVudERlZmF1bHQoKSB0aGUgbW91c2UvdG91Y2ggZXZlbnQpLiBUaGlzIG1ldGhvZCBjaGVja3MgaWYgdGhlIGVsZW1lbnQgaXMgYW4gPGE+LCA8aW5wdXQ+LCBvciA8YnV0dG9uPiBvciBoYXMgYW4gb25jbGljayBvciBoYXMgdGhlIGRhdGEtY2xpY2thYmxlIG9yIGNvbnRlbnRFZGl0YWJsZSBhdHRyaWJ1dGUgc2V0IHRvIHRydWUgKG9yIGFueSBvZiBpdHMgcGFyZW50IGVsZW1lbnRzKS5cblx0XHRsZXQgZGF0YTtcblx0XHRyZXR1cm4gKCFlbGVtZW50IHx8ICFlbGVtZW50LmdldEF0dHJpYnV0ZSB8fCBlbGVtZW50ID09PSBfYm9keSkgPyBmYWxzZSA6ICgoZGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jbGlja2FibGVcIikpID09PSBcInRydWVcIiB8fCAoZGF0YSAhPT0gXCJmYWxzZVwiICYmIChlbGVtZW50Lm9uY2xpY2sgfHwgX2NsaWNrYWJsZVRhZ0V4cC50ZXN0KGVsZW1lbnQubm9kZU5hbWUgKyBcIlwiKSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiKSA9PT0gXCJ0cnVlXCIpKSkgPyB0cnVlIDogX2lzQ2xpY2thYmxlKGVsZW1lbnQucGFyZW50Tm9kZSk7XG5cdH0sXG5cdF9zZXRTZWxlY3RhYmxlID0gKGVsZW1lbnRzLCBzZWxlY3RhYmxlKSA9PiB7XG5cdFx0bGV0IGkgPSBlbGVtZW50cy5sZW5ndGgsXG5cdFx0XHRlO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGUgPSBlbGVtZW50c1tpXTtcblx0XHRcdGUub25kcmFnc3RhcnQgPSBlLm9uc2VsZWN0c3RhcnQgPSBzZWxlY3RhYmxlID8gbnVsbCA6IF9lbXB0eUZ1bmM7XG5cdFx0XHRnc2FwLnNldChlLCB7bGF6eTp0cnVlLCB1c2VyU2VsZWN0OiAoc2VsZWN0YWJsZSA/IFwidGV4dFwiIDogXCJub25lXCIpfSk7XG5cdFx0fVxuXHR9LFxuXHRfaXNGaXhlZCA9IGVsZW1lbnQgPT4ge1xuXHRcdGlmIChfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblx0XHRpZiAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7IC8vIGF2b2lkIGRvY3VtZW50IGZyYWdtZW50cyB3aGljaCB3aWxsIHRocm93IGFuIGVycm9yLlxuXHRcdFx0cmV0dXJuIF9pc0ZpeGVkKGVsZW1lbnQpO1xuXHRcdH1cblx0fSxcblx0X3N1cHBvcnRzM0QsIF9hZGRQYWRkaW5nQlIsXG5cblx0Ly9UaGUgU2Nyb2xsUHJveHkgY2xhc3Mgd3JhcHMgYW4gZWxlbWVudCdzIGNvbnRlbnRzIGludG8gYW5vdGhlciBkaXYgKHdlIGNhbGwgaXQgXCJjb250ZW50XCIpIHRoYXQgd2UgZWl0aGVyIGFkZCBwYWRkaW5nIHdoZW4gbmVjZXNzYXJ5IG9yIGFwcGx5IGEgdHJhbnNsYXRlM2QoKSB0cmFuc2Zvcm0gaW4gb3JkZXIgdG8gb3ZlcnNjcm9sbCAoc2Nyb2xsIHBhc3QgdGhlIGJvdW5kYXJpZXMpLiBUaGlzIGFsbG93cyB1cyB0byBzaW1wbHkgc2V0IHRoZSBzY3JvbGxUb3Avc2Nyb2xsTGVmdCAob3IgdG9wL2xlZnQgZm9yIGVhc2llciByZXZlcnNlLWF4aXMgb3JpZW50YXRpb24sIHdoaWNoIGlzIHdoYXQgd2UgZG8gaW4gRHJhZ2dhYmxlKSBhbmQgaXQnbGwgZG8gYWxsIHRoZSB3b3JrIGZvciB1cy4gRm9yIGV4YW1wbGUsIGlmIHdlIHRyaWVkIHNldHRpbmcgc2Nyb2xsVG9wIHRvIC0xMDAgb24gYSBub3JtYWwgRE9NIGVsZW1lbnQsIGl0IHdvdWxkbid0IHdvcmsgLSBpdCdkIGxvb2sgdGhlIHNhbWUgYXMgc2V0dGluZyBpdCB0byAwLCBidXQgaWYgd2Ugc2V0IHNjcm9sbFRvcCBvZiBhIFNjcm9sbFByb3h5IHRvIC0xMDAsIGl0J2xsIGdpdmUgdGhlIGNvcnJlY3QgYXBwZWFyYW5jZSBieSBlaXRoZXIgc2V0dGluZyBwYWRkaW5nVG9wIG9mIHRoZSB3cmFwcGVyIHRvIDEwMCBvciBhcHBseWluZyBhIDEwMC1waXhlbCB0cmFuc2xhdGVZLlxuXHRTY3JvbGxQcm94eSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHZhcnMpIHtcblx0XHRlbGVtZW50ID0gZ3NhcC51dGlscy50b0FycmF5KGVsZW1lbnQpWzBdO1xuXHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdGxldCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcblx0XHRcdHN0eWxlID0gY29udGVudC5zdHlsZSxcblx0XHRcdG5vZGUgPSBlbGVtZW50LmZpcnN0Q2hpbGQsXG5cdFx0XHRvZmZzZXRUb3AgPSAwLFxuXHRcdFx0b2Zmc2V0TGVmdCA9IDAsXG5cdFx0XHRwcmV2VG9wID0gZWxlbWVudC5zY3JvbGxUb3AsXG5cdFx0XHRwcmV2TGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdCxcblx0XHRcdHNjcm9sbFdpZHRoID0gZWxlbWVudC5zY3JvbGxXaWR0aCxcblx0XHRcdHNjcm9sbEhlaWdodCA9IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0LFxuXHRcdFx0ZXh0cmFQYWRSaWdodCA9IDAsXG5cdFx0XHRtYXhMZWZ0ID0gMCxcblx0XHRcdG1heFRvcCA9IDAsXG5cdFx0XHRlbGVtZW50V2lkdGgsIGVsZW1lbnRIZWlnaHQsIGNvbnRlbnRIZWlnaHQsIG5leHROb2RlLCB0cmFuc2Zvcm1TdGFydCwgdHJhbnNmb3JtRW5kO1xuXHRcdGlmIChfc3VwcG9ydHMzRCAmJiB2YXJzLmZvcmNlM0QgIT09IGZhbHNlKSB7XG5cdFx0XHR0cmFuc2Zvcm1TdGFydCA9IFwidHJhbnNsYXRlM2QoXCI7XG5cdFx0XHR0cmFuc2Zvcm1FbmQgPSBcInB4LDBweClcIjtcblx0XHR9IGVsc2UgaWYgKF90cmFuc2Zvcm1Qcm9wKSB7XG5cdFx0XHR0cmFuc2Zvcm1TdGFydCA9IFwidHJhbnNsYXRlKFwiO1xuXHRcdFx0dHJhbnNmb3JtRW5kID0gXCJweClcIjtcblx0XHR9XG5cdFx0dGhpcy5zY3JvbGxUb3AgPSBmdW5jdGlvbih2YWx1ZSwgZm9yY2UpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gLXRoaXMudG9wKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnRvcCgtdmFsdWUsIGZvcmNlKTtcblx0XHR9O1xuXHRcdHRoaXMuc2Nyb2xsTGVmdCA9IGZ1bmN0aW9uKHZhbHVlLCBmb3JjZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiAtdGhpcy5sZWZ0KCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmxlZnQoLXZhbHVlLCBmb3JjZSk7XG5cdFx0fTtcblx0XHR0aGlzLmxlZnQgPSBmdW5jdGlvbih2YWx1ZSwgZm9yY2UpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gLShlbGVtZW50LnNjcm9sbExlZnQgKyBvZmZzZXRMZWZ0KTtcblx0XHRcdH1cblx0XHRcdGxldCBkaWYgPSBlbGVtZW50LnNjcm9sbExlZnQgLSBwcmV2TGVmdCxcblx0XHRcdFx0b2xkT2Zmc2V0ID0gb2Zmc2V0TGVmdDtcblx0XHRcdGlmICgoZGlmID4gMiB8fCBkaWYgPCAtMikgJiYgIWZvcmNlKSB7IC8vaWYgdGhlIHVzZXIgaW50ZXJhY3RzIHdpdGggdGhlIHNjcm9sbGJhciAob3Igc29tZXRoaW5nIGVsc2Ugc2Nyb2xscyBpdCwgbGlrZSB0aGUgbW91c2Ugd2hlZWwpLCB3ZSBzaG91bGQga2lsbCBhbnkgdHdlZW5zIG9mIHRoZSBTY3JvbGxQcm94eS5cblx0XHRcdFx0cHJldkxlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XG5cdFx0XHRcdGdzYXAua2lsbFR3ZWVuc09mKHRoaXMsIHtsZWZ0OjEsIHNjcm9sbExlZnQ6MX0pO1xuXHRcdFx0XHR0aGlzLmxlZnQoLXByZXZMZWZ0KTtcblx0XHRcdFx0aWYgKHZhcnMub25LaWxsKSB7XG5cdFx0XHRcdFx0dmFycy5vbktpbGwoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9IC12YWx1ZTsgLy9pbnZlcnQgYmVjYXVzZSBzY3JvbGxpbmcgd29ya3MgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuXHRcdFx0aWYgKHZhbHVlIDwgMCkge1xuXHRcdFx0XHRvZmZzZXRMZWZ0ID0gKHZhbHVlIC0gMC41KSB8IDA7XG5cdFx0XHRcdHZhbHVlID0gMDtcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPiBtYXhMZWZ0KSB7XG5cdFx0XHRcdG9mZnNldExlZnQgPSAodmFsdWUgLSBtYXhMZWZ0KSB8IDA7XG5cdFx0XHRcdHZhbHVlID0gbWF4TGVmdDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9mZnNldExlZnQgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9mZnNldExlZnQgfHwgb2xkT2Zmc2V0KSB7XG5cdFx0XHRcdGlmICghdGhpcy5fc2tpcCkge1xuXHRcdFx0XHRcdHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybVN0YXJ0ICsgLW9mZnNldExlZnQgKyBcInB4LFwiICsgLW9mZnNldFRvcCArIHRyYW5zZm9ybUVuZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob2Zmc2V0TGVmdCArIGV4dHJhUGFkUmlnaHQgPj0gMCkge1xuXHRcdFx0XHRcdHN0eWxlLnBhZGRpbmdSaWdodCA9ICBvZmZzZXRMZWZ0ICsgZXh0cmFQYWRSaWdodCArIFwicHhcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudC5zY3JvbGxMZWZ0ID0gdmFsdWUgfCAwO1xuXHRcdFx0cHJldkxlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7IC8vZG9uJ3QgbWVyZ2UgdGhpcyB3aXRoIHRoZSBsaW5lIGFib3ZlIGJlY2F1c2Ugc29tZSBicm93c2VycyBhZGp1c3QgdGhlIHNjcm9sbExlZnQgYWZ0ZXIgaXQncyBzZXQsIHNvIGluIG9yZGVyIHRvIGJlIDEwMCUgYWNjdXJhdGUgaW4gdHJhY2tpbmcgaXQsIHdlIG5lZWQgdG8gYXNrIHRoZSBicm93c2VyIHRvIHJlcG9ydCBpdC5cblx0XHR9O1xuXHRcdHRoaXMudG9wID0gZnVuY3Rpb24odmFsdWUsIGZvcmNlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIC0oZWxlbWVudC5zY3JvbGxUb3AgKyBvZmZzZXRUb3ApO1xuXHRcdFx0fVxuXHRcdFx0bGV0IGRpZiA9IGVsZW1lbnQuc2Nyb2xsVG9wIC0gcHJldlRvcCxcblx0XHRcdFx0b2xkT2Zmc2V0ID0gb2Zmc2V0VG9wO1xuXHRcdFx0aWYgKChkaWYgPiAyIHx8IGRpZiA8IC0yKSAmJiAhZm9yY2UpIHsgLy9pZiB0aGUgdXNlciBpbnRlcmFjdHMgd2l0aCB0aGUgc2Nyb2xsYmFyIChvciBzb21ldGhpbmcgZWxzZSBzY3JvbGxzIGl0LCBsaWtlIHRoZSBtb3VzZSB3aGVlbCksIHdlIHNob3VsZCBraWxsIGFueSB0d2VlbnMgb2YgdGhlIFNjcm9sbFByb3h5LlxuXHRcdFx0XHRwcmV2VG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG5cdFx0XHRcdGdzYXAua2lsbFR3ZWVuc09mKHRoaXMsIHt0b3A6MSwgc2Nyb2xsVG9wOjF9KTtcblx0XHRcdFx0dGhpcy50b3AoLXByZXZUb3ApO1xuXHRcdFx0XHRpZiAodmFycy5vbktpbGwpIHtcblx0XHRcdFx0XHR2YXJzLm9uS2lsbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gLXZhbHVlOyAvL2ludmVydCBiZWNhdXNlIHNjcm9sbGluZyB3b3JrcyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG5cdFx0XHRpZiAodmFsdWUgPCAwKSB7XG5cdFx0XHRcdG9mZnNldFRvcCA9ICh2YWx1ZSAtIDAuNSkgfCAwO1xuXHRcdFx0XHR2YWx1ZSA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbHVlID4gbWF4VG9wKSB7XG5cdFx0XHRcdG9mZnNldFRvcCA9ICh2YWx1ZSAtIG1heFRvcCkgfCAwO1xuXHRcdFx0XHR2YWx1ZSA9IG1heFRvcDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9mZnNldFRvcCA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAob2Zmc2V0VG9wIHx8IG9sZE9mZnNldCkge1xuXHRcdFx0XHRpZiAoIXRoaXMuX3NraXApIHtcblx0XHRcdFx0XHRzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1TdGFydCArIC1vZmZzZXRMZWZ0ICsgXCJweCxcIiArIC1vZmZzZXRUb3AgKyB0cmFuc2Zvcm1FbmQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsZW1lbnQuc2Nyb2xsVG9wID0gdmFsdWUgfCAwO1xuXHRcdFx0cHJldlRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuXHRcdH07XG5cblx0XHR0aGlzLm1heFNjcm9sbFRvcCA9ICgpID0+IG1heFRvcDtcblx0XHR0aGlzLm1heFNjcm9sbExlZnQgPSAoKSA9PiBtYXhMZWZ0O1xuXG5cdFx0dGhpcy5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRub2RlID0gY29udGVudC5maXJzdENoaWxkO1xuXHRcdFx0d2hpbGUgKG5vZGUpIHtcblx0XHRcdFx0bmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuXHRcdFx0XHRlbGVtZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuXHRcdFx0XHRub2RlID0gbmV4dE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZWxlbWVudCA9PT0gY29udGVudC5wYXJlbnROb2RlKSB7IC8vaW4gY2FzZSBkaXNhYmxlKCkgaXMgY2FsbGVkIHdoZW4gaXQncyBhbHJlYWR5IGRpc2FibGVkLlxuXHRcdFx0XHRlbGVtZW50LnJlbW92ZUNoaWxkKGNvbnRlbnQpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0dGhpcy5lbmFibGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdG5vZGUgPSBlbGVtZW50LmZpcnN0Q2hpbGQ7XG5cdFx0XHRpZiAobm9kZSA9PT0gY29udGVudCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAobm9kZSkge1xuXHRcdFx0XHRuZXh0Tm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG5cdFx0XHRcdGNvbnRlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdFx0XHRcdG5vZGUgPSBuZXh0Tm9kZTtcblx0XHRcdH1cblx0XHRcdGVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udGVudCk7XG5cdFx0XHR0aGlzLmNhbGlicmF0ZSgpO1xuXHRcdH07XG5cdFx0dGhpcy5jYWxpYnJhdGUgPSBmdW5jdGlvbihmb3JjZSkge1xuXHRcdFx0bGV0IHdpZHRoTWF0Y2hlcyA9IChlbGVtZW50LmNsaWVudFdpZHRoID09PSBlbGVtZW50V2lkdGgpLFxuXHRcdFx0XHRjcywgeCwgeTtcblx0XHRcdHByZXZUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcblx0XHRcdHByZXZMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xuXHRcdFx0aWYgKHdpZHRoTWF0Y2hlcyAmJiBlbGVtZW50LmNsaWVudEhlaWdodCA9PT0gZWxlbWVudEhlaWdodCAmJiBjb250ZW50Lm9mZnNldEhlaWdodCA9PT0gY29udGVudEhlaWdodCAmJiBzY3JvbGxXaWR0aCA9PT0gZWxlbWVudC5zY3JvbGxXaWR0aCAmJiBzY3JvbGxIZWlnaHQgPT09IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0ICYmICFmb3JjZSkge1xuXHRcdFx0XHRyZXR1cm47IC8vbm8gbmVlZCB0byByZWNhbGN1bGF0ZSB0aGluZ3MgaWYgdGhlIHdpZHRoIGFuZCBoZWlnaHQgaGF2ZW4ndCBjaGFuZ2VkLlxuXHRcdFx0fVxuXHRcdFx0aWYgKG9mZnNldFRvcCB8fCBvZmZzZXRMZWZ0KSB7XG5cdFx0XHRcdHggPSB0aGlzLmxlZnQoKTtcblx0XHRcdFx0eSA9IHRoaXMudG9wKCk7XG5cdFx0XHRcdHRoaXMubGVmdCgtZWxlbWVudC5zY3JvbGxMZWZ0KTtcblx0XHRcdFx0dGhpcy50b3AoLWVsZW1lbnQuc2Nyb2xsVG9wKTtcblx0XHRcdH1cblx0XHRcdGNzID0gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cdFx0XHQvL2ZpcnN0LCB3ZSBuZWVkIHRvIHJlbW92ZSBhbnkgd2lkdGggY29uc3RyYWludHMgdG8gc2VlIGhvdyB0aGUgY29udGVudCBuYXR1cmFsbHkgZmxvd3Mgc28gdGhhdCB3ZSBjYW4gc2VlIGlmIGl0J3Mgd2lkZXIgdGhhbiB0aGUgY29udGFpbmluZyBlbGVtZW50LiBJZiBzbywgd2UndmUgZ290IHRvIHJlY29yZCB0aGUgYW1vdW50IG9mIG92ZXJhZ2Ugc28gdGhhdCB3ZSBjYW4gYXBwbHkgdGhhdCBhcyBwYWRkaW5nIGluIG9yZGVyIGZvciBicm93c2VycyB0byBjb3JyZWN0bHkgaGFuZGxlIHRoaW5ncy4gVGhlbiB3ZSBzd2l0Y2ggYmFjayB0byBhIHdpZHRoIG9mIDEwMCUgKHdpdGhvdXQgdGhhdCwgc29tZSBicm93c2VycyBkb24ndCBmbG93IHRoZSBjb250ZW50IGNvcnJlY3RseSlcblx0XHRcdGlmICghd2lkdGhNYXRjaGVzIHx8IGZvcmNlKSB7XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdFx0XHRcdHN0eWxlLndpZHRoID0gXCJhdXRvXCI7XG5cdFx0XHRcdHN0eWxlLnBhZGRpbmdSaWdodCA9IFwiMHB4XCI7XG5cdFx0XHRcdGV4dHJhUGFkUmlnaHQgPSBNYXRoLm1heCgwLCBlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5jbGllbnRXaWR0aCk7XG5cdFx0XHRcdC8vaWYgdGhlIGNvbnRlbnQgaXMgd2lkZXIgdGhhbiB0aGUgY29udGFpbmVyLCB3ZSBuZWVkIHRvIGFkZCB0aGUgcGFkZGluZ0xlZnQgYW5kIHBhZGRpbmdSaWdodCBpbiBvcmRlciBmb3IgdGhpbmdzIHRvIGJlaGF2ZSBjb3JyZWN0bHkuXG5cdFx0XHRcdGlmIChleHRyYVBhZFJpZ2h0KSB7XG5cdFx0XHRcdFx0ZXh0cmFQYWRSaWdodCArPSBwYXJzZUZsb2F0KGNzLnBhZGRpbmdMZWZ0KSArIChfYWRkUGFkZGluZ0JSID8gcGFyc2VGbG9hdChjcy5wYWRkaW5nUmlnaHQpIDogMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0c3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IFwidmlzaWJsZVwiO1xuXHRcdFx0c3R5bGUudmVydGljYWxBbGlnbiA9IFwidG9wXCI7XG5cdFx0XHRzdHlsZS5ib3hTaXppbmcgPSBcImNvbnRlbnQtYm94XCI7XG5cdFx0XHRzdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuXHRcdFx0c3R5bGUucGFkZGluZ1JpZ2h0ID0gZXh0cmFQYWRSaWdodCArIFwicHhcIjtcblx0XHRcdC8vc29tZSBicm93c2VycyBuZWdsZWN0IHRvIGZhY3RvciBpbiB0aGUgYm90dG9tIHBhZGRpbmcgd2hlbiBjYWxjdWxhdGluZyB0aGUgc2Nyb2xsSGVpZ2h0LCBzbyB3ZSBuZWVkIHRvIGFkZCB0aGF0IHBhZGRpbmcgdG8gdGhlIGNvbnRlbnQgd2hlbiB0aGF0IGhhcHBlbnMuIEFsbG93IGEgMnB4IG1hcmdpbiBmb3IgZXJyb3Jcblx0XHRcdGlmIChfYWRkUGFkZGluZ0JSKSB7XG5cdFx0XHRcdHN0eWxlLnBhZGRpbmdCb3R0b20gPSBjcy5wYWRkaW5nQm90dG9tO1xuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudFdpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcblx0XHRcdGVsZW1lbnRIZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcblx0XHRcdHNjcm9sbFdpZHRoID0gZWxlbWVudC5zY3JvbGxXaWR0aDtcblx0XHRcdHNjcm9sbEhlaWdodCA9IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuXHRcdFx0bWF4TGVmdCA9IGVsZW1lbnQuc2Nyb2xsV2lkdGggLSBlbGVtZW50V2lkdGg7XG5cdFx0XHRtYXhUb3AgPSBlbGVtZW50LnNjcm9sbEhlaWdodCAtIGVsZW1lbnRIZWlnaHQ7XG5cdFx0XHRjb250ZW50SGVpZ2h0ID0gY29udGVudC5vZmZzZXRIZWlnaHQ7XG5cdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXHRcdFx0aWYgKHggfHwgeSkge1xuXHRcdFx0XHR0aGlzLmxlZnQoeCk7XG5cdFx0XHRcdHRoaXMudG9wKHkpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0dGhpcy5jb250ZW50ID0gY29udGVudDtcblx0XHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXHRcdHRoaXMuX3NraXAgPSBmYWxzZTtcblx0XHR0aGlzLmVuYWJsZSgpO1xuXHR9LFxuXHRfaW5pdENvcmUgPSByZXF1aXJlZCA9PiB7XG5cdFx0aWYgKF93aW5kb3dFeGlzdHMoKSAmJiBkb2N1bWVudC5ib2R5KSB7XG5cdFx0XHRsZXQgbmF2ID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG5cdFx0XHRfd2luID0gd2luZG93O1xuXHRcdFx0X2RvYyA9IGRvY3VtZW50O1xuXHRcdFx0X2RvY0VsZW1lbnQgPSBfZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdF9ib2R5ID0gX2RvYy5ib2R5O1xuXHRcdFx0X3RlbXBEaXYgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdF9zdXBwb3J0c1BvaW50ZXIgPSAhIXdpbmRvdy5Qb2ludGVyRXZlbnQ7XG5cdFx0XHRfcGxhY2Vob2xkZXJEaXYgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdF9wbGFjZWhvbGRlckRpdi5zdHlsZS5jc3NUZXh0ID0gXCJ2aXNpYmlsaXR5OmhpZGRlbjtoZWlnaHQ6MXB4O3RvcDotMXB4O3BvaW50ZXItZXZlbnRzOm5vbmU7cG9zaXRpb246cmVsYXRpdmU7Y2xlYXI6Ym90aDtjdXJzb3I6Z3JhYlwiO1xuXHRcdFx0X2RlZmF1bHRDdXJzb3IgPSBfcGxhY2Vob2xkZXJEaXYuc3R5bGUuY3Vyc29yID09PSBcImdyYWJcIiA/IFwiZ3JhYlwiIDogXCJtb3ZlXCI7XG5cdFx0XHRfaXNBbmRyb2lkID0gKG5hdiAmJiBuYXYudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImFuZHJvaWRcIikgIT09IC0xKTsgLy9BbmRyb2lkIGhhbmRsZXMgdG91Y2ggZXZlbnRzIGluIGFuIG9kZCB3YXkgYW5kIGl0J3MgdmlydHVhbGx5IGltcG9zc2libGUgdG8gXCJmZWF0dXJlIHRlc3RcIiBzbyB3ZSByZXNvcnQgdG8gVUEgc25pZmZpbmdcblx0XHRcdF9pc1RvdWNoRGV2aWNlID0gKChcIm9udG91Y2hzdGFydFwiIGluIF9kb2NFbGVtZW50KSAmJiAoXCJvcmllbnRhdGlvblwiIGluIF93aW4pKSB8fCAobmF2ICYmIChuYXYuTWF4VG91Y2hQb2ludHMgPiAwIHx8IG5hdi5tc01heFRvdWNoUG9pbnRzID4gMCkpO1xuXHRcdFx0X2FkZFBhZGRpbmdCUiA9IChmdW5jdGlvbigpIHsgLy90aGlzIGZ1bmN0aW9uIGlzIGluIGNoYXJnZSBvZiBhbmFseXppbmcgYnJvd3NlciBiZWhhdmlvciByZWxhdGVkIHRvIHBhZGRpbmcuIEl0IHNldHMgdGhlIF9hZGRQYWRkaW5nQlIgdG8gdHJ1ZSBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IG5vcm1hbGx5IGZhY3RvciBpbiB0aGUgYm90dG9tIG9yIHJpZ2h0IHBhZGRpbmcgb24gdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBzY3JvbGxpbmcgYXJlYSwgYW5kIGl0IHNldHMgX2FkZFBhZGRpbmdMZWZ0IHRvIHRydWUgaWYgaXQncyBhIGJyb3dzZXIgdGhhdCByZXF1aXJlcyB0aGUgZXh0cmEgb2Zmc2V0IChvZmZzZXRMZWZ0KSB0byBiZSBhZGRlZCB0byB0aGUgcGFkZGluZ1JpZ2h0IChsaWtlIE9wZXJhKS5cblx0XHRcdFx0bGV0IGRpdiA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuXHRcdFx0XHRcdGNoaWxkID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cdFx0XHRcdFx0Y2hpbGRTdHlsZSA9IGNoaWxkLnN0eWxlLFxuXHRcdFx0XHRcdHBhcmVudCA9IF9ib2R5LFxuXHRcdFx0XHRcdHZhbDtcblx0XHRcdFx0Y2hpbGRTdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdFx0Y2hpbGRTdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHRcdFx0ZGl2LnN0eWxlLmNzc1RleHQgPSBjaGlsZC5pbm5lckhUTUwgPSBcIndpZHRoOjkwcHg7aGVpZ2h0OjQwcHg7cGFkZGluZzoxMHB4O292ZXJmbG93OmF1dG87dmlzaWJpbGl0eTpoaWRkZW5cIjtcblx0XHRcdFx0ZGl2LmFwcGVuZENoaWxkKGNoaWxkKTtcblx0XHRcdFx0cGFyZW50LmFwcGVuZENoaWxkKGRpdik7XG5cdFx0XHRcdHZhbCA9IChjaGlsZC5vZmZzZXRIZWlnaHQgKyAxOCA+IGRpdi5zY3JvbGxIZWlnaHQpOyAvL2Rpdi5zY3JvbGxIZWlnaHQgc2hvdWxkIGJlIGNoaWxkLm9mZnNldEhlaWdodCArIDIwIGJlY2F1c2Ugb2YgdGhlIDEwcHggb2YgcGFkZGluZyBvbiBlYWNoIHNpZGUsIGJ1dCBzb21lIGJyb3dzZXJzIGlnbm9yZSBvbmUgc2lkZS4gV2UgYWxsb3cgYSAycHggbWFyZ2luIG9mIGVycm9yLlxuXHRcdFx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQoZGl2KTtcblx0XHRcdFx0cmV0dXJuIHZhbDtcblx0XHRcdH0oKSk7XG5cdFx0XHRfdG91Y2hFdmVudExvb2t1cCA9IChmdW5jdGlvbih0eXBlcykgeyAvL3dlIGNyZWF0ZSBhbiBvYmplY3QgdGhhdCBtYWtlcyBpdCBlYXN5IHRvIHRyYW5zbGF0ZSB0b3VjaCBldmVudCB0eXBlcyBpbnRvIHRoZWlyIFwicG9pbnRlclwiIGNvdW50ZXJwYXJ0cyBpZiB3ZSdyZSBpbiBhIGJyb3dzZXIgdGhhdCB1c2VzIHRob3NlIGluc3RlYWQuIExpa2UgSUUxMCB1c2VzIFwiTVNQb2ludGVyRG93blwiIGluc3RlYWQgb2YgXCJ0b3VjaHN0YXJ0XCIsIGZvciBleGFtcGxlLlxuXHRcdFx0XHRsZXQgc3RhbmRhcmQgPSB0eXBlcy5zcGxpdChcIixcIiksXG5cdFx0XHRcdFx0Y29udmVydGVkID0gKFwib25wb2ludGVyZG93blwiIGluIF90ZW1wRGl2ID8gXCJwb2ludGVyZG93bixwb2ludGVybW92ZSxwb2ludGVydXAscG9pbnRlcmNhbmNlbFwiIDogXCJvbm1zcG9pbnRlcmRvd25cIiBpbiBfdGVtcERpdiA/IFwiTVNQb2ludGVyRG93bixNU1BvaW50ZXJNb3ZlLE1TUG9pbnRlclVwLE1TUG9pbnRlckNhbmNlbFwiIDogdHlwZXMpLnNwbGl0KFwiLFwiKSxcblx0XHRcdFx0XHRvYmogPSB7fSxcblx0XHRcdFx0XHRpID0gNDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0b2JqW3N0YW5kYXJkW2ldXSA9IGNvbnZlcnRlZFtpXTtcblx0XHRcdFx0XHRvYmpbY29udmVydGVkW2ldXSA9IHN0YW5kYXJkW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vdG8gYXZvaWQgcHJvYmxlbXMgaW4gaU9TIDksIHRlc3QgdG8gc2VlIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBcInBhc3NpdmVcIiBvcHRpb24gb24gYWRkRXZlbnRMaXN0ZW5lcigpLlxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdF9kb2NFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsIG51bGwsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJwYXNzaXZlXCIsIHtcblx0XHRcdFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRfc3VwcG9ydHNQYXNzaXZlID0gMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9KFwidG91Y2hzdGFydCx0b3VjaG1vdmUsdG91Y2hlbmQsdG91Y2hjYW5jZWxcIikpO1xuXHRcdFx0X2FkZExpc3RlbmVyKF9kb2MsIFwidG91Y2hjYW5jZWxcIiwgX2VtcHR5RnVuYyk7IC8vc29tZSBvbGRlciBBbmRyb2lkIGRldmljZXMgaW50ZXJtaXR0ZW50bHkgc3RvcCBkaXNwYXRjaGluZyBcInRvdWNobW92ZVwiIGV2ZW50cyBpZiB3ZSBkb24ndCBsaXN0ZW4gZm9yIFwidG91Y2hjYW5jZWxcIiBvbiB0aGUgZG9jdW1lbnQuIFZlcnkgc3RyYW5nZSBpbmRlZWQuXG5cdFx0XHRfYWRkTGlzdGVuZXIoX3dpbiwgXCJ0b3VjaG1vdmVcIiwgX2VtcHR5RnVuYyk7IC8vd29ya3MgYXJvdW5kIFNhZmFyaSBidWdzIHRoYXQgc3RpbGwgYWxsb3cgdGhlIHBhZ2UgdG8gc2Nyb2xsIGV2ZW4gd2hlbiB3ZSBwcmV2ZW50RGVmYXVsdCgpIG9uIHRoZSB0b3VjaG1vdmUgZXZlbnQuXG5cdFx0XHRfYm9keSAmJiBfYm9keS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBfZW1wdHlGdW5jKTsgLy93b3JrcyBhcm91bmQgU2FmYXJpIGJ1ZzogaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMTQ1MC1kcmFnZ2FibGUtaW4taWZyYW1lLW9uLW1vYmlsZS1pcy1idWdneS9cblx0XHRcdF9hZGRMaXN0ZW5lcihfZG9jLCBcImNvbnRleHRtZW51XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKGxldCBwIGluIF9sb29rdXApIHtcblx0XHRcdFx0XHRpZiAoX2xvb2t1cFtwXS5pc1ByZXNzZWQpIHtcblx0XHRcdFx0XHRcdF9sb29rdXBbcF0uZW5kRHJhZygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRnc2FwID0gX2NvcmVJbml0dGVkID0gX2dldEdTQVAoKTtcblx0XHR9XG5cdFx0aWYgKGdzYXApIHtcblx0XHRcdEluZXJ0aWFQbHVnaW4gPSBnc2FwLnBsdWdpbnMuaW5lcnRpYTtcblx0XHRcdF9jaGVja1ByZWZpeCA9IGdzYXAudXRpbHMuY2hlY2tQcmVmaXg7XG5cdFx0XHRfdHJhbnNmb3JtUHJvcCA9IF9jaGVja1ByZWZpeChfdHJhbnNmb3JtUHJvcCk7XG5cdFx0XHRfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF9jaGVja1ByZWZpeChfdHJhbnNmb3JtT3JpZ2luUHJvcCk7XG5cdFx0XHRfdG9BcnJheSA9IGdzYXAudXRpbHMudG9BcnJheTtcblx0XHRcdF9zdXBwb3J0czNEID0gISFfY2hlY2tQcmVmaXgoXCJwZXJzcGVjdGl2ZVwiKTtcblx0XHR9IGVsc2UgaWYgKHJlcXVpcmVkKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXCJQbGVhc2UgZ3NhcC5yZWdpc3RlclBsdWdpbihEcmFnZ2FibGUpXCIpO1xuXHRcdH1cblx0fTtcblxuXG5cblxuXG5cbmNsYXNzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IodGFyZ2V0KSB7XG5cdFx0dGhpcy5fbGlzdGVuZXJzID0ge307XG5cdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQgfHwgdGhpcztcblx0fVxuXG5cdGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spIHtcblx0XHRsZXQgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXSB8fCAodGhpcy5fbGlzdGVuZXJzW3R5cGVdID0gW10pO1xuXHRcdGlmICghfmxpc3QuaW5kZXhPZihjYWxsYmFjaykpIHtcblx0XHRcdGxpc3QucHVzaChjYWxsYmFjayk7XG5cdFx0fVxuXHR9XG5cblx0cmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaykge1xuXHRcdGxldCBsaXN0ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdLFxuXHRcdFx0aSA9IChsaXN0ICYmIGxpc3QuaW5kZXhPZihjYWxsYmFjaykpIHx8IC0xO1xuXHRcdChpID4gLTEpICYmIGxpc3Quc3BsaWNlKGksIDEpO1xuXHR9XG5cblx0ZGlzcGF0Y2hFdmVudCh0eXBlKSB7XG5cdFx0bGV0IHJlc3VsdDtcblx0XHQodGhpcy5fbGlzdGVuZXJzW3R5cGVdIHx8IFtdKS5mb3JFYWNoKGNhbGxiYWNrID0+IChjYWxsYmFjay5jYWxsKHRoaXMsIHt0eXBlOiB0eXBlLCB0YXJnZXQ6IHRoaXMudGFyZ2V0fSkgPT09IGZhbHNlKSAmJiAocmVzdWx0ID0gZmFsc2UpKTtcblx0XHRyZXR1cm4gcmVzdWx0OyAvL2lmIGFueSBvZiB0aGUgY2FsbGJhY2tzIHJldHVybiBmYWxzZSwgcGFzcyB0aGF0IGFsb25nLlxuXHR9XG59XG5cblxuXG5cblxuXG5cblxuXG5leHBvcnQgY2xhc3MgRHJhZ2dhYmxlIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblxuXHRjb25zdHJ1Y3Rvcih0YXJnZXQsIHZhcnMpIHtcblx0XHRzdXBlcigpO1xuXHRcdF9jb3JlSW5pdHRlZCB8fCBfaW5pdENvcmUoMSk7XG5cdFx0dGFyZ2V0ID0gX3RvQXJyYXkodGFyZ2V0KVswXTsgLy9pbiBjYXNlIHRoZSB0YXJnZXQgaXMgYSBzZWxlY3RvciBvYmplY3Qgb3Igc2VsZWN0b3IgdGV4dFxuXHRcdGlmICghSW5lcnRpYVBsdWdpbikge1xuXHRcdFx0SW5lcnRpYVBsdWdpbiA9IGdzYXAucGx1Z2lucy5pbmVydGlhO1xuXHRcdH1cblx0XHR0aGlzLnZhcnMgPSB2YXJzID0gX2NvcHkodmFycyB8fCB7fSk7XG5cdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cdFx0dGhpcy54ID0gdGhpcy55ID0gdGhpcy5yb3RhdGlvbiA9IDA7XG5cdFx0dGhpcy5kcmFnUmVzaXN0YW5jZSA9IHBhcnNlRmxvYXQodmFycy5kcmFnUmVzaXN0YW5jZSkgfHwgMDtcblx0XHR0aGlzLmVkZ2VSZXNpc3RhbmNlID0gaXNOYU4odmFycy5lZGdlUmVzaXN0YW5jZSkgPyAxIDogcGFyc2VGbG9hdCh2YXJzLmVkZ2VSZXNpc3RhbmNlKSB8fCAwO1xuXHRcdHRoaXMubG9ja0F4aXMgPSB2YXJzLmxvY2tBeGlzO1xuXHRcdHRoaXMuYXV0b1Njcm9sbCA9IHZhcnMuYXV0b1Njcm9sbCB8fCAwO1xuXHRcdHRoaXMubG9ja2VkQXhpcyA9IG51bGw7XG5cdFx0dGhpcy5hbGxvd0V2ZW50RGVmYXVsdCA9ICEhdmFycy5hbGxvd0V2ZW50RGVmYXVsdDtcblxuXHRcdGdzYXAuZ2V0UHJvcGVydHkodGFyZ2V0LCBcInhcIik7IC8vIHRvIGVuc3VyZSB0aGF0IHRyYW5zZm9ybXMgYXJlIGluc3RhbnRpYXRlZC5cblxuXHRcdGxldCB0eXBlID0gKHZhcnMudHlwZSB8fCBcIngseVwiKS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0eHlNb2RlID0gKH50eXBlLmluZGV4T2YoXCJ4XCIpIHx8IH50eXBlLmluZGV4T2YoXCJ5XCIpKSxcblx0XHRcdHJvdGF0aW9uTW9kZSA9ICh0eXBlLmluZGV4T2YoXCJyb3RhdGlvblwiKSAhPT0gLTEpLFxuXHRcdFx0eFByb3AgPSByb3RhdGlvbk1vZGUgPyBcInJvdGF0aW9uXCIgOiB4eU1vZGUgPyBcInhcIiA6IFwibGVmdFwiLFxuXHRcdFx0eVByb3AgPSB4eU1vZGUgPyBcInlcIiA6IFwidG9wXCIsXG5cdFx0XHRhbGxvd1ggPSAhISh+dHlwZS5pbmRleE9mKFwieFwiKSB8fCB+dHlwZS5pbmRleE9mKFwibGVmdFwiKSB8fCB0eXBlID09PSBcInNjcm9sbFwiKSxcblx0XHRcdGFsbG93WSA9ICEhKH50eXBlLmluZGV4T2YoXCJ5XCIpIHx8IH50eXBlLmluZGV4T2YoXCJ0b3BcIikgfHwgdHlwZSA9PT0gXCJzY3JvbGxcIiksXG5cdFx0XHRtaW5pbXVtTW92ZW1lbnQgPSB2YXJzLm1pbmltdW1Nb3ZlbWVudCB8fCAyLFxuXHRcdFx0c2VsZiA9IHRoaXMsXG5cdFx0XHR0cmlnZ2VycyA9IF90b0FycmF5KHZhcnMudHJpZ2dlciB8fCB2YXJzLmhhbmRsZSB8fCB0YXJnZXQpLFxuXHRcdFx0a2lsbFByb3BzID0ge30sXG5cdFx0XHRkcmFnRW5kVGltZSA9IDAsXG5cdFx0XHRjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSBmYWxzZSxcblx0XHRcdGF1dG9TY3JvbGxNYXJnaW5Ub3AgPSB2YXJzLmF1dG9TY3JvbGxNYXJnaW5Ub3AgfHwgNDAsXG5cdFx0XHRhdXRvU2Nyb2xsTWFyZ2luUmlnaHQgPSB2YXJzLmF1dG9TY3JvbGxNYXJnaW5SaWdodCB8fCA0MCxcblx0XHRcdGF1dG9TY3JvbGxNYXJnaW5Cb3R0b20gPSB2YXJzLmF1dG9TY3JvbGxNYXJnaW5Cb3R0b20gfHwgNDAsXG5cdFx0XHRhdXRvU2Nyb2xsTWFyZ2luTGVmdCA9IHZhcnMuYXV0b1Njcm9sbE1hcmdpbkxlZnQgfHwgNDAsXG5cdFx0XHRpc0NsaWNrYWJsZSA9IHZhcnMuY2xpY2thYmxlVGVzdCB8fCBfaXNDbGlja2FibGUsXG5cdFx0XHRjbGlja1RpbWUgPSAwLFxuXHRcdFx0Z3NDYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBnc2FwLmNvcmUuZ2V0Q2FjaGUodGFyZ2V0KSxcblx0XHRcdGlzRml4ZWQgPSBfaXNGaXhlZCh0YXJnZXQpLFxuXHRcdFx0Z2V0UHJvcEFzTnVtID0gKHByb3BlcnR5LCB1bml0KSA9PiBwYXJzZUZsb2F0KGdzQ2FjaGUuZ2V0KHRhcmdldCwgcHJvcGVydHksIHVuaXQpKSxcblx0XHRcdG93bmVyRG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgX2RvYyxcblx0XHRcdGVuYWJsZWQsIHNjcm9sbFByb3h5LCBzdGFydFBvaW50ZXJYLCBzdGFydFBvaW50ZXJZLCBzdGFydEVsZW1lbnRYLCBzdGFydEVsZW1lbnRZLCBoYXNCb3VuZHMsIGhhc0RyYWdDYWxsYmFjaywgaGFzTW92ZUNhbGxiYWNrLCBtYXhYLCBtaW5YLCBtYXhZLCBtaW5ZLCB0b3VjaCwgdG91Y2hJRCwgcm90YXRpb25PcmlnaW4sIGRpcnR5LCBvbGQsIHNuYXBYLCBzbmFwWSwgc25hcFhZLCBpc0NsaWNraW5nLCB0b3VjaEV2ZW50VGFyZ2V0LCBtYXRyaXgsIGludGVycnVwdGVkLCBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nLCB0b3VjaERyYWdBeGlzLCBpc0Rpc3BhdGNoaW5nLCBjbGlja0Rpc3BhdGNoLCB0cnVzdGVkQ2xpY2tEaXNwYXRjaCwgaXNQcmV2ZW50aW5nRGVmYXVsdCxcblxuXHRcdFx0b25Db250ZXh0TWVudSA9IGUgPT4geyAvL3VzZWQgdG8gcHJldmVudCBsb25nLXRvdWNoIGZyb20gdHJpZ2dlcmluZyBhIGNvbnRleHQgbWVudS5cblx0XHRcdFx0Ly8gKHNlbGYuaXNQcmVzc2VkICYmIGUud2hpY2ggPCAyKSAmJiBzZWxmLmVuZERyYWcoKSAvLyBwcmV2aW91c2x5IGVuZGVkIGRyYWcgd2hlbiBjb250ZXh0IG1lbnUgd2FzIHRyaWdnZXJlZCwgYnV0IGluc3RlYWQgd2Ugc2hvdWxkIGp1c3Qgc3RvcCBwcm9wYWdhdGlvbiBhbmQgcHJldmVudCB0aGUgZGVmYXVsdCBldmVudCBiZWhhdmlvci5cblx0XHRcdFx0X3ByZXZlbnREZWZhdWx0KGUpO1xuXHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXG5cdFx0XHQvL3RoaXMgbWV0aG9kIGdldHMgY2FsbGVkIG9uIGV2ZXJ5IHRpY2sgb2YgVHdlZW5MaXRlLnRpY2tlciB3aGljaCBhbGxvd3MgdXMgdG8gc3luY2hyb25pemUgdGhlIHJlbmRlcnMgdG8gdGhlIGNvcmUgZW5naW5lICh3aGljaCBpcyB0eXBpY2FsbHkgc3luY2hyb25pemVkIHdpdGggdGhlIGRpc3BsYXkgcmVmcmVzaCB2aWEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKS4gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gLSBpdCdzIGJldHRlciB0aGFuIGFwcGx5aW5nIHRoZSB2YWx1ZXMgaW5zaWRlIHRoZSBcIm1vdXNlbW92ZVwiIG9yIFwidG91Y2htb3ZlXCIgZXZlbnQgaGFuZGxlciB3aGljaCBtYXkgZ2V0IGNhbGxlZCBtYW55IHRpbWVzIGluYmV0d2VlbiByZWZyZXNoZXMuXG5cdFx0XHRyZW5kZXIgPSBzdXBwcmVzc0V2ZW50cyA9PiB7XG5cdFx0XHRcdGlmIChzZWxmLmF1dG9TY3JvbGwgJiYgc2VsZi5pc0RyYWdnaW5nICYmIChjaGVja0F1dG9TY3JvbGxCb3VuZHMgfHwgZGlydHkpKSB7XG5cdFx0XHRcdFx0bGV0IGUgPSB0YXJnZXQsXG5cdFx0XHRcdFx0XHRhdXRvU2Nyb2xsRmFjdG9yID0gc2VsZi5hdXRvU2Nyb2xsICogMTUsIC8vbXVsdGlwbHlpbmcgYnkgMTUganVzdCBnaXZlcyB1cyBhIGJldHRlciBcImZlZWxcIiBzcGVlZC13aXNlLlxuXHRcdFx0XHRcdFx0cGFyZW50LCBpc1Jvb3QsIHJlY3QsIHBvaW50ZXJYLCBwb2ludGVyWSwgY2hhbmdlWCwgY2hhbmdlWSwgZ2FwO1xuXHRcdFx0XHRcdGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IGZhbHNlO1xuXHRcdFx0XHRcdF93aW5kb3dQcm94eS5zY3JvbGxUb3AgPSAoKF93aW4ucGFnZVlPZmZzZXQgIT0gbnVsbCkgPyBfd2luLnBhZ2VZT2Zmc2V0IDogKG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgIT0gbnVsbCkgPyBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIDogb3duZXJEb2MuYm9keS5zY3JvbGxUb3ApO1xuXHRcdFx0XHRcdF93aW5kb3dQcm94eS5zY3JvbGxMZWZ0ID0gKChfd2luLnBhZ2VYT2Zmc2V0ICE9IG51bGwpID8gX3dpbi5wYWdlWE9mZnNldCA6IChvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCAhPSBudWxsKSA/IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IDogb3duZXJEb2MuYm9keS5zY3JvbGxMZWZ0KTtcblx0XHRcdFx0XHRwb2ludGVyWCA9IHNlbGYucG9pbnRlclggLSBfd2luZG93UHJveHkuc2Nyb2xsTGVmdDtcblx0XHRcdFx0XHRwb2ludGVyWSA9IHNlbGYucG9pbnRlclkgLSBfd2luZG93UHJveHkuc2Nyb2xsVG9wO1xuXHRcdFx0XHRcdHdoaWxlIChlICYmICFpc1Jvb3QpIHsgLy93YWxrIHVwIHRoZSBjaGFpbiBhbmQgc2Vuc2Ugd2hlcmV2ZXIgdGhlIHBvaW50ZXIgaXMgd2l0aGluIDQwcHggb2YgYW4gZWRnZSB0aGF0J3Mgc2Nyb2xsYWJsZS5cblx0XHRcdFx0XHRcdGlzUm9vdCA9IF9pc1Jvb3QoZS5wYXJlbnROb2RlKTtcblx0XHRcdFx0XHRcdHBhcmVudCA9IGlzUm9vdCA/IF93aW5kb3dQcm94eSA6IGUucGFyZW50Tm9kZTtcblx0XHRcdFx0XHRcdHJlY3QgPSBpc1Jvb3QgPyB7Ym90dG9tOk1hdGgubWF4KF9kb2NFbGVtZW50LmNsaWVudEhlaWdodCwgX3dpbi5pbm5lckhlaWdodCB8fCAwKSwgcmlnaHQ6IE1hdGgubWF4KF9kb2NFbGVtZW50LmNsaWVudFdpZHRoLCBfd2luLmlubmVyV2lkdGggfHwgMCksIGxlZnQ6MCwgdG9wOjB9IDogcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0XHRcdFx0Y2hhbmdlWCA9IGNoYW5nZVkgPSAwO1xuXHRcdFx0XHRcdFx0aWYgKGFsbG93WSkge1xuXHRcdFx0XHRcdFx0XHRnYXAgPSBwYXJlbnQuX2dzTWF4U2Nyb2xsWSAtIHBhcmVudC5zY3JvbGxUb3A7XG5cdFx0XHRcdFx0XHRcdGlmIChnYXAgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2hhbmdlWSA9IGdhcDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwb2ludGVyWSA+IHJlY3QuYm90dG9tIC0gYXV0b1Njcm9sbE1hcmdpbkJvdHRvbSAmJiBnYXApIHtcblx0XHRcdFx0XHRcdFx0XHRjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdGNoYW5nZVkgPSBNYXRoLm1pbihnYXAsIChhdXRvU2Nyb2xsRmFjdG9yICogKDEgLSBNYXRoLm1heCgwLCAocmVjdC5ib3R0b20gLSBwb2ludGVyWSkpIC8gYXV0b1Njcm9sbE1hcmdpbkJvdHRvbSkpIHwgMCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocG9pbnRlclkgPCByZWN0LnRvcCArIGF1dG9TY3JvbGxNYXJnaW5Ub3AgJiYgcGFyZW50LnNjcm9sbFRvcCkge1xuXHRcdFx0XHRcdFx0XHRcdGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0Y2hhbmdlWSA9IC1NYXRoLm1pbihwYXJlbnQuc2Nyb2xsVG9wLCAoYXV0b1Njcm9sbEZhY3RvciAqICgxIC0gTWF0aC5tYXgoMCwgKHBvaW50ZXJZIC0gcmVjdC50b3ApKSAvIGF1dG9TY3JvbGxNYXJnaW5Ub3ApKSB8IDApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChjaGFuZ2VZKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGFyZW50LnNjcm9sbFRvcCArPSBjaGFuZ2VZO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoYWxsb3dYKSB7XG5cdFx0XHRcdFx0XHRcdGdhcCA9IHBhcmVudC5fZ3NNYXhTY3JvbGxYIC0gcGFyZW50LnNjcm9sbExlZnQ7XG5cdFx0XHRcdFx0XHRcdGlmIChnYXAgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2hhbmdlWCA9IGdhcDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwb2ludGVyWCA+IHJlY3QucmlnaHQgLSBhdXRvU2Nyb2xsTWFyZ2luUmlnaHQgJiYgZ2FwKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2hlY2tBdXRvU2Nyb2xsQm91bmRzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRjaGFuZ2VYID0gTWF0aC5taW4oZ2FwLCAoYXV0b1Njcm9sbEZhY3RvciAqICgxIC0gTWF0aC5tYXgoMCwgKHJlY3QucmlnaHQgLSBwb2ludGVyWCkpIC8gYXV0b1Njcm9sbE1hcmdpblJpZ2h0KSkgfCAwKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwb2ludGVyWCA8IHJlY3QubGVmdCArIGF1dG9TY3JvbGxNYXJnaW5MZWZ0ICYmIHBhcmVudC5zY3JvbGxMZWZ0KSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2hlY2tBdXRvU2Nyb2xsQm91bmRzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRjaGFuZ2VYID0gLU1hdGgubWluKHBhcmVudC5zY3JvbGxMZWZ0LCAoYXV0b1Njcm9sbEZhY3RvciAqICgxIC0gTWF0aC5tYXgoMCwgKHBvaW50ZXJYIC0gcmVjdC5sZWZ0KSkgLyBhdXRvU2Nyb2xsTWFyZ2luTGVmdCkpIHwgMCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKGNoYW5nZVgpIHtcblx0XHRcdFx0XHRcdFx0XHRwYXJlbnQuc2Nyb2xsTGVmdCArPSBjaGFuZ2VYO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChpc1Jvb3QgJiYgKGNoYW5nZVggfHwgY2hhbmdlWSkpIHtcblx0XHRcdFx0XHRcdFx0X3dpbi5zY3JvbGxUbyhwYXJlbnQuc2Nyb2xsTGVmdCwgcGFyZW50LnNjcm9sbFRvcCk7XG5cdFx0XHRcdFx0XHRcdHNldFBvaW50ZXJQb3NpdGlvbihzZWxmLnBvaW50ZXJYICsgY2hhbmdlWCwgc2VsZi5wb2ludGVyWSArIGNoYW5nZVkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZSA9IHBhcmVudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGRpcnR5KSB7XG5cdFx0XHRcdFx0bGV0IHt4LCB5fSA9IHNlbGY7XG5cdFx0XHRcdFx0aWYgKHJvdGF0aW9uTW9kZSkge1xuXHRcdFx0XHRcdFx0c2VsZi5kZWx0YVggPSB4IC0gcGFyc2VGbG9hdChnc0NhY2hlLnJvdGF0aW9uKTtcblx0XHRcdFx0XHRcdHNlbGYucm90YXRpb24gPSB4O1xuXHRcdFx0XHRcdFx0Z3NDYWNoZS5yb3RhdGlvbiA9IHggKyBcImRlZ1wiO1xuXHRcdFx0XHRcdFx0Z3NDYWNoZS5yZW5kZXJUcmFuc2Zvcm0oMSwgZ3NDYWNoZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChzY3JvbGxQcm94eSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoYWxsb3dZKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2VsZi5kZWx0YVkgPSB5IC0gc2Nyb2xsUHJveHkudG9wKCk7XG5cdFx0XHRcdFx0XHRcdFx0c2Nyb2xsUHJveHkudG9wKHkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChhbGxvd1gpIHtcblx0XHRcdFx0XHRcdFx0XHRzZWxmLmRlbHRhWCA9IHggLSBzY3JvbGxQcm94eS5sZWZ0KCk7XG5cdFx0XHRcdFx0XHRcdFx0c2Nyb2xsUHJveHkubGVmdCh4KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh4eU1vZGUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGFsbG93WSkge1xuXHRcdFx0XHRcdFx0XHRcdHNlbGYuZGVsdGFZID0geSAtIHBhcnNlRmxvYXQoZ3NDYWNoZS55KTtcblx0XHRcdFx0XHRcdFx0XHRnc0NhY2hlLnkgPSB5ICsgXCJweFwiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChhbGxvd1gpIHtcblx0XHRcdFx0XHRcdFx0XHRzZWxmLmRlbHRhWCA9IHggLSBwYXJzZUZsb2F0KGdzQ2FjaGUueCk7XG5cdFx0XHRcdFx0XHRcdFx0Z3NDYWNoZS54ID0geCArIFwicHhcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRnc0NhY2hlLnJlbmRlclRyYW5zZm9ybSgxLCBnc0NhY2hlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhbGxvd1kpIHtcblx0XHRcdFx0XHRcdFx0XHRzZWxmLmRlbHRhWSA9IHkgLSBwYXJzZUZsb2F0KHRhcmdldC5zdHlsZS50b3AgfHwgMCk7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0LnN0eWxlLnRvcCA9IHkgKyBcInB4XCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKGFsbG93WCkge1xuXHRcdFx0XHRcdFx0XHRcdHNlbGYuZGVsdGFYID0geCAtIHBhcnNlRmxvYXQodGFyZ2V0LnN0eWxlLmxlZnQgfHwgMCk7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0LnN0eWxlLmxlZnQgPSB4ICsgXCJweFwiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChoYXNEcmFnQ2FsbGJhY2sgJiYgIXN1cHByZXNzRXZlbnRzICYmICFpc0Rpc3BhdGNoaW5nKSB7XG5cdFx0XHRcdFx0XHRpc0Rpc3BhdGNoaW5nID0gdHJ1ZTsgLy9pbiBjYXNlIG9uRHJhZyBoYXMgYW4gdXBkYXRlKCkgY2FsbCAoYXZvaWQgZW5kbGVzcyBsb29wKVxuXHRcdFx0XHRcdFx0aWYgKF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiZHJhZ1wiLCBcIm9uRHJhZ1wiKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGFsbG93WCkge1xuXHRcdFx0XHRcdFx0XHRcdHNlbGYueCAtPSBzZWxmLmRlbHRhWDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoYWxsb3dZKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2VsZi55IC09IHNlbGYuZGVsdGFZO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJlbmRlcih0cnVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGlydHkgPSBmYWxzZTtcblx0XHRcdH0sXG5cblx0XHRcdC8vY29waWVzIHRoZSB4L3kgZnJvbSB0aGUgZWxlbWVudCAod2hldGhlciB0aGF0IGJlIHRyYW5zZm9ybXMsIHRvcC9sZWZ0LCBvciBTY3JvbGxQcm94eSdzIHRvcC9sZWZ0KSB0byB0aGUgRHJhZ2dhYmxlJ3MgeCBhbmQgeSAoYW5kIHJvdGF0aW9uIGlmIG5lY2Vzc2FyeSkgcHJvcGVydGllcyBzbyB0aGF0IHRoZXkgcmVmbGVjdCByZWFsaXR5IGFuZCBpdCBhbHNvIChvcHRpb25hbGx5KSBhcHBsaWVzIGFueSBzbmFwcGluZyBuZWNlc3NhcnkuIFRoaXMgaXMgdXNlZCBieSB0aGUgSW5lcnRpYVBsdWdpbiB0d2VlbiBpbiBhbiBvblVwZGF0ZSB0byBlbnN1cmUgdGhpbmdzIGFyZSBzeW5jZWQgYW5kIHNuYXBwZWQuXG5cdFx0XHRzeW5jWFkgPSAoc2tpcE9uVXBkYXRlLCBza2lwU25hcCkgPT4ge1xuXHRcdFx0XHRsZXQgeyB4LCB5IH0gPSBzZWxmLFxuXHRcdFx0XHRcdHNuYXBwZWRWYWx1ZSwgY3M7XG5cdFx0XHRcdGlmICghdGFyZ2V0Ll9nc2FwKSB7IC8vanVzdCBpbiBjYXNlIHRoZSBfZ3NhcCBjYWNoZSBnb3Qgd2lwZWQsIGxpa2UgaWYgdGhlIHVzZXIgY2FsbGVkIGNsZWFyUHJvcHMgb24gdGhlIHRyYW5zZm9ybSBvciBzb21ldGhpbmcgKHZlcnkgcmFyZSkuXG5cdFx0XHRcdFx0Z3NDYWNoZSA9IGdzYXAuY29yZS5nZXRDYWNoZSh0YXJnZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGdzQ2FjaGUudW5jYWNoZSAmJiBnc2FwLmdldFByb3BlcnR5KHRhcmdldCwgXCJ4XCIpOyAvLyB0cmlnZ2VyIGEgcmUtY2FjaGVcblx0XHRcdFx0aWYgKHh5TW9kZSkge1xuXHRcdFx0XHRcdHNlbGYueCA9IHBhcnNlRmxvYXQoZ3NDYWNoZS54KTtcblx0XHRcdFx0XHRzZWxmLnkgPSBwYXJzZUZsb2F0KGdzQ2FjaGUueSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocm90YXRpb25Nb2RlKSB7XG5cdFx0XHRcdFx0c2VsZi54ID0gc2VsZi5yb3RhdGlvbiA9IHBhcnNlRmxvYXQoZ3NDYWNoZS5yb3RhdGlvbik7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc2Nyb2xsUHJveHkpIHtcblx0XHRcdFx0XHRzZWxmLnkgPSBzY3JvbGxQcm94eS50b3AoKTtcblx0XHRcdFx0XHRzZWxmLnggPSBzY3JvbGxQcm94eS5sZWZ0KCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZi55ID0gcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUudG9wIHx8ICgoY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpKSAmJiBjcy50b3ApKSB8fCAwO1xuXHRcdFx0XHRcdHNlbGYueCA9IHBhcnNlRmxvYXQodGFyZ2V0LnN0eWxlLmxlZnQgfHwgKGNzIHx8IHt9KS5sZWZ0KSB8fCAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICgoc25hcFggfHwgc25hcFkgfHwgc25hcFhZKSAmJiAhc2tpcFNuYXAgJiYgKHNlbGYuaXNEcmFnZ2luZyB8fCBzZWxmLmlzVGhyb3dpbmcpKSB7XG5cdFx0XHRcdFx0aWYgKHNuYXBYWSkge1xuXHRcdFx0XHRcdFx0X3RlbXAxLnggPSBzZWxmLng7XG5cdFx0XHRcdFx0XHRfdGVtcDEueSA9IHNlbGYueTtcblx0XHRcdFx0XHRcdHNuYXBwZWRWYWx1ZSA9IHNuYXBYWShfdGVtcDEpO1xuXHRcdFx0XHRcdFx0aWYgKHNuYXBwZWRWYWx1ZS54ICE9PSBzZWxmLngpIHtcblx0XHRcdFx0XHRcdFx0c2VsZi54ID0gc25hcHBlZFZhbHVlLng7XG5cdFx0XHRcdFx0XHRcdGRpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChzbmFwcGVkVmFsdWUueSAhPT0gc2VsZi55KSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYueSA9IHNuYXBwZWRWYWx1ZS55O1xuXHRcdFx0XHRcdFx0XHRkaXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzbmFwWCkge1xuXHRcdFx0XHRcdFx0c25hcHBlZFZhbHVlID0gc25hcFgoc2VsZi54KTtcblx0XHRcdFx0XHRcdGlmIChzbmFwcGVkVmFsdWUgIT09IHNlbGYueCkge1xuXHRcdFx0XHRcdFx0XHRzZWxmLnggPSBzbmFwcGVkVmFsdWU7XG5cdFx0XHRcdFx0XHRcdGlmIChyb3RhdGlvbk1vZGUpIHtcblx0XHRcdFx0XHRcdFx0XHRzZWxmLnJvdGF0aW9uID0gc25hcHBlZFZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGRpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHNuYXBZKSB7XG5cdFx0XHRcdFx0XHRzbmFwcGVkVmFsdWUgPSBzbmFwWShzZWxmLnkpO1xuXHRcdFx0XHRcdFx0aWYgKHNuYXBwZWRWYWx1ZSAhPT0gc2VsZi55KSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYueSA9IHNuYXBwZWRWYWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGRpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGlydHkgJiYgcmVuZGVyKHRydWUpO1xuXHRcdFx0XHRpZiAoIXNraXBPblVwZGF0ZSkge1xuXHRcdFx0XHRcdHNlbGYuZGVsdGFYID0gc2VsZi54IC0geDtcblx0XHRcdFx0XHRzZWxmLmRlbHRhWSA9IHNlbGYueSAtIHk7XG5cdFx0XHRcdFx0X2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJ0aHJvd3VwZGF0ZVwiLCBcIm9uVGhyb3dVcGRhdGVcIik7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGJ1aWxkU25hcEZ1bmMgPSAoc25hcCwgbWluLCBtYXgsIGZhY3RvcikgPT4ge1xuXHRcdFx0XHRpZiAobWluID09IG51bGwpIHtcblx0XHRcdFx0XHRtaW4gPSAtX2JpZ051bTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobWF4ID09IG51bGwpIHtcblx0XHRcdFx0XHRtYXggPSBfYmlnTnVtO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfaXNGdW5jdGlvbihzbmFwKSkge1xuXHRcdFx0XHRcdHJldHVybiBuID0+IHtcblx0XHRcdFx0XHRcdGxldCBlZGdlVG9sZXJhbmNlID0gIXNlbGYuaXNQcmVzc2VkID8gMSA6IDEgLSBzZWxmLmVkZ2VSZXNpc3RhbmNlOyAvL2lmIHdlJ3JlIHR3ZWVuaW5nLCBkaXNhYmxlIHRoZSBlZGdlVG9sZXJhbmNlIGJlY2F1c2UgaXQncyBhbHJlYWR5IGZhY3RvcmVkIGludG8gdGhlIHR3ZWVuaW5nIHZhbHVlcyAod2UgZG9uJ3Qgd2FudCB0byBhcHBseSBpdCBtdWx0aXBsZSB0aW1lcylcblx0XHRcdFx0XHRcdHJldHVybiBzbmFwLmNhbGwoc2VsZiwgKG4gPiBtYXggPyBtYXggKyAobiAtIG1heCkgKiBlZGdlVG9sZXJhbmNlIDogKG4gPCBtaW4pID8gbWluICsgKG4gLSBtaW4pICogZWRnZVRvbGVyYW5jZSA6IG4pKSAqIGZhY3Rvcjtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfaXNBcnJheShzbmFwKSkge1xuXHRcdFx0XHRcdHJldHVybiBuID0+IHtcblx0XHRcdFx0XHRcdGxldCBpID0gc25hcC5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdGNsb3Nlc3QgPSAwLFxuXHRcdFx0XHRcdFx0XHRhYnNEaWYgPSBfYmlnTnVtLFxuXHRcdFx0XHRcdFx0XHR2YWwsIGRpZjtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHR2YWwgPSBzbmFwW2ldO1xuXHRcdFx0XHRcdFx0XHRkaWYgPSB2YWwgLSBuO1xuXHRcdFx0XHRcdFx0XHRpZiAoZGlmIDwgMCkge1xuXHRcdFx0XHRcdFx0XHRcdGRpZiA9IC1kaWY7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKGRpZiA8IGFic0RpZiAmJiB2YWwgPj0gbWluICYmIHZhbCA8PSBtYXgpIHtcblx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0ID0gaTtcblx0XHRcdFx0XHRcdFx0XHRhYnNEaWYgPSBkaWY7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBzbmFwW2Nsb3Nlc3RdO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGlzTmFOKHNuYXApID8gbiA9PiBuIDogKCkgPT4gc25hcCAqIGZhY3Rvcjtcblx0XHRcdH0sXG5cblx0XHRcdGJ1aWxkUG9pbnRTbmFwRnVuYyA9IChzbmFwLCBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZLCByYWRpdXMsIGZhY3RvcikgPT4ge1xuXHRcdFx0XHRyYWRpdXMgPSAocmFkaXVzICYmIHJhZGl1cyA8IF9iaWdOdW0pID8gcmFkaXVzICogcmFkaXVzIDogX2JpZ051bTsgLy9zbyB3ZSBkb24ndCBoYXZlIHRvIE1hdGguc3FydCgpIGluIHRoZSBmdW5jdGlvbnMuIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cblx0XHRcdFx0aWYgKF9pc0Z1bmN0aW9uKHNuYXApKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBvaW50ID0+IHtcblx0XHRcdFx0XHRcdGxldCBlZGdlVG9sZXJhbmNlID0gIXNlbGYuaXNQcmVzc2VkID8gMSA6IDEgLSBzZWxmLmVkZ2VSZXNpc3RhbmNlLFxuXHRcdFx0XHRcdFx0XHR4ID0gcG9pbnQueCxcblx0XHRcdFx0XHRcdFx0eSA9IHBvaW50LnksXG5cdFx0XHRcdFx0XHRcdHJlc3VsdCwgZHgsIGR5OyAvL2lmIHdlJ3JlIHR3ZWVuaW5nLCBkaXNhYmxlIHRoZSBlZGdlVG9sZXJhbmNlIGJlY2F1c2UgaXQncyBhbHJlYWR5IGZhY3RvcmVkIGludG8gdGhlIHR3ZWVuaW5nIHZhbHVlcyAod2UgZG9uJ3Qgd2FudCB0byBhcHBseSBpdCBtdWx0aXBsZSB0aW1lcylcblx0XHRcdFx0XHRcdHBvaW50LnggPSB4ID0gKHggPiBtYXhYID8gbWF4WCArICh4IC0gbWF4WCkgKiBlZGdlVG9sZXJhbmNlIDogKHggPCBtaW5YKSA/IG1pblggKyAoeCAtIG1pblgpICogZWRnZVRvbGVyYW5jZSA6IHgpO1xuXHRcdFx0XHRcdFx0cG9pbnQueSA9IHkgPSAoeSA+IG1heFkgPyBtYXhZICsgKHkgLSBtYXhZKSAqIGVkZ2VUb2xlcmFuY2UgOiAoeSA8IG1pblkpID8gbWluWSArICh5IC0gbWluWSkgKiBlZGdlVG9sZXJhbmNlIDogeSk7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSBzbmFwLmNhbGwoc2VsZiwgcG9pbnQpO1xuXHRcdFx0XHRcdFx0aWYgKHJlc3VsdCAhPT0gcG9pbnQpIHtcblx0XHRcdFx0XHRcdFx0cG9pbnQueCA9IHJlc3VsdC54O1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gcmVzdWx0Lnk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoZmFjdG9yICE9PSAxKSB7XG5cdFx0XHRcdFx0XHRcdHBvaW50LnggKj0gZmFjdG9yO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ICo9IGZhY3Rvcjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChyYWRpdXMgPCBfYmlnTnVtKSB7XG5cdFx0XHRcdFx0XHRcdGR4ID0gcG9pbnQueCAtIHg7XG5cdFx0XHRcdFx0XHRcdGR5ID0gcG9pbnQueSAtIHk7XG5cdFx0XHRcdFx0XHRcdGlmIChkeCAqIGR4ICsgZHkgKiBkeSA+IHJhZGl1cykge1xuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnggPSB4O1xuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnkgPSB5O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gcG9pbnQ7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX2lzQXJyYXkoc25hcCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gcCA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgaSA9IHNuYXAubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRjbG9zZXN0ID0gMCxcblx0XHRcdFx0XHRcdFx0bWluRGlzdCA9IF9iaWdOdW0sXG5cdFx0XHRcdFx0XHRcdHgsIHksIHBvaW50LCBkaXN0O1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHBvaW50ID0gc25hcFtpXTtcblx0XHRcdFx0XHRcdFx0eCA9IHBvaW50LnggLSBwLng7XG5cdFx0XHRcdFx0XHRcdHkgPSBwb2ludC55IC0gcC55O1xuXHRcdFx0XHRcdFx0XHRkaXN0ID0geCAqIHggKyB5ICogeTtcblx0XHRcdFx0XHRcdFx0aWYgKGRpc3QgPCBtaW5EaXN0KSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdCA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0bWluRGlzdCA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiAobWluRGlzdCA8PSByYWRpdXMpID8gc25hcFtjbG9zZXN0XSA6IHA7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbiA9PiBuO1xuXHRcdFx0fSxcblxuXHRcdFx0Y2FsY3VsYXRlQm91bmRzID0gKCkgPT4ge1xuXHRcdFx0XHRsZXQgYm91bmRzLCB0YXJnZXRCb3VuZHMsIHNuYXAsIHNuYXBJc1Jhdztcblx0XHRcdFx0aGFzQm91bmRzID0gZmFsc2U7XG5cdFx0XHRcdGlmIChzY3JvbGxQcm94eSkge1xuXHRcdFx0XHRcdHNjcm9sbFByb3h5LmNhbGlicmF0ZSgpO1xuXHRcdFx0XHRcdHNlbGYubWluWCA9IG1pblggPSAtc2Nyb2xsUHJveHkubWF4U2Nyb2xsTGVmdCgpO1xuXHRcdFx0XHRcdHNlbGYubWluWSA9IG1pblkgPSAtc2Nyb2xsUHJveHkubWF4U2Nyb2xsVG9wKCk7XG5cdFx0XHRcdFx0c2VsZi5tYXhYID0gbWF4WCA9IHNlbGYubWF4WSA9IG1heFkgPSAwO1xuXHRcdFx0XHRcdGhhc0JvdW5kcyA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoISF2YXJzLmJvdW5kcykge1xuXHRcdFx0XHRcdGJvdW5kcyA9IF9nZXRCb3VuZHModmFycy5ib3VuZHMsIHRhcmdldC5wYXJlbnROb2RlKTsgLy9jb3VsZCBiZSBhIHNlbGVjdG9yL2pRdWVyeSBvYmplY3Qgb3IgYSBET00gZWxlbWVudCBvciBhIGdlbmVyaWMgb2JqZWN0IGxpa2Uge3RvcDowLCBsZWZ0OjEwMCwgd2lkdGg6MTAwMCwgaGVpZ2h0OjgwMH0gb3Ige21pblg6MTAwLCBtYXhYOjExMDAsIG1pblk6MCwgbWF4WTo4MDB9XG5cdFx0XHRcdFx0aWYgKHJvdGF0aW9uTW9kZSkge1xuXHRcdFx0XHRcdFx0c2VsZi5taW5YID0gbWluWCA9IGJvdW5kcy5sZWZ0O1xuXHRcdFx0XHRcdFx0c2VsZi5tYXhYID0gbWF4WCA9IGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoO1xuXHRcdFx0XHRcdFx0c2VsZi5taW5ZID0gbWluWSA9IHNlbGYubWF4WSA9IG1heFkgPSAwO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIV9pc1VuZGVmaW5lZCh2YXJzLmJvdW5kcy5tYXhYKSB8fCAhX2lzVW5kZWZpbmVkKHZhcnMuYm91bmRzLm1heFkpKSB7XG5cdFx0XHRcdFx0XHRib3VuZHMgPSB2YXJzLmJvdW5kcztcblx0XHRcdFx0XHRcdHNlbGYubWluWCA9IG1pblggPSBib3VuZHMubWluWDtcblx0XHRcdFx0XHRcdHNlbGYubWluWSA9IG1pblkgPSBib3VuZHMubWluWTtcblx0XHRcdFx0XHRcdHNlbGYubWF4WCA9IG1heFggPSBib3VuZHMubWF4WDtcblx0XHRcdFx0XHRcdHNlbGYubWF4WSA9IG1heFkgPSBib3VuZHMubWF4WTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGFyZ2V0Qm91bmRzID0gX2dldEJvdW5kcyh0YXJnZXQsIHRhcmdldC5wYXJlbnROb2RlKTtcblx0XHRcdFx0XHRcdHNlbGYubWluWCA9IG1pblggPSBNYXRoLnJvdW5kKGdldFByb3BBc051bSh4UHJvcCwgXCJweFwiKSArIGJvdW5kcy5sZWZ0IC0gdGFyZ2V0Qm91bmRzLmxlZnQgLSAwLjUpO1xuXHRcdFx0XHRcdFx0c2VsZi5taW5ZID0gbWluWSA9IE1hdGgucm91bmQoZ2V0UHJvcEFzTnVtKHlQcm9wLCBcInB4XCIpICsgYm91bmRzLnRvcCAtIHRhcmdldEJvdW5kcy50b3AgLSAwLjUpO1xuXHRcdFx0XHRcdFx0c2VsZi5tYXhYID0gbWF4WCA9IE1hdGgucm91bmQobWluWCArIChib3VuZHMud2lkdGggLSB0YXJnZXRCb3VuZHMud2lkdGgpKTtcblx0XHRcdFx0XHRcdHNlbGYubWF4WSA9IG1heFkgPSBNYXRoLnJvdW5kKG1pblkgKyAoYm91bmRzLmhlaWdodCAtIHRhcmdldEJvdW5kcy5oZWlnaHQpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1pblggPiBtYXhYKSB7XG5cdFx0XHRcdFx0XHRzZWxmLm1pblggPSBtYXhYO1xuXHRcdFx0XHRcdFx0c2VsZi5tYXhYID0gbWF4WCA9IG1pblg7XG5cdFx0XHRcdFx0XHRtaW5YID0gc2VsZi5taW5YO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWluWSA+IG1heFkpIHtcblx0XHRcdFx0XHRcdHNlbGYubWluWSA9IG1heFk7XG5cdFx0XHRcdFx0XHRzZWxmLm1heFkgPSBtYXhZID0gbWluWTtcblx0XHRcdFx0XHRcdG1pblkgPSBzZWxmLm1pblk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChyb3RhdGlvbk1vZGUpIHtcblx0XHRcdFx0XHRcdHNlbGYubWluUm90YXRpb24gPSBtaW5YO1xuXHRcdFx0XHRcdFx0c2VsZi5tYXhSb3RhdGlvbiA9IG1heFg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGhhc0JvdW5kcyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHZhcnMubGl2ZVNuYXApIHtcblx0XHRcdFx0XHRzbmFwID0gKHZhcnMubGl2ZVNuYXAgPT09IHRydWUpID8gKHZhcnMuc25hcCB8fCB7fSkgOiB2YXJzLmxpdmVTbmFwO1xuXHRcdFx0XHRcdHNuYXBJc1JhdyA9IChfaXNBcnJheShzbmFwKSB8fCBfaXNGdW5jdGlvbihzbmFwKSk7XG5cdFx0XHRcdFx0aWYgKHJvdGF0aW9uTW9kZSkge1xuXHRcdFx0XHRcdFx0c25hcFggPSBidWlsZFNuYXBGdW5jKChzbmFwSXNSYXcgPyBzbmFwIDogc25hcC5yb3RhdGlvbiksIG1pblgsIG1heFgsIDEpO1xuXHRcdFx0XHRcdFx0c25hcFkgPSBudWxsO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoc25hcC5wb2ludHMpIHtcblx0XHRcdFx0XHRcdFx0c25hcFhZID0gYnVpbGRQb2ludFNuYXBGdW5jKChzbmFwSXNSYXcgPyBzbmFwIDogc25hcC5wb2ludHMpLCBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZLCBzbmFwLnJhZGl1cywgc2Nyb2xsUHJveHkgPyAtMSA6IDEpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aWYgKGFsbG93WCkge1xuXHRcdFx0XHRcdFx0XHRcdHNuYXBYID0gYnVpbGRTbmFwRnVuYygoc25hcElzUmF3ID8gc25hcCA6IHNuYXAueCB8fCBzbmFwLmxlZnQgfHwgc25hcC5zY3JvbGxMZWZ0KSwgbWluWCwgbWF4WCwgc2Nyb2xsUHJveHkgPyAtMSA6IDEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChhbGxvd1kpIHtcblx0XHRcdFx0XHRcdFx0XHRzbmFwWSA9IGJ1aWxkU25hcEZ1bmMoKHNuYXBJc1JhdyA/IHNuYXAgOiBzbmFwLnkgfHwgc25hcC50b3AgfHwgc25hcC5zY3JvbGxUb3ApLCBtaW5ZLCBtYXhZLCBzY3JvbGxQcm94eSA/IC0xIDogMSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdG9uVGhyb3dDb21wbGV0ZSA9ICgpID0+IHtcblx0XHRcdFx0c2VsZi5pc1Rocm93aW5nID0gZmFsc2U7XG5cdFx0XHRcdF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwidGhyb3djb21wbGV0ZVwiLCBcIm9uVGhyb3dDb21wbGV0ZVwiKTtcblx0XHRcdH0sXG5cdFx0XHRvblRocm93SW50ZXJydXB0ID0gKCkgPT4ge1xuXHRcdFx0XHRzZWxmLmlzVGhyb3dpbmcgPSBmYWxzZTtcblx0XHRcdH0sXG5cblx0XHRcdGFuaW1hdGUgPSAoaW5lcnRpYSwgZm9yY2VaZXJvVmVsb2NpdHkpID0+IHtcblx0XHRcdFx0bGV0IHNuYXAsIHNuYXBJc1JhdywgdHdlZW4sIG92ZXJzaG9vdFRvbGVyYW5jZTtcblx0XHRcdFx0aWYgKGluZXJ0aWEgJiYgSW5lcnRpYVBsdWdpbikge1xuXHRcdFx0XHRcdGlmIChpbmVydGlhID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRzbmFwID0gdmFycy5zbmFwIHx8IHZhcnMubGl2ZVNuYXAgfHwge307XG5cdFx0XHRcdFx0XHRzbmFwSXNSYXcgPSAoX2lzQXJyYXkoc25hcCkgfHwgX2lzRnVuY3Rpb24oc25hcCkpO1xuXHRcdFx0XHRcdFx0aW5lcnRpYSA9IHtyZXNpc3RhbmNlOih2YXJzLnRocm93UmVzaXN0YW5jZSB8fCB2YXJzLnJlc2lzdGFuY2UgfHwgMTAwMCkgLyAocm90YXRpb25Nb2RlID8gMTAgOiAxKX07XG5cdFx0XHRcdFx0XHRpZiAocm90YXRpb25Nb2RlKSB7XG5cdFx0XHRcdFx0XHRcdGluZXJ0aWEucm90YXRpb24gPSBfcGFyc2VJbmVydGlhKHNlbGYsIHNuYXBJc1JhdyA/IHNuYXAgOiBzbmFwLnJvdGF0aW9uLCBtYXhYLCBtaW5YLCAxLCBmb3JjZVplcm9WZWxvY2l0eSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZiAoYWxsb3dYKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5lcnRpYVt4UHJvcF0gPSBfcGFyc2VJbmVydGlhKHNlbGYsIHNuYXBJc1JhdyA/IHNuYXAgOiBzbmFwLnBvaW50cyB8fCBzbmFwLnggfHwgc25hcC5sZWZ0LCBtYXhYLCBtaW5YLCBzY3JvbGxQcm94eSA/IC0xIDogMSwgZm9yY2VaZXJvVmVsb2NpdHkgfHwgKHNlbGYubG9ja2VkQXhpcyA9PT0gXCJ4XCIpKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoYWxsb3dZKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5lcnRpYVt5UHJvcF0gPSBfcGFyc2VJbmVydGlhKHNlbGYsIHNuYXBJc1JhdyA/IHNuYXAgOiBzbmFwLnBvaW50cyB8fCBzbmFwLnkgfHwgc25hcC50b3AsIG1heFksIG1pblksIHNjcm9sbFByb3h5ID8gLTEgOiAxLCBmb3JjZVplcm9WZWxvY2l0eSB8fCAoc2VsZi5sb2NrZWRBeGlzID09PSBcInlcIikpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChzbmFwLnBvaW50cyB8fCAoX2lzQXJyYXkoc25hcCkgJiYgX2lzT2JqZWN0KHNuYXBbMF0pKSkge1xuXHRcdFx0XHRcdFx0XHRcdGluZXJ0aWEubGlua2VkUHJvcHMgPSB4UHJvcCArIFwiLFwiICsgeVByb3A7XG5cdFx0XHRcdFx0XHRcdFx0aW5lcnRpYS5yYWRpdXMgPSBzbmFwLnJhZGl1czsgLy9ub3RlOiB3ZSBhbHNvIGRpc2FibGUgbGl2ZVNuYXBwaW5nIHdoaWxlIHRocm93aW5nIGlmIHRoZXJlJ3MgYSBcInJhZGl1c1wiIGRlZmluZWQsIG90aGVyd2lzZSBpdCBsb29rcyB3ZWlyZCB0byBoYXZlIHRoZSBpdGVtIHRocm93biBwYXN0IGEgc25hcHBpbmcgcG9pbnQgYnV0IGxpdmUtc25hcHBpbmcgbWlkLXR3ZWVuLiBXZSBkbyB0aGlzIGJ5IGFsdGVyaW5nIHRoZSBvblVwZGF0ZVBhcmFtcyBzbyB0aGF0IFwic2tpcFNuYXBcIiBwYXJhbWV0ZXIgaXMgdHJ1ZSBmb3Igc3luY1hZLlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlbGYuaXNUaHJvd2luZyA9IHRydWU7XG5cdFx0XHRcdFx0b3ZlcnNob290VG9sZXJhbmNlID0gKCFpc05hTih2YXJzLm92ZXJzaG9vdFRvbGVyYW5jZSkpID8gdmFycy5vdmVyc2hvb3RUb2xlcmFuY2UgOiAodmFycy5lZGdlUmVzaXN0YW5jZSA9PT0gMSkgPyAwIDogKDEgLSBzZWxmLmVkZ2VSZXNpc3RhbmNlKSArIDAuMjtcblx0XHRcdFx0XHRpZiAoIWluZXJ0aWEuZHVyYXRpb24pIHtcblx0XHRcdFx0XHRcdGluZXJ0aWEuZHVyYXRpb24gPSB7bWF4OiBNYXRoLm1heCh2YXJzLm1pbkR1cmF0aW9uIHx8IDAsIChcIm1heER1cmF0aW9uXCIgaW4gdmFycykgPyB2YXJzLm1heER1cmF0aW9uIDogMiksIG1pbjogKCFpc05hTih2YXJzLm1pbkR1cmF0aW9uKSA/IHZhcnMubWluRHVyYXRpb24gOiAob3ZlcnNob290VG9sZXJhbmNlID09PSAwIHx8IChfaXNPYmplY3QoaW5lcnRpYSkgJiYgaW5lcnRpYS5yZXNpc3RhbmNlID4gMTAwMCkpID8gMCA6IDAuNSksIG92ZXJzaG9vdDogb3ZlcnNob290VG9sZXJhbmNlfTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VsZi50d2VlbiA9IHR3ZWVuID0gZ3NhcC50byhzY3JvbGxQcm94eSB8fCB0YXJnZXQsIHtcblx0XHRcdFx0XHRcdGluZXJ0aWE6IGluZXJ0aWEsXG5cdFx0XHRcdFx0XHRkYXRhOiBcIl9kcmFnZ2FibGVcIixcblx0XHRcdFx0XHRcdG9uQ29tcGxldGU6IG9uVGhyb3dDb21wbGV0ZSxcblx0XHRcdFx0XHRcdG9uSW50ZXJydXB0OiBvblRocm93SW50ZXJydXB0LFxuXHRcdFx0XHRcdFx0b25VcGRhdGU6ICh2YXJzLmZhc3RNb2RlID8gX2Rpc3BhdGNoRXZlbnQgOiBzeW5jWFkpLFxuXHRcdFx0XHRcdFx0b25VcGRhdGVQYXJhbXM6ICh2YXJzLmZhc3RNb2RlID8gW3NlbGYsIFwib250aHJvd3VwZGF0ZVwiLCBcIm9uVGhyb3dVcGRhdGVcIl0gOiAoc25hcCAmJiBzbmFwLnJhZGl1cykgPyBbZmFsc2UsIHRydWVdIDogW10pXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0aWYgKCF2YXJzLmZhc3RNb2RlKSB7XG5cdFx0XHRcdFx0XHRpZiAoc2Nyb2xsUHJveHkpIHtcblx0XHRcdFx0XHRcdFx0c2Nyb2xsUHJveHkuX3NraXAgPSB0cnVlOyAvLyBNaWNyb3NvZnQgYnJvd3NlcnMgaGF2ZSBhIGJ1ZyB0aGF0IGNhdXNlcyB0aGVtIHRvIGJyaWVmbHkgcmVuZGVyIHRoZSBwb3NpdGlvbiBpbmNvcnJlY3RseSAoaXQgZmxhc2hlcyB0byB0aGUgZW5kIHN0YXRlIHdoZW4gd2Ugc2VlaygpIHRoZSB0d2VlbiBldmVuIHRob3VnaCB3ZSBqdW1wIHJpZ2h0IGJhY2sgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24sIGFuZCB0aGlzIG9ubHkgc2VlbXMgdG8gaGFwcGVuIHdoZW4gd2UncmUgYWZmZWN0aW5nIGJvdGggdG9wIGFuZCBsZWZ0KSwgc28gd2Ugc2V0IGEgX3N1c3BlbmRUcmFuc2Zvcm1zIGZsYWcgdG8gcHJldmVudCBpdCBmcm9tIGFjdHVhbGx5IGFwcGx5aW5nIHRoZSB2YWx1ZXMgaW4gdGhlIFNjcm9sbFByb3h5LlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKDFlOSwgdHJ1ZSwgdHJ1ZSk7IC8vIGZvcmNlIHRvIHRoZSBlbmQuIFJlbWVtYmVyLCB0aGUgZHVyYXRpb24gd2lsbCBsaWtlbHkgY2hhbmdlIHVwb24gaW5pdHRpbmcgYmVjYXVzZSB0aGF0J3Mgd2hlbiBJbmVydGlhUGx1Z2luIGNhbGN1bGF0ZXMgaXQuXG5cdFx0XHRcdFx0XHRzeW5jWFkodHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRzZWxmLmVuZFggPSBzZWxmLng7XG5cdFx0XHRcdFx0XHRzZWxmLmVuZFkgPSBzZWxmLnk7XG5cdFx0XHRcdFx0XHRpZiAocm90YXRpb25Nb2RlKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYuZW5kUm90YXRpb24gPSBzZWxmLng7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0d2Vlbi5wbGF5KDApO1xuXHRcdFx0XHRcdFx0c3luY1hZKHRydWUsIHRydWUpO1xuXHRcdFx0XHRcdFx0aWYgKHNjcm9sbFByb3h5KSB7XG5cdFx0XHRcdFx0XHRcdHNjcm9sbFByb3h5Ll9za2lwID0gZmFsc2U7IC8vTWljcm9zb2Z0IGJyb3dzZXJzIGhhdmUgYSBidWcgdGhhdCBjYXVzZXMgdGhlbSB0byBicmllZmx5IHJlbmRlciB0aGUgcG9zaXRpb24gaW5jb3JyZWN0bHkgKGl0IGZsYXNoZXMgdG8gdGhlIGVuZCBzdGF0ZSB3aGVuIHdlIHNlZWsoKSB0aGUgdHdlZW4gZXZlbiB0aG91Z2ggd2UganVtcCByaWdodCBiYWNrIHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uLCBhbmQgdGhpcyBvbmx5IHNlZW1zIHRvIGhhcHBlbiB3aGVuIHdlJ3JlIGFmZmVjdGluZyBib3RoIHRvcCBhbmQgbGVmdCksIHNvIHdlIHNldCBhIF9zdXNwZW5kVHJhbnNmb3JtcyBmbGFnIHRvIHByZXZlbnQgaXQgZnJvbSBhY3R1YWxseSBhcHBseWluZyB0aGUgdmFsdWVzIGluIHRoZSBTY3JvbGxQcm94eS5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoaGFzQm91bmRzKSB7XG5cdFx0XHRcdFx0c2VsZi5hcHBseUJvdW5kcygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHR1cGRhdGVNYXRyaXggPSBzaGlmdFN0YXJ0ID0+IHtcblx0XHRcdFx0bGV0IHN0YXJ0ID0gbWF0cml4LFxuXHRcdFx0XHRcdHA7XG5cdFx0XHRcdG1hdHJpeCA9IGdldEdsb2JhbE1hdHJpeCh0YXJnZXQucGFyZW50Tm9kZSwgdHJ1ZSk7XG5cdFx0XHRcdGlmIChzaGlmdFN0YXJ0ICYmIHNlbGYuaXNQcmVzc2VkICYmICFtYXRyaXguZXF1YWxzKHN0YXJ0IHx8IG5ldyBNYXRyaXgyRCgpKSkgeyAvL2lmIHRoZSBtYXRyaXggY2hhbmdlcyBXSElMRSB0aGUgZWxlbWVudCBpcyBwcmVzc2VkLCB3ZSBtdXN0IGFkanVzdCB0aGUgc3RhcnRQb2ludGVyWCBhbmQgc3RhcnRQb2ludGVyWSBhY2NvcmRpbmdseSwgc28gd2UgaW52ZXJ0IHRoZSBvcmlnaW5hbCBtYXRyaXggYW5kIGZpZ3VyZSBvdXQgd2hlcmUgdGhlIHBvaW50ZXJYIGFuZCBwb2ludGVyWSB3ZXJlIGluIHRoZSBnbG9iYWwgc3BhY2UsIHRoZW4gYXBwbHkgdGhlIG5ldyBtYXRyaXggdG8gZ2V0IHRoZSB1cGRhdGVkIGNvb3JkaW5hdGVzLlxuXHRcdFx0XHRcdHAgPSBzdGFydC5pbnZlcnNlKCkuYXBwbHkoe3g6c3RhcnRQb2ludGVyWCwgeTpzdGFydFBvaW50ZXJZfSk7XG5cdFx0XHRcdFx0bWF0cml4LmFwcGx5KHAsIHApO1xuXHRcdFx0XHRcdHN0YXJ0UG9pbnRlclggPSBwLng7XG5cdFx0XHRcdFx0c3RhcnRQb2ludGVyWSA9IHAueTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobWF0cml4LmVxdWFscyhfaWRlbnRpdHlNYXRyaXgpKSB7IC8vaWYgdGhlcmUgYXJlIG5vIHRyYW5zZm9ybXMsIHdlIGNhbiBvcHRpbWl6ZSBwZXJmb3JtYW5jZSBieSBub3QgZmFjdG9yaW5nIGluIHRoZSBtYXRyaXhcblx0XHRcdFx0XHRtYXRyaXggPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRyZWNvcmRTdGFydFBvc2l0aW9ucyA9ICgpID0+IHtcblx0XHRcdFx0bGV0IGVkZ2VUb2xlcmFuY2UgPSAxIC0gc2VsZi5lZGdlUmVzaXN0YW5jZSxcblx0XHRcdFx0XHRvZmZzZXRYID0gaXNGaXhlZCA/IF9nZXREb2NTY3JvbGxMZWZ0KG93bmVyRG9jKSA6IDAsXG5cdFx0XHRcdFx0b2Zmc2V0WSA9IGlzRml4ZWQgPyBfZ2V0RG9jU2Nyb2xsVG9wKG93bmVyRG9jKSA6IDAsXG5cdFx0XHRcdFx0cGFyc2VkT3JpZ2luLCB4LCB5O1xuXHRcdFx0XHR1cGRhdGVNYXRyaXgoZmFsc2UpO1xuXHRcdFx0XHRfcG9pbnQxLnggPSBzZWxmLnBvaW50ZXJYIC0gb2Zmc2V0WDtcblx0XHRcdFx0X3BvaW50MS55ID0gc2VsZi5wb2ludGVyWSAtIG9mZnNldFk7XG5cdFx0XHRcdG1hdHJpeCAmJiBtYXRyaXguYXBwbHkoX3BvaW50MSwgX3BvaW50MSk7XG5cdFx0XHRcdHN0YXJ0UG9pbnRlclggPSBfcG9pbnQxLng7IC8vdHJhbnNsYXRlIHRvIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtXG5cdFx0XHRcdHN0YXJ0UG9pbnRlclkgPSBfcG9pbnQxLnk7XG5cdFx0XHRcdGlmIChkaXJ0eSkge1xuXHRcdFx0XHRcdHNldFBvaW50ZXJQb3NpdGlvbihzZWxmLnBvaW50ZXJYLCBzZWxmLnBvaW50ZXJZKTtcblx0XHRcdFx0XHRyZW5kZXIodHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHNjcm9sbFByb3h5KSB7XG5cdFx0XHRcdFx0Y2FsY3VsYXRlQm91bmRzKCk7XG5cdFx0XHRcdFx0c3RhcnRFbGVtZW50WSA9IHNjcm9sbFByb3h5LnRvcCgpO1xuXHRcdFx0XHRcdHN0YXJ0RWxlbWVudFggPSBzY3JvbGxQcm94eS5sZWZ0KCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly9pZiB0aGUgZWxlbWVudCBpcyBpbiB0aGUgcHJvY2VzcyBvZiB0d2VlbmluZywgZG9uJ3QgZm9yY2Ugc25hcHBpbmcgdG8gb2NjdXIgYmVjYXVzZSBpdCBjb3VsZCBtYWtlIGl0IGp1bXAuIEltYWdpbmUgdGhlIHVzZXIgdGhyb3dpbmcsIHRoZW4gYmVmb3JlIGl0J3MgZG9uZSwgY2xpY2tpbmcgb24gdGhlIGVsZW1lbnQgaW4gaXRzIGluYmV0d2VlbiBzdGF0ZS5cblx0XHRcdFx0XHRpZiAoaXNUd2VlbmluZygpKSB7XG5cdFx0XHRcdFx0XHRzeW5jWFkodHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRjYWxjdWxhdGVCb3VuZHMoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hcHBseUJvdW5kcygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocm90YXRpb25Nb2RlKSB7XG5cdFx0XHRcdFx0XHRwYXJzZWRPcmlnaW4gPSB0YXJnZXQub3duZXJTVkdFbGVtZW50ID8gW2dzQ2FjaGUueE9yaWdpbiAtIHRhcmdldC5nZXRCQm94KCkueCwgZ3NDYWNoZS55T3JpZ2luIC0gdGFyZ2V0LmdldEJCb3goKS55XSA6IChfZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSB8fCBcIjAgMFwiKS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0XHRyb3RhdGlvbk9yaWdpbiA9IHNlbGYucm90YXRpb25PcmlnaW4gPSBnZXRHbG9iYWxNYXRyaXgodGFyZ2V0KS5hcHBseSh7eDogcGFyc2VGbG9hdChwYXJzZWRPcmlnaW5bMF0pIHx8IDAsIHk6IHBhcnNlRmxvYXQocGFyc2VkT3JpZ2luWzFdKSB8fCAwfSk7XG5cdFx0XHRcdFx0XHRzeW5jWFkodHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR4ID0gc2VsZi5wb2ludGVyWCAtIHJvdGF0aW9uT3JpZ2luLnggLSBvZmZzZXRYO1xuXHRcdFx0XHRcdFx0eSA9IHJvdGF0aW9uT3JpZ2luLnkgLSBzZWxmLnBvaW50ZXJZICsgb2Zmc2V0WTtcblx0XHRcdFx0XHRcdHN0YXJ0RWxlbWVudFggPSBzZWxmLng7IC8vc3RhcnRpbmcgcm90YXRpb24gKHggYWx3YXlzIHJlZmVycyB0byByb3RhdGlvbiBpbiB0eXBlOlwicm90YXRpb25cIiwgbWVhc3VyZWQgaW4gZGVncmVlcylcblx0XHRcdFx0XHRcdHN0YXJ0RWxlbWVudFkgPSBzZWxmLnkgPSBNYXRoLmF0YW4yKHksIHgpICogX1JBRDJERUc7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vcGFyZW50ID0gIWlzRml4ZWQgJiYgdGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0XHRcdFx0XHQvL3N0YXJ0U2Nyb2xsVG9wID0gcGFyZW50ID8gcGFyZW50LnNjcm9sbFRvcCB8fCAwIDogMDtcblx0XHRcdFx0XHRcdC8vc3RhcnRTY3JvbGxMZWZ0ID0gcGFyZW50ID8gcGFyZW50LnNjcm9sbExlZnQgfHwgMCA6IDA7XG5cdFx0XHRcdFx0XHRzdGFydEVsZW1lbnRZID0gZ2V0UHJvcEFzTnVtKHlQcm9wLCBcInB4XCIpOyAvL3JlY29yZCB0aGUgc3RhcnRpbmcgdG9wIGFuZCBsZWZ0IHZhbHVlcyBzbyB0aGF0IHdlIGNhbiBqdXN0IGFkZCB0aGUgbW91c2UncyBtb3ZlbWVudCB0byB0aGVtIGxhdGVyLlxuXHRcdFx0XHRcdFx0c3RhcnRFbGVtZW50WCA9IGdldFByb3BBc051bSh4UHJvcCwgXCJweFwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaGFzQm91bmRzICYmIGVkZ2VUb2xlcmFuY2UpIHtcblx0XHRcdFx0XHRpZiAoc3RhcnRFbGVtZW50WCA+IG1heFgpIHtcblx0XHRcdFx0XHRcdHN0YXJ0RWxlbWVudFggPSBtYXhYICsgKHN0YXJ0RWxlbWVudFggLSBtYXhYKSAvIGVkZ2VUb2xlcmFuY2U7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChzdGFydEVsZW1lbnRYIDwgbWluWCkge1xuXHRcdFx0XHRcdFx0c3RhcnRFbGVtZW50WCA9IG1pblggLSAobWluWCAtIHN0YXJ0RWxlbWVudFgpIC8gZWRnZVRvbGVyYW5jZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFyb3RhdGlvbk1vZGUpIHtcblx0XHRcdFx0XHRcdGlmIChzdGFydEVsZW1lbnRZID4gbWF4WSkge1xuXHRcdFx0XHRcdFx0XHRzdGFydEVsZW1lbnRZID0gbWF4WSArIChzdGFydEVsZW1lbnRZIC0gbWF4WSkgLyBlZGdlVG9sZXJhbmNlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChzdGFydEVsZW1lbnRZIDwgbWluWSkge1xuXHRcdFx0XHRcdFx0XHRzdGFydEVsZW1lbnRZID0gbWluWSAtIChtaW5ZIC0gc3RhcnRFbGVtZW50WSkgLyBlZGdlVG9sZXJhbmNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnN0YXJ0WCA9IHN0YXJ0RWxlbWVudFggPSBfcm91bmQoc3RhcnRFbGVtZW50WCk7XG5cdFx0XHRcdHNlbGYuc3RhcnRZID0gc3RhcnRFbGVtZW50WSA9IF9yb3VuZChzdGFydEVsZW1lbnRZKTtcblx0XHRcdH0sXG5cblx0XHRcdGlzVHdlZW5pbmcgPSAoKSA9PiBzZWxmLnR3ZWVuICYmIHNlbGYudHdlZW4uaXNBY3RpdmUoKSxcblxuXHRcdFx0cmVtb3ZlUGxhY2Vob2xkZXIgPSAoKSA9PiB7XG5cdFx0XHRcdGlmIChfcGxhY2Vob2xkZXJEaXYucGFyZW50Tm9kZSAmJiAhaXNUd2VlbmluZygpICYmICFzZWxmLmlzRHJhZ2dpbmcpIHsgLy9fcGxhY2Vob2xkZXJEaXYganVzdCBwcm9wcyBvcGVuIGF1dG8tc2Nyb2xsaW5nIGNvbnRhaW5lcnMgc28gdGhleSBkb24ndCBjb2xsYXBzZSBhcyB0aGUgdXNlciBkcmFncyBsZWZ0L3VwLiBXZSByZW1vdmUgaXQgYWZ0ZXIgZHJhZ2dpbmcgKGFuZCB0aHJvd2luZywgaWYgbmVjZXNzYXJ5KSBmaW5pc2hlcy5cblx0XHRcdFx0XHRfcGxhY2Vob2xkZXJEaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfcGxhY2Vob2xkZXJEaXYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvL2NhbGxlZCB3aGVuIHRoZSBtb3VzZSBpcyBwcmVzc2VkIChvciB0b3VjaCBzdGFydHMpXG5cdFx0XHRvblByZXNzID0gKGUsIGZvcmNlKSA9PiB7XG5cdFx0XHRcdGxldCBpO1xuXHRcdFx0XHRpZiAoIWVuYWJsZWQgfHwgc2VsZi5pc1ByZXNzZWQgfHwgIWUgfHwgKChlLnR5cGUgPT09IFwibW91c2Vkb3duXCIgfHwgZS50eXBlID09PSBcInBvaW50ZXJkb3duXCIpICYmICFmb3JjZSAmJiBfZ2V0VGltZSgpIC0gY2xpY2tUaW1lIDwgMzAgJiYgX3RvdWNoRXZlbnRMb29rdXBbc2VsZi5wb2ludGVyRXZlbnQudHlwZV0pKSB7IC8vd2hlbiB3ZSBET04nVCBwcmV2ZW50RGVmYXVsdCgpIGluIG9yZGVyIHRvIGFjY29tbW9kYXRlIHRvdWNoLXNjcm9sbGluZyBhbmQgdGhlIHVzZXIganVzdCB0YXBzLCBtYW55IGJyb3dzZXJzIGFsc28gZmlyZSBhIG1vdXNlZG93bi9tb3VzZXVwIHNlcXVlbmNlIEFGVEVSIHRoZSB0b3VjaHN0YXJ0L3RvdWNoZW5kIHNlcXVlbmNlLCB0aHVzIGl0J2QgcmVzdWx0IGluIHR3byBxdWljayBcImNsaWNrXCIgZXZlbnRzIGJlaW5nIGRpc3BhdGNoZWQuIFRoaXMgbGluZSBzZW5zZXMgdGhhdCBjb25kaXRpb24gYW5kIGhhbHRzIGl0IG9uIHRoZSBzdWJzZXF1ZW50IG1vdXNlZG93bi5cblx0XHRcdFx0XHRpc1ByZXZlbnRpbmdEZWZhdWx0ICYmIGUgJiYgZW5hYmxlZCAmJiBfcHJldmVudERlZmF1bHQoZSk7IC8vIGluIHNvbWUgYnJvd3NlcnMsIHdlIG11c3QgbGlzdGVuIGZvciBtdWx0aXBsZSBldmVudCB0eXBlcyBsaWtlIHRvdWNoc3RhcnQsIHBvaW50ZXJkb3duLCBtb3VzZWRvd24uIFRoZSBmaXJzdCB0aW1lIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLCB3ZSByZWNvcmQgd2hldGhlciBvciBub3Qgd2UgX3ByZXZlbnREZWZhdWx0KCkgc28gdGhhdCBvbiBkdXBsaWNhdGUgY2FsbHMsIHdlIGNhbiBkbyB0aGUgc2FtZSBpZiBuZWNlc3NhcnkuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGludGVycnVwdGVkID0gaXNUd2VlbmluZygpO1xuXHRcdFx0XHRzZWxmLnBvaW50ZXJFdmVudCA9IGU7XG5cdFx0XHRcdGlmIChfdG91Y2hFdmVudExvb2t1cFtlLnR5cGVdKSB7IC8vbm90ZTogb24gaU9TLCBCT1RIIHRvdWNobW92ZSBhbmQgbW91c2Vtb3ZlIGFyZSBkaXNwYXRjaGVkLCBidXQgdGhlIG1vdXNlbW92ZSBoYXMgcGFnZVkgYW5kIHBhZ2VYIG9mIDAgd2hpY2ggd291bGQgbWVzcyB1cCB0aGUgY2FsY3VsYXRpb25zIGFuZCBuZWVkbGVzc2x5IGh1cnQgcGVyZm9ybWFuY2UuXG5cdFx0XHRcdFx0dG91Y2hFdmVudFRhcmdldCA9IH5lLnR5cGUuaW5kZXhPZihcInRvdWNoXCIpID8gKGUuY3VycmVudFRhcmdldCB8fCBlLnRhcmdldCkgOiBvd25lckRvYzsgLy9wb2ludGVyLWJhc2VkIHRvdWNoZXMgKGZvciBNaWNyb3NvZnQgYnJvd3NlcnMpIGRvbid0IHJlbWFpbiBsb2NrZWQgdG8gdGhlIG9yaWdpbmFsIHRhcmdldCBsaWtlIG90aGVyIGJyb3dzZXJzLCBzbyB3ZSBtdXN0IHVzZSB0aGUgZG9jdW1lbnQgaW5zdGVhZC4gVGhlIGV2ZW50IHR5cGUgd291bGQgYmUgXCJNU1BvaW50ZXJEb3duXCIgb3IgXCJwb2ludGVyZG93blwiLlxuXHRcdFx0XHRcdF9hZGRMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNoZW5kXCIsIG9uUmVsZWFzZSk7XG5cdFx0XHRcdFx0X2FkZExpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2htb3ZlXCIsIG9uTW92ZSk7XG5cdFx0XHRcdFx0X2FkZExpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2hjYW5jZWxcIiwgb25SZWxlYXNlKTtcblx0XHRcdFx0XHRfYWRkTGlzdGVuZXIob3duZXJEb2MsIFwidG91Y2hzdGFydFwiLCBfb25NdWx0aVRvdWNoRG9jdW1lbnQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRvdWNoRXZlbnRUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHRcdF9hZGRMaXN0ZW5lcihvd25lckRvYywgXCJtb3VzZW1vdmVcIiwgb25Nb3ZlKTsgLy9hdHRhY2ggdGhlc2UgdG8gdGhlIGRvY3VtZW50IGluc3RlYWQgb2YgdGhlIGJveCBpdHNlbGYgc28gdGhhdCBpZiB0aGUgdXNlcidzIG1vdXNlIG1vdmVzIHRvbyBxdWlja2x5IChhbmQgb2ZmIG9mIHRoZSBib3gpLCB0aGluZ3Mgc3RpbGwgd29yay5cblx0XHRcdFx0fVxuXHRcdFx0XHR0b3VjaERyYWdBeGlzID0gbnVsbDtcblx0XHRcdFx0aWYgKCFfc3VwcG9ydHNQb2ludGVyICB8fCAhdG91Y2hFdmVudFRhcmdldCkge1xuXHRcdFx0XHRcdF9hZGRMaXN0ZW5lcihvd25lckRvYywgXCJtb3VzZXVwXCIsIG9uUmVsZWFzZSk7XG5cdFx0XHRcdFx0ZSAmJiBlLnRhcmdldCAmJiBfYWRkTGlzdGVuZXIoZS50YXJnZXQsIFwibW91c2V1cFwiLCBvblJlbGVhc2UpOyAvL3dlIGFsc28gaGF2ZSB0byBsaXN0ZW4gZGlyZWN0bHkgb24gdGhlIGVsZW1lbnQgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGRvbid0IGJ1YmJsZSB1cCB0aGUgZXZlbnQgdG8gdGhlIF9kb2Mgb24gZWxlbWVudHMgd2l0aCBjb250ZW50RWRpdGFibGU9XCJ0cnVlXCJcblx0XHRcdFx0fVxuXHRcdFx0XHRpc0NsaWNraW5nID0gKGlzQ2xpY2thYmxlLmNhbGwoc2VsZiwgZS50YXJnZXQpICYmIHZhcnMuZHJhZ0NsaWNrYWJsZXMgPT09IGZhbHNlICYmICFmb3JjZSk7XG5cdFx0XHRcdGlmIChpc0NsaWNraW5nKSB7XG5cdFx0XHRcdFx0X2FkZExpc3RlbmVyKGUudGFyZ2V0LCBcImNoYW5nZVwiLCBvblJlbGVhc2UpOyAvL2luIHNvbWUgYnJvd3NlcnMsIHdoZW4geW91IG1vdXNlZG93biBvbiBhIDxzZWxlY3Q+IGVsZW1lbnQsIG5vIG1vdXNldXAgZ2V0cyBkaXNwYXRjaGVkISBTbyB3ZSBsaXN0ZW4gZm9yIGEgXCJjaGFuZ2VcIiBldmVudCBpbnN0ZWFkLlxuXHRcdFx0XHRcdF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwicHJlc3NJbml0XCIsIFwib25QcmVzc0luaXRcIik7XG5cdFx0XHRcdFx0X2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJwcmVzc1wiLCBcIm9uUHJlc3NcIik7XG5cdFx0XHRcdFx0X3NldFNlbGVjdGFibGUodHJpZ2dlcnMsIHRydWUpOyAvL2FjY29tbW9kYXRlcyB0aGluZ3MgbGlrZSBpbnB1dHMgYW5kIGVsZW1lbnRzIHdpdGggY29udGVudEVkaXRhYmxlPVwidHJ1ZVwiIChvdGhlcndpc2UgdXNlciBjb3VsZG4ndCBkcmFnIHRvIHNlbGVjdCB0ZXh0KVxuXHRcdFx0XHRcdGlzUHJldmVudGluZ0RlZmF1bHQgPSBmYWxzZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0YWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyA9ICghdG91Y2hFdmVudFRhcmdldCB8fCBhbGxvd1ggPT09IGFsbG93WSB8fCBzZWxmLnZhcnMuYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyA9PT0gZmFsc2UgfHwgKHNlbGYudmFycy5hbGxvd0NvbnRleHRNZW51ICYmIGUgJiYgKGUuY3RybEtleSB8fCBlLndoaWNoID4gMikpKSA/IGZhbHNlIDogYWxsb3dYID8gXCJ5XCIgOiBcInhcIjsgLy9ub3RlOiBpbiBDaHJvbWUsIHJpZ2h0LWNsaWNraW5nIChmb3IgYSBjb250ZXh0IG1lbnUpIGZpcmVzIG9uUHJlc3MgYW5kIGl0IGRvZXNuJ3QgaGF2ZSB0aGUgZXZlbnQud2hpY2ggc2V0IHByb3Blcmx5LCBzbyB3ZSBtdXN0IGxvb2sgZm9yIGV2ZW50LmN0cmxLZXkuIElmIHRoZSB1c2VyIHdhbnRzIHRvIGFsbG93IGNvbnRleHQgbWVudXMgd2Ugc2hvdWxkIG9mIGNvdXJzZSBzZW5zZSBpdCBoZXJlIGFuZCBub3QgYWxsb3cgbmF0aXZlIHRvdWNoIHNjcm9sbGluZy5cblx0XHRcdFx0aXNQcmV2ZW50aW5nRGVmYXVsdCA9ICFhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nICYmICFzZWxmLmFsbG93RXZlbnREZWZhdWx0O1xuXHRcdFx0XHRpZiAoaXNQcmV2ZW50aW5nRGVmYXVsdCkge1xuXHRcdFx0XHRcdF9wcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdFx0XHRfYWRkTGlzdGVuZXIoX3dpbiwgXCJ0b3VjaGZvcmNlY2hhbmdlXCIsIF9wcmV2ZW50RGVmYXVsdCk7IC8vd29ya3MgYXJvdW5kIHNhZmFyaSBidWc6IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjE0NTAtZHJhZ2dhYmxlLWluLWlmcmFtZS1vbi1tb2JpbGUtaXMtYnVnZ3kvXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGUuY2hhbmdlZFRvdWNoZXMpIHsgLy90b3VjaCBldmVudHMgc3RvcmUgdGhlIGRhdGEgc2xpZ2h0bHkgZGlmZmVyZW50bHlcblx0XHRcdFx0XHRlID0gdG91Y2ggPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuXHRcdFx0XHRcdHRvdWNoSUQgPSBlLmlkZW50aWZpZXI7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZS5wb2ludGVySWQpIHtcblx0XHRcdFx0XHR0b3VjaElEID0gZS5wb2ludGVySWQ7IC8vZm9yIHNvbWUgTWljcm9zb2Z0IGJyb3dzZXJzXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG91Y2ggPSB0b3VjaElEID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRfZHJhZ0NvdW50Kys7XG5cdFx0XHRcdF9hZGRUb1JlbmRlclF1ZXVlKHJlbmRlcik7IC8vY2F1c2VzIHRoZSBEcmFnZ2FibGUgdG8gcmVuZGVyIG9uIGVhY2ggXCJ0aWNrXCIgb2YgVHdlZW5MaXRlLnRpY2tlciAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIC0gdXBkYXRpbmcgdmFsdWVzIGluIGEgbW91c2Vtb3ZlIGNhbiBjYXVzZSB0aGVtIHRvIGhhcHBlbiB0b28gZnJlcXVlbnRseSwgbGlrZSBtdWx0aXBsZSB0aW1lcyBiZXR3ZWVuIGZyYW1lIHJlZHJhd3Mgd2hpY2ggaXMgd2FzdGVmdWwsIGFuZCBpdCBhbHNvIHByZXZlbnRzIHZhbHVlcyBmcm9tIHVwZGF0aW5nIHByb3Blcmx5IGluIElFOClcblx0XHRcdFx0c3RhcnRQb2ludGVyWSA9IHNlbGYucG9pbnRlclkgPSBlLnBhZ2VZOyAvL3JlY29yZCB0aGUgc3RhcnRpbmcgeCBhbmQgeSBzbyB0aGF0IHdlIGNhbiBjYWxjdWxhdGUgdGhlIG1vdmVtZW50IGZyb20gdGhlIG9yaWdpbmFsIGluIF9vbk1vdXNlTW92ZVxuXHRcdFx0XHRzdGFydFBvaW50ZXJYID0gc2VsZi5wb2ludGVyWCA9IGUucGFnZVg7XG5cdFx0XHRcdF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwicHJlc3NJbml0XCIsIFwib25QcmVzc0luaXRcIik7XG5cdFx0XHRcdGlmIChhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nIHx8IHNlbGYuYXV0b1Njcm9sbCkge1xuXHRcdFx0XHRcdF9yZWNvcmRNYXhTY3JvbGxzKHRhcmdldC5wYXJlbnROb2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGFyZ2V0LnBhcmVudE5vZGUgJiYgc2VsZi5hdXRvU2Nyb2xsICYmICFzY3JvbGxQcm94eSAmJiAhcm90YXRpb25Nb2RlICYmIHRhcmdldC5wYXJlbnROb2RlLl9nc01heFNjcm9sbFggJiYgIV9wbGFjZWhvbGRlckRpdi5wYXJlbnROb2RlICYmICF0YXJnZXQuZ2V0QkJveCkgeyAvL2FkZCBhIHBsYWNlaG9sZGVyIGRpdiB0byBwcmV2ZW50IHRoZSBwYXJlbnQgY29udGFpbmVyIGZyb20gY29sbGFwc2luZyB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBlbGVtZW50IGxlZnQuXG5cdFx0XHRcdFx0X3BsYWNlaG9sZGVyRGl2LnN0eWxlLndpZHRoID0gdGFyZ2V0LnBhcmVudE5vZGUuc2Nyb2xsV2lkdGggKyBcInB4XCI7XG5cdFx0XHRcdFx0dGFyZ2V0LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoX3BsYWNlaG9sZGVyRGl2KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZWNvcmRTdGFydFBvc2l0aW9ucygpO1xuXHRcdFx0XHRzZWxmLnR3ZWVuICYmIHNlbGYudHdlZW4ua2lsbCgpO1xuXHRcdFx0XHRzZWxmLmlzVGhyb3dpbmcgPSBmYWxzZTtcblx0XHRcdFx0Z3NhcC5raWxsVHdlZW5zT2Yoc2Nyb2xsUHJveHkgfHwgdGFyZ2V0LCBraWxsUHJvcHMsIHRydWUpOyAvL2luIGNhc2UgdGhlIHVzZXIgdHJpZXMgdG8gZHJhZyBpdCBiZWZvcmUgdGhlIGxhc3QgdHdlZW4gaXMgZG9uZS5cblx0XHRcdFx0c2Nyb2xsUHJveHkgJiYgZ3NhcC5raWxsVHdlZW5zT2YodGFyZ2V0LCB7c2Nyb2xsVG86MX0sIHRydWUpOyAvL2p1c3QgaW4gY2FzZSB0aGUgb3JpZ2luYWwgdGFyZ2V0J3Mgc2Nyb2xsIHBvc2l0aW9uIGlzIGJlaW5nIHR3ZWVuZWQgc29tZXdoZXJlIGVsc2UuXG5cdFx0XHRcdHNlbGYudHdlZW4gPSBzZWxmLmxvY2tlZEF4aXMgPSBudWxsO1xuXHRcdFx0XHRpZiAodmFycy56SW5kZXhCb29zdCB8fCAoIXJvdGF0aW9uTW9kZSAmJiAhc2Nyb2xsUHJveHkgJiYgdmFycy56SW5kZXhCb29zdCAhPT0gZmFsc2UpKSB7XG5cdFx0XHRcdFx0dGFyZ2V0LnN0eWxlLnpJbmRleCA9IERyYWdnYWJsZS56SW5kZXgrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLmlzUHJlc3NlZCA9IHRydWU7XG5cdFx0XHRcdGhhc0RyYWdDYWxsYmFjayA9ICEhKHZhcnMub25EcmFnIHx8IHNlbGYuX2xpc3RlbmVycy5kcmFnKTtcblx0XHRcdFx0aGFzTW92ZUNhbGxiYWNrID0gISEodmFycy5vbk1vdmUgfHwgc2VsZi5fbGlzdGVuZXJzLm1vdmUpO1xuXHRcdFx0XHRpZiAodmFycy5jdXJzb3IgIT09IGZhbHNlIHx8IHZhcnMuYWN0aXZlQ3Vyc29yKSB7XG5cdFx0XHRcdFx0aSA9IHRyaWdnZXJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGdzYXAuc2V0KHRyaWdnZXJzW2ldLCB7Y3Vyc29yOiB2YXJzLmFjdGl2ZUN1cnNvciB8fCB2YXJzLmN1cnNvciB8fCAoX2RlZmF1bHRDdXJzb3IgPT09IFwiZ3JhYlwiID8gXCJncmFiYmluZ1wiIDogX2RlZmF1bHRDdXJzb3IpfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwicHJlc3NcIiwgXCJvblByZXNzXCIpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly9jYWxsZWQgZXZlcnkgdGltZSB0aGUgbW91c2UvdG91Y2ggbW92ZXNcblx0XHRcdG9uTW92ZSA9IGUgPT4ge1xuXHRcdFx0XHRsZXQgb3JpZ2luYWxFdmVudCA9IGUsXG5cdFx0XHRcdFx0dG91Y2hlcywgcG9pbnRlclgsIHBvaW50ZXJZLCBpLCBkeCwgZHk7XG5cdFx0XHRcdGlmICghZW5hYmxlZCB8fCBfaXNNdWx0aVRvdWNoaW5nIHx8ICFzZWxmLmlzUHJlc3NlZCB8fCAhZSkge1xuXHRcdFx0XHRcdGlzUHJldmVudGluZ0RlZmF1bHQgJiYgZSAmJiBlbmFibGVkICYmIF9wcmV2ZW50RGVmYXVsdChlKTsgLy8gaW4gc29tZSBicm93c2Vycywgd2UgbXVzdCBsaXN0ZW4gZm9yIG11bHRpcGxlIGV2ZW50IHR5cGVzIGxpa2UgdG91Y2htb3ZlLCBwb2ludGVybW92ZSwgbW91c2Vtb3ZlLiBUaGUgZmlyc3QgdGltZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCwgd2UgcmVjb3JkIHdoZXRoZXIgb3Igbm90IHdlIF9wcmV2ZW50RGVmYXVsdCgpIHNvIHRoYXQgb24gZHVwbGljYXRlIGNhbGxzLCB3ZSBjYW4gZG8gdGhlIHNhbWUgaWYgbmVjZXNzYXJ5LlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnBvaW50ZXJFdmVudCA9IGU7XG5cdFx0XHRcdHRvdWNoZXMgPSBlLmNoYW5nZWRUb3VjaGVzO1xuXHRcdFx0XHRpZiAodG91Y2hlcykgeyAvL3RvdWNoIGV2ZW50cyBzdG9yZSB0aGUgZGF0YSBzbGlnaHRseSBkaWZmZXJlbnRseVxuXHRcdFx0XHRcdGUgPSB0b3VjaGVzWzBdO1xuXHRcdFx0XHRcdGlmIChlICE9PSB0b3VjaCAmJiBlLmlkZW50aWZpZXIgIT09IHRvdWNoSUQpIHsgLy9Vc3VhbGx5IGNoYW5nZWRUb3VjaGVzWzBdIHdpbGwgYmUgd2hhdCB3ZSdyZSBsb29raW5nIGZvciwgYnV0IGluIGNhc2UgaXQncyBub3QsIGxvb2sgdGhyb3VnaCB0aGUgcmVzdCBvZiB0aGUgYXJyYXkuLi4oYW5kIEFuZHJvaWQgYnJvd3NlcnMgZG9uJ3QgcmV1c2UgdGhlIGV2ZW50IGxpa2UgaU9TKVxuXHRcdFx0XHRcdFx0aSA9IHRvdWNoZXMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xICYmIChlID0gdG91Y2hlc1tpXSkuaWRlbnRpZmllciAhPT0gdG91Y2hJRCAmJiBlLnRhcmdldCAhPT0gdGFyZ2V0KSB7fSAvLyBTb21lIEFuZHJvaWQgZGV2aWNlcyBkaXNwYXRjaCBhIHRvdWNoc3RhcnQgQU5EIHBvaW50ZXJkb3duIGluaXRpYWxseSwgYW5kIHRoZW4gb25seSBwb2ludGVybW92ZSB0aHVzIHRoZSB0b3VjaElEIG1heSBub3QgbWF0Y2ggYmVjYXVzZSBpdCB3YXMgZ3JhYmJlZCBmcm9tIHRoZSB0b3VjaHN0YXJ0IGV2ZW50IHdoZXJlYXMgdGhlIHBvaW50ZXIgZXZlbnQgaXMgdGhlIG9uZSB0aGF0IHRoZSBicm93c2VyIGRpc3BhdGNoZXMgZm9yIG1vdmUsIHNvIGlmIHRoZSBldmVudCB0YXJnZXQgbWF0Y2hlcyB0aGlzIERyYWdnYWJsZSdzIHRhcmdldCwgbGV0IGl0IHRocm91Z2guXG5cdFx0XHRcdFx0XHRpZiAoaSA8IDApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChlLnBvaW50ZXJJZCAmJiB0b3VjaElEICYmIGUucG9pbnRlcklkICE9PSB0b3VjaElEKSB7IC8vZm9yIHNvbWUgTWljcm9zb2Z0IGJyb3dzZXJzLCB3ZSBtdXN0IGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8gdGhlIGRvYyByYXRoZXIgdGhhbiB0aGUgdHJpZ2dlciBzbyB0aGF0IHdoZW4gdGhlIGZpbmdlciBtb3ZlcyBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlIHRyaWdnZXIsIHRoaW5ncyBzdGlsbCB3b3JrLiBTbyBpZiB0aGUgZXZlbnQgd2UncmUgcmVjZWl2aW5nIGhhcyBhIHBvaW50ZXJJZCB0aGF0IGRvZXNuJ3QgbWF0Y2ggdGhlIHRvdWNoSUQsIGlnbm9yZSBpdCAoZm9yIG11bHRpLXRvdWNoKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0b3VjaEV2ZW50VGFyZ2V0ICYmIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgJiYgIXRvdWNoRHJhZ0F4aXMpIHsgLy9BbmRyb2lkIGJyb3dzZXJzIGZvcmNlIHVzIHRvIGRlY2lkZSBvbiB0aGUgZmlyc3QgXCJ0b3VjaG1vdmVcIiBldmVudCBpZiB3ZSBzaG91bGQgYWxsb3cgdGhlIGRlZmF1bHQgKHNjcm9sbGluZykgYmVoYXZpb3Igb3IgcHJldmVudERlZmF1bHQoKS4gT3RoZXJ3aXNlLCBhIFwidG91Y2hjYW5jZWxcIiB3aWxsIGJlIGZpcmVkIGFuZCB0aGVuIG5vIFwidG91Y2htb3ZlXCIgb3IgXCJ0b3VjaGVuZFwiIHdpbGwgZmlyZSBkdXJpbmcgdGhlIHNjcm9sbGluZyAobm8gZ29vZCkuXG5cdFx0XHRcdFx0X3BvaW50MS54ID0gZS5wYWdlWCAtIChpc0ZpeGVkID8gX2dldERvY1Njcm9sbExlZnQob3duZXJEb2MpIDogMCk7XG5cdFx0XHRcdFx0X3BvaW50MS55ID0gZS5wYWdlWSAtIChpc0ZpeGVkID8gX2dldERvY1Njcm9sbFRvcChvd25lckRvYykgOiAwKTtcblx0XHRcdFx0XHRtYXRyaXggJiYgbWF0cml4LmFwcGx5KF9wb2ludDEsIF9wb2ludDEpO1xuXHRcdFx0XHRcdHBvaW50ZXJYID0gX3BvaW50MS54O1xuXHRcdFx0XHRcdHBvaW50ZXJZID0gX3BvaW50MS55O1xuXHRcdFx0XHRcdGR4ID0gTWF0aC5hYnMocG9pbnRlclggLSBzdGFydFBvaW50ZXJYKTtcblx0XHRcdFx0XHRkeSA9IE1hdGguYWJzKHBvaW50ZXJZIC0gc3RhcnRQb2ludGVyWSk7XG5cdFx0XHRcdFx0aWYgKChkeCAhPT0gZHkgJiYgKGR4ID4gbWluaW11bU1vdmVtZW50IHx8IGR5ID4gbWluaW11bU1vdmVtZW50KSkgfHwgKF9pc0FuZHJvaWQgJiYgYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyA9PT0gdG91Y2hEcmFnQXhpcykpIHtcblx0XHRcdFx0XHRcdHRvdWNoRHJhZ0F4aXMgPSAoZHggPiBkeSAmJiBhbGxvd1gpID8gXCJ4XCIgOiBcInlcIjtcblx0XHRcdFx0XHRcdGlmIChhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nICYmIHRvdWNoRHJhZ0F4aXMgIT09IGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcpIHtcblx0XHRcdFx0XHRcdFx0X2FkZExpc3RlbmVyKF93aW4sIFwidG91Y2hmb3JjZWNoYW5nZVwiLCBfcHJldmVudERlZmF1bHQpOyAvLyBwcmV2ZW50cyBuYXRpdmUgdG91Y2ggc2Nyb2xsaW5nIGZyb20gdGFraW5nIG92ZXIgaWYgdGhlIHVzZXIgc3RhcnRlZCBkcmFnZ2luZyBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uIGluIGlPUyBTYWZhcmlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChzZWxmLnZhcnMubG9ja0F4aXNPblRvdWNoU2Nyb2xsICE9PSBmYWxzZSAmJiBhbGxvd1ggJiYgYWxsb3dZKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYubG9ja2VkQXhpcyA9ICh0b3VjaERyYWdBeGlzID09PSBcInhcIikgPyBcInlcIiA6IFwieFwiO1xuXHRcdFx0XHRcdFx0XHRfaXNGdW5jdGlvbihzZWxmLnZhcnMub25Mb2NrQXhpcykgJiYgc2VsZi52YXJzLm9uTG9ja0F4aXMuY2FsbChzZWxmLCBvcmlnaW5hbEV2ZW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChfaXNBbmRyb2lkICYmIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgPT09IHRvdWNoRHJhZ0F4aXMpIHtcblx0XHRcdFx0XHRcdFx0b25SZWxlYXNlKG9yaWdpbmFsRXZlbnQpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc2VsZi5hbGxvd0V2ZW50RGVmYXVsdCAmJiAoIWFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgfHwgKHRvdWNoRHJhZ0F4aXMgJiYgYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyAhPT0gdG91Y2hEcmFnQXhpcykpICYmIG9yaWdpbmFsRXZlbnQuY2FuY2VsYWJsZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRfcHJldmVudERlZmF1bHQob3JpZ2luYWxFdmVudCk7XG5cdFx0XHRcdFx0aXNQcmV2ZW50aW5nRGVmYXVsdCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNQcmV2ZW50aW5nRGVmYXVsdCkge1xuXHRcdFx0XHRcdGlzUHJldmVudGluZ0RlZmF1bHQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChzZWxmLmF1dG9TY3JvbGwpIHtcblx0XHRcdFx0XHRjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNldFBvaW50ZXJQb3NpdGlvbihlLnBhZ2VYLCBlLnBhZ2VZLCBoYXNNb3ZlQ2FsbGJhY2spO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0UG9pbnRlclBvc2l0aW9uID0gKHBvaW50ZXJYLCBwb2ludGVyWSwgaW52b2tlT25Nb3ZlKSA9PiB7XG5cdFx0XHRcdGxldCBkcmFnVG9sZXJhbmNlID0gMSAtIHNlbGYuZHJhZ1Jlc2lzdGFuY2UsXG5cdFx0XHRcdFx0ZWRnZVRvbGVyYW5jZSA9IDEgLSBzZWxmLmVkZ2VSZXNpc3RhbmNlLFxuXHRcdFx0XHRcdHByZXZQb2ludGVyWCA9IHNlbGYucG9pbnRlclgsXG5cdFx0XHRcdFx0cHJldlBvaW50ZXJZID0gc2VsZi5wb2ludGVyWSxcblx0XHRcdFx0XHRwcmV2U3RhcnRFbGVtZW50WSA9IHN0YXJ0RWxlbWVudFksXG5cdFx0XHRcdFx0cHJldlggPSBzZWxmLngsXG5cdFx0XHRcdFx0cHJldlkgPSBzZWxmLnksXG5cdFx0XHRcdFx0cHJldkVuZFggPSBzZWxmLmVuZFgsXG5cdFx0XHRcdFx0cHJldkVuZFkgPSBzZWxmLmVuZFksXG5cdFx0XHRcdFx0cHJldkVuZFJvdGF0aW9uID0gc2VsZi5lbmRSb3RhdGlvbixcblx0XHRcdFx0XHRwcmV2RGlydHkgPSBkaXJ0eSxcblx0XHRcdFx0XHR4Q2hhbmdlLCB5Q2hhbmdlLCB4LCB5LCBkaWYsIHRlbXA7XG5cdFx0XHRcdHNlbGYucG9pbnRlclggPSBwb2ludGVyWDtcblx0XHRcdFx0c2VsZi5wb2ludGVyWSA9IHBvaW50ZXJZO1xuXHRcdFx0XHRpZiAoaXNGaXhlZCkge1xuXHRcdFx0XHRcdHBvaW50ZXJYIC09IF9nZXREb2NTY3JvbGxMZWZ0KG93bmVyRG9jKTtcblx0XHRcdFx0XHRwb2ludGVyWSAtPSBfZ2V0RG9jU2Nyb2xsVG9wKG93bmVyRG9jKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocm90YXRpb25Nb2RlKSB7XG5cdFx0XHRcdFx0eSA9IE1hdGguYXRhbjIocm90YXRpb25PcmlnaW4ueSAtIHBvaW50ZXJZLCBwb2ludGVyWCAtIHJvdGF0aW9uT3JpZ2luLngpICogX1JBRDJERUc7XG5cdFx0XHRcdFx0ZGlmID0gc2VsZi55IC0geTtcblx0XHRcdFx0XHRpZiAoZGlmID4gMTgwKSB7XG5cdFx0XHRcdFx0XHRzdGFydEVsZW1lbnRZIC09IDM2MDtcblx0XHRcdFx0XHRcdHNlbGYueSA9IHk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChkaWYgPCAtMTgwKSB7XG5cdFx0XHRcdFx0XHRzdGFydEVsZW1lbnRZICs9IDM2MDtcblx0XHRcdFx0XHRcdHNlbGYueSA9IHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzZWxmLnggIT09IHN0YXJ0RWxlbWVudFggfHwgTWF0aC5hYnMoc3RhcnRFbGVtZW50WSAtIHkpID4gbWluaW11bU1vdmVtZW50KSB7XG5cdFx0XHRcdFx0XHRzZWxmLnkgPSB5O1xuXHRcdFx0XHRcdFx0eCA9IHN0YXJ0RWxlbWVudFggKyAoc3RhcnRFbGVtZW50WSAtIHkpICogZHJhZ1RvbGVyYW5jZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0eCA9IHN0YXJ0RWxlbWVudFg7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRcdFx0dGVtcCA9IHBvaW50ZXJYICogbWF0cml4LmEgKyBwb2ludGVyWSAqIG1hdHJpeC5jICsgbWF0cml4LmU7XG5cdFx0XHRcdFx0XHRwb2ludGVyWSA9IHBvaW50ZXJYICogbWF0cml4LmIgKyBwb2ludGVyWSAqIG1hdHJpeC5kICsgbWF0cml4LmY7XG5cdFx0XHRcdFx0XHRwb2ludGVyWCA9IHRlbXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHlDaGFuZ2UgPSAocG9pbnRlclkgLSBzdGFydFBvaW50ZXJZKTtcblx0XHRcdFx0XHR4Q2hhbmdlID0gKHBvaW50ZXJYIC0gc3RhcnRQb2ludGVyWCk7XG5cdFx0XHRcdFx0aWYgKHlDaGFuZ2UgPCBtaW5pbXVtTW92ZW1lbnQgJiYgeUNoYW5nZSA+IC1taW5pbXVtTW92ZW1lbnQpIHtcblx0XHRcdFx0XHRcdHlDaGFuZ2UgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoeENoYW5nZSA8IG1pbmltdW1Nb3ZlbWVudCAmJiB4Q2hhbmdlID4gLW1pbmltdW1Nb3ZlbWVudCkge1xuXHRcdFx0XHRcdFx0eENoYW5nZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgoc2VsZi5sb2NrQXhpcyB8fCBzZWxmLmxvY2tlZEF4aXMpICYmICh4Q2hhbmdlIHx8IHlDaGFuZ2UpKSB7XG5cdFx0XHRcdFx0XHR0ZW1wID0gc2VsZi5sb2NrZWRBeGlzO1xuXHRcdFx0XHRcdFx0aWYgKCF0ZW1wKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYubG9ja2VkQXhpcyA9IHRlbXAgPSAoYWxsb3dYICYmIE1hdGguYWJzKHhDaGFuZ2UpID4gTWF0aC5hYnMoeUNoYW5nZSkpID8gXCJ5XCIgOiBhbGxvd1kgPyBcInhcIiA6IG51bGw7XG5cdFx0XHRcdFx0XHRcdGlmICh0ZW1wICYmIF9pc0Z1bmN0aW9uKHNlbGYudmFycy5vbkxvY2tBeGlzKSkge1xuXHRcdFx0XHRcdFx0XHRcdHNlbGYudmFycy5vbkxvY2tBeGlzLmNhbGwoc2VsZiwgc2VsZi5wb2ludGVyRXZlbnQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodGVtcCA9PT0gXCJ5XCIpIHtcblx0XHRcdFx0XHRcdFx0eUNoYW5nZSA9IDA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRlbXAgPT09IFwieFwiKSB7XG5cdFx0XHRcdFx0XHRcdHhDaGFuZ2UgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR4ID0gX3JvdW5kKHN0YXJ0RWxlbWVudFggKyB4Q2hhbmdlICogZHJhZ1RvbGVyYW5jZSk7XG5cdFx0XHRcdFx0eSA9IF9yb3VuZChzdGFydEVsZW1lbnRZICsgeUNoYW5nZSAqIGRyYWdUb2xlcmFuY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKChzbmFwWCB8fCBzbmFwWSB8fCBzbmFwWFkpICYmIChzZWxmLnggIT09IHggfHwgKHNlbGYueSAhPT0geSAmJiAhcm90YXRpb25Nb2RlKSkpIHtcblx0XHRcdFx0XHRpZiAoc25hcFhZKSB7XG5cdFx0XHRcdFx0XHRfdGVtcDEueCA9IHg7XG5cdFx0XHRcdFx0XHRfdGVtcDEueSA9IHk7XG5cdFx0XHRcdFx0XHR0ZW1wID0gc25hcFhZKF90ZW1wMSk7XG5cdFx0XHRcdFx0XHR4ID0gX3JvdW5kKHRlbXAueCk7XG5cdFx0XHRcdFx0XHR5ID0gX3JvdW5kKHRlbXAueSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzbmFwWCkge1xuXHRcdFx0XHRcdFx0eCA9IF9yb3VuZChzbmFwWCh4KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzbmFwWSkge1xuXHRcdFx0XHRcdFx0eSA9IF9yb3VuZChzbmFwWSh5KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGhhc0JvdW5kcykge1xuXHRcdFx0XHRcdGlmICh4ID4gbWF4WCkge1xuXHRcdFx0XHRcdFx0eCA9IG1heFggKyBNYXRoLnJvdW5kKCh4IC0gbWF4WCkgKiBlZGdlVG9sZXJhbmNlKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHggPCBtaW5YKSB7XG5cdFx0XHRcdFx0XHR4ID0gbWluWCArIE1hdGgucm91bmQoKHggLSBtaW5YKSAqIGVkZ2VUb2xlcmFuY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIXJvdGF0aW9uTW9kZSkge1xuXHRcdFx0XHRcdFx0aWYgKHkgPiBtYXhZKSB7XG5cdFx0XHRcdFx0XHRcdHkgPSBNYXRoLnJvdW5kKG1heFkgKyAoeSAtIG1heFkpICogZWRnZVRvbGVyYW5jZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHkgPCBtaW5ZKSB7XG5cdFx0XHRcdFx0XHRcdHkgPSBNYXRoLnJvdW5kKG1pblkgKyAoeSAtIG1pblkpICogZWRnZVRvbGVyYW5jZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzZWxmLnggIT09IHggfHwgKHNlbGYueSAhPT0geSAmJiAhcm90YXRpb25Nb2RlKSkge1xuXHRcdFx0XHRcdGlmIChyb3RhdGlvbk1vZGUpIHtcblx0XHRcdFx0XHRcdHNlbGYuZW5kUm90YXRpb24gPSBzZWxmLnggPSBzZWxmLmVuZFggPSB4O1xuXHRcdFx0XHRcdFx0ZGlydHkgPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoYWxsb3dZKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYueSA9IHNlbGYuZW5kWSA9IHk7XG5cdFx0XHRcdFx0XHRcdGRpcnR5ID0gdHJ1ZTsgLy9hIGZsYWcgdGhhdCBpbmRpY2F0ZXMgd2UgbmVlZCB0byByZW5kZXIgdGhlIHRhcmdldCBuZXh0IHRpbWUgdGhlIFR3ZWVuTGl0ZS50aWNrZXIgZGlzcGF0Y2hlcyBhIFwidGlja1wiIGV2ZW50ICh0eXBpY2FsbHkgb24gYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIC0gdGhpcyBpcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiAod2Ugc2hvdWxkbid0IHJlbmRlciBvbiBldmVyeSBtb3ZlIGJlY2F1c2Ugc29tZXRpbWVzIG1hbnkgbW92ZSBldmVudHMgY2FuIGdldCBkaXNwYXRjaGVkIGJldHdlZW4gc2NyZWVuIHJlZnJlc2hlcywgYW5kIHRoYXQnZCBiZSB3YXN0ZWZ1bCB0byByZW5kZXIgZXZlcnkgdGltZSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChhbGxvd1gpIHtcblx0XHRcdFx0XHRcdFx0c2VsZi54ID0gc2VsZi5lbmRYID0geDtcblx0XHRcdFx0XHRcdFx0ZGlydHkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIWludm9rZU9uTW92ZSB8fCBfZGlzcGF0Y2hFdmVudChzZWxmLCBcIm1vdmVcIiwgXCJvbk1vdmVcIikgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNlbGYuaXNEcmFnZ2luZyAmJiBzZWxmLmlzUHJlc3NlZCkge1xuXHRcdFx0XHRcdFx0XHRzZWxmLmlzRHJhZ2dpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRyYWdzdGFydFwiLCBcIm9uRHJhZ1N0YXJ0XCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7IC8vcmV2ZXJ0IGJlY2F1c2UgdGhlIG9uTW92ZSByZXR1cm5lZCBmYWxzZSFcblx0XHRcdFx0XHRcdHNlbGYucG9pbnRlclggPSBwcmV2UG9pbnRlclg7XG5cdFx0XHRcdFx0XHRzZWxmLnBvaW50ZXJZID0gcHJldlBvaW50ZXJZO1xuXHRcdFx0XHRcdFx0c3RhcnRFbGVtZW50WSA9IHByZXZTdGFydEVsZW1lbnRZO1xuXHRcdFx0XHRcdFx0c2VsZi54ID0gcHJldlg7XG5cdFx0XHRcdFx0XHRzZWxmLnkgPSBwcmV2WTtcblx0XHRcdFx0XHRcdHNlbGYuZW5kWCA9IHByZXZFbmRYO1xuXHRcdFx0XHRcdFx0c2VsZi5lbmRZID0gcHJldkVuZFk7XG5cdFx0XHRcdFx0XHRzZWxmLmVuZFJvdGF0aW9uID0gcHJldkVuZFJvdGF0aW9uO1xuXHRcdFx0XHRcdFx0ZGlydHkgPSBwcmV2RGlydHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvL2NhbGxlZCB3aGVuIHRoZSBtb3VzZS90b3VjaCBpcyByZWxlYXNlZFxuXHRcdFx0b25SZWxlYXNlID0gKGUsIGZvcmNlKSA9PiB7XG5cdFx0XHRcdGlmICghZW5hYmxlZCB8fCAhc2VsZi5pc1ByZXNzZWQgfHwgKGUgJiYgdG91Y2hJRCAhPSBudWxsICYmICFmb3JjZSAmJiAoKGUucG9pbnRlcklkICYmIGUucG9pbnRlcklkICE9PSB0b3VjaElEICYmIGUudGFyZ2V0ICE9PSB0YXJnZXQpIHx8IChlLmNoYW5nZWRUb3VjaGVzICYmICFfaGFzVG91Y2hJRChlLmNoYW5nZWRUb3VjaGVzLCB0b3VjaElEKSkpKSkgeyAgLy9mb3Igc29tZSBNaWNyb3NvZnQgYnJvd3NlcnMsIHdlIG11c3QgYXR0YWNoIHRoZSBsaXN0ZW5lciB0byB0aGUgZG9jIHJhdGhlciB0aGFuIHRoZSB0cmlnZ2VyIHNvIHRoYXQgd2hlbiB0aGUgZmluZ2VyIG1vdmVzIG91dHNpZGUgdGhlIGJvdW5kcyBvZiB0aGUgdHJpZ2dlciwgdGhpbmdzIHN0aWxsIHdvcmsuIFNvIGlmIHRoZSBldmVudCB3ZSdyZSByZWNlaXZpbmcgaGFzIGEgcG9pbnRlcklkIHRoYXQgZG9lc24ndCBtYXRjaCB0aGUgdG91Y2hJRCwgaWdub3JlIGl0IChmb3IgbXVsdGktdG91Y2gpXG5cdFx0XHRcdFx0aXNQcmV2ZW50aW5nRGVmYXVsdCAmJiBlICYmIGVuYWJsZWQgJiYgX3ByZXZlbnREZWZhdWx0KGUpOyAvLyBpbiBzb21lIGJyb3dzZXJzLCB3ZSBtdXN0IGxpc3RlbiBmb3IgbXVsdGlwbGUgZXZlbnQgdHlwZXMgbGlrZSB0b3VjaGVuZCwgcG9pbnRlcnVwLCBtb3VzZXVwLiBUaGUgZmlyc3QgdGltZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCwgd2UgcmVjb3JkIHdoZXRoZXIgb3Igbm90IHdlIF9wcmV2ZW50RGVmYXVsdCgpIHNvIHRoYXQgb24gZHVwbGljYXRlIGNhbGxzLCB3ZSBjYW4gZG8gdGhlIHNhbWUgaWYgbmVjZXNzYXJ5LlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLmlzUHJlc3NlZCA9IGZhbHNlO1xuXHRcdFx0XHRsZXQgb3JpZ2luYWxFdmVudCA9IGUsXG5cdFx0XHRcdFx0d2FzRHJhZ2dpbmcgPSBzZWxmLmlzRHJhZ2dpbmcsXG5cdFx0XHRcdFx0aXNDb250ZXh0TWVudVJlbGVhc2UgPSAoc2VsZi52YXJzLmFsbG93Q29udGV4dE1lbnUgJiYgZSAmJiAoZS5jdHJsS2V5IHx8IGUud2hpY2ggPiAyKSksXG5cdFx0XHRcdFx0cGxhY2Vob2xkZXJEZWxheWVkQ2FsbCA9IGdzYXAuZGVsYXllZENhbGwoMC4wMDEsIHJlbW92ZVBsYWNlaG9sZGVyKSxcblx0XHRcdFx0XHR0b3VjaGVzLCBpLCBzeW50aGV0aWNFdmVudCwgZXZlbnRUYXJnZXQsIHN5bnRoZXRpY0NsaWNrO1xuXHRcdFx0XHRpZiAodG91Y2hFdmVudFRhcmdldCkge1xuXHRcdFx0XHRcdF9yZW1vdmVMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNoZW5kXCIsIG9uUmVsZWFzZSk7XG5cdFx0XHRcdFx0X3JlbW92ZUxpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2htb3ZlXCIsIG9uTW92ZSk7XG5cdFx0XHRcdFx0X3JlbW92ZUxpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2hjYW5jZWxcIiwgb25SZWxlYXNlKTtcblx0XHRcdFx0XHRfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIFwidG91Y2hzdGFydFwiLCBfb25NdWx0aVRvdWNoRG9jdW1lbnQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJtb3VzZW1vdmVcIiwgb25Nb3ZlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfcmVtb3ZlTGlzdGVuZXIoX3dpbiwgXCJ0b3VjaGZvcmNlY2hhbmdlXCIsIF9wcmV2ZW50RGVmYXVsdCk7XG5cdFx0XHRcdGlmICghX3N1cHBvcnRzUG9pbnRlciB8fCAhdG91Y2hFdmVudFRhcmdldCkge1xuXHRcdFx0XHRcdF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJtb3VzZXVwXCIsIG9uUmVsZWFzZSk7XG5cdFx0XHRcdFx0ZSAmJiBlLnRhcmdldCAmJiBfcmVtb3ZlTGlzdGVuZXIoZS50YXJnZXQsIFwibW91c2V1cFwiLCBvblJlbGVhc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdGlmICh3YXNEcmFnZ2luZykge1xuXHRcdFx0XHRcdGRyYWdFbmRUaW1lID0gX2xhc3REcmFnVGltZSA9IF9nZXRUaW1lKCk7XG5cdFx0XHRcdFx0c2VsZi5pc0RyYWdnaW5nID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzQ2xpY2tpbmcgJiYgIWlzQ29udGV4dE1lbnVSZWxlYXNlKSB7XG5cdFx0XHRcdFx0aWYgKGUpIHtcblx0XHRcdFx0XHRcdF9yZW1vdmVMaXN0ZW5lcihlLnRhcmdldCwgXCJjaGFuZ2VcIiwgb25SZWxlYXNlKTtcblx0XHRcdFx0XHRcdHNlbGYucG9pbnRlckV2ZW50ID0gb3JpZ2luYWxFdmVudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X3NldFNlbGVjdGFibGUodHJpZ2dlcnMsIGZhbHNlKTtcblx0XHRcdFx0XHRfZGlzcGF0Y2hFdmVudChzZWxmLCBcInJlbGVhc2VcIiwgXCJvblJlbGVhc2VcIik7XG5cdFx0XHRcdFx0X2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJjbGlja1wiLCBcIm9uQ2xpY2tcIik7XG5cdFx0XHRcdFx0aXNDbGlja2luZyA9IGZhbHNlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRfcmVtb3ZlRnJvbVJlbmRlclF1ZXVlKHJlbmRlcik7XG5cdFx0XHRcdGkgPSB0cmlnZ2Vycy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdF9zZXRTdHlsZSh0cmlnZ2Vyc1tpXSwgXCJjdXJzb3JcIiwgdmFycy5jdXJzb3IgfHwgKHZhcnMuY3Vyc29yICE9PSBmYWxzZSA/IF9kZWZhdWx0Q3Vyc29yIDogbnVsbCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9kcmFnQ291bnQtLTtcblx0XHRcdFx0aWYgKGUpIHtcblx0XHRcdFx0XHR0b3VjaGVzID0gZS5jaGFuZ2VkVG91Y2hlcztcblx0XHRcdFx0XHRpZiAodG91Y2hlcykgeyAvL3RvdWNoIGV2ZW50cyBzdG9yZSB0aGUgZGF0YSBzbGlnaHRseSBkaWZmZXJlbnRseVxuXHRcdFx0XHRcdFx0ZSA9IHRvdWNoZXNbMF07XG5cdFx0XHRcdFx0XHRpZiAoZSAhPT0gdG91Y2ggJiYgZS5pZGVudGlmaWVyICE9PSB0b3VjaElEKSB7IC8vVXN1YWxseSBjaGFuZ2VkVG91Y2hlc1swXSB3aWxsIGJlIHdoYXQgd2UncmUgbG9va2luZyBmb3IsIGJ1dCBpbiBjYXNlIGl0J3Mgbm90LCBsb29rIHRocm91Z2ggdGhlIHJlc3Qgb2YgdGhlIGFycmF5Li4uKGFuZCBBbmRyb2lkIGJyb3dzZXJzIGRvbid0IHJldXNlIHRoZSBldmVudCBsaWtlIGlPUylcblx0XHRcdFx0XHRcdFx0aSA9IHRvdWNoZXMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEgJiYgKGUgPSB0b3VjaGVzW2ldKS5pZGVudGlmaWVyICE9PSB0b3VjaElEICYmIGUudGFyZ2V0ICE9PSB0YXJnZXQpIHt9XG5cdFx0XHRcdFx0XHRcdGlmIChpIDwgMCkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZWxmLnBvaW50ZXJFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG5cdFx0XHRcdFx0c2VsZi5wb2ludGVyWCA9IGUucGFnZVg7XG5cdFx0XHRcdFx0c2VsZi5wb2ludGVyWSA9IGUucGFnZVk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzQ29udGV4dE1lbnVSZWxlYXNlICYmIG9yaWdpbmFsRXZlbnQpIHtcblx0XHRcdFx0XHRfcHJldmVudERlZmF1bHQob3JpZ2luYWxFdmVudCk7XG5cdFx0XHRcdFx0aXNQcmV2ZW50aW5nRGVmYXVsdCA9IHRydWU7XG5cdFx0XHRcdFx0X2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJyZWxlYXNlXCIsIFwib25SZWxlYXNlXCIpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG9yaWdpbmFsRXZlbnQgJiYgIXdhc0RyYWdnaW5nKSB7XG5cdFx0XHRcdFx0aXNQcmV2ZW50aW5nRGVmYXVsdCA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChpbnRlcnJ1cHRlZCAmJiAodmFycy5zbmFwIHx8IHZhcnMuYm91bmRzKSkgeyAvL290aGVyd2lzZSwgaWYgdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBvYmplY3Qgd2hpbGUgaXQncyBhbmltYXRpbmcgdG8gYSBzbmFwcGVkIHBvc2l0aW9uLCBhbmQgdGhlbiByZWxlYXNlcyB3aXRob3V0IG1vdmluZyAzIHBpeGVscywgaXQgd2lsbCBqdXN0IHN0YXkgdGhlcmUgKGl0IHNob3VsZCBhbmltYXRlL3NuYXApXG5cdFx0XHRcdFx0XHRhbmltYXRlKHZhcnMuaW5lcnRpYSB8fCB2YXJzLnRocm93UHJvcHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfZGlzcGF0Y2hFdmVudChzZWxmLCBcInJlbGVhc2VcIiwgXCJvblJlbGVhc2VcIik7XG5cdFx0XHRcdFx0aWYgKCghX2lzQW5kcm9pZCB8fCBvcmlnaW5hbEV2ZW50LnR5cGUgIT09IFwidG91Y2htb3ZlXCIpICYmIG9yaWdpbmFsRXZlbnQudHlwZS5pbmRleE9mKFwiY2FuY2VsXCIpID09PSAtMSkgeyAvL3RvIGFjY29tbW9kYXRlIG5hdGl2ZSBzY3JvbGxpbmcgb24gQW5kcm9pZCBkZXZpY2VzLCB3ZSBoYXZlIHRvIGltbWVkaWF0ZWx5IGNhbGwgb25SZWxlYXNlKCkgb24gdGhlIGZpcnN0IHRvdWNobW92ZSBldmVudCwgYnV0IHRoYXQgc2hvdWxkbid0IHRyaWdnZXIgYSBcImNsaWNrXCIuXG5cdFx0XHRcdFx0XHRfZGlzcGF0Y2hFdmVudChzZWxmLCBcImNsaWNrXCIsIFwib25DbGlja1wiKTtcblx0XHRcdFx0XHRcdGlmIChfZ2V0VGltZSgpIC0gY2xpY2tUaW1lIDwgMzAwKSB7XG5cdFx0XHRcdFx0XHRcdF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiZG91YmxlY2xpY2tcIiwgXCJvbkRvdWJsZUNsaWNrXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZXZlbnRUYXJnZXQgPSBvcmlnaW5hbEV2ZW50LnRhcmdldCB8fCB0YXJnZXQ7IC8vb2xkIElFIHVzZXMgc3JjRWxlbWVudFxuXHRcdFx0XHRcdFx0Y2xpY2tUaW1lID0gX2dldFRpbWUoKTtcblx0XHRcdFx0XHRcdHN5bnRoZXRpY0NsaWNrID0gKCkgPT4geyAvLyBzb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpIHdvbid0IHRydXN0IHNjcmlwdC1nZW5lcmF0ZWQgY2xpY2tzLCBzbyBpZiB0aGUgdXNlciB0cmllcyB0byBjbGljayBvbiBhIHZpZGVvIHRvIHBsYXkgaXQsIGZvciBleGFtcGxlLCBpdCBzaW1wbHkgd29uJ3Qgd29yay4gU2luY2UgYSByZWd1bGFyIFwiY2xpY2tcIiBldmVudCB3aWxsIG1vc3QgbGlrZWx5IGJlIGdlbmVyYXRlZCBhbnl3YXkgKG9uZSB0aGF0IGhhcyBpdHMgaXNUcnVzdGVkIGZsYWcgc2V0IHRvIHRydWUpLCB3ZSBtdXN0IHNsaWdodGx5IGRlbGF5IG91ciBzY3JpcHQtZ2VuZXJhdGVkIGNsaWNrIHNvIHRoYXQgdGhlIFwicmVhbFwiL3RydXN0ZWQgb25lIGlzIHByaW9yaXRpemVkLiBSZW1lbWJlciwgd2hlbiB0aGVyZSBhcmUgZHVwbGljYXRlIGV2ZW50cyBpbiBxdWljayBzdWNjZXNzaW9uLCB3ZSBzdXBwcmVzcyBhbGwgYnV0IHRoZSBmaXJzdCBvbmUuIFNvbWUgYnJvd3NlcnMgZG9uJ3QgZXZlbiB0cmlnZ2VyIHRoZSBcInJlYWxcIiBvbmUgYXQgYWxsLCBzbyBvdXIgc3ludGhldGljIG9uZSBpcyBhIHNhZmV0eSB2YWx2ZSB0aGF0IGVuc3VyZXMgdGhhdCBubyBtYXR0ZXIgd2hhdCwgYSBjbGljayBldmVudCBkb2VzIGdldCBkaXNwYXRjaGVkLlxuXHRcdFx0XHRcdFx0XHRpZiAoY2xpY2tUaW1lICE9PSBjbGlja0Rpc3BhdGNoICYmIHNlbGYuZW5hYmxlZCgpICYmICFzZWxmLmlzUHJlc3NlZCAmJiAhb3JpZ2luYWxFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGV2ZW50VGFyZ2V0LmNsaWNrKSB7IC8vc29tZSBicm93c2VycyAobGlrZSBtb2JpbGUgU2FmYXJpKSBkb24ndCBwcm9wZXJseSB0cmlnZ2VyIHRoZSBjbGljayBldmVudFxuXHRcdFx0XHRcdFx0XHRcdFx0ZXZlbnRUYXJnZXQuY2xpY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG93bmVyRG9jLmNyZWF0ZUV2ZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzeW50aGV0aWNFdmVudCA9IG93bmVyRG9jLmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7XG5cdFx0XHRcdFx0XHRcdFx0XHRzeW50aGV0aWNFdmVudC5pbml0TW91c2VFdmVudChcImNsaWNrXCIsIHRydWUsIHRydWUsIF93aW4sIDEsIHNlbGYucG9pbnRlckV2ZW50LnNjcmVlblgsIHNlbGYucG9pbnRlckV2ZW50LnNjcmVlblksIHNlbGYucG9pbnRlclgsIHNlbGYucG9pbnRlclksIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcblx0XHRcdFx0XHRcdFx0XHRcdGV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQoc3ludGhldGljRXZlbnQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGlmICghX2lzQW5kcm9pZCAmJiAhb3JpZ2luYWxFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7IC8vaU9TIFNhZmFyaSByZXF1aXJlcyB0aGUgc3ludGhldGljIGNsaWNrIHRvIGhhcHBlbiBpbW1lZGlhdGVseSBvciBlbHNlIGl0IHNpbXBseSB3b24ndCB3b3JrLCBidXQgQW5kcm9pZCBkb2Vzbid0IHBsYXkgbmljZS5cblx0XHRcdFx0XHRcdFx0Z3NhcC5kZWxheWVkQ2FsbCgwLjA1LCBzeW50aGV0aWNDbGljayk7IC8vaW4gYWRkaXRpb24gdG8gdGhlIGlPUyBidWcgd29ya2Fyb3VuZCwgdGhlcmUncyBhIEZpcmVmb3ggaXNzdWUgd2l0aCBjbGlja2luZyBvbiB0aGluZ3MgbGlrZSBhIHZpZGVvIHRvIHBsYXksIHNvIHdlIG11c3QgZmFrZSBhIGNsaWNrIGV2ZW50IGluIGEgc2xpZ2h0bHkgZGVsYXllZCBmYXNoaW9uLiBQcmV2aW91c2x5LCB3ZSBsaXN0ZW5lZCBmb3IgdGhlIFwiY2xpY2tcIiBldmVudCB3aXRoIFwiY2FwdHVyZVwiIGZhbHNlIHdoaWNoIHNvbHZlZCB0aGUgdmlkZW8tY2xpY2stdG8tcGxheSBpc3N1ZSwgYnV0IGl0IHdvdWxkIGFsbG93IHRoZSBcImNsaWNrXCIgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZCB0d2ljZSBsaWtlIGlmIHlvdSB3ZXJlIHVzaW5nIGEgalF1ZXJ5LmNsaWNrKCkgYmVjYXVzZSB0aGF0IHdhcyBoYW5kbGVkIGluIHRoZSBjYXB0dXJlIHBoYXNlLCB0aHVzIHdlIGhhZCB0byBzd2l0Y2ggdG8gdGhlIGNhcHR1cmUgcGhhc2UgdG8gYXZvaWQgdGhlIGRvdWJsZS1kaXNwYXRjaGluZywgYnV0IGRvIHRoZSBkZWxheWVkIHN5bnRoZXRpYyBjbGljay4gRG9uJ3QgZmlyZSBpdCB0b28gZmFzdCAobGlrZSAwLjAwMDAxKSBiZWNhdXNlIHdlIHdhbnQgdG8gZ2l2ZSB0aGUgbmF0aXZlIGV2ZW50IGEgY2hhbmNlIHRvIGZpcmUgZmlyc3QgYXMgaXQncyBcInRydXN0ZWRcIi5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YW5pbWF0ZSh2YXJzLmluZXJ0aWEgfHwgdmFycy50aHJvd1Byb3BzKTsgLy93aWxsIHNraXAgaWYgaW5lcnRpYS90aHJvd1Byb3BzIGlzbid0IGRlZmluZWQgb3IgSW50ZXJ0aWFQbHVnaW4gaXNuJ3QgbG9hZGVkLlxuXHRcdFx0XHRcdGlmICghc2VsZi5hbGxvd0V2ZW50RGVmYXVsdCAmJiBvcmlnaW5hbEV2ZW50ICYmICh2YXJzLmRyYWdDbGlja2FibGVzICE9PSBmYWxzZSB8fCAhaXNDbGlja2FibGUuY2FsbChzZWxmLCBvcmlnaW5hbEV2ZW50LnRhcmdldCkpICYmIHdhc0RyYWdnaW5nICYmICghYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyB8fCAodG91Y2hEcmFnQXhpcyAmJiBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nID09PSB0b3VjaERyYWdBeGlzKSkgJiYgb3JpZ2luYWxFdmVudC5jYW5jZWxhYmxlICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0aXNQcmV2ZW50aW5nRGVmYXVsdCA9IHRydWU7XG5cdFx0XHRcdFx0XHRfcHJldmVudERlZmF1bHQob3JpZ2luYWxFdmVudCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlzUHJldmVudGluZ0RlZmF1bHQgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0X2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJyZWxlYXNlXCIsIFwib25SZWxlYXNlXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlzVHdlZW5pbmcoKSAmJiBwbGFjZWhvbGRlckRlbGF5ZWRDYWxsLmR1cmF0aW9uKCBzZWxmLnR3ZWVuLmR1cmF0aW9uKCkgKTsgLy9zeW5jIHRoZSB0aW1pbmcgc28gdGhhdCB0aGUgcGxhY2Vob2xkZXIgRElWIGdldHNcblx0XHRcdFx0d2FzRHJhZ2dpbmcgJiYgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJkcmFnZW5kXCIsIFwib25EcmFnRW5kXCIpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdHVwZGF0ZVNjcm9sbCA9IGUgPT4ge1xuXHRcdFx0XHRpZiAoZSAmJiBzZWxmLmlzRHJhZ2dpbmcgJiYgIXNjcm9sbFByb3h5KSB7XG5cdFx0XHRcdFx0bGV0IHBhcmVudCA9IGUudGFyZ2V0IHx8IHRhcmdldC5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0ZGVsdGFYID0gcGFyZW50LnNjcm9sbExlZnQgLSBwYXJlbnQuX2dzU2Nyb2xsWCxcblx0XHRcdFx0XHRcdGRlbHRhWSA9IHBhcmVudC5zY3JvbGxUb3AgLSBwYXJlbnQuX2dzU2Nyb2xsWTtcblx0XHRcdFx0XHRpZiAoZGVsdGFYIHx8IGRlbHRhWSkge1xuXHRcdFx0XHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRcdFx0XHRzdGFydFBvaW50ZXJYIC09IGRlbHRhWCAqIG1hdHJpeC5hICsgZGVsdGFZICogbWF0cml4LmM7XG5cdFx0XHRcdFx0XHRcdHN0YXJ0UG9pbnRlclkgLT0gZGVsdGFZICogbWF0cml4LmQgKyBkZWx0YVggKiBtYXRyaXguYjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHN0YXJ0UG9pbnRlclggLT0gZGVsdGFYO1xuXHRcdFx0XHRcdFx0XHRzdGFydFBvaW50ZXJZIC09IGRlbHRhWTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBhcmVudC5fZ3NTY3JvbGxYICs9IGRlbHRhWDtcblx0XHRcdFx0XHRcdHBhcmVudC5fZ3NTY3JvbGxZICs9IGRlbHRhWTtcblx0XHRcdFx0XHRcdHNldFBvaW50ZXJQb3NpdGlvbihzZWxmLnBvaW50ZXJYLCBzZWxmLnBvaW50ZXJZKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdG9uQ2xpY2sgPSBlID0+IHsgLy90aGlzIHdhcyBhIGh1Z2UgcGFpbiBpbiB0aGUgbmVjayB0byBhbGlnbiBhbGwgdGhlIHZhcmlvdXMgYnJvd3NlcnMgYW5kIHRoZWlyIGJlaGF2aW9ycy4gQ2hyb21lLCBGaXJlZm94LCBTYWZhcmksIE9wZXJhLCBBbmRyb2lkLCBhbmQgTWljcm9zb2Z0IEVkZ2UgYWxsIGhhbmRsZSBldmVudHMgZGlmZmVyZW50bHkhIFNvbWUgd2lsbCBvbmx5IHRyaWdnZXIgbmF0aXZlIGJlaGF2aW9yIChsaWtlIGNoZWNrYm94IHRvZ2dsaW5nKSBmcm9tIHRydXN0ZWQgZXZlbnRzLiBPdGhlcnMgZG9uJ3QgZXZlbiBzdXBwb3J0IGlzVHJ1c3RlZCwgYnV0IHJlcXVpcmUgMiBldmVudHMgdG8gZmxvdyB0aHJvdWdoIGJlZm9yZSB0cmlnZ2VyaW5nIG5hdGl2ZSBiZWhhdmlvci4gRWRnZSB0cmVhdHMgZXZlcnl0aGluZyBhcyB0cnVzdGVkIGJ1dCBhbHNvIG1hbmRhdGVzIHRoYXQgMiBmbG93IHRocm91Z2ggdG8gdHJpZ2dlciB0aGUgY29ycmVjdCBuYXRpdmUgYmVoYXZpb3IuXG5cdFx0XHRcdGxldCB0aW1lID0gX2dldFRpbWUoKSxcblx0XHRcdFx0XHRyZWNlbnRseUNsaWNrZWQgPSAodGltZSAtIGNsaWNrVGltZSA8IDQwKSxcblx0XHRcdFx0XHRyZWNlbnRseURyYWdnZWQgPSAodGltZSAtIGRyYWdFbmRUaW1lIDwgNDApLFxuXHRcdFx0XHRcdGFscmVhZHlEaXNwYXRjaGVkID0gKHJlY2VudGx5Q2xpY2tlZCAmJiBjbGlja0Rpc3BhdGNoID09PSBjbGlja1RpbWUpLFxuXHRcdFx0XHRcdGRlZmF1bHRQcmV2ZW50ZWQgPSAoc2VsZi5wb2ludGVyRXZlbnQgJiYgc2VsZi5wb2ludGVyRXZlbnQuZGVmYXVsdFByZXZlbnRlZCksXG5cdFx0XHRcdFx0YWxyZWFkeURpc3BhdGNoZWRUcnVzdGVkID0gKHJlY2VudGx5Q2xpY2tlZCAmJiB0cnVzdGVkQ2xpY2tEaXNwYXRjaCA9PT0gY2xpY2tUaW1lKSxcblx0XHRcdFx0XHR0cnVzdGVkID0gZS5pc1RydXN0ZWQgfHwgKGUuaXNUcnVzdGVkID09IG51bGwgJiYgcmVjZW50bHlDbGlja2VkICYmIGFscmVhZHlEaXNwYXRjaGVkKTsgLy9ub3RlOiBTYWZhcmkgZG9lc24ndCBzdXBwb3J0IGlzVHJ1c3RlZCwgYW5kIGl0IHdvbid0IHByb3Blcmx5IGV4ZWN1dGUgbmF0aXZlIGJlaGF2aW9yIChsaWtlIHRvZ2dsaW5nIGNoZWNrYm94ZXMpIG9uIHRoZSBmaXJzdCBzeW50aGV0aWMgXCJjbGlja1wiIGV2ZW50IC0gd2UgbXVzdCB3YWl0IGZvciB0aGUgMm5kIGFuZCB0cmVhdCBpdCBhcyB0cnVzdGVkIChidXQgc3RvcCBwcm9wYWdhdGlvbiBhdCB0aGF0IHBvaW50KS4gQ29uZnVzaW5nLCBJIGtub3cuIERvbid0IHlvdSBsb3ZlIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJpbGl0eSBjaGFsbGVuZ2VzP1xuXHRcdFx0XHRpZiAoKGFscmVhZHlEaXNwYXRjaGVkIHx8IChyZWNlbnRseURyYWdnZWQgJiYgc2VsZi52YXJzLnN1cHByZXNzQ2xpY2tPbkRyYWcgIT09IGZhbHNlKSApICYmIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKSB7XG5cdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVjZW50bHlDbGlja2VkICYmICEoc2VsZi5wb2ludGVyRXZlbnQgJiYgc2VsZi5wb2ludGVyRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgJiYgKCFhbHJlYWR5RGlzcGF0Y2hlZCB8fCAodHJ1c3RlZCAmJiAhYWxyZWFkeURpc3BhdGNoZWRUcnVzdGVkKSkpIHsgLy9sZXQgdGhlIGZpcnN0IGNsaWNrIHBhc3MgdGhyb3VnaCB1bmhpbmRlcmVkLiBMZXQgdGhlIG5leHQgb25lIG9ubHkgaWYgaXQncyB0cnVzdGVkLCB0aGVuIG5vIG1vcmUgKHN0b3AgcXVpY2stc3VjY2Vzc2lvbiBvbmVzKVxuXHRcdFx0XHRcdGlmICh0cnVzdGVkICYmIGFscmVhZHlEaXNwYXRjaGVkKSB7XG5cdFx0XHRcdFx0XHR0cnVzdGVkQ2xpY2tEaXNwYXRjaCA9IGNsaWNrVGltZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2xpY2tEaXNwYXRjaCA9IGNsaWNrVGltZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHNlbGYuaXNQcmVzc2VkIHx8IHJlY2VudGx5RHJhZ2dlZCB8fCByZWNlbnRseUNsaWNrZWQpIHtcblx0XHRcdFx0XHRpZiAoIXRydXN0ZWQgfHwgIWUuZGV0YWlsIHx8ICFyZWNlbnRseUNsaWNrZWQgfHwgZGVmYXVsdFByZXZlbnRlZCkge1xuXHRcdFx0XHRcdFx0X3ByZXZlbnREZWZhdWx0KGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXJlY2VudGx5Q2xpY2tlZCAmJiAhcmVjZW50bHlEcmFnZ2VkKSB7IC8vIGZvciBzY3JpcHQtdHJpZ2dlcmVkIGV2ZW50IGRpc3BhdGNoZXMsIGxpa2UgZWxlbWVudC5jbGljaygpXG5cdFx0XHRcdFx0ZSAmJiBlLnRhcmdldCAmJiAoc2VsZi5wb2ludGVyRXZlbnQgPSBlKTtcblx0XHRcdFx0XHRfZGlzcGF0Y2hFdmVudChzZWxmLCBcImNsaWNrXCIsIFwib25DbGlja1wiKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0bG9jYWxpemVQb2ludCA9IHAgPT4gbWF0cml4ID8ge3g6cC54ICogbWF0cml4LmEgKyBwLnkgKiBtYXRyaXguYyArIG1hdHJpeC5lLCB5OnAueCAqIG1hdHJpeC5iICsgcC55ICogbWF0cml4LmQgKyBtYXRyaXguZn0gOiB7eDpwLngsIHk6cC55fTtcblxuXHRcdG9sZCA9IERyYWdnYWJsZS5nZXQodGFyZ2V0KTtcblx0XHRvbGQgJiYgb2xkLmtpbGwoKTsgLy8gYXZvaWRzIGR1cGxpY2F0ZXMgKGFuIGVsZW1lbnQgY2FuIG9ubHkgYmUgY29udHJvbGxlZCBieSBvbmUgRHJhZ2dhYmxlKVxuXG5cdFx0Ly9naXZlIHRoZSB1c2VyIGFjY2VzcyB0byBzdGFydC9zdG9wIGRyYWdnaW5nLi4uXG5cdFx0dGhpcy5zdGFydERyYWcgPSAoZXZlbnQsIGFsaWduKSA9PiB7XG5cdFx0XHRsZXQgcjEsIHIyLCBwMSwgcDI7XG5cdFx0XHRvblByZXNzKGV2ZW50IHx8IHNlbGYucG9pbnRlckV2ZW50LCB0cnVlKTtcblx0XHRcdC8vaWYgdGhlIHBvaW50ZXIgaXNuJ3Qgb24gdG9wIG9mIHRoZSBlbGVtZW50LCBhZGp1c3QgdGhpbmdzIGFjY29yZGluZ2x5XG5cdFx0XHRpZiAoYWxpZ24gJiYgIXNlbGYuaGl0VGVzdChldmVudCB8fCBzZWxmLnBvaW50ZXJFdmVudCkpIHtcblx0XHRcdFx0cjEgPSBfcGFyc2VSZWN0KGV2ZW50IHx8IHNlbGYucG9pbnRlckV2ZW50KTtcblx0XHRcdFx0cjIgPSBfcGFyc2VSZWN0KHRhcmdldCk7XG5cdFx0XHRcdHAxID0gbG9jYWxpemVQb2ludCh7eDpyMS5sZWZ0ICsgcjEud2lkdGggLyAyLCB5OnIxLnRvcCArIHIxLmhlaWdodCAvIDJ9KTtcblx0XHRcdFx0cDIgPSBsb2NhbGl6ZVBvaW50KHt4OnIyLmxlZnQgKyByMi53aWR0aCAvIDIsIHk6cjIudG9wICsgcjIuaGVpZ2h0IC8gMn0pO1xuXHRcdFx0XHRzdGFydFBvaW50ZXJYIC09IHAxLnggLSBwMi54O1xuXHRcdFx0XHRzdGFydFBvaW50ZXJZIC09IHAxLnkgLSBwMi55O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFzZWxmLmlzRHJhZ2dpbmcpIHtcblx0XHRcdFx0c2VsZi5pc0RyYWdnaW5nID0gdHJ1ZTtcblx0XHRcdFx0X2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJkcmFnc3RhcnRcIiwgXCJvbkRyYWdTdGFydFwiKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHRoaXMuZHJhZyA9IG9uTW92ZTtcblx0XHR0aGlzLmVuZERyYWcgPSBlID0+XHRvblJlbGVhc2UoZSB8fCBzZWxmLnBvaW50ZXJFdmVudCwgdHJ1ZSk7XG5cdFx0dGhpcy50aW1lU2luY2VEcmFnID0gKCkgPT4gc2VsZi5pc0RyYWdnaW5nID8gMCA6IChfZ2V0VGltZSgpIC0gZHJhZ0VuZFRpbWUpIC8gMTAwMDtcblx0XHR0aGlzLnRpbWVTaW5jZUNsaWNrID0gKCkgPT4gKF9nZXRUaW1lKCkgLSBjbGlja1RpbWUpIC8gMTAwMDtcblx0XHR0aGlzLmhpdFRlc3QgPSAodGFyZ2V0LCB0aHJlc2hvbGQpID0+IERyYWdnYWJsZS5oaXRUZXN0KHNlbGYudGFyZ2V0LCB0YXJnZXQsIHRocmVzaG9sZCk7XG5cblx0XHR0aGlzLmdldERpcmVjdGlvbiA9IChmcm9tLCBkaWFnb25hbFRocmVzaG9sZCkgPT4geyAvL2Zyb20gY2FuIGJlIFwic3RhcnRcIiAoZGVmYXVsdCksIFwidmVsb2NpdHlcIiwgb3IgYW4gZWxlbWVudFxuXHRcdFx0bGV0IG1vZGUgPSAoZnJvbSA9PT0gXCJ2ZWxvY2l0eVwiICYmIEluZXJ0aWFQbHVnaW4pID8gZnJvbSA6IChfaXNPYmplY3QoZnJvbSkgJiYgIXJvdGF0aW9uTW9kZSkgPyBcImVsZW1lbnRcIiA6IFwic3RhcnRcIixcblx0XHRcdFx0eENoYW5nZSwgeUNoYW5nZSwgcmF0aW8sIGRpcmVjdGlvbiwgcjEsIHIyO1xuXHRcdFx0aWYgKG1vZGUgPT09IFwiZWxlbWVudFwiKSB7XG5cdFx0XHRcdHIxID0gX3BhcnNlUmVjdChzZWxmLnRhcmdldCk7XG5cdFx0XHRcdHIyID0gX3BhcnNlUmVjdChmcm9tKTtcblx0XHRcdH1cblx0XHRcdHhDaGFuZ2UgPSAobW9kZSA9PT0gXCJzdGFydFwiKSA/IHNlbGYueCAtIHN0YXJ0RWxlbWVudFggOiAobW9kZSA9PT0gXCJ2ZWxvY2l0eVwiKSA/IEluZXJ0aWFQbHVnaW4uZ2V0VmVsb2NpdHkodGFyZ2V0LCB4UHJvcCkgOiAocjEubGVmdCArIHIxLndpZHRoIC8gMikgLSAocjIubGVmdCArIHIyLndpZHRoIC8gMik7XG5cdFx0XHRpZiAocm90YXRpb25Nb2RlKSB7XG5cdFx0XHRcdHJldHVybiB4Q2hhbmdlIDwgMCA/IFwiY291bnRlci1jbG9ja3dpc2VcIiA6IFwiY2xvY2t3aXNlXCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkaWFnb25hbFRocmVzaG9sZCA9IGRpYWdvbmFsVGhyZXNob2xkIHx8IDI7XG5cdFx0XHRcdHlDaGFuZ2UgPSAobW9kZSA9PT0gXCJzdGFydFwiKSA/IHNlbGYueSAtIHN0YXJ0RWxlbWVudFkgOiAobW9kZSA9PT0gXCJ2ZWxvY2l0eVwiKSA/IEluZXJ0aWFQbHVnaW4uZ2V0VmVsb2NpdHkodGFyZ2V0LCB5UHJvcCkgOiAocjEudG9wICsgcjEuaGVpZ2h0IC8gMikgLSAocjIudG9wICsgcjIuaGVpZ2h0IC8gMik7XG5cdFx0XHRcdHJhdGlvID0gTWF0aC5hYnMoeENoYW5nZSAvIHlDaGFuZ2UpO1xuXHRcdFx0XHRkaXJlY3Rpb24gPSAocmF0aW8gPCAxIC8gZGlhZ29uYWxUaHJlc2hvbGQpID8gXCJcIiA6ICh4Q2hhbmdlIDwgMCkgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcblx0XHRcdFx0aWYgKHJhdGlvIDwgZGlhZ29uYWxUaHJlc2hvbGQpIHtcblx0XHRcdFx0XHRpZiAoZGlyZWN0aW9uICE9PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRkaXJlY3Rpb24gKz0gXCItXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRpcmVjdGlvbiArPSAoeUNoYW5nZSA8IDApID8gXCJ1cFwiIDogXCJkb3duXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBkaXJlY3Rpb247XG5cdFx0fTtcblxuXHRcdHRoaXMuYXBwbHlCb3VuZHMgPSAobmV3Qm91bmRzLCBzdGlja3kpID0+IHtcblx0XHRcdGxldCB4LCB5LCBmb3JjZVplcm9WZWxvY2l0eSwgZSwgcGFyZW50LCBpc1Jvb3Q7XG5cdFx0XHRpZiAobmV3Qm91bmRzICYmIHZhcnMuYm91bmRzICE9PSBuZXdCb3VuZHMpIHtcblx0XHRcdFx0dmFycy5ib3VuZHMgPSBuZXdCb3VuZHM7XG5cdFx0XHRcdHJldHVybiBzZWxmLnVwZGF0ZSh0cnVlLCBzdGlja3kpO1xuXHRcdFx0fVxuXHRcdFx0c3luY1hZKHRydWUpO1xuXHRcdFx0Y2FsY3VsYXRlQm91bmRzKCk7XG5cdFx0XHRpZiAoaGFzQm91bmRzICYmICFpc1R3ZWVuaW5nKCkpIHtcblx0XHRcdFx0eCA9IHNlbGYueDtcblx0XHRcdFx0eSA9IHNlbGYueTtcblx0XHRcdFx0aWYgKHggPiBtYXhYKSB7XG5cdFx0XHRcdFx0eCA9IG1heFg7XG5cdFx0XHRcdH0gZWxzZSBpZiAoeCA8IG1pblgpIHtcblx0XHRcdFx0XHR4ID0gbWluWDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoeSA+IG1heFkpIHtcblx0XHRcdFx0XHR5ID0gbWF4WTtcblx0XHRcdFx0fSBlbHNlIGlmICh5IDwgbWluWSkge1xuXHRcdFx0XHRcdHkgPSBtaW5ZO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzZWxmLnggIT09IHggfHwgc2VsZi55ICE9PSB5KSB7XG5cdFx0XHRcdFx0Zm9yY2VaZXJvVmVsb2NpdHkgPSB0cnVlO1xuXHRcdFx0XHRcdHNlbGYueCA9IHNlbGYuZW5kWCA9IHg7XG5cdFx0XHRcdFx0aWYgKHJvdGF0aW9uTW9kZSkge1xuXHRcdFx0XHRcdFx0c2VsZi5lbmRSb3RhdGlvbiA9IHg7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYueSA9IHNlbGYuZW5kWSA9IHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRyZW5kZXIodHJ1ZSk7XG5cdFx0XHRcdFx0aWYgKHNlbGYuYXV0b1Njcm9sbCAmJiAhc2VsZi5pc0RyYWdnaW5nKSB7XG5cdFx0XHRcdFx0XHRfcmVjb3JkTWF4U2Nyb2xscyh0YXJnZXQucGFyZW50Tm9kZSk7XG5cdFx0XHRcdFx0XHRlID0gdGFyZ2V0O1xuXHRcdFx0XHRcdFx0X3dpbmRvd1Byb3h5LnNjcm9sbFRvcCA9ICgoX3dpbi5wYWdlWU9mZnNldCAhPSBudWxsKSA/IF93aW4ucGFnZVlPZmZzZXQgOiAob3duZXJEb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCAhPSBudWxsKSA/IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgOiBvd25lckRvYy5ib2R5LnNjcm9sbFRvcCk7XG5cdFx0XHRcdFx0XHRfd2luZG93UHJveHkuc2Nyb2xsTGVmdCA9ICgoX3dpbi5wYWdlWE9mZnNldCAhPSBudWxsKSA/IF93aW4ucGFnZVhPZmZzZXQgOiAob3duZXJEb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgIT0gbnVsbCkgPyBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCA6IG93bmVyRG9jLmJvZHkuc2Nyb2xsTGVmdCk7XG5cdFx0XHRcdFx0XHR3aGlsZSAoZSAmJiAhaXNSb290KSB7IC8vd2FsayB1cCB0aGUgY2hhaW4gYW5kIHNlbnNlIHdoZXJldmVyIHRoZSBzY3JvbGxUb3Avc2Nyb2xsTGVmdCBleGNlZWRzIHRoZSBtYXhpbXVtLlxuXHRcdFx0XHRcdFx0XHRpc1Jvb3QgPSBfaXNSb290KGUucGFyZW50Tm9kZSk7XG5cdFx0XHRcdFx0XHRcdHBhcmVudCA9IGlzUm9vdCA/IF93aW5kb3dQcm94eSA6IGUucGFyZW50Tm9kZTtcblx0XHRcdFx0XHRcdFx0aWYgKGFsbG93WSAmJiBwYXJlbnQuc2Nyb2xsVG9wID4gcGFyZW50Ll9nc01heFNjcm9sbFkpIHtcblx0XHRcdFx0XHRcdFx0XHRwYXJlbnQuc2Nyb2xsVG9wID0gcGFyZW50Ll9nc01heFNjcm9sbFk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKGFsbG93WCAmJiBwYXJlbnQuc2Nyb2xsTGVmdCA+IHBhcmVudC5fZ3NNYXhTY3JvbGxYKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGFyZW50LnNjcm9sbExlZnQgPSBwYXJlbnQuX2dzTWF4U2Nyb2xsWDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc2VsZi5pc1Rocm93aW5nICYmIChmb3JjZVplcm9WZWxvY2l0eSB8fCBzZWxmLmVuZFggPiBtYXhYIHx8IHNlbGYuZW5kWCA8IG1pblggfHwgc2VsZi5lbmRZID4gbWF4WSB8fCBzZWxmLmVuZFkgPCBtaW5ZKSkge1xuXHRcdFx0XHRcdGFuaW1hdGUodmFycy5pbmVydGlhIHx8IHZhcnMudGhyb3dQcm9wcywgZm9yY2VaZXJvVmVsb2NpdHkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXG5cdFx0dGhpcy51cGRhdGUgPSAoYXBwbHlCb3VuZHMsIHN0aWNreSwgaWdub3JlRXh0ZXJuYWxDaGFuZ2VzKSA9PiB7XG5cdFx0XHRsZXQgeyB4LCB5IH0gPSBzZWxmO1xuXHRcdFx0dXBkYXRlTWF0cml4KCFzdGlja3kpO1xuXHRcdFx0aWYgKGFwcGx5Qm91bmRzKSB7XG5cdFx0XHRcdHNlbGYuYXBwbHlCb3VuZHMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRpcnR5ICYmIGlnbm9yZUV4dGVybmFsQ2hhbmdlcyAmJiByZW5kZXIodHJ1ZSk7XG5cdFx0XHRcdHN5bmNYWSh0cnVlKTtcblx0XHRcdH1cblx0XHRcdGlmIChzdGlja3kpIHtcblx0XHRcdFx0c2V0UG9pbnRlclBvc2l0aW9uKHNlbGYucG9pbnRlclgsIHNlbGYucG9pbnRlclkpO1xuXHRcdFx0XHRkaXJ0eSAmJiByZW5kZXIodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2VsZi5pc1ByZXNzZWQgJiYgIXN0aWNreSAmJiAoKGFsbG93WCAmJiBNYXRoLmFicyh4IC0gc2VsZi54KSA+IDAuMDEpIHx8IChhbGxvd1kgJiYgKE1hdGguYWJzKHkgLSBzZWxmLnkpID4gMC4wMSAmJiAhcm90YXRpb25Nb2RlKSkpKSB7XG5cdFx0XHRcdHJlY29yZFN0YXJ0UG9zaXRpb25zKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2VsZi5hdXRvU2Nyb2xsKSB7XG5cdFx0XHRcdF9yZWNvcmRNYXhTY3JvbGxzKHRhcmdldC5wYXJlbnROb2RlLCBzZWxmLmlzRHJhZ2dpbmcpO1xuXHRcdFx0XHRjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSBzZWxmLmlzRHJhZ2dpbmc7XG5cdFx0XHRcdHJlbmRlcih0cnVlKTtcblx0XHRcdFx0Ly9pbiBjYXNlIHJlcGFyZW50aW5nIG9jY3VycmVkLlxuXHRcdFx0XHRfcmVtb3ZlU2Nyb2xsTGlzdGVuZXIodGFyZ2V0LCB1cGRhdGVTY3JvbGwpO1xuXHRcdFx0XHRfYWRkU2Nyb2xsTGlzdGVuZXIodGFyZ2V0LCB1cGRhdGVTY3JvbGwpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fTtcblxuXHRcdHRoaXMuZW5hYmxlID0gdHlwZSA9PiB7XG5cdFx0XHRsZXQgc2V0VmFycyA9IHtsYXp5OiB0cnVlfSxcblx0XHRcdFx0aWQsIGksIHRyaWdnZXI7XG5cdFx0XHRpZiAodmFycy5jdXJzb3IgIT09IGZhbHNlKSB7XG5cdFx0XHRcdHNldFZhcnMuY3Vyc29yID0gdmFycy5jdXJzb3IgfHwgX2RlZmF1bHRDdXJzb3I7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZ3NhcC51dGlscy5jaGVja1ByZWZpeChcInRvdWNoQ2FsbG91dFwiKSkge1xuXHRcdFx0XHRzZXRWYXJzLnRvdWNoQ2FsbG91dCA9IFwibm9uZVwiO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGUgIT09IFwic29mdFwiKSB7XG5cdFx0XHRcdF9zZXRUb3VjaEFjdGlvbkZvckFsbERlc2NlbmRhbnRzKHRyaWdnZXJzLCAoYWxsb3dYID09PSBhbGxvd1kpID8gXCJub25lXCIgOiAodmFycy5hbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nICYmICh0YXJnZXQuc2Nyb2xsSGVpZ2h0ID09PSB0YXJnZXQuY2xpZW50SGVpZ2h0KSA9PT0gKHRhcmdldC5zY3JvbGxXaWR0aCA9PT0gdGFyZ2V0LmNsaWVudEhlaWdodCkpIHx8IHZhcnMuYWxsb3dFdmVudERlZmF1bHQgPyBcIm1hbmlwdWxhdGlvblwiIDogYWxsb3dYID8gXCJwYW4teVwiIDogXCJwYW4teFwiKTsgLy8gU29tZSBicm93c2VycyBsaWtlIEludGVybmV0IEV4cGxvcmVyIHdpbGwgZmlyZSBhIHBvaW50ZXJjYW5jZWwgZXZlbnQgd2hlbiB0aGUgdXNlciBhdHRlbXB0cyB0byBkcmFnIHdoZW4gdG91Y2hBY3Rpb24gaXMgXCJtYW5pcHVsYXRlXCIgYmVjYXVzZSBpdCdzIHBlcmNlaXZlZCBhcyBhIHBhbi4gSWYgdGhlIGVsZW1lbnQgaGFzIHNjcm9sbGFibGUgY29udGVudCBpbiBvbmx5IG9uZSBkaXJlY3Rpb24sIHdlIHNob3VsZCB1c2UgcGFuLXggb3IgcGFuLXkgYWNjb3JkaW5nbHkgc28gdGhhdCB0aGUgcG9pbnRlcmNhbmNlbCBkb2Vzbid0IHByZXZlbnQgZHJhZ2dpbmcuXG5cdFx0XHRcdGkgPSB0cmlnZ2Vycy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHRyaWdnZXIgPSB0cmlnZ2Vyc1tpXTtcblx0XHRcdFx0XHRfc3VwcG9ydHNQb2ludGVyIHx8IF9hZGRMaXN0ZW5lcih0cmlnZ2VyLCBcIm1vdXNlZG93blwiLCBvblByZXNzKTtcblx0XHRcdFx0XHRfYWRkTGlzdGVuZXIodHJpZ2dlciwgXCJ0b3VjaHN0YXJ0XCIsIG9uUHJlc3MpO1xuXHRcdFx0XHRcdF9hZGRMaXN0ZW5lcih0cmlnZ2VyLCBcImNsaWNrXCIsIG9uQ2xpY2ssIHRydWUpOyAvL25vdGU6IHVzZWQgdG8gcGFzcyB0cnVlIGZvciBjYXB0dXJlIGJ1dCBpdCBwcmV2ZW50ZWQgY2xpY2stdG8tcGxheS12aWRlbyBmdW5jdGlvbmFsaXR5IGluIEZpcmVmb3guXG5cdFx0XHRcdFx0Z3NhcC5zZXQodHJpZ2dlciwgc2V0VmFycyk7XG5cdFx0XHRcdFx0aWYgKHRyaWdnZXIuZ2V0QkJveCAmJiB0cmlnZ2VyLm93bmVyU1ZHRWxlbWVudCkgeyAvLyBhIGJ1ZyBpbiBjaHJvbWUgZG9lc24ndCByZXNwZWN0IHRvdWNoLWFjdGlvbiBvbiBTVkcgZWxlbWVudHMgLSBpdCBvbmx5IHdvcmtzIGlmIHdlIHNldCBpdCBvbiB0aGUgcGFyZW50IFNWRy5cblx0XHRcdFx0XHRcdGdzYXAuc2V0KHRyaWdnZXIub3duZXJTVkdFbGVtZW50LCB7dG91Y2hBY3Rpb246IChhbGxvd1ggPT09IGFsbG93WSkgPyBcIm5vbmVcIiA6IHZhcnMuYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyB8fCB2YXJzLmFsbG93RXZlbnREZWZhdWx0ID8gXCJtYW5pcHVsYXRpb25cIiA6IGFsbG93WCA/IFwicGFuLXlcIiA6IFwicGFuLXhcIn0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXJzLmFsbG93Q29udGV4dE1lbnUgfHwgX2FkZExpc3RlbmVyKHRyaWdnZXIsIFwiY29udGV4dG1lbnVcIiwgb25Db250ZXh0TWVudSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3NldFNlbGVjdGFibGUodHJpZ2dlcnMsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdF9hZGRTY3JvbGxMaXN0ZW5lcih0YXJnZXQsIHVwZGF0ZVNjcm9sbCk7XG5cdFx0XHRlbmFibGVkID0gdHJ1ZTtcblx0XHRcdGlmIChJbmVydGlhUGx1Z2luICYmIHR5cGUgIT09IFwic29mdFwiKSB7XG5cdFx0XHRcdEluZXJ0aWFQbHVnaW4udHJhY2soc2Nyb2xsUHJveHkgfHwgdGFyZ2V0LCAoeHlNb2RlID8gXCJ4LHlcIiA6IHJvdGF0aW9uTW9kZSA/IFwicm90YXRpb25cIiA6IFwidG9wLGxlZnRcIikpO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0Ll9nc0RyYWdJRCA9IGlkID0gXCJkXCIgKyAoX2xvb2t1cENvdW50KyspO1xuXHRcdFx0X2xvb2t1cFtpZF0gPSBzZWxmO1xuXHRcdFx0aWYgKHNjcm9sbFByb3h5KSB7XG5cdFx0XHRcdHNjcm9sbFByb3h5LmVuYWJsZSgpO1xuXHRcdFx0XHRzY3JvbGxQcm94eS5lbGVtZW50Ll9nc0RyYWdJRCA9IGlkO1xuXHRcdFx0fVxuXHRcdFx0KHZhcnMuYm91bmRzIHx8IHJvdGF0aW9uTW9kZSkgJiYgcmVjb3JkU3RhcnRQb3NpdGlvbnMoKTtcblx0XHRcdHZhcnMuYm91bmRzICYmIHNlbGYuYXBwbHlCb3VuZHMoKTtcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cblx0XHR0aGlzLmRpc2FibGUgPSB0eXBlID0+IHtcblx0XHRcdGxldCBkcmFnZ2luZyA9IHNlbGYuaXNEcmFnZ2luZyxcblx0XHRcdFx0aSA9IHRyaWdnZXJzLmxlbmd0aCxcblx0XHRcdFx0dHJpZ2dlcjtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRfc2V0U3R5bGUodHJpZ2dlcnNbaV0sIFwiY3Vyc29yXCIsIG51bGwpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGUgIT09IFwic29mdFwiKSB7XG5cdFx0XHRcdF9zZXRUb3VjaEFjdGlvbkZvckFsbERlc2NlbmRhbnRzKHRyaWdnZXJzLCBudWxsKTtcblx0XHRcdFx0aSA9IHRyaWdnZXJzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0dHJpZ2dlciA9IHRyaWdnZXJzW2ldO1xuXHRcdFx0XHRcdF9zZXRTdHlsZSh0cmlnZ2VyLCBcInRvdWNoQ2FsbG91dFwiLCBudWxsKTtcblx0XHRcdFx0XHRfcmVtb3ZlTGlzdGVuZXIodHJpZ2dlciwgXCJtb3VzZWRvd25cIiwgb25QcmVzcyk7XG5cdFx0XHRcdFx0X3JlbW92ZUxpc3RlbmVyKHRyaWdnZXIsIFwidG91Y2hzdGFydFwiLCBvblByZXNzKTtcblx0XHRcdFx0XHRfcmVtb3ZlTGlzdGVuZXIodHJpZ2dlciwgXCJjbGlja1wiLCBvbkNsaWNrKTtcblx0XHRcdFx0XHRfcmVtb3ZlTGlzdGVuZXIodHJpZ2dlciwgXCJjb250ZXh0bWVudVwiLCBvbkNvbnRleHRNZW51KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfc2V0U2VsZWN0YWJsZSh0cmlnZ2VycywgdHJ1ZSk7XG5cdFx0XHRcdGlmICh0b3VjaEV2ZW50VGFyZ2V0KSB7XG5cdFx0XHRcdFx0X3JlbW92ZUxpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2hjYW5jZWxcIiwgb25SZWxlYXNlKTtcblx0XHRcdFx0XHRfcmVtb3ZlTGlzdGVuZXIodG91Y2hFdmVudFRhcmdldCwgXCJ0b3VjaGVuZFwiLCBvblJlbGVhc2UpO1xuXHRcdFx0XHRcdF9yZW1vdmVMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNobW92ZVwiLCBvbk1vdmUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJtb3VzZXVwXCIsIG9uUmVsZWFzZSk7XG5cdFx0XHRcdF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJtb3VzZW1vdmVcIiwgb25Nb3ZlKTtcblx0XHRcdH1cblx0XHRcdF9yZW1vdmVTY3JvbGxMaXN0ZW5lcih0YXJnZXQsIHVwZGF0ZVNjcm9sbCk7XG5cdFx0XHRlbmFibGVkID0gZmFsc2U7XG5cdFx0XHRJbmVydGlhUGx1Z2luICYmIHR5cGUgIT09IFwic29mdFwiICYmIEluZXJ0aWFQbHVnaW4udW50cmFjayhzY3JvbGxQcm94eSB8fCB0YXJnZXQsICh4eU1vZGUgPyBcIngseVwiIDogcm90YXRpb25Nb2RlID8gXCJyb3RhdGlvblwiIDogXCJ0b3AsbGVmdFwiKSk7XG5cdFx0XHRzY3JvbGxQcm94eSAmJiBzY3JvbGxQcm94eS5kaXNhYmxlKCk7XG5cdFx0XHRfcmVtb3ZlRnJvbVJlbmRlclF1ZXVlKHJlbmRlcik7XG5cdFx0XHRzZWxmLmlzRHJhZ2dpbmcgPSBzZWxmLmlzUHJlc3NlZCA9IGlzQ2xpY2tpbmcgPSBmYWxzZTtcblx0XHRcdGRyYWdnaW5nICYmIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiZHJhZ2VuZFwiLCBcIm9uRHJhZ0VuZFwiKTtcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cblx0XHR0aGlzLmVuYWJsZWQgPSBmdW5jdGlvbih2YWx1ZSwgdHlwZSkge1xuXHRcdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmFsdWUgPyBzZWxmLmVuYWJsZSh0eXBlKSA6IHNlbGYuZGlzYWJsZSh0eXBlKSkgOiBlbmFibGVkO1xuXHRcdH07XG5cblx0XHR0aGlzLmtpbGwgPSBmdW5jdGlvbigpIHtcblx0XHRcdHNlbGYuaXNUaHJvd2luZyA9IGZhbHNlO1xuXHRcdFx0c2VsZi50d2VlbiAmJiBzZWxmLnR3ZWVuLmtpbGwoKTtcblx0XHRcdHNlbGYuZGlzYWJsZSgpO1xuXHRcdFx0Z3NhcC5zZXQodHJpZ2dlcnMsIHtjbGVhclByb3BzOlwidXNlclNlbGVjdFwifSk7XG5cdFx0XHRkZWxldGUgX2xvb2t1cFt0YXJnZXQuX2dzRHJhZ0lEXTtcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cblx0XHRpZiAofnR5cGUuaW5kZXhPZihcInNjcm9sbFwiKSkge1xuXHRcdFx0c2Nyb2xsUHJveHkgPSB0aGlzLnNjcm9sbFByb3h5ID0gbmV3IFNjcm9sbFByb3h5KHRhcmdldCwgX2V4dGVuZCh7b25LaWxsOmZ1bmN0aW9uKCkgeyAvL1Njcm9sbFByb3h5J3Mgb25LaWxsKCkgZ2V0cyBjYWxsZWQgaWYvd2hlbiB0aGUgU2Nyb2xsUHJveHkgc2Vuc2VzIHRoYXQgdGhlIHVzZXIgaW50ZXJhY3RlZCB3aXRoIHRoZSBzY3JvbGwgcG9zaXRpb24gbWFudWFsbHkgKGxpa2UgdXNpbmcgdGhlIHNjcm9sbGJhcikuIElFOSBkb2Vzbid0IGZpcmUgdGhlIFwibW91c2V1cFwiIHByb3Blcmx5IHdoZW4gdXNlcnMgZHJhZyB0aGUgc2Nyb2xsYmFyIG9mIGFuIGVsZW1lbnQsIHNvIHRoaXMgd29ya3MgYXJvdW5kIHRoYXQgaXNzdWUuXG5cdFx0XHRcdFx0c2VsZi5pc1ByZXNzZWQgJiYgb25SZWxlYXNlKG51bGwpO1xuXHRcdFx0fX0sIHZhcnMpKTtcblx0XHRcdC8vYSBidWcgaW4gbWFueSBBbmRyb2lkIGRldmljZXMnIHN0b2NrIGJyb3dzZXIgY2F1c2VzIHNjcm9sbFRvcCB0byBnZXQgZm9yY2VkIGJhY2sgdG8gMCBhZnRlciBpdCBpcyBhbHRlcmVkIHZpYSBKUywgc28gd2Ugc2V0IG92ZXJmbG93IHRvIFwiaGlkZGVuXCIgb24gbW9iaWxlL3RvdWNoIGRldmljZXMgKHRoZXkgaGlkZSB0aGUgc2Nyb2xsIGJhciBhbnl3YXkpLiBUaGF0IHdvcmtzIGFyb3VuZCB0aGUgYnVnLiAoVGhpcyBidWcgaXMgZGlzY3Vzc2VkIGF0IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvYW5kcm9pZC9pc3N1ZXMvZGV0YWlsP2lkPTE5NjI1KVxuXHRcdFx0dGFyZ2V0LnN0eWxlLm92ZXJmbG93WSA9IChhbGxvd1kgJiYgIV9pc1RvdWNoRGV2aWNlKSA/IFwiYXV0b1wiIDogXCJoaWRkZW5cIjtcblx0XHRcdHRhcmdldC5zdHlsZS5vdmVyZmxvd1ggPSAoYWxsb3dYICYmICFfaXNUb3VjaERldmljZSkgPyBcImF1dG9cIiA6IFwiaGlkZGVuXCI7XG5cdFx0XHR0YXJnZXQgPSBzY3JvbGxQcm94eS5jb250ZW50O1xuXHRcdH1cblxuXHRcdGlmIChyb3RhdGlvbk1vZGUpIHtcblx0XHRcdGtpbGxQcm9wcy5yb3RhdGlvbiA9IDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChhbGxvd1gpIHtcblx0XHRcdFx0a2lsbFByb3BzW3hQcm9wXSA9IDE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYWxsb3dZKSB7XG5cdFx0XHRcdGtpbGxQcm9wc1t5UHJvcF0gPSAxO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGdzQ2FjaGUuZm9yY2UzRCA9IChcImZvcmNlM0RcIiBpbiB2YXJzKSA/IHZhcnMuZm9yY2UzRCA6IHRydWU7IC8vb3RoZXJ3aXNlLCBub3JtYWwgZHJhZ2dpbmcgd291bGQgYmUgaW4gMkQgYW5kIHRoZW4gYXMgc29vbiBhcyBpdCdzIHJlbGVhc2VkIGFuZCB0aGVyZSdzIGFuIGluZXJ0aWEgdHdlZW4sIGl0J2QganVtcCB0byAzRCB3aGljaCBjYW4gY3JlYXRlIGFuIGluaXRpYWwganVtcCBkdWUgdG8gdGhlIHdvcmsgdGhlIGJyb3dzZXIgbXVzdCB0byBkbyBsYXllcml6ZSBpdC5cblxuXHRcdHRoaXMuZW5hYmxlKCk7XG5cdH1cblxuXG5cblxuXHRzdGF0aWMgcmVnaXN0ZXIoY29yZSkge1xuXHRcdGdzYXAgPSBjb3JlO1xuXHRcdF9pbml0Q29yZSgpO1xuXHR9XG5cblx0c3RhdGljIGNyZWF0ZSh0YXJnZXRzLCB2YXJzKSB7XG5cdFx0X2NvcmVJbml0dGVkIHx8IF9pbml0Q29yZSh0cnVlKTtcblx0XHRyZXR1cm4gX3RvQXJyYXkodGFyZ2V0cykubWFwKHRhcmdldCA9PiBuZXcgRHJhZ2dhYmxlKHRhcmdldCwgdmFycykpO1xuXHR9XG5cblx0c3RhdGljIGdldCh0YXJnZXQpIHtcblx0XHRyZXR1cm4gX2xvb2t1cFsoX3RvQXJyYXkodGFyZ2V0KVswXSB8fCB7fSkuX2dzRHJhZ0lEXTtcblx0fVxuXG5cdHN0YXRpYyB0aW1lU2luY2VEcmFnKCkge1xuXHRcdHJldHVybiAoX2dldFRpbWUoKSAtIF9sYXN0RHJhZ1RpbWUpIC8gMTAwMDtcblx0fVxuXG5cdHN0YXRpYyBoaXRUZXN0KG9iajEsIG9iajIsIHRocmVzaG9sZCkge1xuXHRcdGlmIChvYmoxID09PSBvYmoyKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGxldCByMSA9IF9wYXJzZVJlY3Qob2JqMSksXG5cdFx0XHRyMiA9IF9wYXJzZVJlY3Qob2JqMiksXG5cdFx0XHR7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgd2lkdGgsIGhlaWdodCB9ID0gcjEsXG5cdFx0XHRpc091dHNpZGUgPSAocjIubGVmdCA+IHJpZ2h0IHx8IHIyLnJpZ2h0IDwgbGVmdCB8fCByMi50b3AgPiBib3R0b20gfHwgcjIuYm90dG9tIDwgdG9wKSxcblx0XHRcdG92ZXJsYXAsIGFyZWEsIGlzUmF0aW87XG5cdFx0aWYgKGlzT3V0c2lkZSB8fCAhdGhyZXNob2xkKSB7XG5cdFx0XHRyZXR1cm4gIWlzT3V0c2lkZTtcblx0XHR9XG5cdFx0aXNSYXRpbyA9ICgodGhyZXNob2xkICsgXCJcIikuaW5kZXhPZihcIiVcIikgIT09IC0xKTtcblx0XHR0aHJlc2hvbGQgPSBwYXJzZUZsb2F0KHRocmVzaG9sZCkgfHwgMDtcblx0XHRvdmVybGFwID0ge2xlZnQ6IE1hdGgubWF4KGxlZnQsIHIyLmxlZnQpLCB0b3A6IE1hdGgubWF4KHRvcCwgcjIudG9wKX07XG5cdFx0b3ZlcmxhcC53aWR0aCA9IE1hdGgubWluKHJpZ2h0LCByMi5yaWdodCkgLSBvdmVybGFwLmxlZnQ7XG5cdFx0b3ZlcmxhcC5oZWlnaHQgPSBNYXRoLm1pbihib3R0b20sIHIyLmJvdHRvbSkgLSBvdmVybGFwLnRvcDtcblx0XHRpZiAob3ZlcmxhcC53aWR0aCA8IDAgfHwgb3ZlcmxhcC5oZWlnaHQgPCAwKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmIChpc1JhdGlvKSB7XG5cdFx0XHR0aHJlc2hvbGQgKj0gMC4wMTtcblx0XHRcdGFyZWEgPSBvdmVybGFwLndpZHRoICogb3ZlcmxhcC5oZWlnaHQ7XG5cdFx0XHRyZXR1cm4gKGFyZWEgPj0gd2lkdGggKiBoZWlnaHQgKiB0aHJlc2hvbGQgfHwgYXJlYSA+PSByMi53aWR0aCAqIHIyLmhlaWdodCAqIHRocmVzaG9sZCk7XG5cdFx0fVxuXHRcdHJldHVybiAob3ZlcmxhcC53aWR0aCA+IHRocmVzaG9sZCAmJiBvdmVybGFwLmhlaWdodCA+IHRocmVzaG9sZCk7XG5cdH1cblxufVxuXG5fc2V0RGVmYXVsdHMoRHJhZ2dhYmxlLnByb3RvdHlwZSwge3BvaW50ZXJYOjAsIHBvaW50ZXJZOiAwLCBzdGFydFg6IDAsIHN0YXJ0WTogMCwgZGVsdGFYOiAwLCBkZWx0YVk6IDAsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1ByZXNzZWQ6IGZhbHNlfSk7XG5cbkRyYWdnYWJsZS56SW5kZXggPSAxMDAwO1xuRHJhZ2dhYmxlLnZlcnNpb24gPSBcIjMuNy4wXCI7XG5cbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihEcmFnZ2FibGUpO1xuXG5leHBvcnQgeyBEcmFnZ2FibGUgYXMgZGVmYXVsdCB9OyIsIi8qIVxuICogRWFzZVBhY2sgMy43LjBcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5sZXQgZ3NhcCwgX2NvcmVJbml0dGVkLCBfcmVnaXN0ZXJFYXNlLFxuXHRfZ2V0R1NBUCA9ICgpID0+IGdzYXAgfHwgKHR5cGVvZih3aW5kb3cpICE9PSBcInVuZGVmaW5lZFwiICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcCksXG5cdF9ib29sZWFuID0gKHZhbHVlLCBkZWZhdWx0VmFsdWUpID0+ICEhKHR5cGVvZih2YWx1ZSkgPT09IFwidW5kZWZpbmVkXCIgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZSAmJiAhfigodmFsdWUgKyBcIlwiKS5pbmRleE9mKFwiZmFsc2VcIikpKSxcblx0X2luaXRDb3JlID0gY29yZSA9PiB7XG5cdFx0Z3NhcCA9IGNvcmUgfHwgX2dldEdTQVAoKTtcblx0XHRpZiAoZ3NhcCkge1xuXHRcdFx0X3JlZ2lzdGVyRWFzZSA9IGdzYXAucmVnaXN0ZXJFYXNlO1xuXHRcdFx0Ly9hZGQgd2VpZ2h0ZWQgZWFzZSBjYXBhYmlsaXRpZXMgdG8gc3RhbmRhcmQgZWFzZXMgc28gdXNlcnMgY2FuIGRvIFwicG93ZXIyLmluT3V0KDAuOClcIiBmb3IgZXhhbXBsZSB0byBwdXNoIGV2ZXJ5dGhpbmcgdG93YXJkIHRoZSBcIm91dFwiLCBvciAoLTAuOCkgdG8gcHVzaCBpdCB0b3dhcmQgdGhlIFwiaW5cIiAoMCBpcyBuZXV0cmFsKVxuXHRcdFx0bGV0IGVhc2VzID0gZ3NhcC5wYXJzZUVhc2UoKSxcblx0XHRcdFx0Y3JlYXRlQ29uZmlnID0gZWFzZSA9PiByYXRpbyA9PiB7XG5cdFx0XHRcdFx0bGV0IHkgPSAwLjUgKyByYXRpbyAvIDI7XG5cdFx0XHRcdFx0ZWFzZS5jb25maWcgPSBwID0+IGVhc2UoMiAqICgxIC0gcCkgKiBwICogeSArIHAgKiBwKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0cDtcblx0XHRcdGZvciAocCBpbiBlYXNlcykge1xuXHRcdFx0XHRpZiAoIWVhc2VzW3BdLmNvbmZpZykge1xuXHRcdFx0XHRcdGNyZWF0ZUNvbmZpZyhlYXNlc1twXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdF9yZWdpc3RlckVhc2UoXCJzbG93XCIsIFNsb3dNbyk7XG5cdFx0XHRfcmVnaXN0ZXJFYXNlKFwiZXhwb1NjYWxlXCIsIEV4cG9TY2FsZUVhc2UpO1xuXHRcdFx0X3JlZ2lzdGVyRWFzZShcInJvdWdoXCIsIFJvdWdoRWFzZSk7XG5cdFx0XHRmb3IgKHAgaW4gRWFzZVBhY2spIHtcblx0XHRcdFx0cCAhPT0gXCJ2ZXJzaW9uXCIgJiYgZ3NhcC5jb3JlLmdsb2JhbHMocCwgRWFzZVBhY2tbcF0pO1xuXHRcdFx0fVxuXHRcdFx0X2NvcmVJbml0dGVkID0gMTtcblx0XHR9XG5cdH0sXG5cdF9jcmVhdGVTbG93TW8gPSAobGluZWFyUmF0aW8sIHBvd2VyLCB5b3lvTW9kZSkgPT4ge1xuXHRcdGxpbmVhclJhdGlvID0gTWF0aC5taW4oMSwgbGluZWFyUmF0aW8gfHwgMC43KTtcblx0XHRsZXQgcG93ID0gbGluZWFyUmF0aW8gPCAxID8gKChwb3dlciB8fCBwb3dlciA9PT0gMCkgPyBwb3dlciA6IDAuNykgOiAwLFxuXHRcdFx0cDEgPSAoMSAtIGxpbmVhclJhdGlvKSAvIDIsXG5cdFx0XHRwMyA9IHAxICsgbGluZWFyUmF0aW8sXG5cdFx0XHRjYWxjRW5kID0gX2Jvb2xlYW4oeW95b01vZGUpO1xuXHRcdHJldHVybiBwID0+IHtcblx0XHRcdGxldCByID0gcCArICgwLjUgLSBwKSAqIHBvdztcblx0XHRcdHJldHVybiAocCA8IHAxKSA/IChjYWxjRW5kID8gMSAtICgocCA9IDEgLSAocCAvIHAxKSkgKiBwKSA6IHIgLSAoKHAgPSAxIC0gKHAgLyBwMSkpICogcCAqIHAgKiBwICogcikpIDogKHAgPiBwMykgPyAoY2FsY0VuZCA/IChwID09PSAxID8gMCA6IDEgLSAocCA9IChwIC0gcDMpIC8gcDEpICogcCkgOiByICsgKChwIC0gcikgKiAocCA9IChwIC0gcDMpIC8gcDEpICogcCAqIHAgKiBwKSkgOiAoY2FsY0VuZCA/IDEgOiByKTtcblx0XHR9XG5cdH0sXG5cdF9jcmVhdGVFeHBvU2NhbGUgPSAoc3RhcnQsIGVuZCwgZWFzZSkgPT4ge1xuXHRcdGxldCBwMSA9IE1hdGgubG9nKGVuZCAvIHN0YXJ0KSxcblx0XHRcdHAyID0gZW5kIC0gc3RhcnQ7XG5cdFx0ZWFzZSAmJiAoZWFzZSA9IGdzYXAucGFyc2VFYXNlKGVhc2UpKTtcblx0XHRyZXR1cm4gcCA9PiAoc3RhcnQgKiBNYXRoLmV4cChwMSAqIChlYXNlID8gZWFzZShwKSA6IHApKSAtIHN0YXJ0KSAvIHAyO1xuXHR9LFxuXHRFYXNlUG9pbnQgPSBmdW5jdGlvbih0aW1lLCB2YWx1ZSwgbmV4dCkge1xuXHRcdHRoaXMudCA9IHRpbWU7XG5cdFx0dGhpcy52ID0gdmFsdWU7XG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdHRoaXMubmV4dCA9IG5leHQ7XG5cdFx0XHRuZXh0LnByZXYgPSB0aGlzO1xuXHRcdFx0dGhpcy5jID0gbmV4dC52IC0gdmFsdWU7XG5cdFx0XHR0aGlzLmdhcCA9IG5leHQudCAtIHRpbWU7XG5cdFx0fVxuXHR9LFxuXHRfY3JlYXRlUm91Z2hFYXNlID0gdmFycyA9PiB7XG5cdFx0aWYgKHR5cGVvZih2YXJzKSAhPT0gXCJvYmplY3RcIikgeyAvL3VzZXJzIG1heSBwYXNzIGluIHZpYSBhIHN0cmluZywgbGlrZSBcInJvdWdoKDMwKVwiXG5cdFx0XHR2YXJzID0ge3BvaW50czogK3ZhcnMgfHwgMjB9O1xuXHRcdH1cblx0XHRsZXQgdGFwZXIgPSB2YXJzLnRhcGVyIHx8IFwibm9uZVwiLFxuXHRcdFx0YSA9IFtdLFxuXHRcdFx0Y250ID0gMCxcblx0XHRcdHBvaW50cyA9ICgrdmFycy5wb2ludHMgfHwgMjApIHwgMCxcblx0XHRcdGkgPSBwb2ludHMsXG5cdFx0XHRyYW5kb21pemUgPSBfYm9vbGVhbih2YXJzLnJhbmRvbWl6ZSwgdHJ1ZSksXG5cdFx0XHRjbGFtcCA9IF9ib29sZWFuKHZhcnMuY2xhbXApLFxuXHRcdFx0dGVtcGxhdGUgPSBnc2FwID8gZ3NhcC5wYXJzZUVhc2UodmFycy50ZW1wbGF0ZSkgOiAwLFxuXHRcdFx0c3RyZW5ndGggPSAoK3ZhcnMuc3RyZW5ndGggfHwgMSkgKiAwLjQsXG5cdFx0XHR4LCB5LCBidW1wLCBpbnZYLCBvYmosIHBudCwgcmVjZW50O1xuXHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0eCA9IHJhbmRvbWl6ZSA/IE1hdGgucmFuZG9tKCkgOiAoMSAvIHBvaW50cykgKiBpO1xuXHRcdFx0eSA9IHRlbXBsYXRlID8gdGVtcGxhdGUoeCkgOiB4O1xuXHRcdFx0aWYgKHRhcGVyID09PSBcIm5vbmVcIikge1xuXHRcdFx0XHRidW1wID0gc3RyZW5ndGg7XG5cdFx0XHR9IGVsc2UgaWYgKHRhcGVyID09PSBcIm91dFwiKSB7XG5cdFx0XHRcdGludlggPSAxIC0geDtcblx0XHRcdFx0YnVtcCA9IGludlggKiBpbnZYICogc3RyZW5ndGg7XG5cdFx0XHR9IGVsc2UgaWYgKHRhcGVyID09PSBcImluXCIpIHtcblx0XHRcdFx0YnVtcCA9IHggKiB4ICogc3RyZW5ndGg7XG5cdFx0XHR9IGVsc2UgaWYgKHggPCAwLjUpIHsgIC8vXCJib3RoXCIgKHN0YXJ0KVxuXHRcdFx0XHRpbnZYID0geCAqIDI7XG5cdFx0XHRcdGJ1bXAgPSBpbnZYICogaW52WCAqIDAuNSAqIHN0cmVuZ3RoO1xuXHRcdFx0fSBlbHNlIHtcdFx0XHRcdC8vXCJib3RoXCIgKGVuZClcblx0XHRcdFx0aW52WCA9ICgxIC0geCkgKiAyO1xuXHRcdFx0XHRidW1wID0gaW52WCAqIGludlggKiAwLjUgKiBzdHJlbmd0aDtcblx0XHRcdH1cblx0XHRcdGlmIChyYW5kb21pemUpIHtcblx0XHRcdFx0eSArPSAoTWF0aC5yYW5kb20oKSAqIGJ1bXApIC0gKGJ1bXAgKiAwLjUpO1xuXHRcdFx0fSBlbHNlIGlmIChpICUgMikge1xuXHRcdFx0XHR5ICs9IGJ1bXAgKiAwLjU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR5IC09IGJ1bXAgKiAwLjU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xhbXApIHtcblx0XHRcdFx0aWYgKHkgPiAxKSB7XG5cdFx0XHRcdFx0eSA9IDE7XG5cdFx0XHRcdH0gZWxzZSBpZiAoeSA8IDApIHtcblx0XHRcdFx0XHR5ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YVtjbnQrK10gPSB7eDp4LCB5Onl9O1xuXHRcdH1cblx0XHRhLnNvcnQoKGEsIGIpID0+IGEueCAtIGIueCk7XG5cdFx0cG50ID0gbmV3IEVhc2VQb2ludCgxLCAxLCBudWxsKTtcblx0XHRpID0gcG9pbnRzO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdG9iaiA9IGFbaV07XG5cdFx0XHRwbnQgPSBuZXcgRWFzZVBvaW50KG9iai54LCBvYmoueSwgcG50KTtcblx0XHR9XG5cdFx0cmVjZW50ID0gbmV3IEVhc2VQb2ludCgwLCAwLCBwbnQudCA/IHBudCA6IHBudC5uZXh0KTtcblx0XHRyZXR1cm4gcCA9PiB7XG5cdFx0XHRsZXQgcG50ID0gcmVjZW50O1xuXHRcdFx0aWYgKHAgPiBwbnQudCkge1xuXHRcdFx0XHR3aGlsZSAocG50Lm5leHQgJiYgcCA+PSBwbnQudCkge1xuXHRcdFx0XHRcdHBudCA9IHBudC5uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBudCA9IHBudC5wcmV2O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKHBudC5wcmV2ICYmIHAgPD0gcG50LnQpIHtcblx0XHRcdFx0XHRwbnQgPSBwbnQucHJldjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVjZW50ID0gcG50O1xuXHRcdFx0cmV0dXJuIHBudC52ICsgKChwIC0gcG50LnQpIC8gcG50LmdhcCkgKiBwbnQuYztcblx0XHR9O1xuXHR9O1xuXG5leHBvcnQgY29uc3QgU2xvd01vID0gX2NyZWF0ZVNsb3dNbygwLjcpO1xuU2xvd01vLmVhc2UgPSBTbG93TW87IC8vZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblNsb3dNby5jb25maWcgPSBfY3JlYXRlU2xvd01vO1xuXG5leHBvcnQgY29uc3QgRXhwb1NjYWxlRWFzZSA9IF9jcmVhdGVFeHBvU2NhbGUoMSwgMik7XG5FeHBvU2NhbGVFYXNlLmNvbmZpZyA9IF9jcmVhdGVFeHBvU2NhbGU7XG5cbmV4cG9ydCBjb25zdCBSb3VnaEVhc2UgPSBfY3JlYXRlUm91Z2hFYXNlKCk7XG5Sb3VnaEVhc2UuZWFzZSA9IFJvdWdoRWFzZTsgLy9mb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuUm91Z2hFYXNlLmNvbmZpZyA9IF9jcmVhdGVSb3VnaEVhc2U7XG5cbmV4cG9ydCBjb25zdCBFYXNlUGFjayA9IHtcblx0U2xvd01vOiBTbG93TW8sXG5cdFJvdWdoRWFzZTogUm91Z2hFYXNlLFxuXHRFeHBvU2NhbGVFYXNlOiBFeHBvU2NhbGVFYXNlXG59O1xuXG5mb3IgKGxldCBwIGluIEVhc2VQYWNrKSB7XG5cdEVhc2VQYWNrW3BdLnJlZ2lzdGVyID0gX2luaXRDb3JlO1xuXHRFYXNlUGFja1twXS52ZXJzaW9uID0gXCIzLjcuMFwiO1xufVxuXG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oU2xvd01vKTtcblxuZXhwb3J0IHsgRWFzZVBhY2sgYXMgZGVmYXVsdCB9OyIsIi8qIVxuICogRWFzZWxQbHVnaW4gMy43LjBcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5sZXQgZ3NhcCwgX2NvcmVJbml0dGVkLCBfd2luLCBfY3JlYXRlSlMsIF9Db2xvckZpbHRlciwgX0NvbG9yTWF0cml4RmlsdGVyLFxuXHRfY29sb3JQcm9wcyA9IFwicmVkTXVsdGlwbGllcixncmVlbk11bHRpcGxpZXIsYmx1ZU11bHRpcGxpZXIsYWxwaGFNdWx0aXBsaWVyLHJlZE9mZnNldCxncmVlbk9mZnNldCxibHVlT2Zmc2V0LGFscGhhT2Zmc2V0XCIuc3BsaXQoXCIsXCIpLFxuXHRfd2luZG93RXhpc3RzID0gKCkgPT4gdHlwZW9mKHdpbmRvdykgIT09IFwidW5kZWZpbmVkXCIsXG5cdF9nZXRHU0FQID0gKCkgPT4gZ3NhcCB8fCAoX3dpbmRvd0V4aXN0cygpICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcCksXG5cdF9nZXRDcmVhdGVKUyA9ICgpID0+IF9jcmVhdGVKUyB8fCAoX3dpbiAmJiBfd2luLmNyZWF0ZWpzKSB8fCBfd2luIHx8IHt9LFxuXHRfd2FybiA9IG1lc3NhZ2UgPT4gY29uc29sZS53YXJuKG1lc3NhZ2UpLFxuXHRfY2FjaGUgPSB0YXJnZXQgPT4ge1xuXHRcdGxldCBiID0gdGFyZ2V0LmdldEJvdW5kcyAmJiB0YXJnZXQuZ2V0Qm91bmRzKCk7XG5cdFx0aWYgKCFiKSB7XG5cdFx0XHRiID0gdGFyZ2V0Lm5vbWluYWxCb3VuZHMgfHwge3g6MCwgeTowLCB3aWR0aDogMTAwLCBoZWlnaHQ6IDEwMH07XG5cdFx0XHR0YXJnZXQuc2V0Qm91bmRzICYmIHRhcmdldC5zZXRCb3VuZHMoYi54LCBiLnksIGIud2lkdGgsIGIuaGVpZ2h0KTtcblx0XHR9XG5cdFx0dGFyZ2V0LmNhY2hlICYmIHRhcmdldC5jYWNoZShiLngsIGIueSwgYi53aWR0aCwgYi5oZWlnaHQpO1xuXHRcdF93YXJuKFwiRWFzZWxQbHVnaW46IGZvciBmaWx0ZXJzIHRvIGRpc3BsYXkgaW4gRWFzZWxKUywgeW91IG11c3QgY2FsbCB0aGUgb2JqZWN0J3MgY2FjaGUoKSBtZXRob2QgZmlyc3QuIEdTQVAgYXR0ZW1wdGVkIHRvIHVzZSB0aGUgdGFyZ2V0J3MgZ2V0Qm91bmRzKCkgZm9yIHRoZSBjYWNoZSBidXQgdGhhdCBtYXkgbm90IGJlIGNvbXBsZXRlbHkgYWNjdXJhdGUuIFwiICsgdGFyZ2V0KTtcblx0fSxcblx0X3BhcnNlQ29sb3JGaWx0ZXIgPSAodGFyZ2V0LCB2LCBwbHVnaW4pID0+IHtcblx0XHRpZiAoIV9Db2xvckZpbHRlcikge1xuXHRcdFx0X0NvbG9yRmlsdGVyID0gX2dldENyZWF0ZUpTKCkuQ29sb3JGaWx0ZXI7XG5cdFx0XHRpZiAoIV9Db2xvckZpbHRlcikge1xuXHRcdFx0XHRfd2FybihcIkVhc2VsUGx1Z2luIGVycm9yOiBUaGUgRWFzZWxKUyBDb2xvckZpbHRlciBKYXZhU2NyaXB0IGZpbGUgd2Fzbid0IGxvYWRlZC5cIik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGxldCBmaWx0ZXJzID0gdGFyZ2V0LmZpbHRlcnMgfHwgW10sXG5cdFx0XHRpID0gZmlsdGVycy5sZW5ndGgsXG5cdFx0XHRjLCBzLCBlLCBhLCBwLCBwdDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRpZiAoZmlsdGVyc1tpXSBpbnN0YW5jZW9mIF9Db2xvckZpbHRlcikge1xuXHRcdFx0XHRzID0gZmlsdGVyc1tpXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghcykge1xuXHRcdFx0cyA9IG5ldyBfQ29sb3JGaWx0ZXIoKTtcblx0XHRcdGZpbHRlcnMucHVzaChzKTtcblx0XHRcdHRhcmdldC5maWx0ZXJzID0gZmlsdGVycztcblx0XHR9XG5cdFx0ZSA9IHMuY2xvbmUoKTtcblx0XHRpZiAodi50aW50ICE9IG51bGwpIHtcblx0XHRcdGMgPSBnc2FwLnV0aWxzLnNwbGl0Q29sb3Iodi50aW50KTtcblx0XHRcdGEgPSAodi50aW50QW1vdW50ICE9IG51bGwpID8gK3YudGludEFtb3VudCA6IDE7XG5cdFx0XHRlLnJlZE9mZnNldCA9ICtjWzBdICogYTtcblx0XHRcdGUuZ3JlZW5PZmZzZXQgPSArY1sxXSAqIGE7XG5cdFx0XHRlLmJsdWVPZmZzZXQgPSArY1syXSAqIGE7XG5cdFx0XHRlLnJlZE11bHRpcGxpZXIgPSBlLmdyZWVuTXVsdGlwbGllciA9IGUuYmx1ZU11bHRpcGxpZXIgPSAxIC0gYTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChwIGluIHYpIHtcblx0XHRcdFx0aWYgKHAgIT09IFwiZXhwb3N1cmVcIikgaWYgKHAgIT09IFwiYnJpZ2h0bmVzc1wiKSB7XG5cdFx0XHRcdFx0ZVtwXSA9ICt2W3BdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh2LmV4cG9zdXJlICE9IG51bGwpIHtcblx0XHRcdGUucmVkT2Zmc2V0ID0gZS5ncmVlbk9mZnNldCA9IGUuYmx1ZU9mZnNldCA9IDI1NSAqICgrdi5leHBvc3VyZSAtIDEpO1xuXHRcdFx0ZS5yZWRNdWx0aXBsaWVyID0gZS5ncmVlbk11bHRpcGxpZXIgPSBlLmJsdWVNdWx0aXBsaWVyID0gMTtcblx0XHR9IGVsc2UgaWYgKHYuYnJpZ2h0bmVzcyAhPSBudWxsKSB7XG5cdFx0XHRhID0gK3YuYnJpZ2h0bmVzcyAtIDE7XG5cdFx0XHRlLnJlZE9mZnNldCA9IGUuZ3JlZW5PZmZzZXQgPSBlLmJsdWVPZmZzZXQgPSAoYSA+IDApID8gYSAqIDI1NSA6IDA7XG5cdFx0XHRlLnJlZE11bHRpcGxpZXIgPSBlLmdyZWVuTXVsdGlwbGllciA9IGUuYmx1ZU11bHRpcGxpZXIgPSAxIC0gTWF0aC5hYnMoYSk7XG5cdFx0fVxuXHRcdGkgPSA4O1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdHAgPSBfY29sb3JQcm9wc1tpXTtcblx0XHRcdGlmIChzW3BdICE9PSBlW3BdKSB7XG5cdFx0XHRcdHB0ID0gcGx1Z2luLmFkZChzLCBwLCBzW3BdLCBlW3BdKTtcblx0XHRcdFx0aWYgKHB0KSB7XG5cdFx0XHRcdFx0cHQub3AgPSBcImVhc2VsX2NvbG9yRmlsdGVyXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cGx1Z2luLl9wcm9wcy5wdXNoKFwiZWFzZWxfY29sb3JGaWx0ZXJcIik7XG5cdFx0aWYgKCF0YXJnZXQuY2FjaGVJRCkge1xuXHRcdFx0X2NhY2hlKHRhcmdldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pZE1hdHJpeCA9IFsxLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwxLDBdLFxuXHRfbHVtUiA9IDAuMjEyNjcxLFxuXHRfbHVtRyA9IDAuNzE1MTYwLFxuXHRfbHVtQiA9IDAuMDcyMTY5LFxuXG5cdF9hcHBseU1hdHJpeCA9IChtLCBtMikgPT4ge1xuXHRcdGlmICghKG0gaW5zdGFuY2VvZiBBcnJheSkgfHwgIShtMiBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0cmV0dXJuIG0yO1xuXHRcdH1cblx0XHRsZXQgdGVtcCA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHR6ID0gMCxcblx0XHRcdHksIHg7XG5cdFx0Zm9yICh5ID0gMDsgeSA8IDQ7IHkrKykge1xuXHRcdFx0Zm9yICh4ID0gMDsgeCA8IDU7IHgrKykge1xuXHRcdFx0XHR6ID0gKHggPT09IDQpID8gbVtpICsgNF0gOiAwO1xuXHRcdFx0XHR0ZW1wW2kgKyB4XSA9IG1baV0gICAqIG0yW3hdICsgbVtpKzFdICogbTJbeCArIDVdICtcdG1baSsyXSAqIG0yW3ggKyAxMF0gKyBtW2krM10gKiBtMlt4ICsgMTVdICtcdHo7XG5cdFx0XHR9XG5cdFx0XHRpICs9IDU7XG5cdFx0fVxuXHRcdHJldHVybiB0ZW1wO1xuXHR9LFxuXG5cdF9zZXRTYXR1cmF0aW9uID0gKG0sIG4pID0+IHtcblx0XHRpZiAoaXNOYU4obikpIHtcblx0XHRcdHJldHVybiBtO1xuXHRcdH1cblx0XHRsZXQgaW52ID0gMSAtIG4sXG5cdFx0XHRyID0gaW52ICogX2x1bVIsXG5cdFx0XHRnID0gaW52ICogX2x1bUcsXG5cdFx0XHRiID0gaW52ICogX2x1bUI7XG5cdFx0cmV0dXJuIF9hcHBseU1hdHJpeChbciArIG4sIGcsIGIsIDAsIDAsIHIsIGcgKyBuLCBiLCAwLCAwLCByLCBnLCBiICsgbiwgMCwgMCwgMCwgMCwgMCwgMSwgMF0sIG0pO1xuXHR9LFxuXG5cdF9jb2xvcml6ZSA9IChtLCBjb2xvciwgYW1vdW50KSA9PiB7XG5cdFx0aWYgKGlzTmFOKGFtb3VudCkpIHtcblx0XHRcdGFtb3VudCA9IDE7XG5cdFx0fVxuXHRcdGxldCBjID0gZ3NhcC51dGlscy5zcGxpdENvbG9yKGNvbG9yKSxcblx0XHRcdHIgPSBjWzBdIC8gMjU1LFxuXHRcdFx0ZyA9IGNbMV0gLyAyNTUsXG5cdFx0XHRiID0gY1syXSAvIDI1NSxcblx0XHRcdGludiA9IDEgLSBhbW91bnQ7XG5cdFx0cmV0dXJuIF9hcHBseU1hdHJpeChbaW52ICsgYW1vdW50ICogciAqIF9sdW1SLCBhbW91bnQgKiByICogX2x1bUcsIGFtb3VudCAqIHIgKiBfbHVtQiwgMCwgMCwgYW1vdW50ICogZyAqIF9sdW1SLCBpbnYgKyBhbW91bnQgKiBnICogX2x1bUcsIGFtb3VudCAqIGcgKiBfbHVtQiwgMCwgMCwgYW1vdW50ICogYiAqIF9sdW1SLCBhbW91bnQgKiBiICogX2x1bUcsIGludiArIGFtb3VudCAqIGIgKiBfbHVtQiwgMCwgMCwgMCwgMCwgMCwgMSwgMF0sIG0pO1xuXHR9LFxuXG5cdF9zZXRIdWUgPSAobSwgbikgPT4ge1xuXHRcdGlmIChpc05hTihuKSkge1xuXHRcdFx0cmV0dXJuIG07XG5cdFx0fVxuXHRcdG4gKj0gTWF0aC5QSSAvIDE4MDtcblx0XHRsZXQgYyA9IE1hdGguY29zKG4pLFxuXHRcdFx0cyA9IE1hdGguc2luKG4pO1xuXHRcdHJldHVybiBfYXBwbHlNYXRyaXgoWyhfbHVtUiArIChjICogKDEgLSBfbHVtUikpKSArIChzICogKC1fbHVtUikpLCAoX2x1bUcgKyAoYyAqICgtX2x1bUcpKSkgKyAocyAqICgtX2x1bUcpKSwgKF9sdW1CICsgKGMgKiAoLV9sdW1CKSkpICsgKHMgKiAoMSAtIF9sdW1CKSksIDAsIDAsIChfbHVtUiArIChjICogKC1fbHVtUikpKSArIChzICogMC4xNDMpLCAoX2x1bUcgKyAoYyAqICgxIC0gX2x1bUcpKSkgKyAocyAqIDAuMTQpLCAoX2x1bUIgKyAoYyAqICgtX2x1bUIpKSkgKyAocyAqIC0wLjI4MyksIDAsIDAsIChfbHVtUiArIChjICogKC1fbHVtUikpKSArIChzICogKC0oMSAtIF9sdW1SKSkpLCAoX2x1bUcgKyAoYyAqICgtX2x1bUcpKSkgKyAocyAqIF9sdW1HKSwgKF9sdW1CICsgKGMgKiAoMSAtIF9sdW1CKSkpICsgKHMgKiBfbHVtQiksIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDFdLCBtKTtcblx0fSxcblxuXHRfc2V0Q29udHJhc3QgPSAobSwgbikgPT4ge1xuXHRcdGlmIChpc05hTihuKSkge1xuXHRcdFx0cmV0dXJuIG07XG5cdFx0fVxuXHRcdG4gKz0gMC4wMTtcblx0XHRyZXR1cm4gX2FwcGx5TWF0cml4KFtuLDAsMCwwLDEyOCAqICgxIC0gbiksIDAsbiwwLDAsMTI4ICogKDEgLSBuKSwgMCwwLG4sMCwxMjggKiAoMSAtIG4pLCAwLDAsMCwxLDBdLCBtKTtcblx0fSxcblxuXHRfcGFyc2VDb2xvck1hdHJpeEZpbHRlciA9ICh0YXJnZXQsIHYsIHBsdWdpbikgPT4ge1xuXHRcdGlmICghX0NvbG9yTWF0cml4RmlsdGVyKSB7XG5cdFx0XHRfQ29sb3JNYXRyaXhGaWx0ZXIgPSBfZ2V0Q3JlYXRlSlMoKS5Db2xvck1hdHJpeEZpbHRlcjtcblx0XHRcdGlmICghX0NvbG9yTWF0cml4RmlsdGVyKSB7XG5cdFx0XHRcdF93YXJuKFwiRWFzZWxQbHVnaW46IFRoZSBFYXNlbEpTIENvbG9yTWF0cml4RmlsdGVyIEphdmFTY3JpcHQgZmlsZSB3YXNuJ3QgbG9hZGVkLlwiKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0bGV0IGZpbHRlcnMgPSB0YXJnZXQuZmlsdGVycyB8fCBbXSxcblx0XHRcdGkgPSBmaWx0ZXJzLmxlbmd0aCxcblx0XHRcdG1hdHJpeCwgc3RhcnRNYXRyaXgsIHMsIHBnO1xuXHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0aWYgKGZpbHRlcnNbaV0gaW5zdGFuY2VvZiBfQ29sb3JNYXRyaXhGaWx0ZXIpIHtcblx0XHRcdFx0cyA9IGZpbHRlcnNbaV07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIXMpIHtcblx0XHRcdHMgPSBuZXcgX0NvbG9yTWF0cml4RmlsdGVyKF9pZE1hdHJpeC5zbGljZSgpKTtcblx0XHRcdGZpbHRlcnMucHVzaChzKTtcblx0XHRcdHRhcmdldC5maWx0ZXJzID0gZmlsdGVycztcblx0XHR9XG5cdFx0c3RhcnRNYXRyaXggPSBzLm1hdHJpeDtcblx0XHRtYXRyaXggPSBfaWRNYXRyaXguc2xpY2UoKTtcblx0XHRpZiAodi5jb2xvcml6ZSAhPSBudWxsKSB7XG5cdFx0XHRtYXRyaXggPSBfY29sb3JpemUobWF0cml4LCB2LmNvbG9yaXplLCBOdW1iZXIodi5jb2xvcml6ZUFtb3VudCkpO1xuXHRcdH1cblx0XHRpZiAodi5jb250cmFzdCAhPSBudWxsKSB7XG5cdFx0XHRtYXRyaXggPSBfc2V0Q29udHJhc3QobWF0cml4LCBOdW1iZXIodi5jb250cmFzdCkpO1xuXHRcdH1cblx0XHRpZiAodi5odWUgIT0gbnVsbCkge1xuXHRcdFx0bWF0cml4ID0gX3NldEh1ZShtYXRyaXgsIE51bWJlcih2Lmh1ZSkpO1xuXHRcdH1cblx0XHRpZiAodi5zYXR1cmF0aW9uICE9IG51bGwpIHtcblx0XHRcdG1hdHJpeCA9IF9zZXRTYXR1cmF0aW9uKG1hdHJpeCwgTnVtYmVyKHYuc2F0dXJhdGlvbikpO1xuXHRcdH1cblxuXHRcdGkgPSBtYXRyaXgubGVuZ3RoO1xuXHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0aWYgKG1hdHJpeFtpXSAhPT0gc3RhcnRNYXRyaXhbaV0pIHtcblx0XHRcdFx0cGcgPSBwbHVnaW4uYWRkKHN0YXJ0TWF0cml4LCBpLCBzdGFydE1hdHJpeFtpXSwgbWF0cml4W2ldKTtcblx0XHRcdFx0aWYgKHBnKSB7XG5cdFx0XHRcdFx0cGcub3AgPSBcImVhc2VsX2NvbG9yTWF0cml4RmlsdGVyXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRwbHVnaW4uX3Byb3BzLnB1c2goXCJlYXNlbF9jb2xvck1hdHJpeEZpbHRlclwiKTtcblx0XHRpZiAoIXRhcmdldC5jYWNoZUlEKSB7XG5cdFx0XHRfY2FjaGUoKTtcblx0XHR9XG5cblx0XHRwbHVnaW4uX21hdHJpeCA9IHN0YXJ0TWF0cml4O1xuXHR9LFxuXG5cdF9pbml0Q29yZSA9IGNvcmUgPT4ge1xuXHRcdGdzYXAgPSBjb3JlIHx8IF9nZXRHU0FQKCk7XG5cdFx0aWYgKF93aW5kb3dFeGlzdHMoKSkge1xuXHRcdFx0X3dpbiA9IHdpbmRvdztcblx0XHR9XG5cdFx0aWYgKGdzYXApIHtcblxuXHRcdFx0X2NvcmVJbml0dGVkID0gMTtcblx0XHR9XG5cdH07XG5cblxuZXhwb3J0IGNvbnN0IEVhc2VsUGx1Z2luID0ge1xuXHR2ZXJzaW9uOiBcIjMuNy4wXCIsXG5cdG5hbWU6IFwiZWFzZWxcIixcblx0aW5pdCh0YXJnZXQsIHZhbHVlLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcblx0XHRpZiAoIV9jb3JlSW5pdHRlZCkge1xuXHRcdFx0X2luaXRDb3JlKCk7XG5cdFx0XHRpZiAoIWdzYXApIHtcblx0XHRcdFx0X3dhcm4oXCJQbGVhc2UgZ3NhcC5yZWdpc3RlclBsdWdpbihFYXNlbFBsdWdpbilcIik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdGxldCBwLCBwdCwgdGludCwgY29sb3JNYXRyaXgsIGVuZCwgbGFiZWxzLCBpO1xuXHRcdGZvciAocCBpbiB2YWx1ZSkge1xuXG5cdFx0XHRlbmQgPSB2YWx1ZVtwXTtcblx0XHRcdGlmIChwID09PSBcImNvbG9yRmlsdGVyXCIgfHwgcCA9PT0gXCJ0aW50XCIgfHwgcCA9PT0gXCJ0aW50QW1vdW50XCIgfHwgcCA9PT0gXCJleHBvc3VyZVwiIHx8IHAgPT09IFwiYnJpZ2h0bmVzc1wiKSB7XG5cdFx0XHRcdGlmICghdGludCkge1xuXHRcdFx0XHRcdF9wYXJzZUNvbG9yRmlsdGVyKHRhcmdldCwgdmFsdWUuY29sb3JGaWx0ZXIgfHwgdmFsdWUsIHRoaXMpO1xuXHRcdFx0XHRcdHRpbnQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAocCA9PT0gXCJzYXR1cmF0aW9uXCIgfHwgcCA9PT0gXCJjb250cmFzdFwiIHx8IHAgPT09IFwiaHVlXCIgfHwgcCA9PT0gXCJjb2xvcml6ZVwiIHx8IHAgPT09IFwiY29sb3JpemVBbW91bnRcIikge1xuXHRcdFx0XHRpZiAoIWNvbG9yTWF0cml4KSB7XG5cdFx0XHRcdFx0X3BhcnNlQ29sb3JNYXRyaXhGaWx0ZXIodGFyZ2V0LCB2YWx1ZS5jb2xvck1hdHJpeEZpbHRlciB8fCB2YWx1ZSwgdGhpcyk7XG5cdFx0XHRcdFx0Y29sb3JNYXRyaXggPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAocCA9PT0gXCJmcmFtZVwiKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YoZW5kKSA9PT0gXCJzdHJpbmdcIiAmJiBlbmQuY2hhckF0KDEpICE9PSBcIj1cIiAmJiAobGFiZWxzID0gdGFyZ2V0LmxhYmVscykpIHtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAobGFiZWxzW2ldLmxhYmVsID09PSBlbmQpIHtcblx0XHRcdFx0XHRcdFx0ZW5kID0gbGFiZWxzW2ldLnBvc2l0aW9uO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHRoaXMuYWRkKHRhcmdldCwgXCJnb3RvQW5kU3RvcFwiLCB0YXJnZXQuY3VycmVudEZyYW1lLCBlbmQsIGluZGV4LCB0YXJnZXRzLCBNYXRoLnJvdW5kKTtcblx0XHRcdFx0aWYgKHB0KSB7XG5cdFx0XHRcdFx0cHQub3AgPSBwO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0W3BdICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5hZGQodGFyZ2V0LCBwLCBcImdldFwiLCBlbmQpO1xuXHRcdFx0fVxuXG5cdFx0fVxuXHR9LFxuXHRyZW5kZXIocmF0aW8sIGRhdGEpIHtcblx0XHRsZXQgcHQgPSBkYXRhLl9wdDtcblx0XHR3aGlsZSAocHQpIHtcblx0XHRcdHB0LnIocmF0aW8sIHB0LmQpO1xuXHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHR9XG5cdFx0aWYgKGRhdGEudGFyZ2V0LmNhY2hlSUQpIHtcblx0XHRcdGRhdGEudGFyZ2V0LnVwZGF0ZUNhY2hlKCk7XG5cdFx0fVxuXHR9LFxuXHRyZWdpc3RlcjogX2luaXRDb3JlXG59O1xuXG5FYXNlbFBsdWdpbi5yZWdpc3RlckNyZWF0ZUpTID0gY3JlYXRlanMgPT4ge1xuXHRfY3JlYXRlSlMgPSBjcmVhdGVqcztcbn07XG5cbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihFYXNlbFBsdWdpbik7XG5cbmV4cG9ydCB7IEVhc2VsUGx1Z2luIGFzIGRlZmF1bHQgfTsiLCIvKiFcbiAqIE1vdGlvblBhdGhQbHVnaW4gMy43LjBcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5pbXBvcnQgeyBnZXRSYXdQYXRoLCBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMsIGdldFBvc2l0aW9uT25QYXRoLCBwb2ludHNUb1NlZ21lbnQsIGZsYXRQb2ludHNUb1NlZ21lbnQsIHNsaWNlUmF3UGF0aCwgc3RyaW5nVG9SYXdQYXRoLCByYXdQYXRoVG9TdHJpbmcsIHRyYW5zZm9ybVJhd1BhdGgsIGNvbnZlcnRUb1BhdGggfSBmcm9tIFwiLi91dGlscy9wYXRocy5qc1wiO1xuaW1wb3J0IHsgZ2V0R2xvYmFsTWF0cml4IH0gZnJvbSBcIi4vdXRpbHMvbWF0cml4LmpzXCI7XG5cbmxldCBfeFByb3BzID0gXCJ4LHRyYW5zbGF0ZVgsbGVmdCxtYXJnaW5MZWZ0LHhQZXJjZW50XCIuc3BsaXQoXCIsXCIpLFxuXHRfeVByb3BzID0gXCJ5LHRyYW5zbGF0ZVksdG9wLG1hcmdpblRvcCx5UGVyY2VudFwiLnNwbGl0KFwiLFwiKSxcblx0X0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuXHRnc2FwLCBQcm9wVHdlZW4sIF9nZXRVbml0LCBfdG9BcnJheSxcblx0X2dldEdTQVAgPSAoKSA9PiBnc2FwIHx8ICh0eXBlb2Yod2luZG93KSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXApLFxuXHRfcG9wdWxhdGVTZWdtZW50RnJvbUFycmF5ID0gKHNlZ21lbnQsIHZhbHVlcywgcHJvcGVydHksIG1vZGUpID0+IHsgLy9tb2RlOiAwID0geCBidXQgZG9uJ3QgZmlsbCB5IHlldCwgMSA9IHksIDIgPSB4IGFuZCBmaWxsIHkgd2l0aCAwLlxuXHRcdGxldCBsID0gdmFsdWVzLmxlbmd0aCxcblx0XHRcdHNpID0gbW9kZSA9PT0gMiA/IDAgOiBtb2RlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHR2O1xuXHRcdGZvciAoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRzZWdtZW50W3NpXSA9IHYgPSBwYXJzZUZsb2F0KHZhbHVlc1tpXVtwcm9wZXJ0eV0pO1xuXHRcdFx0bW9kZSA9PT0gMiAmJiAoc2VnbWVudFtzaSsxXSA9IDApO1xuXHRcdFx0c2kgKz0gMjtcblx0XHR9XG5cdFx0cmV0dXJuIHNlZ21lbnQ7XG5cdH0sXG5cdF9nZXRQcm9wTnVtID0gKHRhcmdldCwgcHJvcCwgdW5pdCkgPT4gcGFyc2VGbG9hdCh0YXJnZXQuX2dzYXAuZ2V0KHRhcmdldCwgcHJvcCwgdW5pdCB8fCBcInB4XCIpKSB8fCAwLFxuXHRfcmVsYXRpdml6ZSA9IHNlZ21lbnQgPT4ge1xuXHRcdGxldCB4ID0gc2VnbWVudFswXSxcblx0XHRcdHkgPSBzZWdtZW50WzFdLFxuXHRcdFx0aTtcblx0XHRmb3IgKGkgPSAyOyBpIDwgc2VnbWVudC5sZW5ndGg7IGkrPTIpIHtcblx0XHRcdHggPSAoc2VnbWVudFtpXSArPSB4KTtcblx0XHRcdHkgPSAoc2VnbWVudFtpKzFdICs9IHkpO1xuXHRcdH1cblx0fSxcblx0X3NlZ21lbnRUb1Jhd1BhdGggPSAocGx1Z2luLCBzZWdtZW50LCB0YXJnZXQsIHgsIHksIHNsaWNlciwgdmFycywgdW5pdFgsIHVuaXRZKSA9PiB7XG5cdFx0aWYgKHZhcnMudHlwZSA9PT0gXCJjdWJpY1wiKSB7XG5cdFx0XHRzZWdtZW50ID0gW3NlZ21lbnRdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXJzLmZyb21DdXJyZW50ICE9PSBmYWxzZSAmJiBzZWdtZW50LnVuc2hpZnQoX2dldFByb3BOdW0odGFyZ2V0LCB4LCB1bml0WCksIHkgPyBfZ2V0UHJvcE51bSh0YXJnZXQsIHksIHVuaXRZKSA6IDApO1xuXHRcdFx0dmFycy5yZWxhdGl2ZSAmJiBfcmVsYXRpdml6ZShzZWdtZW50KTtcblx0XHRcdGxldCBwb2ludEZ1bmMgPSB5ID8gcG9pbnRzVG9TZWdtZW50IDogZmxhdFBvaW50c1RvU2VnbWVudDtcblx0XHRcdHNlZ21lbnQgPSBbcG9pbnRGdW5jKHNlZ21lbnQsIHZhcnMuY3VydmluZXNzKV07XG5cdFx0fVxuXHRcdHNlZ21lbnQgPSBzbGljZXIoX2FsaWduKHNlZ21lbnQsIHRhcmdldCwgdmFycykpO1xuXHRcdF9hZGREaW1lbnNpb25hbFByb3BUd2VlbihwbHVnaW4sIHRhcmdldCwgeCwgc2VnbWVudCwgXCJ4XCIsIHVuaXRYKTtcblx0XHR5ICYmIF9hZGREaW1lbnNpb25hbFByb3BUd2VlbihwbHVnaW4sIHRhcmdldCwgeSwgc2VnbWVudCwgXCJ5XCIsIHVuaXRZKTtcblx0XHRyZXR1cm4gY2FjaGVSYXdQYXRoTWVhc3VyZW1lbnRzKHNlZ21lbnQsIHZhcnMucmVzb2x1dGlvbiB8fCAodmFycy5jdXJ2aW5lc3MgPT09IDAgPyAyMCA6IDEyKSk7IC8vd2hlbiBjdXJ2aW5lc3MgaXMgMCwgaXQgY3JlYXRlcyBjb250cm9sIHBvaW50cyByaWdodCBvbiB0b3Agb2YgdGhlIGFuY2hvcnMgd2hpY2ggbWFrZXMgaXQgbW9yZSBzZW5zaXRpdmUgdG8gcmVzb2x1dGlvbiwgdGh1cyB3ZSBjaGFuZ2UgdGhlIGRlZmF1bHQgYWNjb3JkaW5nbHkuXG5cdH0sXG5cdF9lbXB0eUZ1bmMgPSB2ID0+IHYsXG5cdF9udW1FeHAgPSAvWy0rXFwuXSpcXGQrW1xcLmVcXC1cXCtdKlxcZCpbZVxcLVxcK10qXFxkKi9nLFxuXHRfb3JpZ2luVG9Qb2ludCA9IChlbGVtZW50LCBvcmlnaW4sIHBhcmVudE1hdHJpeCkgPT4geyAvLyBvcmlnaW4gaXMgYW4gYXJyYXkgb2Ygbm9ybWFsaXplZCB2YWx1ZXMgKDAtMSkgaW4gcmVsYXRpb24gdG8gdGhlIHdpZHRoL2hlaWdodCwgc28gWzAuNSwgMC41XSB3b3VsZCBiZSB0aGUgY2VudGVyLiBJdCBjYW4gYWxzbyBiZSBcImF1dG9cIiBpbiB3aGljaCBjYXNlIGl0IHdpbGwgYmUgdGhlIHRvcCBsZWZ0IHVubGVzcyBpdCdzIGEgPHBhdGg+LCB3aGVuIGl0IHdpbGwgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcGF0aCBpdHNlbGYuXG5cdFx0bGV0IG0gPSBnZXRHbG9iYWxNYXRyaXgoZWxlbWVudCksXG5cdFx0XHRzdmcsIHgsIHk7XG5cdFx0aWYgKChlbGVtZW50LnRhZ05hbWUgKyBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiKSB7XG5cdFx0XHRzdmcgPSBlbGVtZW50LnZpZXdCb3guYmFzZVZhbDtcblx0XHRcdHggPSBzdmcueDtcblx0XHRcdHkgPSBzdmcueTtcblx0XHRcdHN2Zy53aWR0aCB8fCAoc3ZnID0ge3dpZHRoOiArZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKSwgaGVpZ2h0OiArZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIil9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3ZnID0gb3JpZ2luICYmIGVsZW1lbnQuZ2V0QkJveCAmJiBlbGVtZW50LmdldEJCb3goKTtcblx0XHRcdHggPSB5ID0gMDtcblx0XHR9XG5cdFx0aWYgKG9yaWdpbiAmJiBvcmlnaW4gIT09IFwiYXV0b1wiKSB7XG5cdFx0XHR4ICs9IG9yaWdpbi5wdXNoID8gb3JpZ2luWzBdICogKHN2ZyA/IHN2Zy53aWR0aCA6IGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMCkgOiBvcmlnaW4ueDtcblx0XHRcdHkgKz0gb3JpZ2luLnB1c2ggPyBvcmlnaW5bMV0gKiAoc3ZnID8gc3ZnLmhlaWdodCA6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDApIDogb3JpZ2luLnk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJlbnRNYXRyaXguYXBwbHkoIHggfHwgeSA/IG0uYXBwbHkoe3g6IHgsIHk6IHl9KSA6IHt4OiBtLmUsIHk6IG0uZn0gKTtcblx0fSxcblx0X2dldEFsaWduTWF0cml4ID0gKGZyb21FbGVtZW50LCB0b0VsZW1lbnQsIGZyb21PcmlnaW4sIHRvT3JpZ2luKSA9PiB7XG5cdFx0bGV0IHBhcmVudE1hdHJpeCA9IGdldEdsb2JhbE1hdHJpeChmcm9tRWxlbWVudC5wYXJlbnROb2RlLCB0cnVlLCB0cnVlKSxcblx0XHRcdG0gPSBwYXJlbnRNYXRyaXguY2xvbmUoKS5tdWx0aXBseShnZXRHbG9iYWxNYXRyaXgodG9FbGVtZW50KSksXG5cdFx0XHRmcm9tUG9pbnQgPSBfb3JpZ2luVG9Qb2ludChmcm9tRWxlbWVudCwgZnJvbU9yaWdpbiwgcGFyZW50TWF0cml4KSxcblx0XHRcdHt4LCB5fSA9IF9vcmlnaW5Ub1BvaW50KHRvRWxlbWVudCwgdG9PcmlnaW4sIHBhcmVudE1hdHJpeCksXG5cdFx0XHRwO1xuXHRcdG0uZSA9IG0uZiA9IDA7XG5cdFx0aWYgKHRvT3JpZ2luID09PSBcImF1dG9cIiAmJiB0b0VsZW1lbnQuZ2V0VG90YWxMZW5ndGggJiYgdG9FbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJwYXRoXCIpIHtcblx0XHRcdHAgPSB0b0VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZFwiKS5tYXRjaChfbnVtRXhwKSB8fCBbXTtcblx0XHRcdHAgPSBtLmFwcGx5KHt4OitwWzBdLCB5OitwWzFdfSk7XG5cdFx0XHR4ICs9IHAueDtcblx0XHRcdHkgKz0gcC55O1xuXHRcdH1cblx0XHRpZiAocCB8fCAodG9FbGVtZW50LmdldEJCb3ggJiYgZnJvbUVsZW1lbnQuZ2V0QkJveCAmJiB0b0VsZW1lbnQub3duZXJTVkdFbGVtZW50ID09PSBmcm9tRWxlbWVudC5vd25lclNWR0VsZW1lbnQpKSB7XG5cdFx0XHRwID0gbS5hcHBseSh0b0VsZW1lbnQuZ2V0QkJveCgpKTtcblx0XHRcdHggLT0gcC54O1xuXHRcdFx0eSAtPSBwLnk7XG5cdFx0fVxuXHRcdG0uZSA9IHggLSBmcm9tUG9pbnQueDtcblx0XHRtLmYgPSB5IC0gZnJvbVBvaW50Lnk7XG5cdFx0cmV0dXJuIG07XG5cdH0sXG5cdF9hbGlnbiA9IChyYXdQYXRoLCB0YXJnZXQsIHthbGlnbiwgbWF0cml4LCBvZmZzZXRYLCBvZmZzZXRZLCBhbGlnbk9yaWdpbn0pID0+IHtcblx0XHRsZXQgeCA9IHJhd1BhdGhbMF1bMF0sXG5cdFx0XHR5ID0gcmF3UGF0aFswXVsxXSxcblx0XHRcdGN1clggPSBfZ2V0UHJvcE51bSh0YXJnZXQsIFwieFwiKSxcblx0XHRcdGN1clkgPSBfZ2V0UHJvcE51bSh0YXJnZXQsIFwieVwiKSxcblx0XHRcdGFsaWduVGFyZ2V0LCBtLCBwO1xuXHRcdGlmICghcmF3UGF0aCB8fCAhcmF3UGF0aC5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBnZXRSYXdQYXRoKFwiTTAsMEwwLDBcIik7XG5cdFx0fVxuXHRcdGlmIChhbGlnbikge1xuXHRcdFx0aWYgKGFsaWduID09PSBcInNlbGZcIiB8fCAoKGFsaWduVGFyZ2V0ID0gX3RvQXJyYXkoYWxpZ24pWzBdIHx8IHRhcmdldCkgPT09IHRhcmdldCkpIHtcblx0XHRcdFx0dHJhbnNmb3JtUmF3UGF0aChyYXdQYXRoLCAxLCAwLCAwLCAxLCBjdXJYIC0geCwgY3VyWSAtIHkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGFsaWduT3JpZ2luICYmIGFsaWduT3JpZ2luWzJdICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdGdzYXAuc2V0KHRhcmdldCwge3RyYW5zZm9ybU9yaWdpbjooYWxpZ25PcmlnaW5bMF0gKiAxMDApICsgXCIlIFwiICsgKGFsaWduT3JpZ2luWzFdICogMTAwKSArIFwiJVwifSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YWxpZ25PcmlnaW4gPSBbX2dldFByb3BOdW0odGFyZ2V0LCBcInhQZXJjZW50XCIpIC8gLTEwMCwgX2dldFByb3BOdW0odGFyZ2V0LCBcInlQZXJjZW50XCIpIC8gLTEwMF07XG5cdFx0XHRcdH1cblx0XHRcdFx0bSA9IF9nZXRBbGlnbk1hdHJpeCh0YXJnZXQsIGFsaWduVGFyZ2V0LCBhbGlnbk9yaWdpbiwgXCJhdXRvXCIpO1xuXHRcdFx0XHRwID0gbS5hcHBseSh7eDogeCwgeTogeX0pO1xuXHRcdFx0XHR0cmFuc2Zvcm1SYXdQYXRoKHJhd1BhdGgsIG0uYSwgbS5iLCBtLmMsIG0uZCwgY3VyWCArIG0uZSAtIChwLnggLSBtLmUpLCBjdXJZICsgbS5mIC0gKHAueSAtIG0uZikpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHR0cmFuc2Zvcm1SYXdQYXRoKHJhd1BhdGgsIG1hdHJpeC5hLCBtYXRyaXguYiwgbWF0cml4LmMsIG1hdHJpeC5kLCBtYXRyaXguZSwgbWF0cml4LmYpO1xuXHRcdH0gZWxzZSBpZiAob2Zmc2V0WCB8fCBvZmZzZXRZKSB7XG5cdFx0XHR0cmFuc2Zvcm1SYXdQYXRoKHJhd1BhdGgsIDEsIDAsIDAsIDEsIG9mZnNldFggfHwgMCwgb2Zmc2V0WSB8fCAwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJhd1BhdGg7XG5cdH0sXG5cdF9hZGREaW1lbnNpb25hbFByb3BUd2VlbiA9IChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIHJhd1BhdGgsIHBhdGhQcm9wZXJ0eSwgZm9yY2VVbml0KSA9PiB7XG5cdFx0bGV0IGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuXHRcdFx0aGFybmVzcyA9IGNhY2hlLmhhcm5lc3MsXG5cdFx0XHRhbGlhcyA9IChoYXJuZXNzICYmIGhhcm5lc3MuYWxpYXNlcyAmJiBoYXJuZXNzLmFsaWFzZXNbcHJvcGVydHldKSxcblx0XHRcdHByb3AgPSBhbGlhcyAmJiBhbGlhcy5pbmRleE9mKFwiLFwiKSA8IDAgPyBhbGlhcyA6IHByb3BlcnR5LFxuXHRcdFx0cHQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3AsIDAsIDAsIF9lbXB0eUZ1bmMsIDAsIGNhY2hlLnNldCh0YXJnZXQsIHByb3AsIHBsdWdpbikpO1xuXHRcdHB0LnUgPSBfZ2V0VW5pdChjYWNoZS5nZXQodGFyZ2V0LCBwcm9wLCBmb3JjZVVuaXQpKSB8fCAwO1xuXHRcdHB0LnBhdGggPSByYXdQYXRoO1xuXHRcdHB0LnBwID0gcGF0aFByb3BlcnR5O1xuXHRcdHBsdWdpbi5fcHJvcHMucHVzaChwcm9wKTtcblx0fSxcblx0X3NsaWNlTW9kaWZpZXIgPSAoc3RhcnQsIGVuZCkgPT4gcmF3UGF0aCA9PiAoc3RhcnQgfHwgZW5kICE9PSAxKSA/IHNsaWNlUmF3UGF0aChyYXdQYXRoLCBzdGFydCwgZW5kKSA6IHJhd1BhdGg7XG5cblxuZXhwb3J0IGNvbnN0IE1vdGlvblBhdGhQbHVnaW4gPSB7XG5cdHZlcnNpb246IFwiMy43LjBcIixcblx0bmFtZTogXCJtb3Rpb25QYXRoXCIsXG5cdHJlZ2lzdGVyKGNvcmUsIFBsdWdpbiwgcHJvcFR3ZWVuKSB7XG5cdFx0Z3NhcCA9IGNvcmU7XG5cdFx0X2dldFVuaXQgPSBnc2FwLnV0aWxzLmdldFVuaXQ7XG5cdFx0X3RvQXJyYXkgPSBnc2FwLnV0aWxzLnRvQXJyYXk7XG5cdFx0UHJvcFR3ZWVuID0gcHJvcFR3ZWVuO1xuXHR9LFxuXHRpbml0KHRhcmdldCwgdmFycykge1xuXHRcdGlmICghZ3NhcCkge1xuXHRcdFx0Y29uc29sZS53YXJuKFwiUGxlYXNlIGdzYXAucmVnaXN0ZXJQbHVnaW4oTW90aW9uUGF0aFBsdWdpbilcIik7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICghKHR5cGVvZih2YXJzKSA9PT0gXCJvYmplY3RcIiAmJiAhdmFycy5zdHlsZSkgfHwgIXZhcnMucGF0aCkge1xuXHRcdFx0dmFycyA9IHtwYXRoOnZhcnN9O1xuXHRcdH1cblx0XHRsZXQgcmF3UGF0aHMgPSBbXSxcblx0XHRcdHtwYXRoLCBhdXRvUm90YXRlLCB1bml0WCwgdW5pdFksIHgsIHl9ID0gdmFycyxcblx0XHRcdGZpcnN0T2JqID0gcGF0aFswXSxcblx0XHRcdHNsaWNlciA9IF9zbGljZU1vZGlmaWVyKHZhcnMuc3RhcnQsIChcImVuZFwiIGluIHZhcnMpID8gdmFycy5lbmQgOiAxKSxcblx0XHRcdHJhd1BhdGgsIHA7XG5cdFx0dGhpcy5yYXdQYXRocyA9IHJhd1BhdGhzO1xuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdGlmICgodGhpcy5yb3RhdGUgPSAoYXV0b1JvdGF0ZSB8fCBhdXRvUm90YXRlID09PSAwKSkpIHsgLy9nZXQgdGhlIHJvdGF0aW9uYWwgZGF0YSBGSVJTVCBzbyB0aGF0IHRoZSBzZXRUcmFuc2Zvcm0oKSBtZXRob2QgaXMgY2FsbGVkIGluIHRoZSBjb3JyZWN0IG9yZGVyIGluIHRoZSByZW5kZXIoKSBsb29wIC0gcm90YXRpb24gZ2V0cyBzZXQgbGFzdC5cblx0XHRcdHRoaXMuck9mZnNldCA9IHBhcnNlRmxvYXQoYXV0b1JvdGF0ZSkgfHwgMDtcblx0XHRcdHRoaXMucmFkaWFucyA9ICEhdmFycy51c2VSYWRpYW5zO1xuXHRcdFx0dGhpcy5yUHJvcCA9IHZhcnMucm90YXRpb24gfHwgXCJyb3RhdGlvblwiOyAgICAgICAgICAgICAgICAgICAgICAgLy8gcm90YXRpb24gcHJvcGVydHlcblx0XHRcdHRoaXMuclNldCA9IHRhcmdldC5fZ3NhcC5zZXQodGFyZ2V0LCB0aGlzLnJQcm9wLCB0aGlzKTsgICAgICAgICAvLyByb3RhdGlvbiBzZXR0ZXJcblx0XHRcdHRoaXMucnUgPSBfZ2V0VW5pdCh0YXJnZXQuX2dzYXAuZ2V0KHRhcmdldCwgdGhpcy5yUHJvcCkpIHx8IDA7ICAvLyByb3RhdGlvbiB1bml0c1xuXHRcdH1cblx0XHRpZiAoQXJyYXkuaXNBcnJheShwYXRoKSAmJiAhKFwiY2xvc2VkXCIgaW4gcGF0aCkgJiYgdHlwZW9mKGZpcnN0T2JqKSAhPT0gXCJudW1iZXJcIikge1xuXHRcdFx0Zm9yIChwIGluIGZpcnN0T2JqKSB7XG5cdFx0XHRcdGlmICgheCAmJiB+X3hQcm9wcy5pbmRleE9mKHApKSB7XG5cdFx0XHRcdFx0eCA9IHA7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIXkgJiYgfl95UHJvcHMuaW5kZXhPZihwKSkge1xuXHRcdFx0XHRcdHkgPSBwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoeCAmJiB5KSB7IC8vY29ycmVsYXRlZCB2YWx1ZXNcblx0XHRcdFx0cmF3UGF0aHMucHVzaChfc2VnbWVudFRvUmF3UGF0aCh0aGlzLCBfcG9wdWxhdGVTZWdtZW50RnJvbUFycmF5KF9wb3B1bGF0ZVNlZ21lbnRGcm9tQXJyYXkoW10sIHBhdGgsIHgsIDApLCBwYXRoLCB5LCAxKSwgdGFyZ2V0LCB4LCB5LCBzbGljZXIsIHZhcnMsIHVuaXRYIHx8IF9nZXRVbml0KHBhdGhbMF1beF0pLCB1bml0WSB8fCBfZ2V0VW5pdChwYXRoWzBdW3ldKSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eCA9IHkgPSAwO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChwIGluIGZpcnN0T2JqKSB7XG5cdFx0XHRcdHAgIT09IHggJiYgcCAhPT0geSAmJiByYXdQYXRocy5wdXNoKF9zZWdtZW50VG9SYXdQYXRoKHRoaXMsIF9wb3B1bGF0ZVNlZ21lbnRGcm9tQXJyYXkoW10sIHBhdGgsIHAsIDIpLCB0YXJnZXQsIHAsIDAsIHNsaWNlciwgdmFycywgX2dldFVuaXQocGF0aFswXVtwXSkpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmF3UGF0aCA9IHNsaWNlcihfYWxpZ24oZ2V0UmF3UGF0aCh2YXJzLnBhdGgpLCB0YXJnZXQsIHZhcnMpKTtcblx0XHRcdGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyhyYXdQYXRoLCB2YXJzLnJlc29sdXRpb24pO1xuXHRcdFx0cmF3UGF0aHMucHVzaChyYXdQYXRoKTtcblx0XHRcdF9hZGREaW1lbnNpb25hbFByb3BUd2Vlbih0aGlzLCB0YXJnZXQsIHZhcnMueCB8fCBcInhcIiwgcmF3UGF0aCwgXCJ4XCIsIHZhcnMudW5pdFggfHwgXCJweFwiKTtcblx0XHRcdF9hZGREaW1lbnNpb25hbFByb3BUd2Vlbih0aGlzLCB0YXJnZXQsIHZhcnMueSB8fCBcInlcIiwgcmF3UGF0aCwgXCJ5XCIsIHZhcnMudW5pdFkgfHwgXCJweFwiKTtcblx0XHR9XG5cdH0sXG5cdHJlbmRlcihyYXRpbywgZGF0YSkge1xuXHRcdGxldCByYXdQYXRocyA9IGRhdGEucmF3UGF0aHMsXG5cdFx0XHRpID0gcmF3UGF0aHMubGVuZ3RoLFxuXHRcdFx0cHQgPSBkYXRhLl9wdDtcblx0XHRpZiAocmF0aW8gPiAxKSB7XG5cdFx0XHRyYXRpbyA9IDE7XG5cdFx0fSBlbHNlIGlmIChyYXRpbyA8IDApIHtcblx0XHRcdHJhdGlvID0gMDtcblx0XHR9XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0Z2V0UG9zaXRpb25PblBhdGgocmF3UGF0aHNbaV0sIHJhdGlvLCAhaSAmJiBkYXRhLnJvdGF0ZSwgcmF3UGF0aHNbaV0pO1xuXHRcdH1cblx0XHR3aGlsZSAocHQpIHtcblx0XHRcdHB0LnNldChwdC50LCBwdC5wLCBwdC5wYXRoW3B0LnBwXSArIHB0LnUsIHB0LmQsIHJhdGlvKTtcblx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0fVxuXHRcdGRhdGEucm90YXRlICYmIGRhdGEuclNldChkYXRhLnRhcmdldCwgZGF0YS5yUHJvcCwgcmF3UGF0aHNbMF0uYW5nbGUgKiAoZGF0YS5yYWRpYW5zID8gX0RFRzJSQUQgOiAxKSArIGRhdGEuck9mZnNldCArIGRhdGEucnUsIGRhdGEsIHJhdGlvKTtcblx0fSxcblx0Z2V0TGVuZ3RoKHBhdGgpIHtcblx0XHRyZXR1cm4gY2FjaGVSYXdQYXRoTWVhc3VyZW1lbnRzKGdldFJhd1BhdGgocGF0aCkpLnRvdGFsTGVuZ3RoO1xuXHR9LFxuXHRzbGljZVJhd1BhdGgsXG5cdGdldFJhd1BhdGgsXG5cdHBvaW50c1RvU2VnbWVudCxcblx0c3RyaW5nVG9SYXdQYXRoLFxuXHRyYXdQYXRoVG9TdHJpbmcsXG5cdHRyYW5zZm9ybVJhd1BhdGgsXG5cdGdldEdsb2JhbE1hdHJpeCxcblx0Z2V0UG9zaXRpb25PblBhdGgsXG5cdGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyxcblx0Y29udmVydFRvUGF0aDogKHRhcmdldHMsIHN3YXApID0+IF90b0FycmF5KHRhcmdldHMpLm1hcCh0YXJnZXQgPT4gY29udmVydFRvUGF0aCh0YXJnZXQsIHN3YXAgIT09IGZhbHNlKSksXG5cdGNvbnZlcnRDb29yZGluYXRlcyhmcm9tRWxlbWVudCwgdG9FbGVtZW50LCBwb2ludCkge1xuXHRcdGxldCBtID0gZ2V0R2xvYmFsTWF0cml4KHRvRWxlbWVudCwgdHJ1ZSwgdHJ1ZSkubXVsdGlwbHkoZ2V0R2xvYmFsTWF0cml4KGZyb21FbGVtZW50KSk7XG5cdFx0cmV0dXJuIHBvaW50ID8gbS5hcHBseShwb2ludCkgOiBtO1xuXHR9LFxuXHRnZXRBbGlnbk1hdHJpeDogX2dldEFsaWduTWF0cml4LFxuXHRnZXRSZWxhdGl2ZVBvc2l0aW9uKGZyb21FbGVtZW50LCB0b0VsZW1lbnQsIGZyb21PcmlnaW4sIHRvT3JpZ2luKSB7XG5cdFx0bGV0IG0gPV9nZXRBbGlnbk1hdHJpeChmcm9tRWxlbWVudCwgdG9FbGVtZW50LCBmcm9tT3JpZ2luLCB0b09yaWdpbik7XG5cdFx0cmV0dXJuIHt4OiBtLmUsIHk6IG0uZn07XG5cdH0sXG5cdGFycmF5VG9SYXdQYXRoKHZhbHVlLCB2YXJzKSB7XG5cdFx0dmFycyA9IHZhcnMgfHwge307XG5cdFx0bGV0IHNlZ21lbnQgPSBfcG9wdWxhdGVTZWdtZW50RnJvbUFycmF5KF9wb3B1bGF0ZVNlZ21lbnRGcm9tQXJyYXkoW10sIHZhbHVlLCB2YXJzLnggfHwgXCJ4XCIsIDApLCB2YWx1ZSwgdmFycy55IHx8IFwieVwiLCAxKTtcblx0XHR2YXJzLnJlbGF0aXZlICYmIF9yZWxhdGl2aXplKHNlZ21lbnQpO1xuXHRcdHJldHVybiBbKHZhcnMudHlwZSA9PT0gXCJjdWJpY1wiKSA/IHNlZ21lbnQgOiBwb2ludHNUb1NlZ21lbnQoc2VnbWVudCwgdmFycy5jdXJ2aW5lc3MpXTtcblx0fVxufTtcblxuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKE1vdGlvblBhdGhQbHVnaW4pO1xuXG5leHBvcnQgeyBNb3Rpb25QYXRoUGx1Z2luIGFzIGRlZmF1bHQgfTsiLCIvKiFcbiAqIFBpeGlQbHVnaW4gMy43LjBcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5sZXQgZ3NhcCwgX3dpbiwgX3NwbGl0Q29sb3IsIF9jb3JlSW5pdHRlZCwgX1BJWEksIFByb3BUd2VlbiwgX2dldFNldHRlcixcblx0X3dpbmRvd0V4aXN0cyA9ICgpID0+IHR5cGVvZih3aW5kb3cpICE9PSBcInVuZGVmaW5lZFwiLFxuXHRfZ2V0R1NBUCA9ICgpID0+IGdzYXAgfHwgKF93aW5kb3dFeGlzdHMoKSAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXApLFxuXHRfaXNGdW5jdGlvbiA9IHZhbHVlID0+IHR5cGVvZih2YWx1ZSkgPT09IFwiZnVuY3Rpb25cIixcblx0X3dhcm4gPSBtZXNzYWdlID0+IGNvbnNvbGUud2FybihtZXNzYWdlKSxcblx0X2lkTWF0cml4ID0gWzEsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLDEsMF0sXG5cdF9sdW1SID0gMC4yMTI2NzEsXG5cdF9sdW1HID0gMC43MTUxNjAsXG5cdF9sdW1CID0gMC4wNzIxNjksXG5cdF9hcHBseU1hdHJpeCA9IChtLCBtMikgPT4ge1xuXHRcdGxldCB0ZW1wID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdHogPSAwLFxuXHRcdFx0eSwgeDtcblx0XHRmb3IgKHkgPSAwOyB5IDwgNDsgeSsrKSB7XG5cdFx0XHRmb3IgKHggPSAwOyB4IDwgNTsgeCsrKSB7XG5cdFx0XHRcdHogPSAoeCA9PT0gNCkgPyBtW2kgKyA0XSA6IDA7XG5cdFx0XHRcdHRlbXBbaSArIHhdID0gbVtpXSAgICogbTJbeF0gKyBtW2krMV0gKiBtMlt4ICsgNV0gK1x0bVtpKzJdICogbTJbeCArIDEwXSArIG1baSszXSAqIG0yW3ggKyAxNV0gK1x0ejtcblx0XHRcdH1cblx0XHRcdGkgKz0gNTtcblx0XHR9XG5cdFx0cmV0dXJuIHRlbXA7XG5cdH0sXG5cdF9zZXRTYXR1cmF0aW9uID0gKG0sIG4pID0+IHtcblx0XHRsZXQgaW52ID0gMSAtIG4sXG5cdFx0XHRyID0gaW52ICogX2x1bVIsXG5cdFx0XHRnID0gaW52ICogX2x1bUcsXG5cdFx0XHRiID0gaW52ICogX2x1bUI7XG5cdFx0cmV0dXJuIF9hcHBseU1hdHJpeChbciArIG4sIGcsIGIsIDAsIDAsIHIsIGcgKyBuLCBiLCAwLCAwLCByLCBnLCBiICsgbiwgMCwgMCwgMCwgMCwgMCwgMSwgMF0sIG0pO1xuXHR9LFxuXHRfY29sb3JpemUgPSAobSwgY29sb3IsIGFtb3VudCkgPT4ge1xuXHRcdGxldCBjID0gX3NwbGl0Q29sb3IoY29sb3IpLFxuXHRcdFx0ciA9IGNbMF0gLyAyNTUsXG5cdFx0XHRnID0gY1sxXSAvIDI1NSxcblx0XHRcdGIgPSBjWzJdIC8gMjU1LFxuXHRcdFx0aW52ID0gMSAtIGFtb3VudDtcblx0XHRyZXR1cm4gX2FwcGx5TWF0cml4KFtpbnYgKyBhbW91bnQgKiByICogX2x1bVIsIGFtb3VudCAqIHIgKiBfbHVtRywgYW1vdW50ICogciAqIF9sdW1CLCAwLCAwLCBhbW91bnQgKiBnICogX2x1bVIsIGludiArIGFtb3VudCAqIGcgKiBfbHVtRywgYW1vdW50ICogZyAqIF9sdW1CLCAwLCAwLCBhbW91bnQgKiBiICogX2x1bVIsIGFtb3VudCAqIGIgKiBfbHVtRywgaW52ICsgYW1vdW50ICogYiAqIF9sdW1CLCAwLCAwLCAwLCAwLCAwLCAxLCAwXSwgbSk7XG5cdH0sXG5cdF9zZXRIdWUgPSAobSwgbikgPT4ge1xuXHRcdG4gKj0gTWF0aC5QSSAvIDE4MDtcblx0XHRsZXQgYyA9IE1hdGguY29zKG4pLFxuXHRcdFx0cyA9IE1hdGguc2luKG4pO1xuXHRcdHJldHVybiBfYXBwbHlNYXRyaXgoWyhfbHVtUiArIChjICogKDEgLSBfbHVtUikpKSArIChzICogKC1fbHVtUikpLCAoX2x1bUcgKyAoYyAqICgtX2x1bUcpKSkgKyAocyAqICgtX2x1bUcpKSwgKF9sdW1CICsgKGMgKiAoLV9sdW1CKSkpICsgKHMgKiAoMSAtIF9sdW1CKSksIDAsIDAsIChfbHVtUiArIChjICogKC1fbHVtUikpKSArIChzICogMC4xNDMpLCAoX2x1bUcgKyAoYyAqICgxIC0gX2x1bUcpKSkgKyAocyAqIDAuMTQpLCAoX2x1bUIgKyAoYyAqICgtX2x1bUIpKSkgKyAocyAqIC0wLjI4MyksIDAsIDAsIChfbHVtUiArIChjICogKC1fbHVtUikpKSArIChzICogKC0oMSAtIF9sdW1SKSkpLCAoX2x1bUcgKyAoYyAqICgtX2x1bUcpKSkgKyAocyAqIF9sdW1HKSwgKF9sdW1CICsgKGMgKiAoMSAtIF9sdW1CKSkpICsgKHMgKiBfbHVtQiksIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDFdLCBtKTtcblx0fSxcblx0X3NldENvbnRyYXN0ID0gKG0sIG4pID0+IF9hcHBseU1hdHJpeChbbiwwLDAsMCwwLjUgKiAoMSAtIG4pLCAwLG4sMCwwLDAuNSAqICgxIC0gbiksIDAsMCxuLDAsMC41ICogKDEgLSBuKSwgMCwwLDAsMSwwXSwgbSksXG5cdF9nZXRGaWx0ZXIgPSAodGFyZ2V0LCB0eXBlKSA9PiB7XG5cdFx0bGV0IGZpbHRlckNsYXNzID0gX1BJWEkuZmlsdGVyc1t0eXBlXSxcblx0XHRcdGZpbHRlcnMgPSB0YXJnZXQuZmlsdGVycyB8fCBbXSxcblx0XHRcdGkgPSBmaWx0ZXJzLmxlbmd0aCxcblx0XHRcdGZpbHRlcjtcblx0XHRpZiAoIWZpbHRlckNsYXNzKSB7XG5cdFx0XHRfd2Fybih0eXBlICsgXCIgbm90IGZvdW5kLiBQaXhpUGx1Z2luLnJlZ2lzdGVyUElYSShQSVhJKVwiKTtcblx0XHR9XG5cdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRpZiAoZmlsdGVyc1tpXSBpbnN0YW5jZW9mIGZpbHRlckNsYXNzKSB7XG5cdFx0XHRcdHJldHVybiBmaWx0ZXJzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmaWx0ZXIgPSBuZXcgZmlsdGVyQ2xhc3MoKTtcblx0XHRpZiAodHlwZSA9PT0gXCJCbHVyRmlsdGVyXCIpIHtcblx0XHRcdGZpbHRlci5ibHVyID0gMDtcblx0XHR9XG5cdFx0ZmlsdGVycy5wdXNoKGZpbHRlcik7XG5cdFx0dGFyZ2V0LmZpbHRlcnMgPSBmaWx0ZXJzO1xuXHRcdHJldHVybiBmaWx0ZXI7XG5cdH0sXG5cdF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4gPSAocCwgcGx1Z2luLCBjYWNoZSwgdmFycykgPT4geyAvL3dlIGNhY2hlIHRoZSBDb2xvck1hdHJpeEZpbHRlciBjb21wb25lbnRzIGluIGEgX2dzQ29sb3JNYXRyaXhGaWx0ZXIgb2JqZWN0IGF0dGFjaGVkIHRvIHRoZSB0YXJnZXQgb2JqZWN0IHNvIHRoYXQgaXQncyBlYXN5IHRvIGdyYWIgdGhlIGN1cnJlbnQgdmFsdWUgYXQgYW55IHRpbWUuXG5cdFx0cGx1Z2luLmFkZChjYWNoZSwgcCwgY2FjaGVbcF0sIHZhcnNbcF0pO1xuXHRcdHBsdWdpbi5fcHJvcHMucHVzaChwKTtcblx0fSxcblx0X2FwcGx5QnJpZ2h0bmVzc1RvTWF0cml4ID0gKGJyaWdodG5lc3MsIG1hdHJpeCkgPT4ge1xuXHRcdGxldCB0ZW1wID0gbmV3IF9QSVhJLmZpbHRlcnMuQ29sb3JNYXRyaXhGaWx0ZXIoKTtcblx0XHR0ZW1wLm1hdHJpeCA9IG1hdHJpeDtcblx0XHR0ZW1wLmJyaWdodG5lc3MoYnJpZ2h0bmVzcywgdHJ1ZSk7XG5cdFx0cmV0dXJuIHRlbXAubWF0cml4O1xuXHR9LFxuXHRfY29weSA9IG9iaiA9PiB7XG5cdFx0bGV0IGNvcHkgPSB7fSxcblx0XHRcdHA7XG5cdFx0Zm9yIChwIGluIG9iaikge1xuXHRcdFx0Y29weVtwXSA9IG9ialtwXTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvcHk7XG5cdH0sXG5cdF9DTUZkZWZhdWx0cyA9IHtjb250cmFzdDoxLCBzYXR1cmF0aW9uOjEsIGNvbG9yaXplQW1vdW50OjAsIGNvbG9yaXplOlwicmdiKDI1NSwyNTUsMjU1KVwiLCBodWU6MCwgYnJpZ2h0bmVzczoxfSxcblx0X3BhcnNlQ29sb3JNYXRyaXhGaWx0ZXIgPSAodGFyZ2V0LCB2LCBwZykgPT4ge1xuXHRcdGxldCBmaWx0ZXIgPSBfZ2V0RmlsdGVyKHRhcmdldCwgXCJDb2xvck1hdHJpeEZpbHRlclwiKSxcblx0XHRcdGNhY2hlID0gdGFyZ2V0Ll9nc0NvbG9yTWF0cml4RmlsdGVyID0gdGFyZ2V0Ll9nc0NvbG9yTWF0cml4RmlsdGVyIHx8IF9jb3B5KF9DTUZkZWZhdWx0cyksXG5cdFx0XHRjb21iaW5lID0gdi5jb21iaW5lQ01GICYmICEoXCJjb2xvck1hdHJpeEZpbHRlclwiIGluIHYgJiYgIXYuY29sb3JNYXRyaXhGaWx0ZXIpLFxuXHRcdFx0aSwgbWF0cml4LCBzdGFydE1hdHJpeDtcblx0XHRzdGFydE1hdHJpeCA9IGZpbHRlci5tYXRyaXg7XG5cdFx0aWYgKHYucmVzb2x1dGlvbikge1xuXHRcdFx0ZmlsdGVyLnJlc29sdXRpb24gPSB2LnJlc29sdXRpb247XG5cdFx0fVxuXHRcdGlmICh2Lm1hdHJpeCAmJiB2Lm1hdHJpeC5sZW5ndGggPT09IHN0YXJ0TWF0cml4Lmxlbmd0aCkge1xuXHRcdFx0bWF0cml4ID0gdi5tYXRyaXg7XG5cdFx0XHRpZiAoY2FjaGUuY29udHJhc3QgIT09IDEpIHtcblx0XHRcdFx0X2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbnRyYXN0XCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcblx0XHRcdH1cblx0XHRcdGlmIChjYWNoZS5odWUpIHtcblx0XHRcdFx0X2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImh1ZVwiLCBwZywgY2FjaGUsIF9DTUZkZWZhdWx0cyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2FjaGUuYnJpZ2h0bmVzcyAhPT0gMSkge1xuXHRcdFx0XHRfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiYnJpZ2h0bmVzc1wiLCBwZywgY2FjaGUsIF9DTUZkZWZhdWx0cyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2FjaGUuY29sb3JpemVBbW91bnQpIHtcblx0XHRcdFx0X2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbG9yaXplXCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcblx0XHRcdFx0X2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbG9yaXplQW1vdW50XCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcblx0XHRcdH1cblx0XHRcdGlmIChjYWNoZS5zYXR1cmF0aW9uICE9PSAxKSB7XG5cdFx0XHRcdF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJzYXR1cmF0aW9uXCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRyaXggPSBfaWRNYXRyaXguc2xpY2UoKTtcblx0XHRcdGlmICh2LmNvbnRyYXN0ICE9IG51bGwpIHtcblx0XHRcdFx0bWF0cml4ID0gX3NldENvbnRyYXN0KG1hdHJpeCwgK3YuY29udHJhc3QpO1xuXHRcdFx0XHRfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiY29udHJhc3RcIiwgcGcsIGNhY2hlLCB2KTtcblx0XHRcdH0gZWxzZSBpZiAoY2FjaGUuY29udHJhc3QgIT09IDEpIHtcblx0XHRcdFx0aWYgKGNvbWJpbmUpIHtcblx0XHRcdFx0XHRtYXRyaXggPSBfc2V0Q29udHJhc3QobWF0cml4LCBjYWNoZS5jb250cmFzdCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbnRyYXN0XCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHYuaHVlICE9IG51bGwpIHtcblx0XHRcdFx0bWF0cml4ID0gX3NldEh1ZShtYXRyaXgsICt2Lmh1ZSk7XG5cdFx0XHRcdF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJodWVcIiwgcGcsIGNhY2hlLCB2KTtcblx0XHRcdH0gZWxzZSBpZiAoY2FjaGUuaHVlKSB7XG5cdFx0XHRcdGlmIChjb21iaW5lKSB7XG5cdFx0XHRcdFx0bWF0cml4ID0gX3NldEh1ZShtYXRyaXgsIGNhY2hlLmh1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImh1ZVwiLCBwZywgY2FjaGUsIF9DTUZkZWZhdWx0cyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh2LmJyaWdodG5lc3MgIT0gbnVsbCkge1xuXHRcdFx0XHRtYXRyaXggPSBfYXBwbHlCcmlnaHRuZXNzVG9NYXRyaXgoK3YuYnJpZ2h0bmVzcywgbWF0cml4KTtcblx0XHRcdFx0X2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImJyaWdodG5lc3NcIiwgcGcsIGNhY2hlLCB2KTtcblx0XHRcdH0gZWxzZSBpZiAoY2FjaGUuYnJpZ2h0bmVzcyAhPT0gMSkge1xuXHRcdFx0XHRpZiAoY29tYmluZSkge1xuXHRcdFx0XHRcdG1hdHJpeCA9IF9hcHBseUJyaWdodG5lc3NUb01hdHJpeChjYWNoZS5icmlnaHRuZXNzLCBtYXRyaXgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJicmlnaHRuZXNzXCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHYuY29sb3JpemUgIT0gbnVsbCkge1xuXHRcdFx0XHR2LmNvbG9yaXplQW1vdW50ID0gKFwiY29sb3JpemVBbW91bnRcIiBpbiB2KSA/ICt2LmNvbG9yaXplQW1vdW50IDogMTtcblx0XHRcdFx0bWF0cml4ID0gX2NvbG9yaXplKG1hdHJpeCwgdi5jb2xvcml6ZSwgdi5jb2xvcml6ZUFtb3VudCk7XG5cdFx0XHRcdF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJjb2xvcml6ZVwiLCBwZywgY2FjaGUsIHYpO1xuXHRcdFx0XHRfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiY29sb3JpemVBbW91bnRcIiwgcGcsIGNhY2hlLCB2KTtcblx0XHRcdH0gZWxzZSBpZiAoY2FjaGUuY29sb3JpemVBbW91bnQpIHtcblx0XHRcdFx0aWYgKGNvbWJpbmUpIHtcblx0XHRcdFx0XHRtYXRyaXggPSBfY29sb3JpemUobWF0cml4LCBjYWNoZS5jb2xvcml6ZSwgY2FjaGUuY29sb3JpemVBbW91bnQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJjb2xvcml6ZVwiLCBwZywgY2FjaGUsIF9DTUZkZWZhdWx0cyk7XG5cdFx0XHRcdFx0X2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbG9yaXplQW1vdW50XCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHYuc2F0dXJhdGlvbiAhPSBudWxsKSB7XG5cdFx0XHRcdG1hdHJpeCA9IF9zZXRTYXR1cmF0aW9uKG1hdHJpeCwgK3Yuc2F0dXJhdGlvbik7XG5cdFx0XHRcdF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJzYXR1cmF0aW9uXCIsIHBnLCBjYWNoZSwgdik7XG5cdFx0XHR9IGVsc2UgaWYgKGNhY2hlLnNhdHVyYXRpb24gIT09IDEpIHtcblx0XHRcdFx0aWYgKGNvbWJpbmUpIHtcblx0XHRcdFx0XHRtYXRyaXggPSBfc2V0U2F0dXJhdGlvbihtYXRyaXgsIGNhY2hlLnNhdHVyYXRpb24pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJzYXR1cmF0aW9uXCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpID0gbWF0cml4Lmxlbmd0aDtcblx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdGlmIChtYXRyaXhbaV0gIT09IHN0YXJ0TWF0cml4W2ldKSB7XG5cdFx0XHRcdHBnLmFkZChzdGFydE1hdHJpeCwgaSwgc3RhcnRNYXRyaXhbaV0sIG1hdHJpeFtpXSwgXCJjb2xvck1hdHJpeEZpbHRlclwiKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cGcuX3Byb3BzLnB1c2goXCJjb2xvck1hdHJpeEZpbHRlclwiKTtcblx0fSxcblx0X3JlbmRlckNvbG9yID0gKHJhdGlvLCB7dCwgcCwgY29sb3IsIHNldH0pID0+IHtcblx0XHRzZXQodCwgcCwgY29sb3JbMF0gPDwgMTYgfCBjb2xvclsxXSA8PCA4IHwgY29sb3JbMl0pO1xuXHR9LFxuXHRfcmVuZGVyRGlydHlDYWNoZSA9IChyYXRpbywge2d9KSA9PiB7XG5cdFx0aWYgKGcpIHsgLy9pbiBvcmRlciBmb3IgUGl4aUpTIHRvIGFjdHVhbGx5IHJlZHJhdyBHcmFwaGljc0RhdGEsIHdlJ3ZlIGdvdHRhIGluY3JlbWVudCB0aGUgXCJkaXJ0eVwiIGFuZCBcImNsZWFyRGlydHlcIiB2YWx1ZXMuIElmIHdlIGRvbid0IGRvIHRoaXMsIHRoZSB2YWx1ZXMgd2lsbCBiZSB0d2VlbiBwcm9wZXJseSwgYnV0IG5vdCByZW5kZXJlZC5cblx0XHRcdGcuZGlydHkrKztcblx0XHRcdGcuY2xlYXJEaXJ0eSsrO1xuXHRcdH1cblx0fSxcblx0X3JlbmRlckF1dG9BbHBoYSA9IChyYXRpbywgZGF0YSkgPT4ge1xuXHRcdGRhdGEudC52aXNpYmxlID0gISFkYXRhLnQuYWxwaGE7XG5cdH0sXG5cdF9hZGRDb2xvclR3ZWVuID0gKHRhcmdldCwgcCwgdmFsdWUsIHBsdWdpbikgPT4ge1xuXHRcdGxldCBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcF0sXG5cdFx0XHRzdGFydENvbG9yID0gX3NwbGl0Q29sb3IoX2lzRnVuY3Rpb24oY3VycmVudFZhbHVlKSA/IHRhcmdldFsgKChwLmluZGV4T2YoXCJzZXRcIikgfHwgIV9pc0Z1bmN0aW9uKHRhcmdldFtcImdldFwiICsgcC5zdWJzdHIoMyldKSkgPyBwIDogXCJnZXRcIiArIHAuc3Vic3RyKDMpKSBdKCkgOiBjdXJyZW50VmFsdWUpLFxuXHRcdFx0ZW5kQ29sb3IgPSBfc3BsaXRDb2xvcih2YWx1ZSk7XG5cdFx0cGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwLCAwLCAwLCBfcmVuZGVyQ29sb3IsIHt0OnRhcmdldCwgcDpwLCBjb2xvcjpzdGFydENvbG9yLCBzZXQ6X2dldFNldHRlcih0YXJnZXQsIHApfSk7XG5cdFx0cGx1Z2luLmFkZChzdGFydENvbG9yLCAwLCBzdGFydENvbG9yWzBdLCBlbmRDb2xvclswXSk7XG5cdFx0cGx1Z2luLmFkZChzdGFydENvbG9yLCAxLCBzdGFydENvbG9yWzFdLCBlbmRDb2xvclsxXSk7XG5cdFx0cGx1Z2luLmFkZChzdGFydENvbG9yLCAyLCBzdGFydENvbG9yWzJdLCBlbmRDb2xvclsyXSk7XG5cdH0sXG5cblx0X2NvbG9yUHJvcHMgPSB7dGludDoxLCBsaW5lQ29sb3I6MSwgZmlsbENvbG9yOjF9LFxuXHRfeHlDb250ZXh0cyA9IFwicG9zaXRpb24sc2NhbGUsc2tldyxwaXZvdCxhbmNob3IsdGlsZVBvc2l0aW9uLHRpbGVTY2FsZVwiLnNwbGl0KFwiLFwiKSxcblx0X2NvbnRleHRzID0ge3g6XCJwb3NpdGlvblwiLCB5OlwicG9zaXRpb25cIiwgdGlsZVg6XCJ0aWxlUG9zaXRpb25cIiwgdGlsZVk6XCJ0aWxlUG9zaXRpb25cIn0sXG5cdF9jb2xvck1hdHJpeEZpbHRlclByb3BzID0ge2NvbG9yTWF0cml4RmlsdGVyOjEsIHNhdHVyYXRpb246MSwgY29udHJhc3Q6MSwgaHVlOjEsIGNvbG9yaXplOjEsIGNvbG9yaXplQW1vdW50OjEsIGJyaWdodG5lc3M6MSwgY29tYmluZUNNRjoxfSxcblx0X0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuXHRfaXNTdHJpbmcgPSB2YWx1ZSA9PiB0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiLFxuXHRfZGVncmVlc1RvUmFkaWFucyA9IHZhbHVlID0+IChfaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlLmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gdmFsdWUuc3Vic3RyKDAsIDIpICsgKHBhcnNlRmxvYXQodmFsdWUuc3Vic3RyKDIpKSAqIF9ERUcyUkFEKSA6IHZhbHVlICogX0RFRzJSQUQsXG5cdF9yZW5kZXJQcm9wV2l0aEVuZCA9IChyYXRpbywgZGF0YSkgPT4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID09PSAxID8gZGF0YS5lIDogKE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwMCkgLyAxMDAwMDApLCBkYXRhKSxcblx0X2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4gPSAocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBzdGFydE51bSwgZW5kVmFsdWUsIHJhZGlhbnMpID0+IHtcblx0XHRsZXQgY2FwID0gMzYwICogKHJhZGlhbnMgPyBfREVHMlJBRCA6IDEpLFxuXHRcdFx0aXNTdHJpbmcgPSBfaXNTdHJpbmcoZW5kVmFsdWUpLFxuXHRcdFx0cmVsYXRpdmUgPSAoaXNTdHJpbmcgJiYgZW5kVmFsdWUuY2hhckF0KDEpID09PSBcIj1cIikgPyArKGVuZFZhbHVlLmNoYXJBdCgwKSArIFwiMVwiKSA6IDAsXG5cdFx0XHRlbmROdW0gPSBwYXJzZUZsb2F0KHJlbGF0aXZlID8gZW5kVmFsdWUuc3Vic3RyKDIpIDogZW5kVmFsdWUpICogKHJhZGlhbnMgPyBfREVHMlJBRCA6IDEpLFxuXHRcdFx0Y2hhbmdlID0gcmVsYXRpdmUgPyBlbmROdW0gKiByZWxhdGl2ZSA6IGVuZE51bSAtIHN0YXJ0TnVtLFxuXHRcdFx0ZmluYWxWYWx1ZSA9IHN0YXJ0TnVtICsgY2hhbmdlLFxuXHRcdFx0ZGlyZWN0aW9uLCBwdDtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdGRpcmVjdGlvbiA9IGVuZFZhbHVlLnNwbGl0KFwiX1wiKVsxXTtcblx0XHRcdGlmIChkaXJlY3Rpb24gPT09IFwic2hvcnRcIikge1xuXHRcdFx0XHRjaGFuZ2UgJT0gY2FwO1xuXHRcdFx0XHRpZiAoY2hhbmdlICE9PSBjaGFuZ2UgJSAoY2FwIC8gMikpIHtcblx0XHRcdFx0XHRjaGFuZ2UgKz0gKGNoYW5nZSA8IDApID8gY2FwIDogLWNhcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRpcmVjdGlvbiA9PT0gXCJjd1wiICYmIGNoYW5nZSA8IDApIHtcblx0XHRcdFx0Y2hhbmdlID0gKChjaGFuZ2UgKyBjYXAgKiAxZTEwKSAlIGNhcCkgLSB+fihjaGFuZ2UgLyBjYXApICogY2FwO1xuXHRcdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFwiY2N3XCIgJiYgY2hhbmdlID4gMCkge1xuXHRcdFx0XHRjaGFuZ2UgPSAoKGNoYW5nZSAtIGNhcCAqIDFlMTApICUgY2FwKSAtIH5+KGNoYW5nZSAvIGNhcCkgKiBjYXA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHBsdWdpbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnROdW0sIGNoYW5nZSwgX3JlbmRlclByb3BXaXRoRW5kKTtcblx0XHRwdC5lID0gZmluYWxWYWx1ZTtcblx0XHRyZXR1cm4gcHQ7XG5cdH0sXG5cdF9pbml0Q29yZSA9ICgpID0+IHtcblx0XHRpZiAoX3dpbmRvd0V4aXN0cygpKSB7XG5cdFx0XHRfd2luID0gd2luZG93O1xuXHRcdFx0Z3NhcCA9IF9jb3JlSW5pdHRlZCA9IF9nZXRHU0FQKCk7XG5cdFx0XHRfUElYSSA9IF9QSVhJIHx8IF93aW4uUElYSTtcblx0XHRcdF9zcGxpdENvbG9yID0gY29sb3IgPT4gZ3NhcC51dGlscy5zcGxpdENvbG9yKChjb2xvciArIFwiXCIpLnN1YnN0cigwLDIpID09PSBcIjB4XCIgPyBcIiNcIiArIGNvbG9yLnN1YnN0cigyKSA6IGNvbG9yKTsgLy8gc29tZSBjb2xvcnMgaW4gUElYSSBhcmUgcmVwb3J0ZWQgYXMgXCIweEZGNDQyMVwiIGluc3RlYWQgb2YgXCIjRkY0NDIxXCIuXG5cdFx0fVxuXHR9LCBpLCBwO1xuXG4vL2NvbnRleHQgc2V0dXAuLi5cbmZvciAoaSA9IDA7IGkgPCBfeHlDb250ZXh0cy5sZW5ndGg7IGkrKykge1xuXHRwID0gX3h5Q29udGV4dHNbaV07XG5cdF9jb250ZXh0c1twICsgXCJYXCJdID0gcDtcblx0X2NvbnRleHRzW3AgKyBcIllcIl0gPSBwO1xufVxuXG5cbmV4cG9ydCBjb25zdCBQaXhpUGx1Z2luID0ge1xuXHR2ZXJzaW9uOlwiMy43LjBcIixcblx0bmFtZTpcInBpeGlcIixcblx0cmVnaXN0ZXIoY29yZSwgUGx1Z2luLCBwcm9wVHdlZW4pIHtcblx0XHRnc2FwID0gY29yZTtcblx0XHRQcm9wVHdlZW4gPSBwcm9wVHdlZW47XG5cdFx0X2dldFNldHRlciA9IFBsdWdpbi5nZXRTZXR0ZXI7XG5cdFx0X2luaXRDb3JlKCk7XG5cdH0sXG5cdHJlZ2lzdGVyUElYSShwaXhpKSB7XG5cdFx0X1BJWEkgPSBwaXhpO1xuXHR9LFxuXHRpbml0KHRhcmdldCwgdmFsdWVzLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcblx0XHRpZiAoIV9QSVhJKSB7XG5cdFx0XHRfaW5pdENvcmUoKTtcblx0XHR9XG5cdFx0aWYgKCF0YXJnZXQgaW5zdGFuY2VvZiBfUElYSS5EaXNwbGF5T2JqZWN0KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGxldCBpc1Y0ID0gX1BJWEkuVkVSU0lPTi5jaGFyQXQoMCkgPT09IFwiNFwiLFxuXHRcdFx0Y29udGV4dCwgYXhpcywgdmFsdWUsIGNvbG9yTWF0cml4LCBmaWx0ZXIsIHAsIHBhZGRpbmcsIGksIGRhdGE7XG5cdFx0Zm9yIChwIGluIHZhbHVlcykge1xuXHRcdFx0Y29udGV4dCA9IF9jb250ZXh0c1twXTtcblx0XHRcdHZhbHVlID0gdmFsdWVzW3BdO1xuXHRcdFx0aWYgKGNvbnRleHQpIHtcblx0XHRcdFx0YXhpcyA9IH5wLmNoYXJBdChwLmxlbmd0aC0xKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJ4XCIpID8gXCJ4XCIgOiBcInlcIjtcblx0XHRcdFx0dGhpcy5hZGQodGFyZ2V0W2NvbnRleHRdLCBheGlzLCB0YXJnZXRbY29udGV4dF1bYXhpc10sIChjb250ZXh0ID09PSBcInNrZXdcIikgPyBfZGVncmVlc1RvUmFkaWFucyh2YWx1ZSkgOiB2YWx1ZSk7XG5cdFx0XHR9IGVsc2UgaWYgKHAgPT09IFwic2NhbGVcIiB8fCBwID09PSBcImFuY2hvclwiIHx8IHAgPT09IFwicGl2b3RcIiB8fCBwID09PSBcInRpbGVTY2FsZVwiKSB7XG5cdFx0XHRcdHRoaXMuYWRkKHRhcmdldFtwXSwgXCJ4XCIsIHRhcmdldFtwXS54LCB2YWx1ZSk7XG5cdFx0XHRcdHRoaXMuYWRkKHRhcmdldFtwXSwgXCJ5XCIsIHRhcmdldFtwXS55LCB2YWx1ZSk7XG5cdFx0XHR9IGVsc2UgaWYgKHAgPT09IFwicm90YXRpb25cIiB8fCBwID09PSBcImFuZ2xlXCIpIHsgLy9QSVhJIGV4cGVjdHMgcm90YXRpb24gaW4gcmFkaWFucywgYnV0IGFzIGEgY29udmVuaWVuY2Ugd2UgbGV0IGZvbGtzIGRlZmluZSBpdCBpbiBkZWdyZWVzIGFuZCB3ZSBkbyB0aGUgY29udmVyc2lvbi5cblx0XHRcdFx0X2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4odGhpcywgdGFyZ2V0LCBwLCB0YXJnZXRbcF0sIHZhbHVlLCBwID09PSBcInJvdGF0aW9uXCIpO1xuXHRcdFx0fSBlbHNlIGlmIChfY29sb3JNYXRyaXhGaWx0ZXJQcm9wc1twXSkge1xuXHRcdFx0XHRpZiAoIWNvbG9yTWF0cml4KSB7XG5cdFx0XHRcdFx0X3BhcnNlQ29sb3JNYXRyaXhGaWx0ZXIodGFyZ2V0LCB2YWx1ZXMuY29sb3JNYXRyaXhGaWx0ZXIgfHwgdmFsdWVzLCB0aGlzKTtcblx0XHRcdFx0XHRjb2xvck1hdHJpeCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAocCA9PT0gXCJibHVyXCIgfHwgcCA9PT0gXCJibHVyWFwiIHx8IHAgPT09IFwiYmx1cllcIiB8fCBwID09PSBcImJsdXJQYWRkaW5nXCIpIHtcblx0XHRcdFx0ZmlsdGVyID0gX2dldEZpbHRlcih0YXJnZXQsIFwiQmx1ckZpbHRlclwiKTtcblx0XHRcdFx0dGhpcy5hZGQoZmlsdGVyLCBwLCBmaWx0ZXJbcF0sIHZhbHVlKTtcblx0XHRcdFx0aWYgKHZhbHVlcy5ibHVyUGFkZGluZyAhPT0gMCkge1xuXHRcdFx0XHRcdHBhZGRpbmcgPSB2YWx1ZXMuYmx1clBhZGRpbmcgfHwgTWF0aC5tYXgoZmlsdGVyW3BdLCB2YWx1ZSkgKiAyO1xuXHRcdFx0XHRcdGkgPSB0YXJnZXQuZmlsdGVycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQuZmlsdGVyc1tpXS5wYWRkaW5nID0gTWF0aC5tYXgodGFyZ2V0LmZpbHRlcnNbaV0ucGFkZGluZywgcGFkZGluZyk7IC8vaWYgd2UgZG9uJ3QgZXhwYW5kIHRoZSBwYWRkaW5nIG9uIGFsbCB0aGUgZmlsdGVycywgaXQgY2FuIGxvb2sgY2xpcHBlZC5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoX2NvbG9yUHJvcHNbcF0pIHtcblx0XHRcdFx0aWYgKChwID09PSBcImxpbmVDb2xvclwiIHx8IHAgPT09IFwiZmlsbENvbG9yXCIpICYmIHRhcmdldCBpbnN0YW5jZW9mIF9QSVhJLkdyYXBoaWNzKSB7XG5cdFx0XHRcdFx0ZGF0YSA9ICh0YXJnZXQuZ2VvbWV0cnkgfHwgdGFyZ2V0KS5ncmFwaGljc0RhdGE7IC8vXCJnZW9tZXRyeVwiIHdhcyBpbnRyb2R1Y2VkIGluIFBJWEkgdmVyc2lvbiA1XG5cdFx0XHRcdFx0dGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQsIHAsIDAsIDAsIF9yZW5kZXJEaXJ0eUNhY2hlLCB7ZzogdGFyZ2V0Lmdlb21ldHJ5IHx8IHRhcmdldH0pO1xuXHRcdFx0XHRcdGkgPSBkYXRhLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdF9hZGRDb2xvclR3ZWVuKGlzVjQgPyBkYXRhW2ldIDogZGF0YVtpXVtwLnN1YnN0cigwLCA0KSArIFwiU3R5bGVcIl0sIGlzVjQgPyBwIDogXCJjb2xvclwiLCB2YWx1ZSwgdGhpcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9hZGRDb2xvclR3ZWVuKHRhcmdldCwgcCwgdmFsdWUsIHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHAgPT09IFwiYXV0b0FscGhhXCIpIHtcblx0XHRcdFx0dGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQsIFwidmlzaWJsZVwiLCAwLCAwLCBfcmVuZGVyQXV0b0FscGhhKTtcblx0XHRcdFx0dGhpcy5hZGQodGFyZ2V0LCBcImFscGhhXCIsIHRhcmdldC5hbHBoYSwgdmFsdWUpO1xuXHRcdFx0XHR0aGlzLl9wcm9wcy5wdXNoKFwiYWxwaGFcIiwgXCJ2aXNpYmxlXCIpO1xuXHRcdFx0fSBlbHNlIGlmIChwICE9PSBcInJlc29sdXRpb25cIikge1xuXHRcdFx0XHR0aGlzLmFkZCh0YXJnZXQsIHAsIFwiZ2V0XCIsIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3Byb3BzLnB1c2gocCk7XG5cdFx0fVxuXHR9XG59O1xuXG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oUGl4aVBsdWdpbik7XG5cbmV4cG9ydCB7IFBpeGlQbHVnaW4gYXMgZGVmYXVsdCB9OyIsIi8qIVxuICogU2Nyb2xsVG9QbHVnaW4gMy43LjBcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5sZXQgZ3NhcCwgX2NvcmVJbml0dGVkLCBfd2luZG93LCBfZG9jRWwsIF9ib2R5LCBfdG9BcnJheSwgX2NvbmZpZyxcblx0X3dpbmRvd0V4aXN0cyA9ICgpID0+IHR5cGVvZih3aW5kb3cpICE9PSBcInVuZGVmaW5lZFwiLFxuXHRfZ2V0R1NBUCA9ICgpID0+IGdzYXAgfHwgKF93aW5kb3dFeGlzdHMoKSAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXApLFxuXHRfaXNTdHJpbmcgPSB2YWx1ZSA9PiB0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiLFxuXHRfaXNGdW5jdGlvbiA9IHZhbHVlID0+IHR5cGVvZih2YWx1ZSkgPT09IFwiZnVuY3Rpb25cIixcblx0X21heCA9IChlbGVtZW50LCBheGlzKSA9PiB7XG5cdFx0bGV0IGRpbSA9IChheGlzID09PSBcInhcIikgPyBcIldpZHRoXCIgOiBcIkhlaWdodFwiLFxuXHRcdFx0c2Nyb2xsID0gXCJzY3JvbGxcIiArIGRpbSxcblx0XHRcdGNsaWVudCA9IFwiY2xpZW50XCIgKyBkaW07XG5cdFx0cmV0dXJuIChlbGVtZW50ID09PSBfd2luZG93IHx8IGVsZW1lbnQgPT09IF9kb2NFbCB8fCBlbGVtZW50ID09PSBfYm9keSkgPyBNYXRoLm1heChfZG9jRWxbc2Nyb2xsXSwgX2JvZHlbc2Nyb2xsXSkgLSAoX3dpbmRvd1tcImlubmVyXCIgKyBkaW1dIHx8IF9kb2NFbFtjbGllbnRdIHx8IF9ib2R5W2NsaWVudF0pIDogZWxlbWVudFtzY3JvbGxdIC0gZWxlbWVudFtcIm9mZnNldFwiICsgZGltXTtcblx0fSxcblx0X2J1aWxkR2V0dGVyID0gKGUsIGF4aXMpID0+IHsgLy9wYXNzIGluIGFuIGVsZW1lbnQgYW5kIGFuIGF4aXMgKFwieFwiIG9yIFwieVwiKSBhbmQgaXQnbGwgcmV0dXJuIGEgZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoYXQgZWxlbWVudCAobGlrZSBzY3JvbGxUb3Agb3Igc2Nyb2xsTGVmdCwgYWx0aG91Z2ggaWYgdGhlIGVsZW1lbnQgaXMgdGhlIHdpbmRvdywgaXQnbGwgdXNlIHRoZSBwYWdlWE9mZnNldC9wYWdlWU9mZnNldCBvciB0aGUgZG9jdW1lbnRFbGVtZW50J3Mgc2Nyb2xsVG9wL3Njcm9sbExlZnQgb3IgZG9jdW1lbnQuYm9keSdzLiBCYXNpY2FsbHkgdGhpcyBzdHJlYW1saW5lcyB0aGluZ3MgYW5kIG1ha2VzIGEgdmVyeSBmYXN0IGdldHRlciBhY3Jvc3MgYnJvd3NlcnMuXG5cdFx0bGV0IHAgPSBcInNjcm9sbFwiICsgKChheGlzID09PSBcInhcIikgPyBcIkxlZnRcIiA6IFwiVG9wXCIpO1xuXHRcdGlmIChlID09PSBfd2luZG93KSB7XG5cdFx0XHRpZiAoZS5wYWdlWE9mZnNldCAhPSBudWxsKSB7XG5cdFx0XHRcdHAgPSBcInBhZ2VcIiArIGF4aXMudG9VcHBlckNhc2UoKSArIFwiT2Zmc2V0XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlID0gX2RvY0VsW3BdICE9IG51bGwgPyBfZG9jRWwgOiBfYm9keTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuICgpID0+IGVbcF07XG5cdH0sXG5cdF9jbGVhbiA9ICh2YWx1ZSwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykgPT4ge1xuXHRcdF9pc0Z1bmN0aW9uKHZhbHVlKSAmJiAodmFsdWUgPSB2YWx1ZShpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG5cdFx0aWYgKHR5cGVvZih2YWx1ZSkgIT09IFwib2JqZWN0XCIpIHtcblx0XHRcdHJldHVybiBfaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlICE9PSBcIm1heFwiICYmIHZhbHVlLmNoYXJBdCgxKSAhPT0gXCI9XCIgPyB7eDogdmFsdWUsIHk6IHZhbHVlfSA6IHt5OiB2YWx1ZX07IC8vaWYgd2UgZG9uJ3QgcmVjZWl2ZSBhbiBvYmplY3QgYXMgdGhlIHBhcmFtZXRlciwgYXNzdW1lIHRoZSB1c2VyIGludGVuZHMgXCJ5XCIuXG5cdFx0fSBlbHNlIGlmICh2YWx1ZS5ub2RlVHlwZSkge1xuXHRcdFx0cmV0dXJuIHt5OiB2YWx1ZSwgeDogdmFsdWV9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgcmVzdWx0ID0ge30sIHA7XG5cdFx0XHRmb3IgKHAgaW4gdmFsdWUpIHtcblx0XHRcdFx0cmVzdWx0W3BdID0gcCAhPT0gXCJvbkF1dG9LaWxsXCIgJiYgX2lzRnVuY3Rpb24odmFsdWVbcF0pID8gdmFsdWVbcF0oaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykgOiB2YWx1ZVtwXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9LFxuXHRfZ2V0T2Zmc2V0ID0gKGVsZW1lbnQsIGNvbnRhaW5lcikgPT4ge1xuXHRcdGVsZW1lbnQgPSBfdG9BcnJheShlbGVtZW50KVswXTtcblx0XHRpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG5cdFx0XHRyZXR1cm4gY29uc29sZS53YXJuKFwic2Nyb2xsVG8gdGFyZ2V0IGRvZXNuJ3QgZXhpc3QuIFVzaW5nIDBcIikgfHwge3g6MCwgeTowfTtcblx0XHR9XG5cdFx0bGV0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuXHRcdFx0aXNSb290ID0gKCFjb250YWluZXIgfHwgY29udGFpbmVyID09PSBfd2luZG93IHx8IGNvbnRhaW5lciA9PT0gX2JvZHkpLFxuXHRcdFx0Y1JlY3QgPSBpc1Jvb3QgPyB7dG9wOl9kb2NFbC5jbGllbnRUb3AgLSAoX3dpbmRvdy5wYWdlWU9mZnNldCB8fCBfZG9jRWwuc2Nyb2xsVG9wIHx8IF9ib2R5LnNjcm9sbFRvcCB8fCAwKSwgbGVmdDpfZG9jRWwuY2xpZW50TGVmdCAtIChfd2luZG93LnBhZ2VYT2Zmc2V0IHx8IF9kb2NFbC5zY3JvbGxMZWZ0IHx8IF9ib2R5LnNjcm9sbExlZnQgfHwgMCl9IDogY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuXHRcdFx0b2Zmc2V0cyA9IHt4OiByZWN0LmxlZnQgLSBjUmVjdC5sZWZ0LCB5OiByZWN0LnRvcCAtIGNSZWN0LnRvcH07XG5cdFx0aWYgKCFpc1Jvb3QgJiYgY29udGFpbmVyKSB7IC8vb25seSBhZGQgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIGlmIGl0J3Mgbm90IHRoZSB3aW5kb3cvYm9keS5cblx0XHRcdG9mZnNldHMueCArPSBfYnVpbGRHZXR0ZXIoY29udGFpbmVyLCBcInhcIikoKTtcblx0XHRcdG9mZnNldHMueSArPSBfYnVpbGRHZXR0ZXIoY29udGFpbmVyLCBcInlcIikoKTtcblx0XHR9XG5cdFx0cmV0dXJuIG9mZnNldHM7XG5cdH0sXG5cdF9wYXJzZVZhbCA9ICh2YWx1ZSwgdGFyZ2V0LCBheGlzLCBjdXJyZW50VmFsLCBvZmZzZXQpID0+ICFpc05hTih2YWx1ZSkgJiYgdHlwZW9mKHZhbHVlKSAhPT0gXCJvYmplY3RcIiA/IHBhcnNlRmxvYXQodmFsdWUpIC0gb2Zmc2V0IDogKF9pc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuY2hhckF0KDEpID09PSBcIj1cIikgPyBwYXJzZUZsb2F0KHZhbHVlLnN1YnN0cigyKSkgKiAodmFsdWUuY2hhckF0KDApID09PSBcIi1cIiA/IC0xIDogMSkgKyBjdXJyZW50VmFsIC0gb2Zmc2V0IDogKHZhbHVlID09PSBcIm1heFwiKSA/IF9tYXgodGFyZ2V0LCBheGlzKSAtIG9mZnNldCA6IE1hdGgubWluKF9tYXgodGFyZ2V0LCBheGlzKSwgX2dldE9mZnNldCh2YWx1ZSwgdGFyZ2V0KVtheGlzXSAtIG9mZnNldCksXG5cdF9pbml0Q29yZSA9ICgpID0+IHtcblx0XHRnc2FwID0gX2dldEdTQVAoKTtcblx0XHRpZiAoX3dpbmRvd0V4aXN0cygpICYmIGdzYXAgJiYgZG9jdW1lbnQuYm9keSkge1xuXHRcdFx0X3dpbmRvdyA9IHdpbmRvdztcblx0XHRcdF9ib2R5ID0gZG9jdW1lbnQuYm9keTtcblx0XHRcdF9kb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0XHRcdF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuXHRcdFx0Z3NhcC5jb25maWcoe2F1dG9LaWxsVGhyZXNob2xkOjd9KTtcblx0XHRcdF9jb25maWcgPSBnc2FwLmNvbmZpZygpO1xuXHRcdFx0X2NvcmVJbml0dGVkID0gMTtcblx0XHR9XG5cdH07XG5cblxuZXhwb3J0IGNvbnN0IFNjcm9sbFRvUGx1Z2luID0ge1xuXHR2ZXJzaW9uOiBcIjMuNy4wXCIsXG5cdG5hbWU6IFwic2Nyb2xsVG9cIixcblx0cmF3VmFyczogMSxcblx0cmVnaXN0ZXIoY29yZSkge1xuXHRcdGdzYXAgPSBjb3JlO1xuXHRcdF9pbml0Q29yZSgpO1xuXHR9LFxuXHRpbml0KHRhcmdldCwgdmFsdWUsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xuXHRcdF9jb3JlSW5pdHRlZCB8fCBfaW5pdENvcmUoKTtcblx0XHRsZXQgZGF0YSA9IHRoaXMsXG5cdFx0XHRzbmFwVHlwZSA9IGdzYXAuZ2V0UHJvcGVydHkodGFyZ2V0LCBcInNjcm9sbFNuYXBUeXBlXCIpO1xuXHRcdGRhdGEuaXNXaW4gPSAodGFyZ2V0ID09PSBfd2luZG93KTtcblx0XHRkYXRhLnRhcmdldCA9IHRhcmdldDtcblx0XHRkYXRhLnR3ZWVuID0gdHdlZW47XG5cdFx0dmFsdWUgPSBfY2xlYW4odmFsdWUsIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpO1xuXHRcdGRhdGEudmFycyA9IHZhbHVlO1xuXHRcdGRhdGEuYXV0b0tpbGwgPSAhIXZhbHVlLmF1dG9LaWxsO1xuXHRcdGRhdGEuZ2V0WCA9IF9idWlsZEdldHRlcih0YXJnZXQsIFwieFwiKTtcblx0XHRkYXRhLmdldFkgPSBfYnVpbGRHZXR0ZXIodGFyZ2V0LCBcInlcIik7XG5cdFx0ZGF0YS54ID0gZGF0YS54UHJldiA9IGRhdGEuZ2V0WCgpO1xuXHRcdGRhdGEueSA9IGRhdGEueVByZXYgPSBkYXRhLmdldFkoKTtcblx0XHRpZiAoc25hcFR5cGUgJiYgc25hcFR5cGUgIT09IFwibm9uZVwiKSB7IC8vIGRpc2FibGUgc2Nyb2xsIHNuYXBwaW5nIHRvIGF2b2lkIHN0cmFuZ2UgYmVoYXZpb3Jcblx0XHRcdGRhdGEuc25hcCA9IDE7XG5cdFx0XHRkYXRhLnNuYXBJbmxpbmUgPSB0YXJnZXQuc3R5bGUuc2Nyb2xsU25hcFR5cGU7XG5cdFx0XHR0YXJnZXQuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSBcIm5vbmVcIjtcblx0XHR9XG5cdFx0aWYgKHZhbHVlLnggIT0gbnVsbCkge1xuXHRcdFx0ZGF0YS5hZGQoZGF0YSwgXCJ4XCIsIGRhdGEueCwgX3BhcnNlVmFsKHZhbHVlLngsIHRhcmdldCwgXCJ4XCIsIGRhdGEueCwgdmFsdWUub2Zmc2V0WCB8fCAwKSwgaW5kZXgsIHRhcmdldHMpO1xuXHRcdFx0ZGF0YS5fcHJvcHMucHVzaChcInNjcm9sbFRvX3hcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEuc2tpcFggPSAxO1xuXHRcdH1cblx0XHRpZiAodmFsdWUueSAhPSBudWxsKSB7XG5cdFx0XHRkYXRhLmFkZChkYXRhLCBcInlcIiwgZGF0YS55LCBfcGFyc2VWYWwodmFsdWUueSwgdGFyZ2V0LCBcInlcIiwgZGF0YS55LCB2YWx1ZS5vZmZzZXRZIHx8IDApLCBpbmRleCwgdGFyZ2V0cyk7XG5cdFx0XHRkYXRhLl9wcm9wcy5wdXNoKFwic2Nyb2xsVG9feVwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YS5za2lwWSA9IDE7XG5cdFx0fVxuXHR9LFxuXHRyZW5kZXIocmF0aW8sIGRhdGEpIHtcblx0XHRsZXQgcHQgPSBkYXRhLl9wdCxcblx0XHRcdHsgdGFyZ2V0LCB0d2VlbiwgYXV0b0tpbGwsIHhQcmV2LCB5UHJldiwgaXNXaW4sIHNuYXAsIHNuYXBJbmxpbmUgfSA9IGRhdGEsXG5cdFx0XHR4LCB5LCB5RGlmLCB4RGlmLCB0aHJlc2hvbGQ7XG5cdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRwdC5yKHJhdGlvLCBwdC5kKTtcblx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0fVxuXHRcdHggPSAoaXNXaW4gfHwgIWRhdGEuc2tpcFgpID8gZGF0YS5nZXRYKCkgOiB4UHJldjtcblx0XHR5ID0gKGlzV2luIHx8ICFkYXRhLnNraXBZKSA/IGRhdGEuZ2V0WSgpIDogeVByZXY7XG5cdFx0eURpZiA9IHkgLSB5UHJldjtcblx0XHR4RGlmID0geCAtIHhQcmV2O1xuXHRcdHRocmVzaG9sZCA9IF9jb25maWcuYXV0b0tpbGxUaHJlc2hvbGQ7XG5cdFx0aWYgKGRhdGEueCA8IDApIHsgLy9jYW4ndCBzY3JvbGwgdG8gYSBwb3NpdGlvbiBsZXNzIHRoYW4gMCEgTWlnaHQgaGFwcGVuIGlmIHNvbWVvbmUgdXNlcyBhIEJhY2suZWFzZU91dCBvciBFbGFzdGljLmVhc2VPdXQgd2hlbiBzY3JvbGxpbmcgYmFjayB0byB0aGUgdG9wIG9mIHRoZSBwYWdlIChmb3IgZXhhbXBsZSlcblx0XHRcdGRhdGEueCA9IDA7XG5cdFx0fVxuXHRcdGlmIChkYXRhLnkgPCAwKSB7XG5cdFx0XHRkYXRhLnkgPSAwO1xuXHRcdH1cblx0XHRpZiAoYXV0b0tpbGwpIHtcblx0XHRcdC8vbm90ZTogaU9TIGhhcyBhIGJ1ZyB0aGF0IHRocm93cyBvZmYgdGhlIHNjcm9sbCBieSBzZXZlcmFsIHBpeGVscywgc28gd2UgbmVlZCB0byBjaGVjayBpZiBpdCdzIHdpdGhpbiA3IHBpeGVscyBvZiB0aGUgcHJldmlvdXMgb25lIHRoYXQgd2Ugc2V0IGluc3RlYWQgb2YganVzdCBsb29raW5nIGZvciBhbiBleGFjdCBtYXRjaC5cblx0XHRcdGlmICghZGF0YS5za2lwWCAmJiAoeERpZiA+IHRocmVzaG9sZCB8fCB4RGlmIDwgLXRocmVzaG9sZCkgJiYgeCA8IF9tYXgodGFyZ2V0LCBcInhcIikpIHtcblx0XHRcdFx0ZGF0YS5za2lwWCA9IDE7IC8vaWYgdGhlIHVzZXIgc2Nyb2xscyBzZXBhcmF0ZWx5LCB3ZSBzaG91bGQgc3RvcCB0d2VlbmluZyFcblx0XHRcdH1cblx0XHRcdGlmICghZGF0YS5za2lwWSAmJiAoeURpZiA+IHRocmVzaG9sZCB8fCB5RGlmIDwgLXRocmVzaG9sZCkgJiYgeSA8IF9tYXgodGFyZ2V0LCBcInlcIikpIHtcblx0XHRcdFx0ZGF0YS5za2lwWSA9IDE7IC8vaWYgdGhlIHVzZXIgc2Nyb2xscyBzZXBhcmF0ZWx5LCB3ZSBzaG91bGQgc3RvcCB0d2VlbmluZyFcblx0XHRcdH1cblx0XHRcdGlmIChkYXRhLnNraXBYICYmIGRhdGEuc2tpcFkpIHtcblx0XHRcdFx0dHdlZW4ua2lsbCgpO1xuXHRcdFx0XHRkYXRhLnZhcnMub25BdXRvS2lsbCAmJiBkYXRhLnZhcnMub25BdXRvS2lsbC5hcHBseSh0d2VlbiwgZGF0YS52YXJzLm9uQXV0b0tpbGxQYXJhbXMgfHwgW10pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoaXNXaW4pIHtcblx0XHRcdF93aW5kb3cuc2Nyb2xsVG8oKCFkYXRhLnNraXBYKSA/IGRhdGEueCA6IHgsICghZGF0YS5za2lwWSkgPyBkYXRhLnkgOiB5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YS5za2lwWSB8fCAodGFyZ2V0LnNjcm9sbFRvcCA9IGRhdGEueSk7XG5cdFx0XHRkYXRhLnNraXBYIHx8ICh0YXJnZXQuc2Nyb2xsTGVmdCA9IGRhdGEueCk7XG5cdFx0fVxuXHRcdGlmIChzbmFwICYmIChyYXRpbyA9PT0gMSB8fCByYXRpbyA9PT0gMCkpIHtcblx0XHRcdHkgPSB0YXJnZXQuc2Nyb2xsVG9wO1xuXHRcdFx0eCA9IHRhcmdldC5zY3JvbGxMZWZ0O1xuXHRcdFx0c25hcElubGluZSA/ICh0YXJnZXQuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSBzbmFwSW5saW5lKSA6IHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInNjcm9sbC1zbmFwLXR5cGVcIik7XG5cdFx0XHR0YXJnZXQuc2Nyb2xsVG9wID0geSArIDE7IC8vIGJ1ZyBpbiBTYWZhcmkgY2F1c2VzIHRoZSBlbGVtZW50IHRvIHRvdGFsbHkgcmVzZXQgaXRzIHNjcm9sbCBwb3NpdGlvbiB3aGVuIHNjcm9sbC1zbmFwLXR5cGUgY2hhbmdlcywgc28gd2UgbmVlZCB0byBzZXQgaXQgdG8gYSBzbGlnaHRseSBkaWZmZXJlbnQgdmFsdWUgYW5kIHRoZW4gYmFjayBhZ2FpbiB0byB3b3JrIGFyb3VuZCB0aGlzIGJ1Zy5cblx0XHRcdHRhcmdldC5zY3JvbGxMZWZ0ID0geCArIDE7XG5cdFx0XHR0YXJnZXQuc2Nyb2xsVG9wID0geTtcblx0XHRcdHRhcmdldC5zY3JvbGxMZWZ0ID0geDtcblx0XHR9XG5cdFx0ZGF0YS54UHJldiA9IGRhdGEueDtcblx0XHRkYXRhLnlQcmV2ID0gZGF0YS55O1xuXHR9LFxuXHRraWxsKHByb3BlcnR5KSB7XG5cdFx0bGV0IGJvdGggPSAocHJvcGVydHkgPT09IFwic2Nyb2xsVG9cIik7XG5cdFx0aWYgKGJvdGggfHwgcHJvcGVydHkgPT09IFwic2Nyb2xsVG9feFwiKSB7XG5cdFx0XHR0aGlzLnNraXBYID0gMTtcblx0XHR9XG5cdFx0aWYgKGJvdGggfHwgcHJvcGVydHkgPT09IFwic2Nyb2xsVG9feVwiKSB7XG5cdFx0XHR0aGlzLnNraXBZID0gMTtcblx0XHR9XG5cdH1cbn07XG5cblNjcm9sbFRvUGx1Z2luLm1heCA9IF9tYXg7XG5TY3JvbGxUb1BsdWdpbi5nZXRPZmZzZXQgPSBfZ2V0T2Zmc2V0O1xuU2Nyb2xsVG9QbHVnaW4uYnVpbGRHZXR0ZXIgPSBfYnVpbGRHZXR0ZXI7XG5cbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihTY3JvbGxUb1BsdWdpbik7XG5cbmV4cG9ydCB7IFNjcm9sbFRvUGx1Z2luIGFzIGRlZmF1bHQgfTsiLCIvKiFcbiAqIFNjcm9sbFRyaWdnZXIgMy43LjBcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5sZXQgZ3NhcCwgX2NvcmVJbml0dGVkLCBfd2luLCBfZG9jLCBfZG9jRWwsIF9ib2R5LCBfcm9vdCwgX3Jlc2l6ZURlbGF5LCBfcmFmLCBfcmVxdWVzdCwgX3RvQXJyYXksIF9jbGFtcCwgX3RpbWUyLCBfc3luY0ludGVydmFsLCBfcmVmcmVzaGluZywgX3BvaW50ZXJJc0Rvd24sIF90cmFuc2Zvcm1Qcm9wLCBfaSwgX3ByZXZXaWR0aCwgX3ByZXZIZWlnaHQsIF9hdXRvUmVmcmVzaCwgX3NvcnQsIF9zdXBwcmVzc092ZXJ3cml0ZXMsIF9pZ25vcmVSZXNpemUsXG5cdF9saW1pdENhbGxiYWNrcywgLy8gaWYgdHJ1ZSwgd2UnbGwgb25seSB0cmlnZ2VyIGNhbGxiYWNrcyBpZiB0aGUgYWN0aXZlIHN0YXRlIHRvZ2dsZXMsIHNvIGlmIHlvdSBzY3JvbGwgaW1tZWRpYXRlbHkgcGFzdCBib3RoIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBvZiBhIFNjcm9sbFRyaWdnZXIgKHRodXMgaW5hY3RpdmUgdG8gaW5hY3RpdmUpLCBuZWl0aGVyIGl0cyBvbkVudGVyIG5vciBvbkxlYXZlIHdpbGwgYmUgY2FsbGVkLiBUaGlzIGlzIHVzZWZ1bCBkdXJpbmcgc3RhcnR1cC5cblx0X3N0YXJ0dXAgPSAxLFxuXHRfcHJveGllcyA9IFtdLFxuXHRfc2Nyb2xsZXJzID0gW10sXG5cdF9nZXRUaW1lID0gRGF0ZS5ub3csXG5cdF90aW1lMSA9IF9nZXRUaW1lKCksXG5cdF9sYXN0U2Nyb2xsVGltZSA9IDAsXG5cdF9lbmFibGVkID0gMSxcblx0X3Bhc3NUaHJvdWdoID0gdiA9PiB2LFxuXHRfcm91bmQgPSB2YWx1ZSA9PiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwKSAvIDEwMDAwMCB8fCAwLFxuXHRfd2luZG93RXhpc3RzID0gKCkgPT4gdHlwZW9mKHdpbmRvdykgIT09IFwidW5kZWZpbmVkXCIsXG5cdF9nZXRHU0FQID0gKCkgPT4gZ3NhcCB8fCAoX3dpbmRvd0V4aXN0cygpICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcCksXG5cdF9pc1ZpZXdwb3J0ID0gZSA9PiAhIX5fcm9vdC5pbmRleE9mKGUpLFxuXHRfZ2V0UHJveHlQcm9wID0gKGVsZW1lbnQsIHByb3BlcnR5KSA9PiB+X3Byb3hpZXMuaW5kZXhPZihlbGVtZW50KSAmJiBfcHJveGllc1tfcHJveGllcy5pbmRleE9mKGVsZW1lbnQpICsgMV1bcHJvcGVydHldLFxuXHRfZ2V0U2Nyb2xsRnVuYyA9IChlbGVtZW50LCB7cywgc2N9KSA9PiB7IC8vIHdlIHN0b3JlIHRoZSBzY3JvbGxlciBmdW5jdGlvbnMgaW4gYSBhbHRlcm5hdGluZyBzZXF1ZW5jZWQgQXJyYXkgbGlrZSBbZWxlbWVudCwgdmVydGljYWxTY3JvbGxGdW5jLCBob3Jpem9udGFsU2Nyb2xsRnVuYywgLi4uXSBzbyB0aGF0IHdlIGNhbiBtaW5pbWl6ZSBtZW1vcnksIG1heGltaXplIHBlcmZvcm1hbmNlLCBhbmQgd2UgYWxzbyByZWNvcmQgdGhlIGxhc3QgcG9zaXRpb24gYXMgYSBcIi5yZWNcIiBwcm9wZXJ0eSBpbiBvcmRlciB0byByZXZlcnQgdG8gdGhhdCBhZnRlciByZWZyZXNoaW5nIHRvIGVuc3VyZSB0aGluZ3MgZG9uJ3Qgc2hpZnQgYXJvdW5kLlxuXHRcdGxldCBpID0gX3Njcm9sbGVycy5pbmRleE9mKGVsZW1lbnQpLFxuXHRcdFx0b2Zmc2V0ID0gc2MgPT09IF92ZXJ0aWNhbC5zYyA/IDEgOiAyO1xuXHRcdCF+aSAmJiAoaSA9IF9zY3JvbGxlcnMucHVzaChlbGVtZW50KSAtIDEpO1xuXHRcdHJldHVybiBfc2Nyb2xsZXJzW2kgKyBvZmZzZXRdIHx8IChfc2Nyb2xsZXJzW2kgKyBvZmZzZXRdID0gX2dldFByb3h5UHJvcChlbGVtZW50LCBzKSB8fCAoX2lzVmlld3BvcnQoZWxlbWVudCkgPyBzYyA6IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVsZW1lbnRbc10gPSB2YWx1ZSkgOiBlbGVtZW50W3NdOyB9KSk7XG5cdH0sXG5cdF9nZXRCb3VuZHNGdW5jID0gZWxlbWVudCA9PiBfZ2V0UHJveHlQcm9wKGVsZW1lbnQsIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIpIHx8IChfaXNWaWV3cG9ydChlbGVtZW50KSA/ICgpID0+IHtfd2luT2Zmc2V0cy53aWR0aCA9IF93aW4uaW5uZXJXaWR0aDsgX3dpbk9mZnNldHMuaGVpZ2h0ID0gX3dpbi5pbm5lckhlaWdodDsgcmV0dXJuIF93aW5PZmZzZXRzO30gOiAoKSA9PiBfZ2V0Qm91bmRzKGVsZW1lbnQpKSxcblx0X2dldFNpemVGdW5jID0gKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCB7ZCwgZDIsIGF9KSA9PiAoYSA9IF9nZXRQcm94eVByb3Aoc2Nyb2xsZXIsIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIpKSA/ICgpID0+IGEoKVtkXSA6ICgpID0+IChpc1ZpZXdwb3J0ID8gX3dpbltcImlubmVyXCIgKyBkMl0gOiBzY3JvbGxlcltcImNsaWVudFwiICsgZDJdKSB8fCAwLFxuXHRfZ2V0T2Zmc2V0c0Z1bmMgPSAoZWxlbWVudCwgaXNWaWV3cG9ydCkgPT4gIWlzVmlld3BvcnQgfHwgfl9wcm94aWVzLmluZGV4T2YoZWxlbWVudCkgPyBfZ2V0Qm91bmRzRnVuYyhlbGVtZW50KSA6ICgpID0+IF93aW5PZmZzZXRzLFxuXHRfbWF4U2Nyb2xsID0gKGVsZW1lbnQsIHtzLCBkMiwgZCwgYX0pID0+IChzID0gXCJzY3JvbGxcIiArIGQyKSAmJiAoYSA9IF9nZXRQcm94eVByb3AoZWxlbWVudCwgcykpID8gYSgpIC0gX2dldEJvdW5kc0Z1bmMoZWxlbWVudCkoKVtkXSA6IF9pc1ZpZXdwb3J0KGVsZW1lbnQpID8gTWF0aC5tYXgoX2RvY0VsW3NdLCBfYm9keVtzXSkgLSAoX3dpbltcImlubmVyXCIgKyBkMl0gfHwgX2RvY0VsW1wiY2xpZW50XCIgKyBkMl0gfHwgX2JvZHlbXCJjbGllbnRcIiArIGQyXSkgOiBlbGVtZW50W3NdIC0gZWxlbWVudFtcIm9mZnNldFwiICsgZDJdLFxuXHRfaXRlcmF0ZUF1dG9SZWZyZXNoID0gKGZ1bmMsIGV2ZW50cykgPT4ge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgX2F1dG9SZWZyZXNoLmxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHQoIWV2ZW50cyB8fCB+ZXZlbnRzLmluZGV4T2YoX2F1dG9SZWZyZXNoW2krMV0pKSAmJiBmdW5jKF9hdXRvUmVmcmVzaFtpXSwgX2F1dG9SZWZyZXNoW2krMV0sIF9hdXRvUmVmcmVzaFtpKzJdKTtcblx0XHR9XG5cdH0sXG5cdF9pc1N0cmluZyA9IHZhbHVlID0+IHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIsXG5cdF9pc0Z1bmN0aW9uID0gdmFsdWUgPT4gdHlwZW9mKHZhbHVlKSA9PT0gXCJmdW5jdGlvblwiLFxuXHRfaXNOdW1iZXIgPSB2YWx1ZSA9PiB0eXBlb2YodmFsdWUpID09PSBcIm51bWJlclwiLFxuXHRfaXNPYmplY3QgPSB2YWx1ZSA9PiB0eXBlb2YodmFsdWUpID09PSBcIm9iamVjdFwiLFxuXHRfY2FsbElmRnVuYyA9IHZhbHVlID0+IF9pc0Z1bmN0aW9uKHZhbHVlKSAmJiB2YWx1ZSgpLFxuXHRfY29tYmluZUZ1bmMgPSAoZjEsIGYyKSA9PiAoKSA9PiB7XG5cdFx0bGV0IHJlc3VsdDEgPSBfY2FsbElmRnVuYyhmMSksXG5cdFx0XHRyZXN1bHQyID0gX2NhbGxJZkZ1bmMoZjIpO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRfY2FsbElmRnVuYyhyZXN1bHQxKTtcblx0XHRcdF9jYWxsSWZGdW5jKHJlc3VsdDIpO1xuXHRcdH1cblx0fSxcblx0X2FicyA9IE1hdGguYWJzLFxuXHRfc2Nyb2xsTGVmdCA9IFwic2Nyb2xsTGVmdFwiLFxuXHRfc2Nyb2xsVG9wID0gXCJzY3JvbGxUb3BcIixcblx0X2xlZnQgPSBcImxlZnRcIixcblx0X3RvcCA9IFwidG9wXCIsXG5cdF9yaWdodCA9IFwicmlnaHRcIixcblx0X2JvdHRvbSA9IFwiYm90dG9tXCIsXG5cdF93aWR0aCA9IFwid2lkdGhcIixcblx0X2hlaWdodCA9IFwiaGVpZ2h0XCIsXG5cdF9SaWdodCA9IFwiUmlnaHRcIixcblx0X0xlZnQgPSBcIkxlZnRcIixcblx0X1RvcCA9IFwiVG9wXCIsXG5cdF9Cb3R0b20gPSBcIkJvdHRvbVwiLFxuXHRfcGFkZGluZyA9IFwicGFkZGluZ1wiLFxuXHRfbWFyZ2luID0gXCJtYXJnaW5cIixcblx0X1dpZHRoID0gXCJXaWR0aFwiLFxuXHRfSGVpZ2h0ID0gXCJIZWlnaHRcIixcblx0X3B4ID0gXCJweFwiLFxuXHRfaG9yaXpvbnRhbCA9IHtzOiBfc2Nyb2xsTGVmdCwgcDogX2xlZnQsIHAyOiBfTGVmdCwgb3M6IF9yaWdodCwgb3MyOiBfUmlnaHQsIGQ6IF93aWR0aCwgZDI6IF9XaWR0aCwgYTogXCJ4XCIsIHNjOiBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IF93aW4uc2Nyb2xsVG8odmFsdWUsIF92ZXJ0aWNhbC5zYygpKSA6IF93aW4ucGFnZVhPZmZzZXQgfHwgX2RvY1tfc2Nyb2xsTGVmdF0gfHwgX2RvY0VsW19zY3JvbGxMZWZ0XSB8fCBfYm9keVtfc2Nyb2xsTGVmdF0gfHwgMH19LFxuXHRfdmVydGljYWwgPSB7czogX3Njcm9sbFRvcCwgcDogX3RvcCwgcDI6IF9Ub3AsIG9zOiBfYm90dG9tLCBvczI6IF9Cb3R0b20sIGQ6IF9oZWlnaHQsIGQyOiBfSGVpZ2h0LCBhOiBcInlcIiwgb3A6IF9ob3Jpem9udGFsLCBzYzogZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBfd2luLnNjcm9sbFRvKF9ob3Jpem9udGFsLnNjKCksIHZhbHVlKSA6IF93aW4ucGFnZVlPZmZzZXQgfHwgX2RvY1tfc2Nyb2xsVG9wXSB8fCBfZG9jRWxbX3Njcm9sbFRvcF0gfHwgX2JvZHlbX3Njcm9sbFRvcF0gfHwgMH19LFxuXHRfZ2V0Q29tcHV0ZWRTdHlsZSA9IGVsZW1lbnQgPT4gX3dpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLFxuXHRfbWFrZVBvc2l0aW9uYWJsZSA9IGVsZW1lbnQgPT4geyAvLyBpZiB0aGUgZWxlbWVudCBhbHJlYWR5IGhhcyBwb3NpdGlvbjogYWJzb2x1dGUgb3IgZml4ZWQsIGxlYXZlIHRoYXQsIG90aGVyd2lzZSBtYWtlIGl0IHBvc2l0aW9uOiByZWxhdGl2ZVxuXHRcdGxldCBwb3NpdGlvbiA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uO1xuXHRcdGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAocG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSA/IHBvc2l0aW9uIDogXCJyZWxhdGl2ZVwiO1xuXHR9LFxuXHRfc2V0RGVmYXVsdHMgPSAob2JqLCBkZWZhdWx0cykgPT4ge1xuXHRcdGZvciAobGV0IHAgaW4gZGVmYXVsdHMpIHtcblx0XHRcdChwIGluIG9iaikgfHwgKG9ialtwXSA9IGRlZmF1bHRzW3BdKTtcblx0XHR9XG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblx0Ly9faXNJblZpZXdwb3J0ID0gZWxlbWVudCA9PiAoZWxlbWVudCA9IF9nZXRCb3VuZHMoZWxlbWVudCkpICYmICEoZWxlbWVudC50b3AgPiAoX3dpbi5pbm5lckhlaWdodCB8fCBfZG9jRWwuY2xpZW50SGVpZ2h0KSB8fCBlbGVtZW50LmJvdHRvbSA8IDAgfHwgZWxlbWVudC5sZWZ0ID4gKF93aW4uaW5uZXJXaWR0aCB8fCBfZG9jRWwuY2xpZW50V2lkdGgpIHx8IGVsZW1lbnQucmlnaHQgPCAwKSAmJiBlbGVtZW50LFxuXHRfZ2V0Qm91bmRzID0gKGVsZW1lbnQsIHdpdGhvdXRUcmFuc2Zvcm1zKSA9PiB7XG5cdFx0bGV0IHR3ZWVuID0gd2l0aG91dFRyYW5zZm9ybXMgJiYgX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudClbX3RyYW5zZm9ybVByb3BdICE9PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiICYmIGdzYXAudG8oZWxlbWVudCwge3g6IDAsIHk6IDAsIHhQZXJjZW50OiAwLCB5UGVyY2VudDogMCwgcm90YXRpb246IDAsIHJvdGF0aW9uWDogMCwgcm90YXRpb25ZOiAwLCBzY2FsZTogMSwgc2tld1g6IDAsIHNrZXdZOiAwfSkucHJvZ3Jlc3MoMSksXG5cdFx0XHRib3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHR3ZWVuICYmIHR3ZWVuLnByb2dyZXNzKDApLmtpbGwoKTtcblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXHRfZ2V0U2l6ZSA9IChlbGVtZW50LCB7ZDJ9KSA9PiBlbGVtZW50W1wib2Zmc2V0XCIgKyBkMl0gfHwgZWxlbWVudFtcImNsaWVudFwiICsgZDJdIHx8IDAsXG5cdF9nZXRMYWJlbFJhdGlvQXJyYXkgPSB0aW1lbGluZSA9PiB7XG5cdFx0bGV0IGEgPSBbXSxcblx0XHRcdGxhYmVscyA9IHRpbWVsaW5lLmxhYmVscyxcblx0XHRcdGR1cmF0aW9uID0gdGltZWxpbmUuZHVyYXRpb24oKSxcblx0XHRcdHA7XG5cdFx0Zm9yIChwIGluIGxhYmVscykge1xuXHRcdFx0YS5wdXNoKGxhYmVsc1twXSAvIGR1cmF0aW9uKTtcblx0XHR9XG5cdFx0cmV0dXJuIGE7XG5cdH0sXG5cdF9nZXRDbG9zZXN0TGFiZWwgPSBhbmltYXRpb24gPT4gdmFsdWUgPT4gZ3NhcC51dGlscy5zbmFwKF9nZXRMYWJlbFJhdGlvQXJyYXkoYW5pbWF0aW9uKSwgdmFsdWUpLFxuXHRfZ2V0TGFiZWxBdERpcmVjdGlvbiA9IHRpbWVsaW5lID0+IHtcblx0XHRyZXR1cm4gKHZhbHVlLCBzdCkgPT4ge1xuXHRcdFx0bGV0IGEgPSBfZ2V0TGFiZWxSYXRpb0FycmF5KHRpbWVsaW5lKSxcblx0XHRcdFx0aTtcblx0XHRcdGEuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuXHRcdFx0aWYgKHN0LmRpcmVjdGlvbiA+IDApIHtcblx0XHRcdFx0dmFsdWUgLT0gMWUtNDsgLy8gdG8gYXZvaWQgcm91bmRpbmcgZXJyb3JzLiBJZiB3ZSdyZSB0b28gc3RyaWN0LCBpdCBtaWdodCBzbmFwIGZvcndhcmQsIHRoZW4gaW1tZWRpYXRlbHkgYWdhaW4sIGFuZCBhZ2Fpbi5cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoYVtpXSA+PSB2YWx1ZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGFbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBhLnBvcCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHR2YWx1ZSArPSAxZS00O1xuXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0aWYgKGFbaV0gPD0gdmFsdWUpIHtcblx0XHRcdFx0XHRcdHJldHVybiBhW2ldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFbMF07XG5cdFx0fTtcblx0fSxcblx0X211bHRpTGlzdGVuZXIgPSAoZnVuYywgZWxlbWVudCwgdHlwZXMsIGNhbGxiYWNrKSA9PiB0eXBlcy5zcGxpdChcIixcIikuZm9yRWFjaCh0eXBlID0+IGZ1bmMoZWxlbWVudCwgdHlwZSwgY2FsbGJhY2spKSxcblx0X2FkZExpc3RlbmVyID0gKGVsZW1lbnQsIHR5cGUsIGZ1bmMpID0+IGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jLCB7cGFzc2l2ZTogdHJ1ZX0pLFxuXHRfcmVtb3ZlTGlzdGVuZXIgPSAoZWxlbWVudCwgdHlwZSwgZnVuYykgPT4gZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmMpLFxuXHRfbWFya2VyRGVmYXVsdHMgPSB7c3RhcnRDb2xvcjogXCJncmVlblwiLCBlbmRDb2xvcjogXCJyZWRcIiwgaW5kZW50OiAwLCBmb250U2l6ZTogXCIxNnB4XCIsIGZvbnRXZWlnaHQ6XCJub3JtYWxcIn0sXG5cdF9kZWZhdWx0cyA9IHt0b2dnbGVBY3Rpb25zOiBcInBsYXlcIiwgYW50aWNpcGF0ZVBpbjogMH0sXG5cdF9rZXl3b3JkcyA9IHt0b3A6IDAsIGxlZnQ6IDAsIGNlbnRlcjogMC41LCBib3R0b206IDEsIHJpZ2h0OiAxfSxcblx0X29mZnNldFRvUHggPSAodmFsdWUsIHNpemUpID0+IHtcblx0XHRpZiAoX2lzU3RyaW5nKHZhbHVlKSkge1xuXHRcdFx0bGV0IGVxSW5kZXggPSB2YWx1ZS5pbmRleE9mKFwiPVwiKSxcblx0XHRcdFx0cmVsYXRpdmUgPSB+ZXFJbmRleCA/ICsodmFsdWUuY2hhckF0KGVxSW5kZXgtMSkgKyAxKSAqIHBhcnNlRmxvYXQodmFsdWUuc3Vic3RyKGVxSW5kZXggKyAxKSkgOiAwO1xuXHRcdFx0aWYgKH5lcUluZGV4KSB7XG5cdFx0XHRcdCh2YWx1ZS5pbmRleE9mKFwiJVwiKSA+IGVxSW5kZXgpICYmIChyZWxhdGl2ZSAqPSBzaXplIC8gMTAwKTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgZXFJbmRleC0xKTtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gcmVsYXRpdmUgKyAoKHZhbHVlIGluIF9rZXl3b3JkcykgPyBfa2V5d29yZHNbdmFsdWVdICogc2l6ZSA6IH52YWx1ZS5pbmRleE9mKFwiJVwiKSA/IHBhcnNlRmxvYXQodmFsdWUpICogc2l6ZSAvIDEwMCA6IHBhcnNlRmxvYXQodmFsdWUpIHx8IDApO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdF9jcmVhdGVNYXJrZXIgPSAodHlwZSwgbmFtZSwgY29udGFpbmVyLCBkaXJlY3Rpb24sIHtzdGFydENvbG9yLCBlbmRDb2xvciwgZm9udFNpemUsIGluZGVudCwgZm9udFdlaWdodH0sIG9mZnNldCwgbWF0Y2hXaWR0aEVsKSA9PiB7XG5cdFx0bGV0IGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cdFx0XHR1c2VGaXhlZFBvc2l0aW9uID0gX2lzVmlld3BvcnQoY29udGFpbmVyKSB8fCBfZ2V0UHJveHlQcm9wKGNvbnRhaW5lciwgXCJwaW5UeXBlXCIpID09PSBcImZpeGVkXCIsXG5cdFx0XHRpc1Njcm9sbGVyID0gdHlwZS5pbmRleE9mKFwic2Nyb2xsZXJcIikgIT09IC0xLFxuXHRcdFx0cGFyZW50ID0gdXNlRml4ZWRQb3NpdGlvbiA/IF9ib2R5IDogY29udGFpbmVyLFxuXHRcdFx0aXNTdGFydCA9IHR5cGUuaW5kZXhPZihcInN0YXJ0XCIpICE9PSAtMSxcblx0XHRcdGNvbG9yID0gaXNTdGFydCA/IHN0YXJ0Q29sb3IgOiBlbmRDb2xvcixcblx0XHRcdGNzcyA9IFwiYm9yZGVyLWNvbG9yOlwiICsgY29sb3IgKyBcIjtmb250LXNpemU6XCIgKyBmb250U2l6ZSArIFwiO2NvbG9yOlwiICsgY29sb3IgKyBcIjtmb250LXdlaWdodDpcIiArIGZvbnRXZWlnaHQgKyBcIjtwb2ludGVyLWV2ZW50czpub25lO3doaXRlLXNwYWNlOm5vd3JhcDtmb250LWZhbWlseTpzYW5zLXNlcmlmLEFyaWFsO3otaW5kZXg6MTAwMDtwYWRkaW5nOjRweCA4cHg7Ym9yZGVyLXdpZHRoOjA7Ym9yZGVyLXN0eWxlOnNvbGlkO1wiO1xuXHRcdGNzcyArPSBcInBvc2l0aW9uOlwiICsgKGlzU2Nyb2xsZXIgJiYgdXNlRml4ZWRQb3NpdGlvbiA/IFwiZml4ZWQ7XCIgOiBcImFic29sdXRlO1wiKTtcblx0XHQoaXNTY3JvbGxlciB8fCAhdXNlRml4ZWRQb3NpdGlvbikgJiYgKGNzcyArPSAoZGlyZWN0aW9uID09PSBfdmVydGljYWwgPyBfcmlnaHQgOiBfYm90dG9tKSArIFwiOlwiICsgKG9mZnNldCArIHBhcnNlRmxvYXQoaW5kZW50KSkgKyBcInB4O1wiKTtcblx0XHRtYXRjaFdpZHRoRWwgJiYgKGNzcyArPSBcImJveC1zaXppbmc6Ym9yZGVyLWJveDt0ZXh0LWFsaWduOmxlZnQ7d2lkdGg6XCIgKyBtYXRjaFdpZHRoRWwub2Zmc2V0V2lkdGggKyBcInB4O1wiKTtcblx0XHRlLl9pc1N0YXJ0ID0gaXNTdGFydDtcblx0XHRlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiZ3NhcC1tYXJrZXItXCIgKyB0eXBlKTtcblx0XHRlLnN0eWxlLmNzc1RleHQgPSBjc3M7XG5cdFx0ZS5pbm5lclRleHQgPSBuYW1lIHx8IG5hbWUgPT09IDAgPyB0eXBlICsgXCItXCIgKyBuYW1lIDogdHlwZTtcblx0XHRwYXJlbnQuY2hpbGRyZW5bMF0gPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKGUsIHBhcmVudC5jaGlsZHJlblswXSkgOiBwYXJlbnQuYXBwZW5kQ2hpbGQoZSk7XG5cdFx0ZS5fb2Zmc2V0ID0gZVtcIm9mZnNldFwiICsgZGlyZWN0aW9uLm9wLmQyXTtcblx0XHRfcG9zaXRpb25NYXJrZXIoZSwgMCwgZGlyZWN0aW9uLCBpc1N0YXJ0KTtcblx0XHRyZXR1cm4gZTtcblx0fSxcblx0X3Bvc2l0aW9uTWFya2VyID0gKG1hcmtlciwgc3RhcnQsIGRpcmVjdGlvbiwgZmxpcHBlZCkgPT4ge1xuXHRcdGxldCB2YXJzID0ge2Rpc3BsYXk6IFwiYmxvY2tcIn0sXG5cdFx0XHRzaWRlID0gZGlyZWN0aW9uW2ZsaXBwZWQgPyBcIm9zMlwiIDogXCJwMlwiXSxcblx0XHRcdG9wcG9zaXRlU2lkZSA9IGRpcmVjdGlvbltmbGlwcGVkID8gXCJwMlwiIDogXCJvczJcIl07XG5cdFx0bWFya2VyLl9pc0ZsaXBwZWQgPSBmbGlwcGVkO1xuXHRcdHZhcnNbZGlyZWN0aW9uLmEgKyBcIlBlcmNlbnRcIl0gPSBmbGlwcGVkID8gLTEwMCA6IDA7XG5cdFx0dmFyc1tkaXJlY3Rpb24uYV0gPSBmbGlwcGVkID8gXCIxcHhcIiA6IDA7XG5cdFx0dmFyc1tcImJvcmRlclwiICsgc2lkZSArIF9XaWR0aF0gPSAxO1xuXHRcdHZhcnNbXCJib3JkZXJcIiArIG9wcG9zaXRlU2lkZSArIF9XaWR0aF0gPSAwO1xuXHRcdHZhcnNbZGlyZWN0aW9uLnBdID0gc3RhcnQgKyBcInB4XCI7XG5cdFx0Z3NhcC5zZXQobWFya2VyLCB2YXJzKTtcblx0fSxcblx0X3RyaWdnZXJzID0gW10sXG5cdF9pZHMgPSB7fSxcblx0X3N5bmMgPSAoKSA9PiBfcmVxdWVzdCB8fCAoX3JlcXVlc3QgPSBfcmFmKF91cGRhdGVBbGwpKSxcblx0X29uU2Nyb2xsID0gKCkgPT4ge1xuXHRcdGlmICghX3JlcXVlc3QpIHtcblx0XHRcdF9yZXF1ZXN0ID0gX3JhZihfdXBkYXRlQWxsKTtcblx0XHRcdF9sYXN0U2Nyb2xsVGltZSB8fCBfZGlzcGF0Y2goXCJzY3JvbGxTdGFydFwiKTtcblx0XHRcdF9sYXN0U2Nyb2xsVGltZSA9IF9nZXRUaW1lKCk7XG5cdFx0fVxuXHR9LFxuXHRfb25SZXNpemUgPSAoKSA9PiAhX3JlZnJlc2hpbmcgJiYgIV9pZ25vcmVSZXNpemUgJiYgIV9kb2MuZnVsbHNjcmVlbkVsZW1lbnQgJiYgX3Jlc2l6ZURlbGF5LnJlc3RhcnQodHJ1ZSksIC8vIGlnbm9yZSByZXNpemVzIHRyaWdnZXJlZCBieSByZWZyZXNoKClcblx0X2xpc3RlbmVycyA9IHt9LFxuXHRfZW1wdHlBcnJheSA9IFtdLFxuXHRfbWVkaWEgPSBbXSxcblx0X2NyZWF0aW5nTWVkaWEsIC8vIHdoZW4gU2Nyb2xsVHJpZ2dlci5tYXRjaE1lZGlhKCkgaXMgY2FsbGVkLCB3ZSByZWNvcmQgdGhlIGN1cnJlbnQgbWVkaWEga2V5IGhlcmUgKGxpa2UgXCIobWluLXdpZHRoOiA4MDBweClcIikgc28gdGhhdCB3ZSBjYW4gYXNzaWduIGl0IHRvIGV2ZXJ5dGhpbmcgdGhhdCdzIGNyZWF0ZWQgZHVyaW5nIHRoYXQgY2FsbC4gVGhlbiB3ZSBjYW4gcmV2ZXJ0IGp1c3QgdGhvc2Ugd2hlbiBuZWNlc3NhcnkuIEluIHRoZSBTY3JvbGxUcmlnZ2VyJ3MgaW5pdCgpIGNhbGwsIHRoZSBfY3JlYXRpbmdNZWRpYSBpcyByZWNvcmRlZCBhcyBhIFwibWVkaWFcIiBwcm9wZXJ0eSBvbiB0aGUgaW5zdGFuY2UuXG5cdF9sYXN0TWVkaWFUaWNrLFxuXHRfb25NZWRpYUNoYW5nZSA9IGUgPT4ge1xuXHRcdGxldCB0aWNrID0gZ3NhcC50aWNrZXIuZnJhbWUsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGluZGV4O1xuXHRcdGlmIChfbGFzdE1lZGlhVGljayAhPT0gdGljayB8fCBfc3RhcnR1cCkge1xuXHRcdFx0X3JldmVydEFsbCgpO1xuXHRcdFx0Zm9yICg7IGkgPCBfbWVkaWEubGVuZ3RoOyBpKz00KSB7XG5cdFx0XHRcdGluZGV4ID0gX3dpbi5tYXRjaE1lZGlhKF9tZWRpYVtpXSkubWF0Y2hlcztcblx0XHRcdFx0aWYgKGluZGV4ICE9PSBfbWVkaWFbaSszXSkgeyAvLyBub3RlOiBzb21lIGJyb3dzZXJzIGZpcmUgdGhlIG1hdGNoTWVkaWEgZXZlbnQgbXVsdGlwbGUgdGltZXMsIGxpa2Ugd2hlbiBnb2luZyBmdWxsIHNjcmVlbiwgc28gd2Ugc2hvdWxkbid0IGNhbGwgdGhlIGZ1bmN0aW9uIG11bHRpcGxlIHRpbWVzLiBDaGVjayB0byBzZWUgaWYgaXQncyBhbHJlYWR5IG1hdGNoZWQuXG5cdFx0XHRcdFx0X21lZGlhW2krM10gPSBpbmRleDtcblx0XHRcdFx0XHRpbmRleCA/IG1hdGNoZXMucHVzaChpKSA6IF9yZXZlcnRBbGwoMSwgX21lZGlhW2ldKSB8fCAoX2lzRnVuY3Rpb24oX21lZGlhW2krMl0pICYmIF9tZWRpYVtpKzJdKCkpOyAvLyBGaXJlZm94IGRvZXNuJ3QgdXBkYXRlIHRoZSBcIm1hdGNoZXNcIiBwcm9wZXJ0eSBvZiB0aGUgTWVkaWFRdWVyeUxpc3Qgb2JqZWN0IGNvcnJlY3RseSAtIGl0IG9ubHkgZG9lcyBzbyBhcyBpdCBjYWxscyBpdHMgY2hhbmdlIGhhbmRsZXIgLSBzbyB3ZSBtdXN0IHJlLWNyZWF0ZSBhIG1lZGlhIHF1ZXJ5IGhlcmUgdG8gZW5zdXJlIGl0J3MgYWNjdXJhdGUuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdF9yZXZlcnRSZWNvcmRlZCgpOyAvLyBpbiBjYXNlIGtpbGxpbmcvcmV2ZXJ0aW5nIGFueSBvZiB0aGUgYW5pbWF0aW9ucyBhY3R1YWxseSBhZGRlZCBpbmxpbmUgc3R5bGVzIGJhY2suXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpbmRleCA9IG1hdGNoZXNbaV07XG5cdFx0XHRcdF9jcmVhdGluZ01lZGlhID0gX21lZGlhW2luZGV4XTtcblx0XHRcdFx0X21lZGlhW2luZGV4KzJdID0gX21lZGlhW2luZGV4KzFdKGUpO1xuXHRcdFx0fVxuXHRcdFx0X2NyZWF0aW5nTWVkaWEgPSAwO1xuXHRcdFx0X2NvcmVJbml0dGVkICYmIF9yZWZyZXNoQWxsKDAsIDEpO1xuXHRcdFx0X2xhc3RNZWRpYVRpY2sgPSB0aWNrO1xuXHRcdFx0X2Rpc3BhdGNoKFwibWF0Y2hNZWRpYVwiKTtcblx0XHR9XG5cdH0sXG5cdF9zb2Z0UmVmcmVzaCA9ICgpID0+IF9yZW1vdmVMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInNjcm9sbEVuZFwiLCBfc29mdFJlZnJlc2gpIHx8IF9yZWZyZXNoQWxsKHRydWUpLFxuXHRfZGlzcGF0Y2ggPSB0eXBlID0+IChfbGlzdGVuZXJzW3R5cGVdICYmIF9saXN0ZW5lcnNbdHlwZV0ubWFwKGYgPT4gZigpKSkgfHwgX2VtcHR5QXJyYXksXG5cdF9zYXZlZFN0eWxlcyA9IFtdLCAvLyB3aGVuIFNjcm9sbFRyaWdnZXIuc2F2ZVN0eWxlcygpIGlzIGNhbGxlZCwgdGhlIGlubGluZSBzdHlsZXMgYXJlIHJlY29yZGVkIGluIHRoaXMgQXJyYXkgaW4gYSBzZXF1ZW50aWFsIGZvcm1hdCBsaWtlIFtlbGVtZW50LCBjc3NUZXh0LCBnc0NhY2hlLCBtZWRpYV0uIFRoaXMga2VlcHMgaXQgdmVyeSBtZW1vcnktZWZmaWNpZW50IGFuZCBmYXN0IHRvIGl0ZXJhdGUgdGhyb3VnaC5cblx0X3JldmVydFJlY29yZGVkID0gbWVkaWEgPT4ge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgX3NhdmVkU3R5bGVzLmxlbmd0aDsgaSs9NSkge1xuXHRcdFx0aWYgKCFtZWRpYSB8fCBfc2F2ZWRTdHlsZXNbaSs0XSA9PT0gbWVkaWEpIHtcblx0XHRcdFx0X3NhdmVkU3R5bGVzW2ldLnN0eWxlLmNzc1RleHQgPSBfc2F2ZWRTdHlsZXNbaSsxXTtcblx0XHRcdFx0X3NhdmVkU3R5bGVzW2ldLmdldEJCb3ggJiYgX3NhdmVkU3R5bGVzW2ldLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBfc2F2ZWRTdHlsZXNbaSsyXSB8fCBcIlwiKTtcblx0XHRcdFx0X3NhdmVkU3R5bGVzW2krM10udW5jYWNoZSA9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRfcmV2ZXJ0QWxsID0gKGtpbGwsIG1lZGlhKSA9PiB7XG5cdFx0bGV0IHRyaWdnZXI7XG5cdFx0Zm9yIChfaSA9IDA7IF9pIDwgX3RyaWdnZXJzLmxlbmd0aDsgX2krKykge1xuXHRcdFx0dHJpZ2dlciA9IF90cmlnZ2Vyc1tfaV07XG5cdFx0XHRpZiAoIW1lZGlhIHx8IHRyaWdnZXIubWVkaWEgPT09IG1lZGlhKSB7XG5cdFx0XHRcdGlmIChraWxsKSB7XG5cdFx0XHRcdFx0dHJpZ2dlci5raWxsKDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRyaWdnZXIucmV2ZXJ0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0bWVkaWEgJiYgX3JldmVydFJlY29yZGVkKG1lZGlhKTtcblx0XHRtZWRpYSB8fCBfZGlzcGF0Y2goXCJyZXZlcnRcIik7XG5cdH0sXG5cdF9yZWZyZXNoQWxsID0gKGZvcmNlLCBza2lwUmV2ZXJ0KSA9PiB7XG5cdFx0aWYgKF9sYXN0U2Nyb2xsVGltZSAmJiAhZm9yY2UpIHtcblx0XHRcdF9hZGRMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInNjcm9sbEVuZFwiLCBfc29mdFJlZnJlc2gpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRsZXQgcmVmcmVzaEluaXRzID0gX2Rpc3BhdGNoKFwicmVmcmVzaEluaXRcIik7XG5cdFx0X3NvcnQgJiYgU2Nyb2xsVHJpZ2dlci5zb3J0KCk7XG5cdFx0c2tpcFJldmVydCB8fCBfcmV2ZXJ0QWxsKCk7XG5cdFx0X3RyaWdnZXJzLmZvckVhY2godCA9PiB0LnJlZnJlc2goKSkgLy8gZG9uJ3QgbG9vcCB3aXRoIF9pIGJlY2F1c2UgZHVyaW5nIGEgcmVmcmVzaCgpIHNvbWVvbmUgY291bGQgY2FsbCBTY3JvbGxUcmlnZ2VyLnVwZGF0ZSgpIHdoaWNoIHdvdWxkIGl0ZXJhdGUgdGhyb3VnaCBfaSByZXN1bHRpbmcgaW4gYSBza2lwLlxuXHRcdHJlZnJlc2hJbml0cy5mb3JFYWNoKHJlc3VsdCA9PiByZXN1bHQgJiYgcmVzdWx0LnJlbmRlciAmJiByZXN1bHQucmVuZGVyKC0xKSk7IC8vIGlmIHRoZSBvblJlZnJlc2hJbml0KCkgcmV0dXJucyBhbiBhbmltYXRpb24gKHR5cGljYWxseSBhIGdzYXAuc2V0KCkpLCByZXZlcnQgaXQuIFRoaXMgbWFrZXMgaXQgZWFzeSB0byBwdXQgdGhpbmdzIGluIGEgY2VydGFpbiBzcG90IGJlZm9yZSByZWZyZXNoaW5nIGZvciBtZWFzdXJlbWVudCBwdXJwb3NlcywgYW5kIHRoZW4gcHV0IHRoaW5ncyBiYWNrLlxuXHRcdF9zY3JvbGxlcnMuZm9yRWFjaChvYmogPT4gdHlwZW9mKG9iaikgPT09IFwiZnVuY3Rpb25cIiAmJiAob2JqLnJlYyA9IDApKTsgLy8gemVyby1vdXQgYWxsIHRoZSByZWNvcmRlZCBzY3JvbGwgcG9zaXRpb25zLiBEb24ndCB1c2UgX3RyaWdnZXJzIGJlY2F1c2UgaWYsIGZvciBleGFtcGxlLCAubWF0Y2hNZWRpYSgpIGlzIHVzZWQgdG8gY3JlYXRlIHNvbWUgU2Nyb2xsVHJpZ2dlcnMgYW5kIHRoZW4gdGhlIHVzZXIgcmVzaXplcyBhbmQgaXQgcmVtb3ZlcyBBTEwgU2Nyb2xsVHJpZ2dlcnMsIGFuZCB0aGVuIGdvIGJhY2sgdG8gYSBzaXplIHdoZXJlIHRoZXJlIGFyZSBTY3JvbGxUcmlnZ2VycywgaXQgd291bGQgaGF2ZSBrZXB0IHRoZSBwb3NpdGlvbihzKSBzYXZlZCBmcm9tIHRoZSBpbml0aWFsIHN0YXRlLlxuXHRcdF9yZXNpemVEZWxheS5wYXVzZSgpO1xuXHRcdF9kaXNwYXRjaChcInJlZnJlc2hcIik7XG5cdH0sXG5cdF9sYXN0U2Nyb2xsID0gMCxcblx0X2RpcmVjdGlvbiA9IDEsXG5cdF91cGRhdGVBbGwgPSAoKSA9PiB7XG5cdFx0bGV0IGwgPSBfdHJpZ2dlcnMubGVuZ3RoLFxuXHRcdFx0dGltZSA9IF9nZXRUaW1lKCksXG5cdFx0XHRyZWNvcmRWZWxvY2l0eSA9IHRpbWUgLSBfdGltZTEgPj0gNTAsXG5cdFx0XHRzY3JvbGwgPSBsICYmIF90cmlnZ2Vyc1swXS5zY3JvbGwoKTtcblx0XHRfZGlyZWN0aW9uID0gX2xhc3RTY3JvbGwgPiBzY3JvbGwgPyAtMSA6IDE7XG5cdFx0X2xhc3RTY3JvbGwgPSBzY3JvbGw7XG5cdFx0aWYgKHJlY29yZFZlbG9jaXR5KSB7XG5cdFx0XHRpZiAoX2xhc3RTY3JvbGxUaW1lICYmICFfcG9pbnRlcklzRG93biAmJiB0aW1lIC0gX2xhc3RTY3JvbGxUaW1lID4gMjAwKSB7XG5cdFx0XHRcdF9sYXN0U2Nyb2xsVGltZSA9IDA7XG5cdFx0XHRcdF9kaXNwYXRjaChcInNjcm9sbEVuZFwiKTtcblx0XHRcdH1cblx0XHRcdF90aW1lMiA9IF90aW1lMTtcblx0XHRcdF90aW1lMSA9IHRpbWU7XG5cdFx0fVxuXHRcdGlmIChfZGlyZWN0aW9uIDwgMCkge1xuXHRcdFx0X2kgPSBsO1xuXHRcdFx0d2hpbGUgKF9pLS0gPiAwKSB7XG5cdFx0XHRcdF90cmlnZ2Vyc1tfaV0gJiYgX3RyaWdnZXJzW19pXS51cGRhdGUoMCwgcmVjb3JkVmVsb2NpdHkpO1xuXHRcdFx0fVxuXHRcdFx0X2RpcmVjdGlvbiA9IDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoX2kgPSAwOyBfaSA8IGw7IF9pKyspIHtcblx0XHRcdFx0X3RyaWdnZXJzW19pXSAmJiBfdHJpZ2dlcnNbX2ldLnVwZGF0ZSgwLCByZWNvcmRWZWxvY2l0eSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdF9yZXF1ZXN0ID0gMDtcblx0fSxcblx0X3Byb3BOYW1lc1RvQ29weSA9IFtfbGVmdCwgX3RvcCwgX2JvdHRvbSwgX3JpZ2h0LCBfbWFyZ2luICsgX0JvdHRvbSwgX21hcmdpbiArIF9SaWdodCwgX21hcmdpbiArIF9Ub3AsIF9tYXJnaW4gKyBfTGVmdCwgXCJkaXNwbGF5XCIsIFwiZmxleFNocmlua1wiLCBcImZsb2F0XCIsIFwiekluZGV4XCIsIFwiZ3JpZC1jb2x1bW4tc3RhcnRcIiwgXCJncmlkLWNvbHVtbi1lbmRcIiwgXCJncmlkLXJvdy1zdGFydFwiLCBcImdyaWQtcm93LWVuZFwiLCBcImdyaWQtYXJlYVwiLCBcImp1c3RpZnktc2VsZlwiLCBcImFsaWduLXNlbGZcIiwgXCJwbGFjZS1zZWxmXCJdLFxuXHRfc3RhdGVQcm9wcyA9IF9wcm9wTmFtZXNUb0NvcHkuY29uY2F0KFtfd2lkdGgsIF9oZWlnaHQsIFwiYm94U2l6aW5nXCIsIFwibWF4XCIgKyBfV2lkdGgsIFwibWF4XCIgKyBfSGVpZ2h0LCBcInBvc2l0aW9uXCIsIF9tYXJnaW4sIF9wYWRkaW5nLCBfcGFkZGluZyArIF9Ub3AsIF9wYWRkaW5nICsgX1JpZ2h0LCBfcGFkZGluZyArIF9Cb3R0b20sIF9wYWRkaW5nICsgX0xlZnRdKSxcblx0X3N3YXBQaW5PdXQgPSAocGluLCBzcGFjZXIsIHN0YXRlKSA9PiB7XG5cdFx0X3NldFN0YXRlKHN0YXRlKTtcblx0XHRpZiAocGluLnBhcmVudE5vZGUgPT09IHNwYWNlcikge1xuXHRcdFx0bGV0IHBhcmVudCA9IHNwYWNlci5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0XHRwYXJlbnQuaW5zZXJ0QmVmb3JlKHBpbiwgc3BhY2VyKTtcblx0XHRcdFx0cGFyZW50LnJlbW92ZUNoaWxkKHNwYWNlcik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRfc3dhcFBpbkluID0gKHBpbiwgc3BhY2VyLCBjcywgc3BhY2VyU3RhdGUpID0+IHtcblx0XHRpZiAocGluLnBhcmVudE5vZGUgIT09IHNwYWNlcikge1xuXHRcdFx0bGV0IGkgPSBfcHJvcE5hbWVzVG9Db3B5Lmxlbmd0aCxcblx0XHRcdFx0c3BhY2VyU3R5bGUgPSBzcGFjZXIuc3R5bGUsXG5cdFx0XHRcdHBpblN0eWxlID0gcGluLnN0eWxlLFxuXHRcdFx0XHRwO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRwID0gX3Byb3BOYW1lc1RvQ29weVtpXTtcblx0XHRcdFx0c3BhY2VyU3R5bGVbcF0gPSBjc1twXTtcblx0XHRcdH1cblx0XHRcdHNwYWNlclN0eWxlLnBvc2l0aW9uID0gY3MucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiA/IFwiYWJzb2x1dGVcIiA6IFwicmVsYXRpdmVcIjtcblx0XHRcdChjcy5kaXNwbGF5ID09PSBcImlubGluZVwiKSAmJiAoc3BhY2VyU3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCIpO1xuXHRcdFx0cGluU3R5bGVbX2JvdHRvbV0gPSBwaW5TdHlsZVtfcmlnaHRdID0gXCJhdXRvXCI7XG5cdFx0XHRzcGFjZXJTdHlsZS5vdmVyZmxvdyA9IFwidmlzaWJsZVwiO1xuXHRcdFx0c3BhY2VyU3R5bGUuYm94U2l6aW5nID0gXCJib3JkZXItYm94XCI7XG5cdFx0XHRzcGFjZXJTdHlsZVtfd2lkdGhdID0gX2dldFNpemUocGluLCBfaG9yaXpvbnRhbCkgKyBfcHg7XG5cdFx0XHRzcGFjZXJTdHlsZVtfaGVpZ2h0XSA9IF9nZXRTaXplKHBpbiwgX3ZlcnRpY2FsKSArIF9weDtcblx0XHRcdHNwYWNlclN0eWxlW19wYWRkaW5nXSA9IHBpblN0eWxlW19tYXJnaW5dID0gcGluU3R5bGVbX3RvcF0gPSBwaW5TdHlsZVtfbGVmdF0gPSBcIjBcIjtcblx0XHRcdF9zZXRTdGF0ZShzcGFjZXJTdGF0ZSk7XG5cdFx0XHRwaW5TdHlsZVtfd2lkdGhdID0gcGluU3R5bGVbXCJtYXhcIiArIF9XaWR0aF0gPSBjc1tfd2lkdGhdO1xuXHRcdFx0cGluU3R5bGVbX2hlaWdodF0gPSBwaW5TdHlsZVtcIm1heFwiICsgX0hlaWdodF0gPSBjc1tfaGVpZ2h0XTtcblx0XHRcdHBpblN0eWxlW19wYWRkaW5nXSA9IGNzW19wYWRkaW5nXTtcblx0XHRcdHBpbi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzcGFjZXIsIHBpbik7XG5cdFx0XHRzcGFjZXIuYXBwZW5kQ2hpbGQocGluKTtcblx0XHR9XG5cdH0sXG5cdF9jYXBzRXhwID0gLyhbQS1aXSkvZyxcblx0X3NldFN0YXRlID0gc3RhdGUgPT4ge1xuXHRcdGlmIChzdGF0ZSkge1xuXHRcdFx0bGV0IHN0eWxlID0gc3RhdGUudC5zdHlsZSxcblx0XHRcdFx0bCA9IHN0YXRlLmxlbmd0aCxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdHAsIHZhbHVlO1xuXHRcdFx0KHN0YXRlLnQuX2dzYXAgfHwgZ3NhcC5jb3JlLmdldENhY2hlKHN0YXRlLnQpKS51bmNhY2hlID0gMTsgLy8gb3RoZXJ3aXNlIHRyYW5zZm9ybXMgbWF5IGJlIG9mZlxuXHRcdFx0Zm9yICg7IGkgPCBsOyBpICs9Mikge1xuXHRcdFx0XHR2YWx1ZSA9IHN0YXRlW2krMV07XG5cdFx0XHRcdHAgPSBzdGF0ZVtpXTtcblx0XHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdFx0c3R5bGVbcF0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChzdHlsZVtwXSkge1xuXHRcdFx0XHRcdHN0eWxlLnJlbW92ZVByb3BlcnR5KHAucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdF9nZXRTdGF0ZSA9IGVsZW1lbnQgPT4geyAvLyByZXR1cm5zIGFuIEFycmF5IHdpdGggYWx0ZXJuYXRpbmcgdmFsdWVzIGxpa2UgW3Byb3BlcnR5LCB2YWx1ZSwgcHJvcGVydHksIHZhbHVlXSBhbmQgYSBcInRcIiBwcm9wZXJ0eSBwb2ludGluZyB0byB0aGUgdGFyZ2V0IChlbGVtZW50KS4gTWFrZXMgaXQgZmFzdCBhbmQgY2hlYXAuXG5cdFx0bGV0IGwgPSBfc3RhdGVQcm9wcy5sZW5ndGgsXG5cdFx0XHRzdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG5cdFx0XHRzdGF0ZSA9IFtdLFxuXHRcdFx0aSA9IDA7XG5cdFx0Zm9yICg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHN0YXRlLnB1c2goX3N0YXRlUHJvcHNbaV0sIHN0eWxlW19zdGF0ZVByb3BzW2ldXSk7XG5cdFx0fVxuXHRcdHN0YXRlLnQgPSBlbGVtZW50O1xuXHRcdHJldHVybiBzdGF0ZTtcblx0fSxcblx0X2NvcHlTdGF0ZSA9IChzdGF0ZSwgb3ZlcnJpZGUsIG9taXRPZmZzZXRzKSA9PiB7XG5cdFx0bGV0IHJlc3VsdCA9IFtdLFxuXHRcdFx0bCA9IHN0YXRlLmxlbmd0aCxcblx0XHRcdGkgPSBvbWl0T2Zmc2V0cyA/IDggOiAwLCAvLyBza2lwIHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSBpZiBvbWl0T2Zmc2V0cyBpcyB0cnVlXG5cdFx0XHRwO1xuXHRcdGZvciAoOyBpIDwgbDsgaSArPSAyKSB7XG5cdFx0XHRwID0gc3RhdGVbaV07XG5cdFx0XHRyZXN1bHQucHVzaChwLCAocCBpbiBvdmVycmlkZSkgPyBvdmVycmlkZVtwXSA6IHN0YXRlW2krMV0pO1xuXHRcdH1cblx0XHRyZXN1bHQudCA9IHN0YXRlLnQ7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblx0X3dpbk9mZnNldHMgPSB7bGVmdDowLCB0b3A6MH0sXG5cdF9wYXJzZVBvc2l0aW9uID0gKHZhbHVlLCB0cmlnZ2VyLCBzY3JvbGxlclNpemUsIGRpcmVjdGlvbiwgc2Nyb2xsLCBtYXJrZXIsIG1hcmtlclNjcm9sbGVyLCBzZWxmLCBzY3JvbGxlckJvdW5kcywgYm9yZGVyV2lkdGgsIHVzZUZpeGVkUG9zaXRpb24sIHNjcm9sbGVyTWF4KSA9PiB7XG5cdFx0X2lzRnVuY3Rpb24odmFsdWUpICYmICh2YWx1ZSA9IHZhbHVlKHNlbGYpKTtcblx0XHRpZiAoX2lzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5zdWJzdHIoMCwzKSA9PT0gXCJtYXhcIikge1xuXHRcdFx0dmFsdWUgPSBzY3JvbGxlck1heCArICh2YWx1ZS5jaGFyQXQoNCkgPT09IFwiPVwiID8gX29mZnNldFRvUHgoXCIwXCIgKyB2YWx1ZS5zdWJzdHIoMyksIHNjcm9sbGVyU2l6ZSkgOiAwKTtcblx0XHR9XG5cdFx0aWYgKCFfaXNOdW1iZXIodmFsdWUpKSB7XG5cdFx0XHRfaXNGdW5jdGlvbih0cmlnZ2VyKSAmJiAodHJpZ2dlciA9IHRyaWdnZXIoc2VsZikpO1xuXHRcdFx0bGV0IGVsZW1lbnQgPSBfdG9BcnJheSh0cmlnZ2VyKVswXSB8fCBfYm9keSxcblx0XHRcdFx0Ym91bmRzID0gX2dldEJvdW5kcyhlbGVtZW50KSB8fCB7fSxcblx0XHRcdFx0b2Zmc2V0cyA9IHZhbHVlLnNwbGl0KFwiIFwiKSxcblx0XHRcdFx0bG9jYWxPZmZzZXQsIGdsb2JhbE9mZnNldCwgZGlzcGxheTtcblx0XHRcdGlmICgoIWJvdW5kcyB8fCAoIWJvdW5kcy5sZWZ0ICYmICFib3VuZHMudG9wKSkgJiYgX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZGlzcGxheSA9PT0gXCJub25lXCIpIHsgLy8gaWYgZGlzcGxheSBpcyBcIm5vbmVcIiwgaXQgd29uJ3QgcmVwb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHByb3Blcmx5XG5cdFx0XHRcdGRpc3BsYXkgPSBlbGVtZW50LnN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0XHRcdFx0Ym91bmRzID0gX2dldEJvdW5kcyhlbGVtZW50KTtcblx0XHRcdFx0ZGlzcGxheSA/IChlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5KSA6IGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJkaXNwbGF5XCIpO1xuXHRcdFx0fVxuXHRcdFx0bG9jYWxPZmZzZXQgPSBfb2Zmc2V0VG9QeChvZmZzZXRzWzBdLCBib3VuZHNbZGlyZWN0aW9uLmRdKTtcblx0XHRcdGdsb2JhbE9mZnNldCA9IF9vZmZzZXRUb1B4KG9mZnNldHNbMV0gfHwgXCIwXCIsIHNjcm9sbGVyU2l6ZSk7XG5cdFx0XHR2YWx1ZSA9IGJvdW5kc1tkaXJlY3Rpb24ucF0gLSBzY3JvbGxlckJvdW5kc1tkaXJlY3Rpb24ucF0gLSBib3JkZXJXaWR0aCArIGxvY2FsT2Zmc2V0ICsgc2Nyb2xsIC0gZ2xvYmFsT2Zmc2V0O1xuXHRcdFx0bWFya2VyU2Nyb2xsZXIgJiYgX3Bvc2l0aW9uTWFya2VyKG1hcmtlclNjcm9sbGVyLCBnbG9iYWxPZmZzZXQsIGRpcmVjdGlvbiwgKHNjcm9sbGVyU2l6ZSAtIGdsb2JhbE9mZnNldCA8IDIwIHx8IChtYXJrZXJTY3JvbGxlci5faXNTdGFydCAmJiBnbG9iYWxPZmZzZXQgPiAyMCkpKTtcblx0XHRcdHNjcm9sbGVyU2l6ZSAtPSBzY3JvbGxlclNpemUgLSBnbG9iYWxPZmZzZXQ7IC8vIGFkanVzdCBmb3IgdGhlIG1hcmtlclxuXHRcdH0gZWxzZSBpZiAobWFya2VyU2Nyb2xsZXIpIHtcblx0XHRcdF9wb3NpdGlvbk1hcmtlcihtYXJrZXJTY3JvbGxlciwgc2Nyb2xsZXJTaXplLCBkaXJlY3Rpb24sIHRydWUpO1xuXHRcdH1cblx0XHRpZiAobWFya2VyKSB7XG5cdFx0XHRsZXQgcG9zaXRpb24gPSB2YWx1ZSArIHNjcm9sbGVyU2l6ZSxcblx0XHRcdFx0aXNTdGFydCA9IG1hcmtlci5faXNTdGFydDtcblx0XHRcdHNjcm9sbGVyTWF4ID0gXCJzY3JvbGxcIiArIGRpcmVjdGlvbi5kMjtcblx0XHRcdF9wb3NpdGlvbk1hcmtlcihtYXJrZXIsIHBvc2l0aW9uLCBkaXJlY3Rpb24sIChpc1N0YXJ0ICYmIHBvc2l0aW9uID4gMjApIHx8ICghaXNTdGFydCAmJiAodXNlRml4ZWRQb3NpdGlvbiA/IE1hdGgubWF4KF9ib2R5W3Njcm9sbGVyTWF4XSwgX2RvY0VsW3Njcm9sbGVyTWF4XSkgOiBtYXJrZXIucGFyZW50Tm9kZVtzY3JvbGxlck1heF0pIDw9IHBvc2l0aW9uICsgMSkpO1xuXHRcdFx0aWYgKHVzZUZpeGVkUG9zaXRpb24pIHtcblx0XHRcdFx0c2Nyb2xsZXJCb3VuZHMgPSBfZ2V0Qm91bmRzKG1hcmtlclNjcm9sbGVyKTtcblx0XHRcdFx0dXNlRml4ZWRQb3NpdGlvbiAmJiAobWFya2VyLnN0eWxlW2RpcmVjdGlvbi5vcC5wXSA9IChzY3JvbGxlckJvdW5kc1tkaXJlY3Rpb24ub3AucF0gLSBkaXJlY3Rpb24ub3AubSAtIG1hcmtlci5fb2Zmc2V0KSArIF9weCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKTtcblx0fSxcblx0X3ByZWZpeEV4cCA9IC8oPzp3ZWJraXR8bW96fGxlbmd0aHxjc3NUZXh0fGluc2V0KS9pLFxuXHRfcmVwYXJlbnQgPSAoZWxlbWVudCwgcGFyZW50LCB0b3AsIGxlZnQpID0+IHtcblx0XHRpZiAoZWxlbWVudC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHtcblx0XHRcdGxldCBzdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG5cdFx0XHRcdHAsIGNzO1xuXHRcdFx0aWYgKHBhcmVudCA9PT0gX2JvZHkpIHtcblx0XHRcdFx0ZWxlbWVudC5fc3RPcmlnID0gc3R5bGUuY3NzVGV4dDsgLy8gcmVjb3JkIG9yaWdpbmFsIGlubGluZSBzdHlsZXMgc28gd2UgY2FuIHJldmVydCB0aGVtIGxhdGVyXG5cdFx0XHRcdGNzID0gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cdFx0XHRcdGZvciAocCBpbiBjcykgeyAvLyBtdXN0IGNvcHkgYWxsIHJlbGV2YW50IHN0eWxlcyB0byBlbnN1cmUgdGhhdCBub3RoaW5nIGNoYW5nZXMgdmlzdWFsbHkgd2hlbiB3ZSByZXBhcmVudCB0byB0aGUgPGJvZHk+LiBTa2lwIHRoZSB2ZW5kb3IgcHJlZml4ZWQgb25lcy5cblx0XHRcdFx0XHRpZiAoIStwICYmICFfcHJlZml4RXhwLnRlc3QocCkgJiYgY3NbcF0gJiYgdHlwZW9mIHN0eWxlW3BdID09PSBcInN0cmluZ1wiICYmIHAgIT09IFwiMFwiKSB7XG5cdFx0XHRcdFx0XHRzdHlsZVtwXSA9IGNzW3BdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS50b3AgPSB0b3A7XG5cdFx0XHRcdHN0eWxlLmxlZnQgPSBsZWZ0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3R5bGUuY3NzVGV4dCA9IGVsZW1lbnQuX3N0T3JpZztcblx0XHRcdH1cblx0XHRcdGdzYXAuY29yZS5nZXRDYWNoZShlbGVtZW50KS51bmNhY2hlID0gMTtcblx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcblx0XHR9XG5cdH0sXG5cdC8vIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHR3ZWVuIHRoZSBzY3JvbGwgcG9zaXRpb24gaW4gdGhlIGRpcmVjdGlvbiBwcm92aWRlZCwgYW5kIHdoZW4gZG9pbmcgc28gaXQnbGwgYWRkIGEgLnR3ZWVuIHByb3BlcnR5IHRvIHRoZSBGVU5DVElPTiBpdHNlbGYsIGFuZCByZW1vdmUgaXQgd2hlbiB0aGUgdHdlZW4gY29tcGxldGVzIG9yIGdldHMga2lsbGVkLiBUaGlzIGdpdmVzIHVzIGEgd2F5IHRvIGhhdmUgbXVsdGlwbGUgU2Nyb2xsVHJpZ2dlcnMgdXNlIGEgY2VudHJhbCBmdW5jdGlvbiBmb3IgYW55IGdpdmVuIHNjcm9sbGVyIGFuZCBzZWUgaWYgdGhlcmUncyBhIHNjcm9sbCB0d2VlbiBydW5uaW5nICh3aGljaCB3b3VsZCBhZmZlY3QgaWYvaG93IHRoaW5ncyBnZXQgdXBkYXRlZClcblx0X2dldFR3ZWVuQ3JlYXRvciA9IChzY3JvbGxlciwgZGlyZWN0aW9uKSA9PiB7XG5cdFx0bGV0IGdldFNjcm9sbCA9IF9nZXRTY3JvbGxGdW5jKHNjcm9sbGVyLCBkaXJlY3Rpb24pLFxuXHRcdFx0cHJvcCA9IFwiX3Njcm9sbFwiICsgZGlyZWN0aW9uLnAyLCAvLyBhZGQgYSB0d2VlbmFibGUgcHJvcGVydHkgdG8gdGhlIHNjcm9sbGVyIHRoYXQncyBhIGdldHRlci9zZXR0ZXIgZnVuY3Rpb24sIGxpa2UgX3Njcm9sbFRvcCBvciBfc2Nyb2xsTGVmdC4gVGhpcyB3YXksIGlmIHNvbWVvbmUgZG9lcyBnc2FwLmtpbGxUd2VlbnNPZihzY3JvbGxlcikgaXQnbGwga2lsbCB0aGUgc2Nyb2xsIHR3ZWVuLlxuXHRcdFx0bGFzdFNjcm9sbDEsIGxhc3RTY3JvbGwyLFxuXHRcdFx0Z2V0VHdlZW4gPSAoc2Nyb2xsVG8sIHZhcnMsIGluaXRpYWxWYWx1ZSwgY2hhbmdlMSwgY2hhbmdlMikgPT4ge1xuXHRcdFx0XHRsZXQgdHdlZW4gPSBnZXRUd2Vlbi50d2Vlbixcblx0XHRcdFx0XHRvbkNvbXBsZXRlID0gdmFycy5vbkNvbXBsZXRlLFxuXHRcdFx0XHRcdG1vZGlmaWVycyA9IHt9O1xuXHRcdFx0XHR0d2VlbiAmJiB0d2Vlbi5raWxsKCk7XG5cdFx0XHRcdGxhc3RTY3JvbGwxID0gTWF0aC5yb3VuZChpbml0aWFsVmFsdWUpO1xuXHRcdFx0XHR2YXJzW3Byb3BdID0gc2Nyb2xsVG87XG5cdFx0XHRcdHZhcnMubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuXHRcdFx0XHRtb2RpZmllcnNbcHJvcF0gPSB2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0dmFsdWUgPSBfcm91bmQoZ2V0U2Nyb2xsKCkpOyAvLyByb3VuZCBiZWNhdXNlIGluIHNvbWUgW3ZlcnkgdW5jb21tb25dIFdpbmRvd3MgZW52aXJvbm1lbnRzLCBpdCBjYW4gZ2V0IHJlcG9ydGVkIHdpdGggZGVjaW1hbHMgZXZlbiB0aG91Z2ggaXQgd2FzIHNldCB3aXRob3V0LlxuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gbGFzdFNjcm9sbDEgJiYgdmFsdWUgIT09IGxhc3RTY3JvbGwyICYmIE1hdGguYWJzKHZhbHVlIC0gbGFzdFNjcm9sbDEpID4gMikgeyAvLyBpZiB0aGUgdXNlciBzY3JvbGxzLCBraWxsIHRoZSB0d2Vlbi4gaU9TIFNhZmFyaSBpbnRlcm1pdHRlbnRseSBtaXNyZXBvcnRzIHRoZSBzY3JvbGwgcG9zaXRpb24sIGl0IG1heSBiZSB0aGUgbW9zdCByZWNlbnRseS1zZXQgb25lIG9yIHRoZSBvbmUgYmVmb3JlIHRoYXQhIFdoZW4gU2FmYXJpIGlzIHpvb21lZCAoQ01ELSspLCBpdCBvZnRlbiBtaXNyZXBvcnRzIGFzIDEgcGl4ZWwgb2ZmIHRvbyEgU28gaWYgd2Ugc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gdG8gMTI1LCBmb3IgZXhhbXBsZSwgaXQnbGwgYWN0dWFsbHkgcmVwb3J0IGl0IGFzIDEyNC5cblx0XHRcdFx0XHRcdHR3ZWVuLmtpbGwoKTtcblx0XHRcdFx0XHRcdGdldFR3ZWVuLnR3ZWVuID0gMDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBpbml0aWFsVmFsdWUgKyBjaGFuZ2UxICogdHdlZW4ucmF0aW8gKyBjaGFuZ2UyICogdHdlZW4ucmF0aW8gKiB0d2Vlbi5yYXRpbztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGFzdFNjcm9sbDIgPSBsYXN0U2Nyb2xsMTtcblx0XHRcdFx0XHRyZXR1cm4gKGxhc3RTY3JvbGwxID0gX3JvdW5kKHZhbHVlKSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHZhcnMub25Db21wbGV0ZSA9ICgpID0+IHtcblx0XHRcdFx0XHRnZXRUd2Vlbi50d2VlbiA9IDA7XG5cdFx0XHRcdFx0b25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlLmNhbGwodHdlZW4pO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR0d2VlbiA9IGdldFR3ZWVuLnR3ZWVuID0gZ3NhcC50byhzY3JvbGxlciwgdmFycyk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH07XG5cdFx0c2Nyb2xsZXJbcHJvcF0gPSBnZXRTY3JvbGw7XG5cdFx0c2Nyb2xsZXIuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsICgpID0+IGdldFR3ZWVuLnR3ZWVuICYmIGdldFR3ZWVuLnR3ZWVuLmtpbGwoKSAmJiAoZ2V0VHdlZW4udHdlZW4gPSAwKSk7IC8vIFdpbmRvd3MgbWFjaGluZXMgaGFuZGxlIG1vdXNld2hlZWwgc2Nyb2xsaW5nIGluIGNodW5rcyAobGlrZSBcIjMgbGluZXMgcGVyIHNjcm9sbFwiKSBtZWFuaW5nIHRoZSB0eXBpY2FsIHN0cmF0ZWd5IGZvciBjYW5jZWxsaW5nIHRoZSBzY3JvbGwgaXNuJ3QgYXMgc2Vuc2l0aXZlLiBJdCdzIG11Y2ggbW9yZSBsaWtlbHkgdG8gbWF0Y2ggb25lIG9mIHRoZSBwcmV2aW91cyAyIHNjcm9sbCBldmVudCBwb3NpdGlvbnMuIFNvIHdlIGtpbGwgYW55IHNuYXBwaW5nIGFzIHNvb24gYXMgdGhlcmUncyBhIHdoZWVsIGV2ZW50LlxuXHRcdHJldHVybiBnZXRUd2Vlbjtcblx0fTtcblxuX2hvcml6b250YWwub3AgPSBfdmVydGljYWw7XG5cblxuXG5leHBvcnQgY2xhc3MgU2Nyb2xsVHJpZ2dlciB7XG5cblx0Y29uc3RydWN0b3IodmFycywgYW5pbWF0aW9uKSB7XG5cdFx0X2NvcmVJbml0dGVkIHx8IFNjcm9sbFRyaWdnZXIucmVnaXN0ZXIoZ3NhcCkgfHwgY29uc29sZS53YXJuKFwiUGxlYXNlIGdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVHJpZ2dlcilcIik7XG5cdFx0dGhpcy5pbml0KHZhcnMsIGFuaW1hdGlvbik7XG5cdH1cblxuXHRpbml0KHZhcnMsIGFuaW1hdGlvbikge1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSB0aGlzLnN0YXJ0ID0gMDtcblx0XHR0aGlzLnZhcnMgJiYgdGhpcy5raWxsKDEpOyAvLyBpbiBjYXNlIGl0J3MgYmVpbmcgaW5pdHRlZCBhZ2FpblxuXHRcdGlmICghX2VuYWJsZWQpIHtcblx0XHRcdHRoaXMudXBkYXRlID0gdGhpcy5yZWZyZXNoID0gdGhpcy5raWxsID0gX3Bhc3NUaHJvdWdoO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXJzID0gX3NldERlZmF1bHRzKChfaXNTdHJpbmcodmFycykgfHwgX2lzTnVtYmVyKHZhcnMpIHx8IHZhcnMubm9kZVR5cGUpID8ge3RyaWdnZXI6IHZhcnN9IDogdmFycywgX2RlZmF1bHRzKTtcblx0XHRsZXQgZGlyZWN0aW9uID0gdmFycy5ob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwsXG5cdFx0XHR7b25VcGRhdGUsIHRvZ2dsZUNsYXNzLCBpZCwgb25Ub2dnbGUsIG9uUmVmcmVzaCwgc2NydWIsIHRyaWdnZXIsIHBpbiwgcGluU3BhY2luZywgaW52YWxpZGF0ZU9uUmVmcmVzaCwgYW50aWNpcGF0ZVBpbiwgb25TY3J1YkNvbXBsZXRlLCBvblNuYXBDb21wbGV0ZSwgb25jZSwgc25hcCwgcGluUmVwYXJlbnR9ID0gdmFycyxcblx0XHRcdGlzVG9nZ2xlID0gIXNjcnViICYmIHNjcnViICE9PSAwLFxuXHRcdFx0c2Nyb2xsZXIgPSBfdG9BcnJheSh2YXJzLnNjcm9sbGVyIHx8IF93aW4pWzBdLFxuXHRcdFx0c2Nyb2xsZXJDYWNoZSA9IGdzYXAuY29yZS5nZXRDYWNoZShzY3JvbGxlciksXG5cdFx0XHRpc1ZpZXdwb3J0ID0gX2lzVmlld3BvcnQoc2Nyb2xsZXIpLFxuXHRcdFx0dXNlRml4ZWRQb3NpdGlvbiA9IFwicGluVHlwZVwiIGluIHZhcnMgPyB2YXJzLnBpblR5cGUgPT09IFwiZml4ZWRcIiA6IGlzVmlld3BvcnQgfHwgX2dldFByb3h5UHJvcChzY3JvbGxlciwgXCJwaW5UeXBlXCIpID09PSBcImZpeGVkXCIsXG5cdFx0XHRjYWxsYmFja3MgPSBbdmFycy5vbkVudGVyLCB2YXJzLm9uTGVhdmUsIHZhcnMub25FbnRlckJhY2ssIHZhcnMub25MZWF2ZUJhY2tdLFxuXHRcdFx0dG9nZ2xlQWN0aW9ucyA9IGlzVG9nZ2xlICYmIHZhcnMudG9nZ2xlQWN0aW9ucy5zcGxpdChcIiBcIiksXG5cdFx0XHRtYXJrZXJzID0gXCJtYXJrZXJzXCIgaW4gdmFycyA/IHZhcnMubWFya2VycyA6IF9kZWZhdWx0cy5tYXJrZXJzLFxuXHRcdFx0Ym9yZGVyV2lkdGggPSBpc1ZpZXdwb3J0ID8gMCA6IHBhcnNlRmxvYXQoX2dldENvbXB1dGVkU3R5bGUoc2Nyb2xsZXIpW1wiYm9yZGVyXCIgKyBkaXJlY3Rpb24ucDIgKyBfV2lkdGhdKSB8fCAwLFxuXHRcdFx0c2VsZiA9IHRoaXMsXG5cdFx0XHRvblJlZnJlc2hJbml0ID0gdmFycy5vblJlZnJlc2hJbml0ICYmICgoKSA9PiB2YXJzLm9uUmVmcmVzaEluaXQoc2VsZikpLFxuXHRcdFx0Z2V0U2Nyb2xsZXJTaXplID0gX2dldFNpemVGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCBkaXJlY3Rpb24pLFxuXHRcdFx0Z2V0U2Nyb2xsZXJPZmZzZXRzID0gX2dldE9mZnNldHNGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0KSxcblx0XHRcdGxhc3RTbmFwID0gMCxcblx0XHRcdHR3ZWVuVG8sIHBpbkNhY2hlLCBzbmFwRnVuYywgc2Nyb2xsMSwgc2Nyb2xsMiwgc3RhcnQsIGVuZCwgbWFya2VyU3RhcnQsIG1hcmtlckVuZCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyLCBtYXJrZXJWYXJzLFxuXHRcdFx0Y2hhbmdlLCBwaW5PcmlnaW5hbFN0YXRlLCBwaW5BY3RpdmVTdGF0ZSwgcGluU3RhdGUsIHNwYWNlciwgb2Zmc2V0LCBwaW5HZXR0ZXIsIHBpblNldHRlciwgcGluU3RhcnQsIHBpbkNoYW5nZSwgc3BhY2luZ1N0YXJ0LCBzcGFjZXJTdGF0ZSwgbWFya2VyU3RhcnRTZXR0ZXIsXG5cdFx0XHRtYXJrZXJFbmRTZXR0ZXIsIGNzLCBzbmFwMSwgc25hcDIsIHNjcnViVHdlZW4sIHNjcnViU21vb3RoLCBzbmFwRHVyQ2xhbXAsIHNuYXBEZWxheWVkQ2FsbCwgcHJldlByb2dyZXNzLCBwcmV2U2Nyb2xsLCBwcmV2QW5pbVByb2dyZXNzO1xuXG5cdFx0c2VsZi5tZWRpYSA9IF9jcmVhdGluZ01lZGlhO1xuXHRcdGFudGljaXBhdGVQaW4gKj0gNDU7XG5cdFx0c2VsZi5zY3JvbGxlciA9IHNjcm9sbGVyO1xuXHRcdHNlbGYuc2Nyb2xsID0gX2dldFNjcm9sbEZ1bmMoc2Nyb2xsZXIsIGRpcmVjdGlvbik7XG5cdFx0c2Nyb2xsMSA9IHNlbGYuc2Nyb2xsKCk7XG5cdFx0c2VsZi52YXJzID0gdmFycztcblx0XHRhbmltYXRpb24gPSBhbmltYXRpb24gfHwgdmFycy5hbmltYXRpb247XG5cdFx0KFwicmVmcmVzaFByaW9yaXR5XCIgaW4gdmFycykgJiYgKF9zb3J0ID0gMSk7XG5cdFx0c2Nyb2xsZXJDYWNoZS50d2VlblNjcm9sbCA9IHNjcm9sbGVyQ2FjaGUudHdlZW5TY3JvbGwgfHwge1xuXHRcdFx0dG9wOiBfZ2V0VHdlZW5DcmVhdG9yKHNjcm9sbGVyLCBfdmVydGljYWwpLFxuXHRcdFx0bGVmdDogX2dldFR3ZWVuQ3JlYXRvcihzY3JvbGxlciwgX2hvcml6b250YWwpXG5cdFx0fTtcblx0XHRzZWxmLnR3ZWVuVG8gPSB0d2VlblRvID0gc2Nyb2xsZXJDYWNoZS50d2VlblNjcm9sbFtkaXJlY3Rpb24ucF07XG5cdFx0aWYgKGFuaW1hdGlvbikge1xuXHRcdFx0YW5pbWF0aW9uLnZhcnMubGF6eSA9IGZhbHNlO1xuXHRcdFx0YW5pbWF0aW9uLl9pbml0dGVkIHx8IChhbmltYXRpb24udmFycy5pbW1lZGlhdGVSZW5kZXIgIT09IGZhbHNlICYmIHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZSAmJiBhbmltYXRpb24ucmVuZGVyKDAsIHRydWUsIHRydWUpKTtcblx0XHRcdHNlbGYuYW5pbWF0aW9uID0gYW5pbWF0aW9uLnBhdXNlKCk7XG5cdFx0XHRhbmltYXRpb24uc2Nyb2xsVHJpZ2dlciA9IHNlbGY7XG5cdFx0XHRzY3J1YlNtb290aCA9IF9pc051bWJlcihzY3J1YikgJiYgc2NydWI7XG5cdFx0XHRzY3J1YlNtb290aCAmJiAoc2NydWJUd2VlbiA9IGdzYXAudG8oYW5pbWF0aW9uLCB7ZWFzZTogXCJwb3dlcjNcIiwgZHVyYXRpb246IHNjcnViU21vb3RoLCBvbkNvbXBsZXRlOiAoKSA9PiBvblNjcnViQ29tcGxldGUgJiYgb25TY3J1YkNvbXBsZXRlKHNlbGYpfSkpO1xuXHRcdFx0c25hcDEgPSAwO1xuXHRcdFx0aWQgfHwgKGlkID0gYW5pbWF0aW9uLnZhcnMuaWQpO1xuXHRcdH1cblx0XHRfdHJpZ2dlcnMucHVzaChzZWxmKTtcblx0XHRpZiAoc25hcCkge1xuXHRcdFx0X2lzT2JqZWN0KHNuYXApIHx8IChzbmFwID0ge3NuYXBUbzogc25hcH0pO1xuXHRcdFx0KFwic2Nyb2xsQmVoYXZpb3JcIiBpbiBfYm9keS5zdHlsZSkgJiYgZ3NhcC5zZXQoaXNWaWV3cG9ydCA/IFtfYm9keSwgX2RvY0VsXSA6IHNjcm9sbGVyLCB7c2Nyb2xsQmVoYXZpb3I6IFwiYXV0b1wifSk7IC8vIHNtb290aCBzY3JvbGxpbmcgZG9lc24ndCB3b3JrIHdpdGggc25hcC5cblx0XHRcdHNuYXBGdW5jID0gX2lzRnVuY3Rpb24oc25hcC5zbmFwVG8pID8gc25hcC5zbmFwVG8gOiBzbmFwLnNuYXBUbyA9PT0gXCJsYWJlbHNcIiA/IF9nZXRDbG9zZXN0TGFiZWwoYW5pbWF0aW9uKSA6IHNuYXAuc25hcFRvID09PSBcImxhYmVsc0RpcmVjdGlvbmFsXCIgPyBfZ2V0TGFiZWxBdERpcmVjdGlvbihhbmltYXRpb24pIDogZ3NhcC51dGlscy5zbmFwKHNuYXAuc25hcFRvKTtcblx0XHRcdHNuYXBEdXJDbGFtcCA9IHNuYXAuZHVyYXRpb24gfHwge21pbjogMC4xLCBtYXg6IDJ9O1xuXHRcdFx0c25hcER1ckNsYW1wID0gX2lzT2JqZWN0KHNuYXBEdXJDbGFtcCkgPyBfY2xhbXAoc25hcER1ckNsYW1wLm1pbiwgc25hcER1ckNsYW1wLm1heCkgOiBfY2xhbXAoc25hcER1ckNsYW1wLCBzbmFwRHVyQ2xhbXApO1xuXHRcdFx0c25hcERlbGF5ZWRDYWxsID0gZ3NhcC5kZWxheWVkQ2FsbChzbmFwLmRlbGF5IHx8IChzY3J1YlNtb290aCAvIDIpIHx8IDAuMSwgKCkgPT4ge1xuXHRcdFx0XHRpZiAoTWF0aC5hYnMoc2VsZi5nZXRWZWxvY2l0eSgpKSA8IDEwICYmICFfcG9pbnRlcklzRG93biAmJiBsYXN0U25hcCAhPT0gc2VsZi5zY3JvbGwoKSkge1xuXHRcdFx0XHRcdGxldCB0b3RhbFByb2dyZXNzID0gYW5pbWF0aW9uICYmICFpc1RvZ2dsZSA/IGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKCkgOiBzZWxmLnByb2dyZXNzLFxuXHRcdFx0XHRcdFx0dmVsb2NpdHkgPSAoKHRvdGFsUHJvZ3Jlc3MgLSBzbmFwMikgLyAoX2dldFRpbWUoKSAtIF90aW1lMikgKiAxMDAwKSB8fCAwLFxuXHRcdFx0XHRcdFx0Y2hhbmdlMSA9IGdzYXAudXRpbHMuY2xhbXAoLXNlbGYucHJvZ3Jlc3MsIDEgLSBzZWxmLnByb2dyZXNzLCBfYWJzKHZlbG9jaXR5IC8gMikgKiB2ZWxvY2l0eSAvIDAuMTg1KSxcblx0XHRcdFx0XHRcdG5hdHVyYWxFbmQgPSBzZWxmLnByb2dyZXNzICsgKHNuYXAuaW5lcnRpYSA9PT0gZmFsc2UgPyAwIDogY2hhbmdlMSksXG5cdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IF9jbGFtcCgwLCAxLCBzbmFwRnVuYyhuYXR1cmFsRW5kLCBzZWxmKSksXG5cdFx0XHRcdFx0XHRzY3JvbGwgPSBzZWxmLnNjcm9sbCgpLFxuXHRcdFx0XHRcdFx0ZW5kU2Nyb2xsID0gTWF0aC5yb3VuZChzdGFydCArIGVuZFZhbHVlICogY2hhbmdlKSxcblx0XHRcdFx0XHRcdHsgb25TdGFydCwgb25JbnRlcnJ1cHQsIG9uQ29tcGxldGUgfSA9IHNuYXAsXG5cdFx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuVG8udHdlZW47XG5cdFx0XHRcdFx0aWYgKHNjcm9sbCA8PSBlbmQgJiYgc2Nyb2xsID49IHN0YXJ0ICYmIGVuZFNjcm9sbCAhPT0gc2Nyb2xsKSB7XG5cdFx0XHRcdFx0XHRpZiAodHdlZW4gJiYgIXR3ZWVuLl9pbml0dGVkICYmIHR3ZWVuLmRhdGEgPD0gTWF0aC5hYnMoZW5kU2Nyb2xsIC0gc2Nyb2xsKSkgeyAvLyB0aGVyZSdzIGFuIG92ZXJsYXBwaW5nIHNuYXAhIFNvIHdlIG11c3QgZmlndXJlIG91dCB3aGljaCBvbmUgaXMgY2xvc2VyIGFuZCBsZXQgdGhhdCB0d2VlbiBsaXZlLlxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoc25hcC5pbmVydGlhID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0XHRjaGFuZ2UxID0gZW5kVmFsdWUgLSBzZWxmLnByb2dyZXNzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHdlZW5UbyhlbmRTY3JvbGwsIHtcblx0XHRcdFx0XHRcdFx0ZHVyYXRpb246IHNuYXBEdXJDbGFtcChfYWJzKCAoTWF0aC5tYXgoX2FicyhuYXR1cmFsRW5kIC0gdG90YWxQcm9ncmVzcyksIF9hYnMoZW5kVmFsdWUgLSB0b3RhbFByb2dyZXNzKSkgKiAwLjE4NSAvIHZlbG9jaXR5IC8gMC4wNSkgfHwgMCkpLFxuXHRcdFx0XHRcdFx0XHRlYXNlOiBzbmFwLmVhc2UgfHwgXCJwb3dlcjNcIixcblx0XHRcdFx0XHRcdFx0ZGF0YTogTWF0aC5hYnMoZW5kU2Nyb2xsIC0gc2Nyb2xsKSwgLy8gcmVjb3JkIHRoZSBkaXN0YW5jZSBzbyB0aGF0IGlmIGFub3RoZXIgc25hcCB0d2VlbiBvY2N1cnMgKGNvbmZsaWN0KSB3ZSBjYW4gcHJpb3JpdGl6ZSB0aGUgY2xvc2VzdCBzbmFwLlxuXHRcdFx0XHRcdFx0XHRvbkludGVycnVwdDogKCkgPT4gc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSkgJiYgb25JbnRlcnJ1cHQgJiYgb25JbnRlcnJ1cHQoc2VsZiksXG5cdFx0XHRcdFx0XHRcdG9uQ29tcGxldGU6ICgpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRsYXN0U25hcCA9IHNlbGYuc2Nyb2xsKCk7XG5cdFx0XHRcdFx0XHRcdFx0c25hcDEgPSBzbmFwMiA9IGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUgPyBhbmltYXRpb24udG90YWxQcm9ncmVzcygpIDogc2VsZi5wcm9ncmVzcztcblx0XHRcdFx0XHRcdFx0XHRvblNuYXBDb21wbGV0ZSAmJiBvblNuYXBDb21wbGV0ZShzZWxmKTtcblx0XHRcdFx0XHRcdFx0XHRvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUoc2VsZik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sIHNjcm9sbCwgY2hhbmdlMSAqIGNoYW5nZSwgZW5kU2Nyb2xsIC0gc2Nyb2xsIC0gY2hhbmdlMSAqIGNoYW5nZSk7XG5cdFx0XHRcdFx0XHRvblN0YXJ0ICYmIG9uU3RhcnQoc2VsZiwgdHdlZW5Uby50d2Vlbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHNlbGYuaXNBY3RpdmUpIHtcblx0XHRcdFx0XHRzbmFwRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSkucGF1c2UoKTtcblx0XHR9XG5cdFx0aWQgJiYgKF9pZHNbaWRdID0gc2VsZik7XG5cdFx0dHJpZ2dlciA9IHNlbGYudHJpZ2dlciA9IF90b0FycmF5KHRyaWdnZXIgfHwgcGluKVswXTtcblx0XHRwaW4gPSBwaW4gPT09IHRydWUgPyB0cmlnZ2VyIDogX3RvQXJyYXkocGluKVswXTtcblx0XHRfaXNTdHJpbmcodG9nZ2xlQ2xhc3MpICYmICh0b2dnbGVDbGFzcyA9IHt0YXJnZXRzOiB0cmlnZ2VyLCBjbGFzc05hbWU6IHRvZ2dsZUNsYXNzfSk7XG5cdFx0aWYgKHBpbikge1xuXHRcdFx0KHBpblNwYWNpbmcgPT09IGZhbHNlIHx8IHBpblNwYWNpbmcgPT09IF9tYXJnaW4pIHx8IChwaW5TcGFjaW5nID0gIXBpblNwYWNpbmcgJiYgX2dldENvbXB1dGVkU3R5bGUocGluLnBhcmVudE5vZGUpLmRpc3BsYXkgPT09IFwiZmxleFwiID8gZmFsc2UgOiBfcGFkZGluZyk7IC8vIGlmIHRoZSBwYXJlbnQgaXMgZGlzcGxheTogZmxleCwgZG9uJ3QgYXBwbHkgcGluU3BhY2luZyBieSBkZWZhdWx0LlxuXHRcdFx0c2VsZi5waW4gPSBwaW47XG5cdFx0XHR2YXJzLmZvcmNlM0QgIT09IGZhbHNlICYmIGdzYXAuc2V0KHBpbiwge2ZvcmNlM0Q6IHRydWV9KTtcblx0XHRcdHBpbkNhY2hlID0gZ3NhcC5jb3JlLmdldENhY2hlKHBpbik7XG5cdFx0XHRpZiAoIXBpbkNhY2hlLnNwYWNlcikgeyAvLyByZWNvcmQgdGhlIHNwYWNlciBhbmQgcGluT3JpZ2luYWxTdGF0ZSBvbiB0aGUgY2FjaGUgaW4gY2FzZSBzb21lb25lIHRyaWVzIHBpbm5pbmcgdGhlIHNhbWUgZWxlbWVudCB3aXRoIE1VTFRJUExFIFNjcm9sbFRyaWdnZXJzIC0gd2UgZG9uJ3Qgd2FudCB0byBoYXZlIG11bHRpcGxlIHNwYWNlcnMgb3IgcmVjb3JkIHRoZSBcIm9yaWdpbmFsXCIgcGluIHN0YXRlIGFmdGVyIGl0IGhhcyBhbHJlYWR5IGJlZW4gYWZmZWN0ZWQgYnkgYW5vdGhlciBTY3JvbGxUcmlnZ2VyLlxuXHRcdFx0XHRwaW5DYWNoZS5zcGFjZXIgPSBzcGFjZXIgPSBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0XHRcdHNwYWNlci5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInBpbi1zcGFjZXJcIiArIChpZCA/IFwiIHBpbi1zcGFjZXItXCIgKyBpZCA6IFwiXCIpKTtcblx0XHRcdFx0cGluQ2FjaGUucGluU3RhdGUgPSBwaW5PcmlnaW5hbFN0YXRlID0gX2dldFN0YXRlKHBpbik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwaW5PcmlnaW5hbFN0YXRlID0gcGluQ2FjaGUucGluU3RhdGU7XG5cdFx0XHR9XG5cdFx0XHRzZWxmLnNwYWNlciA9IHNwYWNlciA9IHBpbkNhY2hlLnNwYWNlcjtcblx0XHRcdGNzID0gX2dldENvbXB1dGVkU3R5bGUocGluKTtcblx0XHRcdHNwYWNpbmdTdGFydCA9IGNzW3BpblNwYWNpbmcgKyBkaXJlY3Rpb24ub3MyXTtcblx0XHRcdHBpbkdldHRlciA9IGdzYXAuZ2V0UHJvcGVydHkocGluKTtcblx0XHRcdHBpblNldHRlciA9IGdzYXAucXVpY2tTZXR0ZXIocGluLCBkaXJlY3Rpb24uYSwgX3B4KTtcblx0XHRcdC8vIHBpbi5maXJzdENoaWxkICYmICFfbWF4U2Nyb2xsKHBpbiwgZGlyZWN0aW9uKSAmJiAocGluLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIik7IC8vIHByb3RlY3RzIGZyb20gY29sbGFwc2luZyBtYXJnaW5zLCBidXQgY2FuIGhhdmUgdW5pbnRlbmRlZCBjb25zZXF1ZW5jZXMgYXMgZGVtb25zdHJhdGVkIGhlcmU6IGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuLzFlNDJjN2E3M2JmYTQwOWQyY2YxZTE4NGU3YTQyNDhkIHNvIGl0IHdhcyByZW1vdmVkIGluIGZhdm9yIG9mIGp1c3QgdGVsbGluZyBwZW9wbGUgdG8gc2V0IHVwIHRoZWlyIENTUyB0byBhdm9pZCB0aGUgY29sbGFwc2luZyBtYXJnaW5zIChvdmVyZmxvdzogaGlkZGVuIHwgYXV0byBpcyBqdXN0IG9uZSBvcHRpb24uIEFub3RoZXIgaXMgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHRyYW5zcGFyZW50KS5cblx0XHRcdF9zd2FwUGluSW4ocGluLCBzcGFjZXIsIGNzKTtcblx0XHRcdHBpblN0YXRlID0gX2dldFN0YXRlKHBpbik7XG5cdFx0fVxuXHRcdGlmIChtYXJrZXJzKSB7XG5cdFx0XHRtYXJrZXJWYXJzID0gX2lzT2JqZWN0KG1hcmtlcnMpID8gX3NldERlZmF1bHRzKG1hcmtlcnMsIF9tYXJrZXJEZWZhdWx0cykgOiBfbWFya2VyRGVmYXVsdHM7XG5cdFx0XHRtYXJrZXJTdGFydFRyaWdnZXIgPSBfY3JlYXRlTWFya2VyKFwic2Nyb2xsZXItc3RhcnRcIiwgaWQsIHNjcm9sbGVyLCBkaXJlY3Rpb24sIG1hcmtlclZhcnMsIDApO1xuXHRcdFx0bWFya2VyRW5kVHJpZ2dlciA9IF9jcmVhdGVNYXJrZXIoXCJzY3JvbGxlci1lbmRcIiwgaWQsIHNjcm9sbGVyLCBkaXJlY3Rpb24sIG1hcmtlclZhcnMsIDAsIG1hcmtlclN0YXJ0VHJpZ2dlcik7XG5cdFx0XHRvZmZzZXQgPSBtYXJrZXJTdGFydFRyaWdnZXJbXCJvZmZzZXRcIiArIGRpcmVjdGlvbi5vcC5kMl07XG5cdFx0XHRtYXJrZXJTdGFydCA9IF9jcmVhdGVNYXJrZXIoXCJzdGFydFwiLCBpZCwgc2Nyb2xsZXIsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgb2Zmc2V0KTtcblx0XHRcdG1hcmtlckVuZCA9X2NyZWF0ZU1hcmtlcihcImVuZFwiLCBpZCwgc2Nyb2xsZXIsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgb2Zmc2V0KTtcblx0XHRcdGlmICghdXNlRml4ZWRQb3NpdGlvbiAmJiAhKF9wcm94aWVzLmxlbmd0aCAmJiBfZ2V0UHJveHlQcm9wKHNjcm9sbGVyLCBcImZpeGVkTWFya2Vyc1wiKSA9PT0gdHJ1ZSkpIHtcblx0XHRcdFx0X21ha2VQb3NpdGlvbmFibGUoaXNWaWV3cG9ydCA/IF9ib2R5IDogc2Nyb2xsZXIpO1xuXHRcdFx0XHRnc2FwLnNldChbbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXSwge2ZvcmNlM0Q6IHRydWV9KTtcblx0XHRcdFx0bWFya2VyU3RhcnRTZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKG1hcmtlclN0YXJ0VHJpZ2dlciwgZGlyZWN0aW9uLmEsIF9weCk7XG5cdFx0XHRcdG1hcmtlckVuZFNldHRlciA9IGdzYXAucXVpY2tTZXR0ZXIobWFya2VyRW5kVHJpZ2dlciwgZGlyZWN0aW9uLmEsIF9weCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2VsZi5yZXZlcnQgPSByZXZlcnQgPT4ge1xuXHRcdFx0bGV0IHIgPSByZXZlcnQgIT09IGZhbHNlIHx8ICFzZWxmLmVuYWJsZWQsXG5cdFx0XHRcdHByZXZSZWZyZXNoaW5nID0gX3JlZnJlc2hpbmc7XG5cdFx0XHRpZiAociAhPT0gc2VsZi5pc1JldmVydGVkKSB7XG5cdFx0XHRcdGlmIChyKSB7XG5cdFx0XHRcdFx0c2VsZi5zY3JvbGwucmVjIHx8IChzZWxmLnNjcm9sbC5yZWMgPSBzZWxmLnNjcm9sbCgpKTtcblx0XHRcdFx0XHRwcmV2U2Nyb2xsID0gTWF0aC5tYXgoc2VsZi5zY3JvbGwoKSwgc2VsZi5zY3JvbGwucmVjIHx8IDApOyAvLyByZWNvcmQgdGhlIHNjcm9sbCBzbyB3ZSBjYW4gcmV2ZXJ0IGxhdGVyIChyZXBvc2l0aW9uaW5nL3Bpbm5pbmcgdGhpbmdzIGNhbiBhZmZlY3Qgc2Nyb2xsIHBvc2l0aW9uKS4gSW4gdGhlIHN0YXRpYyByZWZyZXNoKCkgbWV0aG9kLCB3ZSBmaXJzdCByZWNvcmQgYWxsIHRoZSBzY3JvbGwgcG9zaXRpb25zIGFzIGEgcmVmZXJlbmNlLlxuXHRcdFx0XHRcdHByZXZQcm9ncmVzcyA9IHNlbGYucHJvZ3Jlc3M7XG5cdFx0XHRcdFx0cHJldkFuaW1Qcm9ncmVzcyA9IGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucHJvZ3Jlc3MoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtYXJrZXJTdGFydCAmJiBbbWFya2VyU3RhcnQsIG1hcmtlckVuZCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXS5mb3JFYWNoKG0gPT4gbS5zdHlsZS5kaXNwbGF5ID0gciA/IFwibm9uZVwiIDogXCJibG9ja1wiKTtcblx0XHRcdFx0ciAmJiAoX3JlZnJlc2hpbmcgPSAxKTtcblx0XHRcdFx0c2VsZi51cGRhdGUocik7IC8vIG1ha2Ugc3VyZSB0aGUgcGluIGlzIGJhY2sgaW4gaXRzIG9yaWdpbmFsIHBvc2l0aW9uIHNvIHRoYXQgYWxsIHRoZSBtZWFzdXJlbWVudHMgYXJlIGNvcnJlY3QuXG5cdFx0XHRcdF9yZWZyZXNoaW5nID0gcHJldlJlZnJlc2hpbmc7XG5cdFx0XHRcdHBpbiAmJiAociA/IF9zd2FwUGluT3V0KHBpbiwgc3BhY2VyLCBwaW5PcmlnaW5hbFN0YXRlKSA6ICghcGluUmVwYXJlbnQgfHwgIXNlbGYuaXNBY3RpdmUpICYmIF9zd2FwUGluSW4ocGluLCBzcGFjZXIsIF9nZXRDb21wdXRlZFN0eWxlKHBpbiksIHNwYWNlclN0YXRlKSk7XG5cdFx0XHRcdHNlbGYuaXNSZXZlcnRlZCA9IHI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHRzZWxmLnJlZnJlc2ggPSAoc29mdCwgZm9yY2UpID0+IHtcblx0XHRcdGlmICgoX3JlZnJlc2hpbmcgfHwgIXNlbGYuZW5hYmxlZCkgJiYgIWZvcmNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmIChwaW4gJiYgc29mdCAmJiBfbGFzdFNjcm9sbFRpbWUpIHtcblx0XHRcdFx0X2FkZExpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwic2Nyb2xsRW5kXCIsIF9zb2Z0UmVmcmVzaCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0X3JlZnJlc2hpbmcgPSAxO1xuXHRcdFx0c2NydWJUd2VlbiAmJiBzY3J1YlR3ZWVuLnBhdXNlKCk7XG5cdFx0XHRpbnZhbGlkYXRlT25SZWZyZXNoICYmIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucHJvZ3Jlc3MoMCkuaW52YWxpZGF0ZSgpO1xuXHRcdFx0c2VsZi5pc1JldmVydGVkIHx8IHNlbGYucmV2ZXJ0KCk7XG5cdFx0XHRsZXQgc2l6ZSA9IGdldFNjcm9sbGVyU2l6ZSgpLFxuXHRcdFx0XHRzY3JvbGxlckJvdW5kcyA9IGdldFNjcm9sbGVyT2Zmc2V0cygpLFxuXHRcdFx0XHRtYXggPSBfbWF4U2Nyb2xsKHNjcm9sbGVyLCBkaXJlY3Rpb24pLFxuXHRcdFx0XHRvZmZzZXQgPSAwLFxuXHRcdFx0XHRvdGhlclBpbk9mZnNldCA9IDAsXG5cdFx0XHRcdHBhcnNlZEVuZCA9IHZhcnMuZW5kLFxuXHRcdFx0XHRwYXJzZWRFbmRUcmlnZ2VyID0gdmFycy5lbmRUcmlnZ2VyIHx8IHRyaWdnZXIsXG5cdFx0XHRcdHBhcnNlZFN0YXJ0ID0gdmFycy5zdGFydCB8fCAodmFycy5zdGFydCA9PT0gMCB8fCAhdHJpZ2dlciA/IDAgOiAocGluID8gXCIwIDBcIiA6IFwiMCAxMDAlXCIpKSxcblx0XHRcdFx0cGlubmVkQ29udGFpbmVyID0gdmFycy5waW5uZWRDb250YWluZXIgJiYgX3RvQXJyYXkodmFycy5waW5uZWRDb250YWluZXIpWzBdLFxuXHRcdFx0XHR0cmlnZ2VySW5kZXggPSAodHJpZ2dlciAmJiBNYXRoLm1heCgwLCBfdHJpZ2dlcnMuaW5kZXhPZihzZWxmKSkpIHx8IDAsXG5cdFx0XHRcdGkgPSB0cmlnZ2VySW5kZXgsXG5cdFx0XHRcdGNzLCBib3VuZHMsIHNjcm9sbCwgaXNWZXJ0aWNhbCwgb3ZlcnJpZGUsIGN1clRyaWdnZXIsIGN1clBpbiwgb3Bwb3NpdGVTY3JvbGwsIGluaXR0ZWQsIHJldmVydGVkUGlucztcblx0XHRcdHdoaWxlIChpLS0pIHsgLy8gdXNlciBtaWdodCB0cnkgdG8gcGluIHRoZSBzYW1lIGVsZW1lbnQgbW9yZSB0aGFuIG9uY2UsIHNvIHdlIG11c3QgZmluZCBhbnkgcHJpb3IgdHJpZ2dlcnMgd2l0aCB0aGUgc2FtZSBwaW4sIHJldmVydCB0aGVtLCBhbmQgZGV0ZXJtaW5lIGhvdyBsb25nIHRoZXkncmUgcGlubmluZyBzbyB0aGF0IHdlIGNhbiBvZmZzZXQgdGhpbmdzIGFwcHJvcHJpYXRlbHkuIE1ha2Ugc3VyZSB3ZSByZXZlcnQgZnJvbSBsYXN0IHRvIGZpcnN0IHNvIHRoYXQgdGhpbmdzIFwicmV3aW5kXCIgcHJvcGVybHkuXG5cdFx0XHRcdGN1clRyaWdnZXIgPSBfdHJpZ2dlcnNbaV07XG5cdFx0XHRcdGN1clRyaWdnZXIuZW5kIHx8IGN1clRyaWdnZXIucmVmcmVzaCgwLCAxKSB8fCAoX3JlZnJlc2hpbmcgPSAxKTsgLy8gaWYgaXQncyBhIHRpbWVsaW5lLWJhc2VkIHRyaWdnZXIgdGhhdCBoYXNuJ3QgYmVlbiBmdWxseSBpbml0aWFsaXplZCB5ZXQgYmVjYXVzZSBpdCdzIHdhaXRpbmcgZm9yIDEgdGljaywganVzdCBmb3JjZSB0aGUgcmVmcmVzaCgpIGhlcmUsIG90aGVyd2lzZSBpZiBpdCBjb250YWlucyBhIHBpbiB0aGF0J3Mgc3VwcG9zZWQgdG8gYWZmZWN0IG90aGVyIFNjcm9sbFRyaWdnZXJzIGZ1cnRoZXIgZG93biB0aGUgcGFnZSwgdGhleSB3b24ndCBiZSBhZGp1c3RlZCBwcm9wZXJseS5cblx0XHRcdFx0Y3VyUGluID0gY3VyVHJpZ2dlci5waW47XG5cdFx0XHRcdGlmIChjdXJQaW4gJiYgKGN1clBpbiA9PT0gdHJpZ2dlciB8fCBjdXJQaW4gPT09IHBpbikgJiYgIWN1clRyaWdnZXIuaXNSZXZlcnRlZCkge1xuXHRcdFx0XHRcdHJldmVydGVkUGlucyB8fCAocmV2ZXJ0ZWRQaW5zID0gW10pO1xuXHRcdFx0XHRcdHJldmVydGVkUGlucy51bnNoaWZ0KGN1clRyaWdnZXIpOyAvLyB3ZSdsbCByZXZlcnQgZnJvbSBmaXJzdCB0byBsYXN0IHRvIG1ha2Ugc3VyZSB0aGluZ3MgcmVhY2ggdGhlaXIgZW5kIHN0YXRlIHByb3Blcmx5XG5cdFx0XHRcdFx0Y3VyVHJpZ2dlci5yZXZlcnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c3RhcnQgPSBfcGFyc2VQb3NpdGlvbihwYXJzZWRTdGFydCwgdHJpZ2dlciwgc2l6ZSwgZGlyZWN0aW9uLCBzZWxmLnNjcm9sbCgpLCBtYXJrZXJTdGFydCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBzZWxmLCBzY3JvbGxlckJvdW5kcywgYm9yZGVyV2lkdGgsIHVzZUZpeGVkUG9zaXRpb24sIG1heCkgfHwgKHBpbiA/IC0wLjAwMSA6IDApO1xuXHRcdFx0X2lzRnVuY3Rpb24ocGFyc2VkRW5kKSAmJiAocGFyc2VkRW5kID0gcGFyc2VkRW5kKHNlbGYpKTtcblx0XHRcdGlmIChfaXNTdHJpbmcocGFyc2VkRW5kKSAmJiAhcGFyc2VkRW5kLmluZGV4T2YoXCIrPVwiKSkge1xuXHRcdFx0XHRpZiAofnBhcnNlZEVuZC5pbmRleE9mKFwiIFwiKSkge1xuXHRcdFx0XHRcdHBhcnNlZEVuZCA9IChfaXNTdHJpbmcocGFyc2VkU3RhcnQpID8gcGFyc2VkU3RhcnQuc3BsaXQoXCIgXCIpWzBdIDogXCJcIikgKyBwYXJzZWRFbmQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b2Zmc2V0ID0gX29mZnNldFRvUHgocGFyc2VkRW5kLnN1YnN0cigyKSwgc2l6ZSk7XG5cdFx0XHRcdFx0cGFyc2VkRW5kID0gX2lzU3RyaW5nKHBhcnNlZFN0YXJ0KSA/IHBhcnNlZFN0YXJ0IDogc3RhcnQgKyBvZmZzZXQ7IC8vIF9wYXJzZVBvc2l0aW9uIHdvbid0IGZhY3RvciBpbiB0aGUgb2Zmc2V0IGlmIHRoZSBzdGFydCBpcyBhIG51bWJlciwgc28gZG8gaXQgaGVyZS5cblx0XHRcdFx0XHRwYXJzZWRFbmRUcmlnZ2VyID0gdHJpZ2dlcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZW5kID0gTWF0aC5tYXgoc3RhcnQsIF9wYXJzZVBvc2l0aW9uKHBhcnNlZEVuZCB8fCAocGFyc2VkRW5kVHJpZ2dlciA/IFwiMTAwJSAwXCIgOiBtYXgpLCBwYXJzZWRFbmRUcmlnZ2VyLCBzaXplLCBkaXJlY3Rpb24sIHNlbGYuc2Nyb2xsKCkgKyBvZmZzZXQsIG1hcmtlckVuZCwgbWFya2VyRW5kVHJpZ2dlciwgc2VsZiwgc2Nyb2xsZXJCb3VuZHMsIGJvcmRlcldpZHRoLCB1c2VGaXhlZFBvc2l0aW9uLCBtYXgpKSB8fCAtMC4wMDE7XG5cdFx0XHRjaGFuZ2UgPSAoZW5kIC0gc3RhcnQpIHx8ICgoc3RhcnQgLT0gMC4wMSkgJiYgMC4wMDEpO1xuXG5cdFx0XHRvZmZzZXQgPSAwO1xuXHRcdFx0aSA9IHRyaWdnZXJJbmRleDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0Y3VyVHJpZ2dlciA9IF90cmlnZ2Vyc1tpXTtcblx0XHRcdFx0Y3VyUGluID0gY3VyVHJpZ2dlci5waW47XG5cdFx0XHRcdGlmIChjdXJQaW4gJiYgY3VyVHJpZ2dlci5zdGFydCAtIGN1clRyaWdnZXIuX3BpblB1c2ggPCBzdGFydCkge1xuXHRcdFx0XHRcdGNzID0gY3VyVHJpZ2dlci5lbmQgLSBjdXJUcmlnZ2VyLnN0YXJ0O1xuXHRcdFx0XHRcdChjdXJQaW4gPT09IHRyaWdnZXIgfHwgY3VyUGluID09PSBwaW5uZWRDb250YWluZXIpICYmIChvZmZzZXQgKz0gY3MpO1xuXHRcdFx0XHRcdGN1clBpbiA9PT0gcGluICYmIChvdGhlclBpbk9mZnNldCArPSBjcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHN0YXJ0ICs9IG9mZnNldDtcblx0XHRcdGVuZCArPSBvZmZzZXQ7XG5cdFx0XHRzZWxmLl9waW5QdXNoID0gb3RoZXJQaW5PZmZzZXQ7XG5cdFx0XHRpZiAobWFya2VyU3RhcnQgJiYgb2Zmc2V0KSB7IC8vIG9mZnNldCB0aGUgbWFya2VycyBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0Y3MgPSB7fTtcblx0XHRcdFx0Y3NbZGlyZWN0aW9uLmFdID0gXCIrPVwiICsgb2Zmc2V0O1xuXHRcdFx0XHRwaW5uZWRDb250YWluZXIgJiYgKGNzW2RpcmVjdGlvbi5wXSA9IFwiLT1cIiArIHNlbGYuc2Nyb2xsKCkpO1xuXHRcdFx0XHRnc2FwLnNldChbbWFya2VyU3RhcnQsIG1hcmtlckVuZF0sIGNzKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHBpbikge1xuXHRcdFx0XHRjcyA9IF9nZXRDb21wdXRlZFN0eWxlKHBpbik7XG5cdFx0XHRcdGlzVmVydGljYWwgPSBkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbDtcblx0XHRcdFx0c2Nyb2xsID0gc2VsZi5zY3JvbGwoKTsgLy8gcmVjYWxjdWxhdGUgYmVjYXVzZSB0aGUgdHJpZ2dlcnMgY2FuIGFmZmVjdCB0aGUgc2Nyb2xsXG5cdFx0XHRcdHBpblN0YXJ0ID0gcGFyc2VGbG9hdChwaW5HZXR0ZXIoZGlyZWN0aW9uLmEpKSArIG90aGVyUGluT2Zmc2V0O1xuXHRcdFx0XHQhbWF4ICYmIGVuZCA+IDEgJiYgKChpc1ZpZXdwb3J0ID8gX2JvZHkgOiBzY3JvbGxlcikuc3R5bGVbXCJvdmVyZmxvdy1cIiArIGRpcmVjdGlvbi5hXSA9IFwic2Nyb2xsXCIpOyAvLyBtYWtlcyBzdXJlIHRoZSBzY3JvbGxlciBoYXMgYSBzY3JvbGxiYXIsIG90aGVyd2lzZSBpZiBzb21ldGhpbmcgaGFzIHdpZHRoOiAxMDAlLCBmb3IgZXhhbXBsZSwgaXQgd291bGQgYmUgdG9vIGJpZyAoZXhjbHVkZSB0aGUgc2Nyb2xsYmFyKS4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjUxODItc2Nyb2xsdHJpZ2dlci13aWR0aC1vZi1wYWdlLWluY3JlYXNlLXdoZXJlLW1hcmtlcnMtYXJlLXNldC10by1mYWxzZS9cblx0XHRcdFx0X3N3YXBQaW5JbihwaW4sIHNwYWNlciwgY3MpO1xuXHRcdFx0XHRwaW5TdGF0ZSA9IF9nZXRTdGF0ZShwaW4pO1xuXHRcdFx0XHQvLyB0cmFuc2Zvcm1zIHdpbGwgaW50ZXJmZXJlIHdpdGggdGhlIHRvcC9sZWZ0L3JpZ2h0L2JvdHRvbSBwbGFjZW1lbnQsIHNvIHJlbW92ZSB0aGVtIHRlbXBvcmFyaWx5LiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBmYWN0b3JzIGluIHRyYW5zZm9ybXMuXG5cdFx0XHRcdGJvdW5kcyA9IF9nZXRCb3VuZHMocGluLCB0cnVlKTtcblx0XHRcdFx0b3Bwb3NpdGVTY3JvbGwgPSB1c2VGaXhlZFBvc2l0aW9uICYmIF9nZXRTY3JvbGxGdW5jKHNjcm9sbGVyLCBpc1ZlcnRpY2FsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwpKCk7XG5cdFx0XHRcdGlmIChwaW5TcGFjaW5nKSB7XG5cdFx0XHRcdFx0c3BhY2VyU3RhdGUgPSBbcGluU3BhY2luZyArIGRpcmVjdGlvbi5vczIsIGNoYW5nZSArIG90aGVyUGluT2Zmc2V0ICsgX3B4XTtcblx0XHRcdFx0XHRzcGFjZXJTdGF0ZS50ID0gc3BhY2VyO1xuXHRcdFx0XHRcdGkgPSAocGluU3BhY2luZyA9PT0gX3BhZGRpbmcpID8gX2dldFNpemUocGluLCBkaXJlY3Rpb24pICsgY2hhbmdlICsgb3RoZXJQaW5PZmZzZXQgOiAwO1xuXHRcdFx0XHRcdGkgJiYgc3BhY2VyU3RhdGUucHVzaChkaXJlY3Rpb24uZCwgaSArIF9weCk7IC8vIGZvciBib3gtc2l6aW5nOiBib3JkZXItYm94IChtdXN0IGluY2x1ZGUgcGFkZGluZykuXG5cdFx0XHRcdFx0X3NldFN0YXRlKHNwYWNlclN0YXRlKTtcblx0XHRcdFx0XHR1c2VGaXhlZFBvc2l0aW9uICYmIHNlbGYuc2Nyb2xsKHByZXZTY3JvbGwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh1c2VGaXhlZFBvc2l0aW9uKSB7XG5cdFx0XHRcdFx0b3ZlcnJpZGUgPSB7XG5cdFx0XHRcdFx0XHR0b3A6IChib3VuZHMudG9wICsgKGlzVmVydGljYWwgPyBzY3JvbGwgLSBzdGFydCA6IG9wcG9zaXRlU2Nyb2xsKSkgKyBfcHgsXG5cdFx0XHRcdFx0XHRsZWZ0OiAoYm91bmRzLmxlZnQgKyAoaXNWZXJ0aWNhbCA/IG9wcG9zaXRlU2Nyb2xsIDogc2Nyb2xsIC0gc3RhcnQpKSArIF9weCxcblx0XHRcdFx0XHRcdGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogXCJmaXhlZFwiXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRvdmVycmlkZVtfd2lkdGhdID0gb3ZlcnJpZGVbXCJtYXhcIiArIF9XaWR0aF0gPSBNYXRoLmNlaWwoYm91bmRzLndpZHRoKSArIF9weDtcblx0XHRcdFx0XHRvdmVycmlkZVtfaGVpZ2h0XSA9IG92ZXJyaWRlW1wibWF4XCIgKyBfSGVpZ2h0XSA9IE1hdGguY2VpbChib3VuZHMuaGVpZ2h0KSArIF9weDtcblx0XHRcdFx0XHRvdmVycmlkZVtfbWFyZ2luXSA9IG92ZXJyaWRlW19tYXJnaW4gKyBfVG9wXSA9IG92ZXJyaWRlW19tYXJnaW4gKyBfUmlnaHRdID0gb3ZlcnJpZGVbX21hcmdpbiArIF9Cb3R0b21dID0gb3ZlcnJpZGVbX21hcmdpbiArIF9MZWZ0XSA9IFwiMFwiO1xuXHRcdFx0XHRcdG92ZXJyaWRlW19wYWRkaW5nXSA9IGNzW19wYWRkaW5nXTtcblx0XHRcdFx0XHRvdmVycmlkZVtfcGFkZGluZyArIF9Ub3BdID0gY3NbX3BhZGRpbmcgKyBfVG9wXTtcblx0XHRcdFx0XHRvdmVycmlkZVtfcGFkZGluZyArIF9SaWdodF0gPSBjc1tfcGFkZGluZyArIF9SaWdodF07XG5cdFx0XHRcdFx0b3ZlcnJpZGVbX3BhZGRpbmcgKyBfQm90dG9tXSA9IGNzW19wYWRkaW5nICsgX0JvdHRvbV07XG5cdFx0XHRcdFx0b3ZlcnJpZGVbX3BhZGRpbmcgKyBfTGVmdF0gPSBjc1tfcGFkZGluZyArIF9MZWZ0XTtcblx0XHRcdFx0XHRwaW5BY3RpdmVTdGF0ZSA9IF9jb3B5U3RhdGUocGluT3JpZ2luYWxTdGF0ZSwgb3ZlcnJpZGUsIHBpblJlcGFyZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYW5pbWF0aW9uKSB7IC8vIHRoZSBhbmltYXRpb24gbWlnaHQgYmUgYWZmZWN0aW5nIHRoZSB0cmFuc2Zvcm0sIHNvIHdlIG11c3QganVtcCB0byB0aGUgZW5kLCBjaGVjayB0aGUgdmFsdWUsIGFuZCBjb21wZW5zYXRlIGFjY29yZGluZ2x5LiBPdGhlcndpc2UsIHdoZW4gaXQgYmVjb21lcyB1bnBpbm5lZCwgdGhlIHBpblNldHRlcigpIHdpbGwgZ2V0IHNldCB0byBhIHZhbHVlIHRoYXQgZG9lc24ndCBpbmNsdWRlIHdoYXRldmVyIHRoZSBhbmltYXRpb24gZGlkLlxuXHRcdFx0XHRcdGluaXR0ZWQgPSBhbmltYXRpb24uX2luaXR0ZWQ7IC8vIGlmIG5vdCwgd2UgbXVzdCBpbnZhbGlkYXRlKCkgYWZ0ZXIgdGhpcyBzdGVwLCBvdGhlcndpc2UgaXQgY291bGQgbG9jayBpbiBzdGFydGluZyB2YWx1ZXMgcHJlbWF0dXJlbHkuXG5cdFx0XHRcdFx0X3N1cHByZXNzT3ZlcndyaXRlcygxKTtcblx0XHRcdFx0XHRhbmltYXRpb24ucmVuZGVyKGFuaW1hdGlvbi5kdXJhdGlvbigpLCB0cnVlLCB0cnVlKTtcblx0XHRcdFx0XHRwaW5DaGFuZ2UgPSBwaW5HZXR0ZXIoZGlyZWN0aW9uLmEpIC0gcGluU3RhcnQgKyBjaGFuZ2UgKyBvdGhlclBpbk9mZnNldDtcblx0XHRcdFx0XHRjaGFuZ2UgIT09IHBpbkNoYW5nZSAmJiBwaW5BY3RpdmVTdGF0ZS5zcGxpY2UocGluQWN0aXZlU3RhdGUubGVuZ3RoIC0gMiwgMik7IC8vIHRyYW5zZm9ybSBpcyB0aGUgbGFzdCBwcm9wZXJ0eS92YWx1ZSBzZXQgaW4gdGhlIHN0YXRlIEFycmF5LiBTaW5jZSB0aGUgYW5pbWF0aW9uIGlzIGNvbnRyb2xsaW5nIHRoYXQsIHdlIHNob3VsZCBvbWl0IGl0LlxuXHRcdFx0XHRcdGFuaW1hdGlvbi5yZW5kZXIoMCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0aW5pdHRlZCB8fCBhbmltYXRpb24uaW52YWxpZGF0ZSgpO1xuXHRcdFx0XHRcdF9zdXBwcmVzc092ZXJ3cml0ZXMoMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGluQ2hhbmdlID0gY2hhbmdlXG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodHJpZ2dlciAmJiBzZWxmLnNjcm9sbCgpKSB7IC8vIGl0IG1heSBiZSBJTlNJREUgYSBwaW5uZWQgZWxlbWVudCwgc28gd2FsayB1cCB0aGUgdHJlZSBhbmQgbG9vayBmb3IgYW55IGVsZW1lbnRzIHdpdGggX3Bpbk9mZnNldCB0byBjb21wZW5zYXRlIGJlY2F1c2UgYW55dGhpbmcgd2l0aCBwaW5TcGFjaW5nIHRoYXQncyBhbHJlYWR5IHNjcm9sbGVkIHdvdWxkIHRocm93IG9mZiB0aGUgbWVhc3VyZW1lbnRzIGluIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cdFx0XHRcdGJvdW5kcyA9IHRyaWdnZXIucGFyZW50Tm9kZTtcblx0XHRcdFx0d2hpbGUgKGJvdW5kcyAmJiBib3VuZHMgIT09IF9ib2R5KSB7XG5cdFx0XHRcdFx0aWYgKGJvdW5kcy5fcGluT2Zmc2V0KSB7XG5cdFx0XHRcdFx0XHRzdGFydCAtPSBib3VuZHMuX3Bpbk9mZnNldDtcblx0XHRcdFx0XHRcdGVuZCAtPSBib3VuZHMuX3Bpbk9mZnNldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ym91bmRzID0gYm91bmRzLnBhcmVudE5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldmVydGVkUGlucyAmJiByZXZlcnRlZFBpbnMuZm9yRWFjaCh0ID0+IHQucmV2ZXJ0KGZhbHNlKSk7XG5cdFx0XHRzZWxmLnN0YXJ0ID0gc3RhcnQ7XG5cdFx0XHRzZWxmLmVuZCA9IGVuZDtcblx0XHRcdHNjcm9sbDEgPSBzY3JvbGwyID0gc2VsZi5zY3JvbGwoKTsgLy8gcmVzZXQgdmVsb2NpdHlcblx0XHRcdHNjcm9sbDEgPCBwcmV2U2Nyb2xsICYmIHNlbGYuc2Nyb2xsKHByZXZTY3JvbGwpO1xuXHRcdFx0c2VsZi5yZXZlcnQoZmFsc2UpO1xuXHRcdFx0X3JlZnJlc2hpbmcgPSAwO1xuXHRcdFx0YW5pbWF0aW9uICYmIGlzVG9nZ2xlICYmIGFuaW1hdGlvbi5faW5pdHRlZCAmJiBhbmltYXRpb24ucHJvZ3Jlc3MoKSAhPT0gcHJldkFuaW1Qcm9ncmVzcyAmJiBhbmltYXRpb24ucHJvZ3Jlc3MocHJldkFuaW1Qcm9ncmVzcywgdHJ1ZSkucmVuZGVyKGFuaW1hdGlvbi50aW1lKCksIHRydWUsIHRydWUpOyAvLyBtdXN0IGZvcmNlIGEgcmUtcmVuZGVyIGJlY2F1c2UgaWYgc2F2ZVN0eWxlcygpIHdhcyB1c2VkIG9uIHRoZSB0YXJnZXQocyksIHRoZSBzdHlsZXMgY291bGQgaGF2ZSBiZWVuIHdpcGVkIG91dCBkdXJpbmcgdGhlIHJlZnJlc2goKS5cblx0XHRcdGlmIChwcmV2UHJvZ3Jlc3MgIT09IHNlbGYucHJvZ3Jlc3MpIHsgLy8gZW5zdXJlcyB0aGF0IHRoZSBkaXJlY3Rpb24gaXMgc2V0IHByb3Blcmx5ICh3aGVuIHJlZnJlc2hpbmcsIHByb2dyZXNzIGlzIHNldCBiYWNrIHRvIDAgaW5pdGlhbGx5LCB0aGVuIGJhY2sgYWdhaW4gdG8gd2hlcmV2ZXIgaXQgbmVlZHMgdG8gYmUpIGFuZCB0aGF0IGNhbGxiYWNrcyBhcmUgdHJpZ2dlcmVkLlxuXHRcdFx0XHRzY3J1YlR3ZWVuICYmIGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKHByZXZQcm9ncmVzcywgdHJ1ZSk7IC8vIHRvIGF2b2lkIGlzc3VlcyB3aGVyZSBhbmltYXRpb24gY2FsbGJhY2tzIGxpa2Ugb25TdGFydCBhcmVuJ3QgdHJpZ2dlcmVkLlxuXHRcdFx0XHRzZWxmLnByb2dyZXNzID0gcHJldlByb2dyZXNzO1xuXHRcdFx0XHRzZWxmLnVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0cGluICYmIHBpblNwYWNpbmcgJiYgKHNwYWNlci5fcGluT2Zmc2V0ID0gTWF0aC5yb3VuZChzZWxmLnByb2dyZXNzICogcGluQ2hhbmdlKSk7XG5cdFx0XHRvblJlZnJlc2ggJiYgb25SZWZyZXNoKHNlbGYpO1xuXHRcdH07XG5cblx0XHRzZWxmLmdldFZlbG9jaXR5ID0gKCkgPT4gKChzZWxmLnNjcm9sbCgpIC0gc2Nyb2xsMikgLyAoX2dldFRpbWUoKSAtIF90aW1lMikgKiAxMDAwKSB8fCAwO1xuXG5cdFx0c2VsZi51cGRhdGUgPSAocmVzZXQsIHJlY29yZFZlbG9jaXR5KSA9PiB7XG5cdFx0XHRsZXQgc2Nyb2xsID0gc2VsZi5zY3JvbGwoKSxcblx0XHRcdFx0cCA9IHJlc2V0ID8gMCA6IChzY3JvbGwgLSBzdGFydCkgLyBjaGFuZ2UsXG5cdFx0XHRcdGNsaXBwZWQgPSBwIDwgMCA/IDAgOiBwID4gMSA/IDEgOiBwIHx8IDAsXG5cdFx0XHRcdHByZXZQcm9ncmVzcyA9IHNlbGYucHJvZ3Jlc3MsXG5cdFx0XHRcdGlzQWN0aXZlLCB3YXNBY3RpdmUsIHRvZ2dsZVN0YXRlLCBhY3Rpb24sIHN0YXRlQ2hhbmdlZCwgdG9nZ2xlZDtcblx0XHRcdGlmIChyZWNvcmRWZWxvY2l0eSkge1xuXHRcdFx0XHRzY3JvbGwyID0gc2Nyb2xsMTtcblx0XHRcdFx0c2Nyb2xsMSA9IHNjcm9sbDtcblx0XHRcdFx0aWYgKHNuYXApIHtcblx0XHRcdFx0XHRzbmFwMiA9IHNuYXAxO1xuXHRcdFx0XHRcdHNuYXAxID0gYW5pbWF0aW9uICYmICFpc1RvZ2dsZSA/IGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKCkgOiBjbGlwcGVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBhbnRpY2lwYXRlIHRoZSBwaW5uaW5nIGEgZmV3IHRpY2tzIGFoZWFkIG9mIHRpbWUgYmFzZWQgb24gdmVsb2NpdHkgdG8gYXZvaWQgYSB2aXN1YWwgZ2xpdGNoIGR1ZSB0byB0aGUgZmFjdCB0aGF0IG1vc3QgYnJvd3NlcnMgZG8gc2Nyb2xsaW5nIG9uIGEgc2VwYXJhdGUgdGhyZWFkIChub3Qgc3luY2VkIHdpdGggcmVxdWVzdEFuaW1hdGlvbkZyYW1lKS5cblx0XHRcdChhbnRpY2lwYXRlUGluICYmICFjbGlwcGVkICYmIHBpbiAmJiAhX3JlZnJlc2hpbmcgJiYgIV9zdGFydHVwICYmIF9sYXN0U2Nyb2xsVGltZSAmJiBzdGFydCA8IHNjcm9sbCArICgoc2Nyb2xsIC0gc2Nyb2xsMikgLyAoX2dldFRpbWUoKSAtIF90aW1lMikpICogYW50aWNpcGF0ZVBpbikgJiYgKGNsaXBwZWQgPSAwLjAwMDEpO1xuXHRcdFx0aWYgKGNsaXBwZWQgIT09IHByZXZQcm9ncmVzcyAmJiBzZWxmLmVuYWJsZWQpIHtcblx0XHRcdFx0aXNBY3RpdmUgPSBzZWxmLmlzQWN0aXZlID0gISFjbGlwcGVkICYmIGNsaXBwZWQgPCAxO1xuXHRcdFx0XHR3YXNBY3RpdmUgPSAhIXByZXZQcm9ncmVzcyAmJiBwcmV2UHJvZ3Jlc3MgPCAxO1xuXHRcdFx0XHR0b2dnbGVkID0gaXNBY3RpdmUgIT09IHdhc0FjdGl2ZTtcblx0XHRcdFx0c3RhdGVDaGFuZ2VkID0gdG9nZ2xlZCB8fCAhIWNsaXBwZWQgIT09ICEhcHJldlByb2dyZXNzOyAvLyBjb3VsZCBnbyBmcm9tIHN0YXJ0IGFsbCB0aGUgd2F5IHRvIGVuZCwgdGh1cyBpdCBkaWRuJ3QgdG9nZ2xlIGJ1dCBpdCBkaWQgY2hhbmdlIHN0YXRlIGluIGEgc2Vuc2UgKG1heSBuZWVkIHRvIGZpcmUgYSBjYWxsYmFjaylcblx0XHRcdFx0c2VsZi5kaXJlY3Rpb24gPSBjbGlwcGVkID4gcHJldlByb2dyZXNzID8gMSA6IC0xO1xuXHRcdFx0XHRzZWxmLnByb2dyZXNzID0gY2xpcHBlZDtcblx0XHRcdFx0aWYgKCFpc1RvZ2dsZSkge1xuXHRcdFx0XHRcdGlmIChzY3J1YlR3ZWVuICYmICFfcmVmcmVzaGluZyAmJiAhX3N0YXJ0dXApIHtcblx0XHRcdFx0XHRcdHNjcnViVHdlZW4udmFycy50b3RhbFByb2dyZXNzID0gY2xpcHBlZDtcblx0XHRcdFx0XHRcdHNjcnViVHdlZW4uaW52YWxpZGF0ZSgpLnJlc3RhcnQoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGFuaW1hdGlvbikge1xuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLnRvdGFsUHJvZ3Jlc3MoY2xpcHBlZCwgISFfcmVmcmVzaGluZyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwaW4pIHtcblx0XHRcdFx0XHRyZXNldCAmJiBwaW5TcGFjaW5nICYmIChzcGFjZXIuc3R5bGVbcGluU3BhY2luZyArIGRpcmVjdGlvbi5vczJdID0gc3BhY2luZ1N0YXJ0KTtcblx0XHRcdFx0XHRpZiAoIXVzZUZpeGVkUG9zaXRpb24pIHtcblx0XHRcdFx0XHRcdHBpblNldHRlcihwaW5TdGFydCArIHBpbkNoYW5nZSAqIGNsaXBwZWQpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoc3RhdGVDaGFuZ2VkKSB7XG5cdFx0XHRcdFx0XHRhY3Rpb24gPSAhcmVzZXQgJiYgY2xpcHBlZCA+IHByZXZQcm9ncmVzcyAmJiBlbmQgKyAxID4gc2Nyb2xsICYmIHNjcm9sbCArIDEgPj0gX21heFNjcm9sbChzY3JvbGxlciwgZGlyZWN0aW9uKTsgLy8gaWYgaXQncyBhdCB0aGUgVkVSWSBlbmQgb2YgdGhlIHBhZ2UsIGRvbid0IHN3aXRjaCBhd2F5IGZyb20gcG9zaXRpb246IGZpeGVkIGJlY2F1c2UgaXQncyBwb2ludGxlc3MgYW5kIGl0IGNvdWxkIGNhdXNlIGEgYnJpZWYgZmxhc2ggd2hlbiB0aGUgdXNlciBzY3JvbGxzIGJhY2sgdXAgKHdoZW4gaXQgZ2V0cyBwaW5uZWQgYWdhaW4pXG5cdFx0XHRcdFx0XHRpZiAocGluUmVwYXJlbnQpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFyZXNldCAmJiAoaXNBY3RpdmUgfHwgYWN0aW9uKSkge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBib3VuZHMgPSBfZ2V0Qm91bmRzKHBpbiwgdHJ1ZSksXG5cdFx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgPSBzY3JvbGwgLSBzdGFydDtcblx0XHRcdFx0XHRcdFx0XHRfcmVwYXJlbnQocGluLCBfYm9keSwgKGJvdW5kcy50b3AgKyAoZGlyZWN0aW9uID09PSBfdmVydGljYWwgPyBvZmZzZXQgOiAwKSkgKyBfcHgsIChib3VuZHMubGVmdCArIChkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbCA/IDAgOiBvZmZzZXQpKSArIF9weCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0X3JlcGFyZW50KHBpbiwgc3BhY2VyKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0X3NldFN0YXRlKGlzQWN0aXZlIHx8IGFjdGlvbiA/IHBpbkFjdGl2ZVN0YXRlIDogcGluU3RhdGUpO1xuXHRcdFx0XHRcdFx0KHBpbkNoYW5nZSAhPT0gY2hhbmdlICYmIGNsaXBwZWQgPCAxICYmIGlzQWN0aXZlKSB8fCBwaW5TZXR0ZXIocGluU3RhcnQgKyAoY2xpcHBlZCA9PT0gMSAmJiAhYWN0aW9uID8gcGluQ2hhbmdlIDogMCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzbmFwICYmICF0d2VlblRvLnR3ZWVuICYmICFfcmVmcmVzaGluZyAmJiAhX3N0YXJ0dXAgJiYgc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG5cdFx0XHRcdHRvZ2dsZUNsYXNzICYmICh0b2dnbGVkIHx8IChvbmNlICYmIGNsaXBwZWQgJiYgKGNsaXBwZWQgPCAxIHx8ICFfbGltaXRDYWxsYmFja3MpKSkgJiYgX3RvQXJyYXkodG9nZ2xlQ2xhc3MudGFyZ2V0cykuZm9yRWFjaChlbCA9PiBlbC5jbGFzc0xpc3RbaXNBY3RpdmUgfHwgb25jZSA/IFwiYWRkXCIgOiBcInJlbW92ZVwiXSh0b2dnbGVDbGFzcy5jbGFzc05hbWUpKTsgLy8gY2xhc3NlcyBjb3VsZCBhZmZlY3QgcG9zaXRpb25pbmcsIHNvIGRvIGl0IGV2ZW4gaWYgcmVzZXQgb3IgcmVmcmVzaGluZyBpcyB0cnVlLlxuXHRcdFx0XHRvblVwZGF0ZSAmJiAhaXNUb2dnbGUgJiYgIXJlc2V0ICYmIG9uVXBkYXRlKHNlbGYpO1xuXHRcdFx0XHRpZiAoc3RhdGVDaGFuZ2VkICYmICFfcmVmcmVzaGluZykge1xuXHRcdFx0XHRcdHRvZ2dsZVN0YXRlID0gY2xpcHBlZCAmJiAhcHJldlByb2dyZXNzID8gMCA6IGNsaXBwZWQgPT09IDEgPyAxIDogcHJldlByb2dyZXNzID09PSAxID8gMiA6IDM7IC8vIDAgPSBlbnRlciwgMSA9IGxlYXZlLCAyID0gZW50ZXJCYWNrLCAzID0gbGVhdmVCYWNrICh3ZSBwcmlvcml0aXplIHRoZSBGSVJTVCBlbmNvdW50ZXIsIHRodXMgaWYgeW91IHNjcm9sbCByZWFsbHkgZmFzdCBwYXN0IHRoZSBvbkVudGVyIGFuZCBvbkxlYXZlIGluIG9uZSB0aWNrLCBpdCdkIHByaW9yaXRpemUgb25FbnRlci5cblx0XHRcdFx0XHRpZiAoaXNUb2dnbGUpIHtcblx0XHRcdFx0XHRcdGFjdGlvbiA9ICghdG9nZ2xlZCAmJiB0b2dnbGVBY3Rpb25zW3RvZ2dsZVN0YXRlICsgMV0gIT09IFwibm9uZVwiICYmIHRvZ2dsZUFjdGlvbnNbdG9nZ2xlU3RhdGUgKyAxXSkgfHwgdG9nZ2xlQWN0aW9uc1t0b2dnbGVTdGF0ZV07IC8vIGlmIGl0IGRpZG4ndCB0b2dnbGUsIHRoYXQgbWVhbnMgaXQgc2hvdCByaWdodCBwYXN0IGFuZCBzaW5jZSB3ZSBwcmlvcml0aXplIHRoZSBcImVudGVyXCIgYWN0aW9uLCB3ZSBzaG91bGQgc3dpdGNoIHRvIHRoZSBcImxlYXZlXCIgaW4gdGhpcyBjYXNlIChidXQgb25seSBpZiBvbmUgaXMgZGVmaW5lZClcblx0XHRcdFx0XHRcdGlmIChhbmltYXRpb24gJiYgKGFjdGlvbiA9PT0gXCJjb21wbGV0ZVwiIHx8IGFjdGlvbiA9PT0gXCJyZXNldFwiIHx8IGFjdGlvbiBpbiBhbmltYXRpb24pKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhY3Rpb24gPT09IFwiY29tcGxldGVcIikge1xuXHRcdFx0XHRcdFx0XHRcdGFuaW1hdGlvbi5wYXVzZSgpLnRvdGFsUHJvZ3Jlc3MoMSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoYWN0aW9uID09PSBcInJlc2V0XCIpIHtcblx0XHRcdFx0XHRcdFx0XHRhbmltYXRpb24ucmVzdGFydCh0cnVlKS5wYXVzZSgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJyZXN0YXJ0XCIpIHtcblx0XHRcdFx0XHRcdFx0XHRhbmltYXRpb24ucmVzdGFydCh0cnVlKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRhbmltYXRpb25bYWN0aW9uXSgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRvblVwZGF0ZSAmJiBvblVwZGF0ZShzZWxmKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRvZ2dsZWQgfHwgIV9saW1pdENhbGxiYWNrcykgeyAvLyBvbiBzdGFydHVwLCB0aGUgcGFnZSBjb3VsZCBiZSBzY3JvbGxlZCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBmaXJlIGNhbGxiYWNrcyB0aGF0IGRpZG4ndCB0b2dnbGUuIEZvciBleGFtcGxlIG9uRW50ZXIgc2hvdWxkbid0IGZpcmUgaWYgdGhlIFNjcm9sbFRyaWdnZXIgaXNuJ3QgYWN0dWFsbHkgZW50ZXJlZC5cblx0XHRcdFx0XHRcdG9uVG9nZ2xlICYmIHRvZ2dsZWQgJiYgb25Ub2dnbGUoc2VsZik7XG5cdFx0XHRcdFx0XHRjYWxsYmFja3NbdG9nZ2xlU3RhdGVdICYmIGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0oc2VsZik7XG5cdFx0XHRcdFx0XHRvbmNlICYmIChjbGlwcGVkID09PSAxID8gc2VsZi5raWxsKGZhbHNlLCAxKSA6IChjYWxsYmFja3NbdG9nZ2xlU3RhdGVdID0gMCkpOyAvLyBhIGNhbGxiYWNrIHNob3VsZG4ndCBiZSBjYWxsZWQgYWdhaW4gaWYgb25jZSBpcyB0cnVlLlxuXHRcdFx0XHRcdFx0aWYgKCF0b2dnbGVkKSB7IC8vIGl0J3MgcG9zc2libGUgdG8gZ28gY29tcGxldGVseSBwYXN0LCBsaWtlIGZyb20gYmVmb3JlIHRoZSBzdGFydCB0byBhZnRlciB0aGUgZW5kIChvciB2aWNlLXZlcnNhKSBpbiB3aGljaCBjYXNlIEJPVEggY2FsbGJhY2tzIHNob3VsZCBiZSBmaXJlZCBpbiB0aGF0IG9yZGVyXG5cdFx0XHRcdFx0XHRcdHRvZ2dsZVN0YXRlID0gY2xpcHBlZCA9PT0gMSA/IDEgOiAzO1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFja3NbdG9nZ2xlU3RhdGVdICYmIGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0oc2VsZik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGlzVG9nZ2xlICYmIG9uVXBkYXRlICYmICFfcmVmcmVzaGluZykge1xuXHRcdFx0XHRcdG9uVXBkYXRlKHNlbGYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyB1cGRhdGUgYWJzb2x1dGVseS1wb3NpdGlvbmVkIG1hcmtlcnMgKG9ubHkgaWYgdGhlIHNjcm9sbGVyIGlzbid0IHRoZSB2aWV3cG9ydClcblx0XHRcdGlmIChtYXJrZXJFbmRTZXR0ZXIpIHtcblx0XHRcdFx0bWFya2VyU3RhcnRTZXR0ZXIoc2Nyb2xsICsgKG1hcmtlclN0YXJ0VHJpZ2dlci5faXNGbGlwcGVkID8gMSA6IDApKTtcblx0XHRcdFx0bWFya2VyRW5kU2V0dGVyKHNjcm9sbCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHNlbGYuZW5hYmxlID0gKHJlc2V0LCByZWZyZXNoKSA9PiB7XG5cdFx0XHRpZiAoIXNlbGYuZW5hYmxlZCkge1xuXHRcdFx0XHRzZWxmLmVuYWJsZWQgPSB0cnVlO1xuXHRcdFx0XHRfYWRkTGlzdGVuZXIoc2Nyb2xsZXIsIFwicmVzaXplXCIsIF9vblJlc2l6ZSk7XG5cdFx0XHRcdF9hZGRMaXN0ZW5lcihzY3JvbGxlciwgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTtcblx0XHRcdFx0b25SZWZyZXNoSW5pdCAmJiBfYWRkTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJyZWZyZXNoSW5pdFwiLCBvblJlZnJlc2hJbml0KTtcblx0XHRcdFx0aWYgKHJlc2V0ICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdHNlbGYucHJvZ3Jlc3MgPSBwcmV2UHJvZ3Jlc3MgPSAwO1xuXHRcdFx0XHRcdHNjcm9sbDEgPSBzY3JvbGwyID0gbGFzdFNuYXAgPSBzZWxmLnNjcm9sbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlZnJlc2ggIT09IGZhbHNlICYmIHNlbGYucmVmcmVzaCgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRzZWxmLmdldFR3ZWVuID0gc25hcCA9PiBzbmFwICYmIHR3ZWVuVG8gPyB0d2VlblRvLnR3ZWVuIDogc2NydWJUd2VlbjtcblxuXHRcdHNlbGYuZGlzYWJsZSA9IChyZXNldCwgYWxsb3dBbmltYXRpb24pID0+IHtcblx0XHRcdGlmIChzZWxmLmVuYWJsZWQpIHtcblx0XHRcdFx0cmVzZXQgIT09IGZhbHNlICYmIHNlbGYucmV2ZXJ0KCk7XG5cdFx0XHRcdHNlbGYuZW5hYmxlZCA9IHNlbGYuaXNBY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0YWxsb3dBbmltYXRpb24gfHwgKHNjcnViVHdlZW4gJiYgc2NydWJUd2Vlbi5wYXVzZSgpKTtcblx0XHRcdFx0cHJldlNjcm9sbCA9IDA7XG5cdFx0XHRcdHBpbkNhY2hlICYmIChwaW5DYWNoZS51bmNhY2hlID0gMSk7XG5cdFx0XHRcdG9uUmVmcmVzaEluaXQgJiYgX3JlbW92ZUxpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwicmVmcmVzaEluaXRcIiwgb25SZWZyZXNoSW5pdCk7XG5cdFx0XHRcdGlmIChzbmFwRGVsYXllZENhbGwpIHtcblx0XHRcdFx0XHRzbmFwRGVsYXllZENhbGwucGF1c2UoKTtcblx0XHRcdFx0XHR0d2VlblRvLnR3ZWVuICYmIHR3ZWVuVG8udHdlZW4ua2lsbCgpICYmICh0d2VlblRvLnR3ZWVuID0gMCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFpc1ZpZXdwb3J0KSB7XG5cdFx0XHRcdFx0bGV0IGkgPSBfdHJpZ2dlcnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRcdGlmIChfdHJpZ2dlcnNbaV0uc2Nyb2xsZXIgPT09IHNjcm9sbGVyICYmIF90cmlnZ2Vyc1tpXSAhPT0gc2VsZikge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47IC8vZG9uJ3QgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgaWYgdGhlcmUgYXJlIHN0aWxsIG90aGVyIHRyaWdnZXJzIHJlZmVyZW5jaW5nIGl0LlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfcmVtb3ZlTGlzdGVuZXIoc2Nyb2xsZXIsIFwicmVzaXplXCIsIF9vblJlc2l6ZSk7XG5cdFx0XHRcdFx0X3JlbW92ZUxpc3RlbmVyKHNjcm9sbGVyLCBcInNjcm9sbFwiLCBfb25TY3JvbGwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHNlbGYua2lsbCA9IChyZXZlcnQsIGFsbG93QW5pbWF0aW9uKSA9PiB7XG5cdFx0XHRzZWxmLmRpc2FibGUocmV2ZXJ0LCBhbGxvd0FuaW1hdGlvbik7XG5cdFx0XHRpZCAmJiAoZGVsZXRlIF9pZHNbaWRdKTtcblx0XHRcdGxldCBpID0gX3RyaWdnZXJzLmluZGV4T2Yoc2VsZik7XG5cdFx0XHRfdHJpZ2dlcnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0aSA9PT0gX2kgJiYgX2RpcmVjdGlvbiA+IDAgJiYgX2ktLTsgLy8gaWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHJlZnJlc2goKSBvciB1cGRhdGUoKSwgc3BsaWNpbmcgd291bGQgY2F1c2Ugc2tpcHMgaW4gdGhlIGluZGV4LCBzbyBhZGp1c3QuLi5cblx0XHRcdGlmIChhbmltYXRpb24pIHtcblx0XHRcdFx0YW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIgPSBudWxsO1xuXHRcdFx0XHRyZXZlcnQgJiYgYW5pbWF0aW9uLnJlbmRlcigtMSk7XG5cdFx0XHRcdGFsbG93QW5pbWF0aW9uIHx8IGFuaW1hdGlvbi5raWxsKCk7XG5cdFx0XHR9XG5cdFx0XHRtYXJrZXJTdGFydCAmJiBbbWFya2VyU3RhcnQsIG1hcmtlckVuZCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXS5mb3JFYWNoKG0gPT4gbS5wYXJlbnROb2RlICYmIG0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtKSk7XG5cdFx0XHRpZiAocGluKSB7XG5cdFx0XHRcdHBpbkNhY2hlICYmIChwaW5DYWNoZS51bmNhY2hlID0gMSk7XG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRfdHJpZ2dlcnMuZm9yRWFjaCh0ID0+IHQucGluID09PSBwaW4gJiYgaSsrKTtcblx0XHRcdFx0aSB8fCAocGluQ2FjaGUuc3BhY2VyID0gMCk7IC8vIGlmIHRoZXJlIGFyZW4ndCBhbnkgbW9yZSBTY3JvbGxUcmlnZ2VycyB3aXRoIHRoZSBzYW1lIHBpbiwgcmVtb3ZlIHRoZSBzcGFjZXIsIG90aGVyd2lzZSBpdCBjb3VsZCBiZSBjb250YW1pbmF0ZWQgd2l0aCBvbGQvc3RhbGUgdmFsdWVzIGlmIHRoZSB1c2VyIHJlLWNyZWF0ZXMgYSBTY3JvbGxUcmlnZ2VyIGZvciB0aGUgc2FtZSBlbGVtZW50LlxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRzZWxmLmVuYWJsZShmYWxzZSwgZmFsc2UpO1xuXHRcdCFhbmltYXRpb24gfHwgIWFuaW1hdGlvbi5hZGQgfHwgY2hhbmdlID8gc2VsZi5yZWZyZXNoKCkgOiBnc2FwLmRlbGF5ZWRDYWxsKDAuMDEsICgpID0+IHN0YXJ0IHx8IGVuZCB8fCBzZWxmLnJlZnJlc2goKSkgJiYgKGNoYW5nZSA9IDAuMDEpICYmIChzdGFydCA9IGVuZCA9IDApOyAvLyBpZiB0aGUgYW5pbWF0aW9uIGlzIGEgdGltZWxpbmUsIGl0IG1heSBub3QgaGF2ZSBiZWVuIHBvcHVsYXRlZCB5ZXQsIHNvIGl0IHdvdWxkbid0IHJlbmRlciBhdCB0aGUgcHJvcGVyIHBsYWNlIG9uIHRoZSBmaXJzdCByZWZyZXNoKCksIHRodXMgd2Ugc2hvdWxkIHNjaGVkdWxlIG9uZSBmb3IgdGhlIG5leHQgdGljay4gSWYgXCJjaGFuZ2VcIiBpcyBkZWZpbmVkLCB3ZSBrbm93IGl0IG11c3QgYmUgcmUtZW5hYmxpbmcsIHRodXMgd2UgY2FuIHJlZnJlc2goKSByaWdodCBhd2F5LlxuXHR9XG5cblxuXHRzdGF0aWMgcmVnaXN0ZXIoY29yZSkge1xuXHRcdGlmICghX2NvcmVJbml0dGVkKSB7XG5cdFx0XHRnc2FwID0gY29yZSB8fCBfZ2V0R1NBUCgpO1xuXHRcdFx0aWYgKF93aW5kb3dFeGlzdHMoKSAmJiB3aW5kb3cuZG9jdW1lbnQpIHtcblx0XHRcdFx0X3dpbiA9IHdpbmRvdztcblx0XHRcdFx0X2RvYyA9IGRvY3VtZW50O1xuXHRcdFx0XHRfZG9jRWwgPSBfZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdFx0X2JvZHkgPSBfZG9jLmJvZHk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZ3NhcCkge1xuXHRcdFx0XHRfdG9BcnJheSA9IGdzYXAudXRpbHMudG9BcnJheTtcblx0XHRcdFx0X2NsYW1wID0gZ3NhcC51dGlscy5jbGFtcDtcblx0XHRcdFx0X3N1cHByZXNzT3ZlcndyaXRlcyA9IGdzYXAuY29yZS5zdXBwcmVzc092ZXJ3cml0ZXMgfHwgX3Bhc3NUaHJvdWdoO1xuXHRcdFx0XHRnc2FwLmNvcmUuZ2xvYmFscyhcIlNjcm9sbFRyaWdnZXJcIiwgU2Nyb2xsVHJpZ2dlcik7IC8vIG11c3QgcmVnaXN0ZXIgdGhlIGdsb2JhbCBtYW51YWxseSBiZWNhdXNlIGluIEludGVybmV0IEV4cGxvcmVyLCBmdW5jdGlvbnMgKGNsYXNzZXMpIGRvbid0IGhhdmUgYSBcIm5hbWVcIiBwcm9wZXJ0eS5cblx0XHRcdFx0aWYgKF9ib2R5KSB7XG5cdFx0XHRcdFx0X3JhZiA9IF93aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IChmID0+IHNldFRpbWVvdXQoZiwgMTYpKTtcblx0XHRcdFx0XHRfYWRkTGlzdGVuZXIoX3dpbiwgXCJ3aGVlbFwiLCBfb25TY3JvbGwpO1xuXHRcdFx0XHRcdF9yb290ID0gW193aW4sIF9kb2MsIF9kb2NFbCwgX2JvZHldO1xuXHRcdFx0XHRcdF9hZGRMaXN0ZW5lcihfZG9jLCBcInNjcm9sbFwiLCBfb25TY3JvbGwpOyAvLyBzb21lIGJyb3dzZXJzIChsaWtlIENocm9tZSksIHRoZSB3aW5kb3cgc3RvcHMgZGlzcGF0Y2hpbmcgc2Nyb2xsIGV2ZW50cyBvbiB0aGUgd2luZG93IGlmIHlvdSBzY3JvbGwgcmVhbGx5IGZhc3QsIGJ1dCBpdCdzIGNvbnNpc3RlbnQgb24gdGhlIGRvY3VtZW50IVxuXHRcdFx0XHRcdGxldCBib2R5U3R5bGUgPSBfYm9keS5zdHlsZSxcblx0XHRcdFx0XHRcdGJvcmRlciA9IGJvZHlTdHlsZS5ib3JkZXJUb3AsXG5cdFx0XHRcdFx0XHRib3VuZHM7XG5cdFx0XHRcdFx0Ym9keVN0eWxlLmJvcmRlclRvcCA9IFwiMXB4IHNvbGlkICMwMDBcIjsgLy8gd29ya3MgYXJvdW5kIGFuIGlzc3VlIHdoZXJlIGEgbWFyZ2luIG9mIGEgY2hpbGQgZWxlbWVudCBjb3VsZCB0aHJvdyBvZmYgdGhlIGJvdW5kcyBvZiB0aGUgX2JvZHksIG1ha2luZyBpdCBzZWVtIGxpa2UgdGhlcmUncyBhIG1hcmdpbiB3aGVuIHRoZXJlIGFjdHVhbGx5IGlzbid0LiBUaGUgYm9yZGVyIGVuc3VyZXMgdGhhdCB0aGUgYm91bmRzIGFyZSBhY2N1cmF0ZS5cblx0XHRcdFx0XHRib3VuZHMgPSBfZ2V0Qm91bmRzKF9ib2R5KTtcblx0XHRcdFx0XHRfdmVydGljYWwubSA9IE1hdGgucm91bmQoYm91bmRzLnRvcCArIF92ZXJ0aWNhbC5zYygpKSB8fCAwOyAvLyBhY2NvbW1vZGF0ZSB0aGUgb2Zmc2V0IG9mIHRoZSA8Ym9keT4gY2F1c2VkIGJ5IG1hcmdpbnMgYW5kL29yIHBhZGRpbmdcblx0XHRcdFx0XHRfaG9yaXpvbnRhbC5tID0gTWF0aC5yb3VuZChib3VuZHMubGVmdCArIF9ob3Jpem9udGFsLnNjKCkpIHx8IDA7XG5cdFx0XHRcdFx0Ym9yZGVyID8gKGJvZHlTdHlsZS5ib3JkZXJUb3AgPSBib3JkZXIpIDogYm9keVN0eWxlLnJlbW92ZVByb3BlcnR5KFwiYm9yZGVyLXRvcFwiKTtcblx0XHRcdFx0XHRfc3luY0ludGVydmFsID0gc2V0SW50ZXJ2YWwoX3N5bmMsIDIwMCk7XG5cdFx0XHRcdFx0Z3NhcC5kZWxheWVkQ2FsbCgwLjUsICgpID0+IF9zdGFydHVwID0gMCk7XG5cdFx0XHRcdFx0X2FkZExpc3RlbmVyKF9kb2MsIFwidG91Y2hjYW5jZWxcIiwgX3Bhc3NUaHJvdWdoKTsgLy8gc29tZSBvbGRlciBBbmRyb2lkIGRldmljZXMgaW50ZXJtaXR0ZW50bHkgc3RvcCBkaXNwYXRjaGluZyBcInRvdWNobW92ZVwiIGV2ZW50cyBpZiB3ZSBkb24ndCBsaXN0ZW4gZm9yIFwidG91Y2hjYW5jZWxcIiBvbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRcdFx0X2FkZExpc3RlbmVyKF9ib2R5LCBcInRvdWNoc3RhcnRcIiwgX3Bhc3NUaHJvdWdoKTsgLy93b3JrcyBhcm91bmQgU2FmYXJpIGJ1ZzogaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMTQ1MC1kcmFnZ2FibGUtaW4taWZyYW1lLW9uLW1vYmlsZS1pcy1idWdneS9cblx0XHRcdFx0XHRfbXVsdGlMaXN0ZW5lcihfYWRkTGlzdGVuZXIsIF9kb2MsIFwicG9pbnRlcmRvd24sdG91Y2hzdGFydCxtb3VzZWRvd25cIiwgKCkgPT4gX3BvaW50ZXJJc0Rvd24gPSAxKTtcblx0XHRcdFx0XHRfbXVsdGlMaXN0ZW5lcihfYWRkTGlzdGVuZXIsIF9kb2MsIFwicG9pbnRlcnVwLHRvdWNoZW5kLG1vdXNldXBcIiwgKCkgPT4gX3BvaW50ZXJJc0Rvd24gPSAwKTtcblx0XHRcdFx0XHRfdHJhbnNmb3JtUHJvcCA9IGdzYXAudXRpbHMuY2hlY2tQcmVmaXgoXCJ0cmFuc2Zvcm1cIik7XG5cdFx0XHRcdFx0X3N0YXRlUHJvcHMucHVzaChfdHJhbnNmb3JtUHJvcCk7XG5cdFx0XHRcdFx0X2NvcmVJbml0dGVkID0gX2dldFRpbWUoKTtcblx0XHRcdFx0XHRfcmVzaXplRGVsYXkgPSBnc2FwLmRlbGF5ZWRDYWxsKDAuMiwgX3JlZnJlc2hBbGwpLnBhdXNlKCk7XG5cdFx0XHRcdFx0X2F1dG9SZWZyZXNoID0gW19kb2MsIFwidmlzaWJpbGl0eWNoYW5nZVwiLCAoKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgdyA9IF93aW4uaW5uZXJXaWR0aCxcblx0XHRcdFx0XHRcdFx0aCA9IF93aW4uaW5uZXJIZWlnaHQ7XG5cdFx0XHRcdFx0XHRpZiAoX2RvYy5oaWRkZW4pIHtcblx0XHRcdFx0XHRcdFx0X3ByZXZXaWR0aCA9IHc7XG5cdFx0XHRcdFx0XHRcdF9wcmV2SGVpZ2h0ID0gaDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoX3ByZXZXaWR0aCAhPT0gdyB8fCBfcHJldkhlaWdodCAhPT0gaCkge1xuXHRcdFx0XHRcdFx0XHRfb25SZXNpemUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCBfZG9jLCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgX3JlZnJlc2hBbGwsIF93aW4sIFwibG9hZFwiLCAoKSA9PiBfbGFzdFNjcm9sbFRpbWUgfHwgX3JlZnJlc2hBbGwoKSwgX3dpbiwgXCJyZXNpemVcIiwgX29uUmVzaXplXTtcblx0XHRcdFx0XHRfaXRlcmF0ZUF1dG9SZWZyZXNoKF9hZGRMaXN0ZW5lcik7XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX2NvcmVJbml0dGVkO1xuXHR9XG5cblx0c3RhdGljIGRlZmF1bHRzKGNvbmZpZykge1xuXHRcdGZvciAobGV0IHAgaW4gY29uZmlnKSB7XG5cdFx0XHRfZGVmYXVsdHNbcF0gPSBjb25maWdbcF07XG5cdFx0fVxuXHR9XG5cblx0c3RhdGljIGtpbGwoKSB7XG5cdFx0X2VuYWJsZWQgPSAwO1xuXHRcdF90cmlnZ2Vycy5zbGljZSgwKS5mb3JFYWNoKHRyaWdnZXIgPT4gdHJpZ2dlci5raWxsKDEpKTtcblx0fVxuXG5cdHN0YXRpYyBjb25maWcodmFycykge1xuXHRcdChcImxpbWl0Q2FsbGJhY2tzXCIgaW4gdmFycykgJiYgKF9saW1pdENhbGxiYWNrcyA9ICEhdmFycy5saW1pdENhbGxiYWNrcyk7XG5cdFx0bGV0IG1zID0gdmFycy5zeW5jSW50ZXJ2YWw7XG5cdFx0bXMgJiYgY2xlYXJJbnRlcnZhbChfc3luY0ludGVydmFsKSB8fCAoKF9zeW5jSW50ZXJ2YWwgPSBtcykgJiYgc2V0SW50ZXJ2YWwoX3N5bmMsIG1zKSk7XG5cdFx0aWYgKFwiYXV0b1JlZnJlc2hFdmVudHNcIiBpbiB2YXJzKSB7XG5cdFx0XHRfaXRlcmF0ZUF1dG9SZWZyZXNoKF9yZW1vdmVMaXN0ZW5lcikgfHwgX2l0ZXJhdGVBdXRvUmVmcmVzaChfYWRkTGlzdGVuZXIsIHZhcnMuYXV0b1JlZnJlc2hFdmVudHMgfHwgXCJub25lXCIpO1xuXHRcdFx0X2lnbm9yZVJlc2l6ZSA9ICh2YXJzLmF1dG9SZWZyZXNoRXZlbnRzICsgXCJcIikuaW5kZXhPZihcInJlc2l6ZVwiKSA9PT0gLTE7XG5cdFx0fVxuXHR9XG5cblx0c3RhdGljIHNjcm9sbGVyUHJveHkodGFyZ2V0LCB2YXJzKSB7XG5cdFx0bGV0IHQgPSBfdG9BcnJheSh0YXJnZXQpWzBdLFxuXHRcdFx0aSA9IF9zY3JvbGxlcnMuaW5kZXhPZih0KSxcblx0XHRcdGlzVmlld3BvcnQgPSBfaXNWaWV3cG9ydCh0KTtcblx0XHRpZiAofmkpIHtcblx0XHRcdF9zY3JvbGxlcnMuc3BsaWNlKGksIGlzVmlld3BvcnQgPyA2IDogMik7XG5cdFx0fVxuXHRcdGlzVmlld3BvcnQgPyBfcHJveGllcy51bnNoaWZ0KF93aW4sIHZhcnMsIF9ib2R5LCB2YXJzLCBfZG9jRWwsIHZhcnMpIDogX3Byb3hpZXMudW5zaGlmdCh0LCB2YXJzKTtcblx0fVxuXG5cdHN0YXRpYyBtYXRjaE1lZGlhKHZhcnMpIHsgLy8gX21lZGlhIGlzIHBvcHVsYXRlZCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOiBtZWRpYVF1ZXJ5U3RyaW5nLCBvbk1hdGNoLCBvblVubWF0Y2gsIGlzTWF0Y2hlZC4gU28gaWYgdGhlcmUgYXJlIHR3byBtZWRpYSBxdWVyaWVzLCB0aGUgQXJyYXkgd291bGQgaGF2ZSBhIGxlbmd0aCBvZiA4XG5cdFx0bGV0IG1xLCBwLCBpLCBmdW5jLCByZXN1bHQ7XG5cdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdGkgPSBfbWVkaWEuaW5kZXhPZihwKTtcblx0XHRcdGZ1bmMgPSB2YXJzW3BdO1xuXHRcdFx0X2NyZWF0aW5nTWVkaWEgPSBwO1xuXHRcdFx0aWYgKHAgPT09IFwiYWxsXCIpIHtcblx0XHRcdFx0ZnVuYygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bXEgPSBfd2luLm1hdGNoTWVkaWEocCk7XG5cdFx0XHRcdGlmIChtcSkge1xuXHRcdFx0XHRcdG1xLm1hdGNoZXMgJiYgKHJlc3VsdCA9IGZ1bmMoKSk7XG5cdFx0XHRcdFx0aWYgKH5pKSB7XG5cdFx0XHRcdFx0XHRfbWVkaWFbaSArIDFdID0gX2NvbWJpbmVGdW5jKF9tZWRpYVtpICsgMV0sIGZ1bmMpO1xuXHRcdFx0XHRcdFx0X21lZGlhW2kgKyAyXSA9IF9jb21iaW5lRnVuYyhfbWVkaWFbaSArIDJdLCByZXN1bHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpID0gX21lZGlhLmxlbmd0aDtcblx0XHRcdFx0XHRcdF9tZWRpYS5wdXNoKHAsIGZ1bmMsIHJlc3VsdCk7XG5cdFx0XHRcdFx0XHRtcS5hZGRMaXN0ZW5lciA/IG1xLmFkZExpc3RlbmVyKF9vbk1lZGlhQ2hhbmdlKSA6IG1xLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgX29uTWVkaWFDaGFuZ2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfbWVkaWFbaSArIDNdID0gbXEubWF0Y2hlcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0X2NyZWF0aW5nTWVkaWEgPSAwO1xuXHRcdH1cblx0XHRyZXR1cm4gX21lZGlhO1xuXHR9XG5cblx0c3RhdGljIGNsZWFyTWF0Y2hNZWRpYShxdWVyeSkge1xuXHRcdHF1ZXJ5IHx8IChfbWVkaWEubGVuZ3RoID0gMCk7XG5cdFx0cXVlcnkgPSBfbWVkaWEuaW5kZXhPZihxdWVyeSk7XG5cdFx0cXVlcnkgPj0gMCAmJiBfbWVkaWEuc3BsaWNlKHF1ZXJ5LCA0KTtcblx0fVxuXG59XG5cblNjcm9sbFRyaWdnZXIudmVyc2lvbiA9IFwiMy43LjBcIjtcblNjcm9sbFRyaWdnZXIuc2F2ZVN0eWxlcyA9IHRhcmdldHMgPT4gdGFyZ2V0cyA/IF90b0FycmF5KHRhcmdldHMpLmZvckVhY2godGFyZ2V0ID0+IHsgLy8gc2F2ZWQgc3R5bGVzIGFyZSByZWNvcmRlZCBpbiBhIGNvbnNlY3V0aXZlIGFsdGVybmF0aW5nIEFycmF5LCBsaWtlIFtlbGVtZW50LCBjc3NUZXh0LCB0cmFuc2Zvcm0gYXR0cmlidXRlLCBjYWNoZSwgbWF0Y2hNZWRpYSwgLi4uXVxuXHRpZiAodGFyZ2V0ICYmIHRhcmdldC5zdHlsZSkge1xuXHRcdGxldCBpID0gX3NhdmVkU3R5bGVzLmluZGV4T2YodGFyZ2V0KTtcblx0XHRpID49IDAgJiYgX3NhdmVkU3R5bGVzLnNwbGljZShpLCA1KTtcblx0XHRfc2F2ZWRTdHlsZXMucHVzaCh0YXJnZXQsIHRhcmdldC5zdHlsZS5jc3NUZXh0LCB0YXJnZXQuZ2V0QkJveCAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpLCBnc2FwLmNvcmUuZ2V0Q2FjaGUodGFyZ2V0KSwgX2NyZWF0aW5nTWVkaWEpO1xuXHR9XG59KSA6IF9zYXZlZFN0eWxlcztcblNjcm9sbFRyaWdnZXIucmV2ZXJ0ID0gKHNvZnQsIG1lZGlhKSA9PiBfcmV2ZXJ0QWxsKCFzb2Z0LCBtZWRpYSk7XG5TY3JvbGxUcmlnZ2VyLmNyZWF0ZSA9ICh2YXJzLCBhbmltYXRpb24pID0+IG5ldyBTY3JvbGxUcmlnZ2VyKHZhcnMsIGFuaW1hdGlvbik7XG5TY3JvbGxUcmlnZ2VyLnJlZnJlc2ggPSBzYWZlID0+IHNhZmUgPyBfb25SZXNpemUoKSA6IF9yZWZyZXNoQWxsKHRydWUpO1xuU2Nyb2xsVHJpZ2dlci51cGRhdGUgPSBfdXBkYXRlQWxsO1xuU2Nyb2xsVHJpZ2dlci5tYXhTY3JvbGwgPSAoZWxlbWVudCwgaG9yaXpvbnRhbCkgPT4gX21heFNjcm9sbChlbGVtZW50LCBob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwpO1xuU2Nyb2xsVHJpZ2dlci5nZXRTY3JvbGxGdW5jID0gKGVsZW1lbnQsIGhvcml6b250YWwpID0+IF9nZXRTY3JvbGxGdW5jKF90b0FycmF5KGVsZW1lbnQpWzBdLCBob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwpO1xuU2Nyb2xsVHJpZ2dlci5nZXRCeUlkID0gaWQgPT4gX2lkc1tpZF07XG5TY3JvbGxUcmlnZ2VyLmdldEFsbCA9ICgpID0+IF90cmlnZ2Vycy5zbGljZSgwKTtcblNjcm9sbFRyaWdnZXIuaXNTY3JvbGxpbmcgPSAoKSA9PiAhIV9sYXN0U2Nyb2xsVGltZTtcblNjcm9sbFRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lciA9ICh0eXBlLCBjYWxsYmFjaykgPT4ge1xuXHRsZXQgYSA9IF9saXN0ZW5lcnNbdHlwZV0gfHwgKF9saXN0ZW5lcnNbdHlwZV0gPSBbXSk7XG5cdH5hLmluZGV4T2YoY2FsbGJhY2spIHx8IGEucHVzaChjYWxsYmFjayk7XG59O1xuU2Nyb2xsVHJpZ2dlci5yZW1vdmVFdmVudExpc3RlbmVyID0gKHR5cGUsIGNhbGxiYWNrKSA9PiB7XG5cdGxldCBhID0gX2xpc3RlbmVyc1t0eXBlXSxcblx0XHRpID0gYSAmJiBhLmluZGV4T2YoY2FsbGJhY2spO1xuXHRpID49IDAgJiYgYS5zcGxpY2UoaSwgMSk7XG59O1xuU2Nyb2xsVHJpZ2dlci5iYXRjaCA9ICh0YXJnZXRzLCB2YXJzKSA9PiB7XG5cdGxldCByZXN1bHQgPSBbXSxcblx0XHR2YXJzQ29weSA9IHt9LFxuXHRcdGludGVydmFsID0gdmFycy5pbnRlcnZhbCB8fCAwLjAxNixcblx0XHRiYXRjaE1heCA9IHZhcnMuYmF0Y2hNYXggfHwgMWU5LFxuXHRcdHByb3h5Q2FsbGJhY2sgPSAodHlwZSwgY2FsbGJhY2spID0+IHtcblx0XHRcdGxldCBlbGVtZW50cyA9IFtdLFxuXHRcdFx0XHR0cmlnZ2VycyA9IFtdLFxuXHRcdFx0XHRkZWxheSA9IGdzYXAuZGVsYXllZENhbGwoaW50ZXJ2YWwsICgpID0+IHtjYWxsYmFjayhlbGVtZW50cywgdHJpZ2dlcnMpOyBlbGVtZW50cyA9IFtdOyB0cmlnZ2VycyA9IFtdO30pLnBhdXNlKCk7XG5cdFx0XHRyZXR1cm4gc2VsZiA9PiB7XG5cdFx0XHRcdGVsZW1lbnRzLmxlbmd0aCB8fCBkZWxheS5yZXN0YXJ0KHRydWUpO1xuXHRcdFx0XHRlbGVtZW50cy5wdXNoKHNlbGYudHJpZ2dlcik7XG5cdFx0XHRcdHRyaWdnZXJzLnB1c2goc2VsZik7XG5cdFx0XHRcdGJhdGNoTWF4IDw9IGVsZW1lbnRzLmxlbmd0aCAmJiBkZWxheS5wcm9ncmVzcygxKTtcblx0XHRcdH07XG5cdFx0fSxcblx0XHRwO1xuXHRmb3IgKHAgaW4gdmFycykge1xuXHRcdHZhcnNDb3B5W3BdID0gKHAuc3Vic3RyKDAsIDIpID09PSBcIm9uXCIgJiYgX2lzRnVuY3Rpb24odmFyc1twXSkgJiYgcCAhPT0gXCJvblJlZnJlc2hJbml0XCIpID8gcHJveHlDYWxsYmFjayhwLCB2YXJzW3BdKSA6IHZhcnNbcF07XG5cdH1cblx0aWYgKF9pc0Z1bmN0aW9uKGJhdGNoTWF4KSkge1xuXHRcdGJhdGNoTWF4ID0gYmF0Y2hNYXgoKTtcblx0XHRfYWRkTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJyZWZyZXNoXCIsICgpID0+IGJhdGNoTWF4ID0gdmFycy5iYXRjaE1heCgpKTtcblx0fVxuXHRfdG9BcnJheSh0YXJnZXRzKS5mb3JFYWNoKHRhcmdldCA9PiB7XG5cdFx0bGV0IGNvbmZpZyA9IHt9O1xuXHRcdGZvciAocCBpbiB2YXJzQ29weSkge1xuXHRcdFx0Y29uZmlnW3BdID0gdmFyc0NvcHlbcF07XG5cdFx0fVxuXHRcdGNvbmZpZy50cmlnZ2VyID0gdGFyZ2V0O1xuXHRcdHJlc3VsdC5wdXNoKFNjcm9sbFRyaWdnZXIuY3JlYXRlKGNvbmZpZykpO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblNjcm9sbFRyaWdnZXIuc29ydCA9IGZ1bmMgPT4gX3RyaWdnZXJzLnNvcnQoZnVuYyB8fCAoKGEsIGIpID0+IChhLnZhcnMucmVmcmVzaFByaW9yaXR5IHx8IDApICogLTFlNiArIGEuc3RhcnQgLSAoYi5zdGFydCArIChiLnZhcnMucmVmcmVzaFByaW9yaXR5IHx8IDApICogLTFlNikpKTtcblxuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRyaWdnZXIpO1xuXG5leHBvcnQgeyBTY3JvbGxUcmlnZ2VyIGFzIGRlZmF1bHQgfTsiLCIvKiFcbiAqIFRleHRQbHVnaW4gMy43LjBcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5pbXBvcnQgeyBlbW9qaVNhZmVTcGxpdCwgZ2V0VGV4dCwgc3BsaXRJbm5lckhUTUwgfSBmcm9tIFwiLi91dGlscy9zdHJpbmdzLmpzXCI7XG5cbmxldCBnc2FwLCBfdGVtcERpdixcblx0X2dldEdTQVAgPSAoKSA9PiBnc2FwIHx8ICh0eXBlb2Yod2luZG93KSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXApO1xuXG5cbmV4cG9ydCBjb25zdCBUZXh0UGx1Z2luID0ge1xuXHR2ZXJzaW9uOlwiMy43LjBcIixcblx0bmFtZTpcInRleHRcIixcblx0aW5pdCh0YXJnZXQsIHZhbHVlLCB0d2Vlbikge1xuXHRcdGxldCBpID0gdGFyZ2V0Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCksXG5cdFx0XHRkYXRhID0gdGhpcyxcblx0XHRcdHNob3J0LCB0ZXh0LCBvcmlnaW5hbCwgaiwgY29uZGVuc2VkVGV4dCwgY29uZGVuc2VkT3JpZ2luYWwsIGFnZ3JlZ2F0ZSwgcztcblx0XHRkYXRhLnN2ZyA9ICh0YXJnZXQuZ2V0QkJveCAmJiAoaSA9PT0gXCJURVhUXCIgfHwgaSA9PT0gXCJUU1BBTlwiKSk7XG5cdFx0aWYgKCEoXCJpbm5lckhUTUxcIiBpbiB0YXJnZXQpICYmICFkYXRhLnN2Zykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRkYXRhLnRhcmdldCA9IHRhcmdldDtcblx0XHRpZiAodHlwZW9mKHZhbHVlKSAhPT0gXCJvYmplY3RcIikge1xuXHRcdFx0dmFsdWUgPSB7dmFsdWU6dmFsdWV9O1xuXHRcdH1cblx0XHRpZiAoIShcInZhbHVlXCIgaW4gdmFsdWUpKSB7XG5cdFx0XHRkYXRhLnRleHQgPSBkYXRhLm9yaWdpbmFsID0gW1wiXCJdO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRkYXRhLmRlbGltaXRlciA9IHZhbHVlLmRlbGltaXRlciB8fCBcIlwiO1xuXHRcdG9yaWdpbmFsID0gc3BsaXRJbm5lckhUTUwodGFyZ2V0LCBkYXRhLmRlbGltaXRlcik7XG5cdFx0aWYgKCFfdGVtcERpdikge1xuXHRcdFx0X3RlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdH1cblx0XHRfdGVtcERpdi5pbm5lckhUTUwgPSB2YWx1ZS52YWx1ZTtcblx0XHR0ZXh0ID0gc3BsaXRJbm5lckhUTUwoX3RlbXBEaXYsIGRhdGEuZGVsaW1pdGVyKTtcblx0XHRkYXRhLmZyb20gPSB0d2Vlbi5fZnJvbTtcblx0XHRpZiAoZGF0YS5mcm9tKSB7XG5cdFx0XHRpID0gb3JpZ2luYWw7XG5cdFx0XHRvcmlnaW5hbCA9IHRleHQ7XG5cdFx0XHR0ZXh0ID0gaTtcblx0XHR9XG5cdFx0ZGF0YS5oYXNDbGFzcyA9ICEhKHZhbHVlLm5ld0NsYXNzIHx8IHZhbHVlLm9sZENsYXNzKTtcblx0XHRkYXRhLm5ld0NsYXNzID0gdmFsdWUubmV3Q2xhc3M7XG5cdFx0ZGF0YS5vbGRDbGFzcyA9IHZhbHVlLm9sZENsYXNzO1xuXHRcdGkgPSBvcmlnaW5hbC5sZW5ndGggLSB0ZXh0Lmxlbmd0aDtcblx0XHRzaG9ydCA9IChpIDwgMCkgPyBvcmlnaW5hbCA6IHRleHQ7XG5cdFx0ZGF0YS5maWxsQ2hhciA9IHZhbHVlLmZpbGxDaGFyIHx8ICh2YWx1ZS5wYWRTcGFjZSA/IFwiJm5ic3A7XCIgOiBcIlwiKTtcblx0XHRpZiAoaSA8IDApIHtcblx0XHRcdGkgPSAtaTtcblx0XHR9XG5cdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRzaG9ydC5wdXNoKGRhdGEuZmlsbENoYXIpO1xuXHRcdH1cblx0XHRpZiAodmFsdWUudHlwZSA9PT0gXCJkaWZmXCIpIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0Y29uZGVuc2VkVGV4dCA9IFtdO1xuXHRcdFx0Y29uZGVuc2VkT3JpZ2luYWwgPSBbXTtcblx0XHRcdGFnZ3JlZ2F0ZSA9IFwiXCI7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRzID0gdGV4dFtpXTtcblx0XHRcdFx0aWYgKHMgPT09IG9yaWdpbmFsW2ldKSB7XG5cdFx0XHRcdFx0YWdncmVnYXRlICs9IHM7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uZGVuc2VkVGV4dFtqXSA9IGFnZ3JlZ2F0ZSArIHM7XG5cdFx0XHRcdFx0Y29uZGVuc2VkT3JpZ2luYWxbaisrXSA9IGFnZ3JlZ2F0ZSArIG9yaWdpbmFsW2ldO1xuXHRcdFx0XHRcdGFnZ3JlZ2F0ZSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRleHQgPSBjb25kZW5zZWRUZXh0O1xuXHRcdFx0b3JpZ2luYWwgPSBjb25kZW5zZWRPcmlnaW5hbDtcblx0XHRcdGlmIChhZ2dyZWdhdGUpIHtcblx0XHRcdFx0dGV4dC5wdXNoKGFnZ3JlZ2F0ZSk7XG5cdFx0XHRcdG9yaWdpbmFsLnB1c2goYWdncmVnYXRlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHZhbHVlLnNwZWVkKSB7XG5cdFx0XHR0d2Vlbi5kdXJhdGlvbihNYXRoLm1pbigwLjA1IC8gdmFsdWUuc3BlZWQgKiBzaG9ydC5sZW5ndGgsIHZhbHVlLm1heER1cmF0aW9uIHx8IDk5OTkpKTtcblx0XHR9XG5cdFx0dGhpcy5vcmlnaW5hbCA9IG9yaWdpbmFsO1xuXHRcdHRoaXMudGV4dCA9IHRleHQ7XG5cdFx0dGhpcy5fcHJvcHMucHVzaChcInRleHRcIik7XG5cdH0sXG5cdHJlbmRlcihyYXRpbywgZGF0YSkge1xuXHRcdGlmIChyYXRpbyA+IDEpIHtcblx0XHRcdHJhdGlvID0gMTtcblx0XHR9IGVsc2UgaWYgKHJhdGlvIDwgMCkge1xuXHRcdFx0cmF0aW8gPSAwO1xuXHRcdH1cblx0XHRpZiAoZGF0YS5mcm9tKSB7XG5cdFx0XHRyYXRpbyA9IDEgLSByYXRpbztcblx0XHR9XG5cdFx0bGV0IHsgdGV4dCwgaGFzQ2xhc3MsIG5ld0NsYXNzLCBvbGRDbGFzcywgZGVsaW1pdGVyLCB0YXJnZXQsIGZpbGxDaGFyLCBvcmlnaW5hbCB9ID0gZGF0YSxcblx0XHRcdGwgPSB0ZXh0Lmxlbmd0aCxcblx0XHRcdGkgPSAocmF0aW8gKiBsICsgMC41KSB8IDAsXG5cdFx0XHRhcHBseU5ldywgYXBwbHlPbGQsIHN0cjtcblx0XHRpZiAoaGFzQ2xhc3MpIHtcblx0XHRcdGFwcGx5TmV3ID0gKG5ld0NsYXNzICYmIGkpO1xuXHRcdFx0YXBwbHlPbGQgPSAob2xkQ2xhc3MgJiYgaSAhPT0gbCk7XG5cdFx0XHRzdHIgPSAoYXBwbHlOZXcgPyBcIjxzcGFuIGNsYXNzPSdcIiArIG5ld0NsYXNzICsgXCInPlwiIDogXCJcIikgKyB0ZXh0LnNsaWNlKDAsIGkpLmpvaW4oZGVsaW1pdGVyKSArIChhcHBseU5ldyA/IFwiPC9zcGFuPlwiIDogXCJcIikgKyAoYXBwbHlPbGQgPyBcIjxzcGFuIGNsYXNzPSdcIiArIG9sZENsYXNzICsgXCInPlwiIDogXCJcIikgKyBkZWxpbWl0ZXIgKyBvcmlnaW5hbC5zbGljZShpKS5qb2luKGRlbGltaXRlcikgKyAoYXBwbHlPbGQgPyBcIjwvc3Bhbj5cIiA6IFwiXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHIgPSB0ZXh0LnNsaWNlKDAsIGkpLmpvaW4oZGVsaW1pdGVyKSArIGRlbGltaXRlciArIG9yaWdpbmFsLnNsaWNlKGkpLmpvaW4oZGVsaW1pdGVyKTtcblx0XHR9XG5cdFx0aWYgKGRhdGEuc3ZnKSB7IC8vU1ZHIHRleHQgZWxlbWVudHMgZG9uJ3QgaGF2ZSBhbiBcImlubmVySFRNTFwiIGluIE1pY3Jvc29mdCBicm93c2Vycy5cblx0XHRcdHRhcmdldC50ZXh0Q29udGVudCA9IHN0cjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmlubmVySFRNTCA9IChmaWxsQ2hhciA9PT0gXCImbmJzcDtcIiAmJiB+c3RyLmluZGV4T2YoXCIgIFwiKSkgPyBzdHIuc3BsaXQoXCIgIFwiKS5qb2luKFwiJm5ic3A7Jm5ic3A7XCIpIDogc3RyO1xuXHRcdH1cblx0fVxufTtcblxuVGV4dFBsdWdpbi5zcGxpdElubmVySFRNTCA9IHNwbGl0SW5uZXJIVE1MO1xuVGV4dFBsdWdpbi5lbW9qaVNhZmVTcGxpdCA9IGVtb2ppU2FmZVNwbGl0O1xuVGV4dFBsdWdpbi5nZXRUZXh0ID0gZ2V0VGV4dDtcblxuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKFRleHRQbHVnaW4pO1xuXG5leHBvcnQgeyBUZXh0UGx1Z2luIGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgZ3NhcCBmcm9tIFwiLi9nc2FwLWNvcmUuanNcIjtcbmltcG9ydCBDU1NQbHVnaW4gZnJvbSBcIi4vQ1NTUGx1Z2luLmpzXCI7XG5jb25zdCBnc2FwV2l0aENTUyA9IGdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUGx1Z2luKSB8fCBnc2FwLCAvLyB0byBwcm90ZWN0IGZyb20gdHJlZSBzaGFraW5nXG5cdFR3ZWVuTWF4V2l0aENTUyA9IGdzYXBXaXRoQ1NTLmNvcmUuVHdlZW47XG5cbmV4cG9ydCB7IGdzYXBXaXRoQ1NTIGFzIGdzYXAsIGdzYXBXaXRoQ1NTIGFzIGRlZmF1bHQsIENTU1BsdWdpbiwgVHdlZW5NYXhXaXRoQ1NTIGFzIFR3ZWVuTWF4IH07XG5cbmV4cG9ydCB7IFR3ZWVuTGl0ZSwgVGltZWxpbmVNYXgsIFRpbWVsaW5lTGl0ZSwgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjLCB3cmFwLCB3cmFwWW95bywgZGlzdHJpYnV0ZSwgcmFuZG9tLCBzbmFwLCBub3JtYWxpemUsIGdldFVuaXQsIGNsYW1wLCBzcGxpdENvbG9yLCB0b0FycmF5LCBtYXBSYW5nZSwgcGlwZSwgdW5pdGl6ZSwgaW50ZXJwb2xhdGUsIHNodWZmbGUsIHNlbGVjdG9yIH0gZnJvbSBcIi4vZ3NhcC1jb3JlLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9EcmFnZ2FibGUuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0NTU1J1bGVQbHVnaW4uanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0Vhc2VsUGx1Z2luLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9FYXNlUGFjay5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vTW90aW9uUGF0aFBsdWdpbi5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vUGl4aVBsdWdpbi5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vU2Nyb2xsVG9QbHVnaW4uanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1Njcm9sbFRyaWdnZXIuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1RleHRQbHVnaW4uanNcIjtcblxuLy9CT05VUyBFWFBPUlRTXG4vL2V4cG9ydCAqIGZyb20gXCIuL0N1c3RvbUVhc2UuanNcIjtcbi8vZXhwb3J0ICogZnJvbSBcIi4vRHJhd1NWR1BsdWdpbi5qc1wiO1xuLy9leHBvcnQgKiBmcm9tIFwiLi9QaHlzaWNzMkRQbHVnaW4uanNcIjtcbi8vZXhwb3J0ICogZnJvbSBcIi4vUGh5c2ljc1Byb3BzUGx1Z2luLmpzXCI7XG4vL2V4cG9ydCAqIGZyb20gXCIuL1NjcmFtYmxlVGV4dFBsdWdpbi5qc1wiO1xuLy9leHBvcnQgKiBmcm9tIFwiLi9DdXN0b21Cb3VuY2UuanNcIjtcbi8vZXhwb3J0ICogZnJvbSBcIi4vQ3VzdG9tV2lnZ2xlLmpzXCI7XG4vL2V4cG9ydCAqIGZyb20gXCIuL0ZsaXAuanNcIjtcbi8vZXhwb3J0ICogZnJvbSBcIi4vR1NEZXZUb29scy5qc1wiO1xuLy9leHBvcnQgKiBmcm9tIFwiLi9JbmVydGlhUGx1Z2luLmpzXCI7XG4vL2V4cG9ydCAqIGZyb20gXCIuL01vcnBoU1ZHUGx1Z2luLmpzXCI7XG4vL2V4cG9ydCAqIGZyb20gXCIuL01vdGlvblBhdGhIZWxwZXIuanNcIjtcbi8vZXhwb3J0ICogZnJvbSBcIi4vU3BsaXRUZXh0LmpzXCI7IiwiLyohXG4gKiBHU0FQIDMuNy4wXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDIxLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuLyogZXNsaW50LWRpc2FibGUgKi9cblxubGV0IF9jb25maWcgPSB7XG5cdFx0YXV0b1NsZWVwOiAxMjAsXG5cdFx0Zm9yY2UzRDogXCJhdXRvXCIsXG5cdFx0bnVsbFRhcmdldFdhcm46IDEsXG5cdFx0dW5pdHM6IHtsaW5lSGVpZ2h0OlwiXCJ9XG5cdH0sXG5cdF9kZWZhdWx0cyA9IHtcblx0XHRkdXJhdGlvbjogLjUsXG5cdFx0b3ZlcndyaXRlOiBmYWxzZSxcblx0XHRkZWxheTogMFxuXHR9LFxuXHRfc3VwcHJlc3NPdmVyd3JpdGVzLFxuXHRfYmlnTnVtID0gMWU4LFxuXHRfdGlueU51bSA9IDEgLyBfYmlnTnVtLFxuXHRfMlBJID0gTWF0aC5QSSAqIDIsXG5cdF9IQUxGX1BJID0gXzJQSSAvIDQsXG5cdF9nc0lEID0gMCxcblx0X3NxcnQgPSBNYXRoLnNxcnQsXG5cdF9jb3MgPSBNYXRoLmNvcyxcblx0X3NpbiA9IE1hdGguc2luLFxuXHRfaXNTdHJpbmcgPSB2YWx1ZSA9PiB0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiLFxuXHRfaXNGdW5jdGlvbiA9IHZhbHVlID0+IHR5cGVvZih2YWx1ZSkgPT09IFwiZnVuY3Rpb25cIixcblx0X2lzTnVtYmVyID0gdmFsdWUgPT4gdHlwZW9mKHZhbHVlKSA9PT0gXCJudW1iZXJcIixcblx0X2lzVW5kZWZpbmVkID0gdmFsdWUgPT4gdHlwZW9mKHZhbHVlKSA9PT0gXCJ1bmRlZmluZWRcIixcblx0X2lzT2JqZWN0ID0gdmFsdWUgPT4gdHlwZW9mKHZhbHVlKSA9PT0gXCJvYmplY3RcIixcblx0X2lzTm90RmFsc2UgPSB2YWx1ZSA9PiB2YWx1ZSAhPT0gZmFsc2UsXG5cdF93aW5kb3dFeGlzdHMgPSAoKSA9PiB0eXBlb2Yod2luZG93KSAhPT0gXCJ1bmRlZmluZWRcIixcblx0X2lzRnVuY09yU3RyaW5nID0gdmFsdWUgPT4gX2lzRnVuY3Rpb24odmFsdWUpIHx8IF9pc1N0cmluZyh2YWx1ZSksXG5cdF9pc1R5cGVkQXJyYXkgPSAodHlwZW9mIEFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCIgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KSB8fCBmdW5jdGlvbigpIHt9LCAvLyBub3RlOiBJRTEwIGhhcyBBcnJheUJ1ZmZlciwgYnV0IE5PVCBBcnJheUJ1ZmZlci5pc1ZpZXcoKS5cblx0X2lzQXJyYXkgPSBBcnJheS5pc0FycmF5LFxuXHRfc3RyaWN0TnVtRXhwID0gLyg/Oi0/XFwuP1xcZHxcXC4pKy9naSwgLy9vbmx5IG51bWJlcnMgKGluY2x1ZGluZyBuZWdhdGl2ZXMgYW5kIGRlY2ltYWxzKSBidXQgTk9UIHJlbGF0aXZlIHZhbHVlcy5cblx0X251bUV4cCA9IC9bLSs9Ll0qXFxkK1suZVxcLStdKlxcZCpbZVxcLStdKlxcZCovZywgLy9maW5kcyBhbnkgbnVtYmVycywgaW5jbHVkaW5nIG9uZXMgdGhhdCBzdGFydCB3aXRoICs9IG9yIC09LCBuZWdhdGl2ZSBudW1iZXJzLCBhbmQgb25lcyBpbiBzY2llbnRpZmljIG5vdGF0aW9uIGxpa2UgMWUtOC5cblx0X251bVdpdGhVbml0RXhwID0gL1stKz0uXSpcXGQrWy5lLV0qXFxkKlthLXolXSovZyxcblx0X2NvbXBsZXhTdHJpbmdOdW1FeHAgPSAvWy0rPS5dKlxcZCtcXC4/XFxkKig/OmUtfGVcXCspP1xcZCovZ2ksIC8vZHVwbGljYXRlIHNvIHRoYXQgd2hpbGUgd2UncmUgbG9vcGluZyB0aHJvdWdoIG1hdGNoZXMgZnJvbSBleGVjKCksIGl0IGRvZXNuJ3QgY29udGFtaW5hdGUgdGhlIGxhc3RJbmRleCBvZiBfbnVtRXhwIHdoaWNoIHdlIHVzZSB0byBzZWFyY2ggZm9yIGNvbG9ycyB0b28uXG5cdF9yZWxFeHAgPSAvWystXT0tP1suXFxkXSsvLFxuXHRfZGVsaW1pdGVkVmFsdWVFeHAgPSAvW14sJ1wiXFxbXFxdXFxzXSsvZ2ksIC8vIHByZXZpb3VzbHkgL1sjXFwtKy5dKlxcYlthLXpcXGRcXC09KyUuXSsvZ2kgYnV0IGRpZG4ndCBjYXRjaCBzcGVjaWFsIGNoYXJhY3RlcnMuXG5cdF91bml0RXhwID0gL1tcXGQuK1xcLT1dKyg/OmVbLStdXFxkKikqL2ksXG5cdF9nbG9iYWxUaW1lbGluZSwgX3dpbiwgX2NvcmVJbml0dGVkLCBfZG9jLFxuXHRfZ2xvYmFscyA9IHt9LFxuXHRfaW5zdGFsbFNjb3BlID0ge30sXG5cdF9jb3JlUmVhZHksXG5cdF9pbnN0YWxsID0gc2NvcGUgPT4gKF9pbnN0YWxsU2NvcGUgPSBfbWVyZ2Uoc2NvcGUsIF9nbG9iYWxzKSkgJiYgZ3NhcCxcblx0X21pc3NpbmdQbHVnaW4gPSAocHJvcGVydHksIHZhbHVlKSA9PiBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHByb3BlcnR5XCIsIHByb3BlcnR5LCBcInNldCB0b1wiLCB2YWx1ZSwgXCJNaXNzaW5nIHBsdWdpbj8gZ3NhcC5yZWdpc3RlclBsdWdpbigpXCIpLFxuXHRfd2FybiA9IChtZXNzYWdlLCBzdXBwcmVzcykgPT4gIXN1cHByZXNzICYmIGNvbnNvbGUud2FybihtZXNzYWdlKSxcblx0X2FkZEdsb2JhbCA9IChuYW1lLCBvYmopID0+IChuYW1lICYmIChfZ2xvYmFsc1tuYW1lXSA9IG9iaikgJiYgKF9pbnN0YWxsU2NvcGUgJiYgKF9pbnN0YWxsU2NvcGVbbmFtZV0gPSBvYmopKSkgfHwgX2dsb2JhbHMsXG5cdF9lbXB0eUZ1bmMgPSAoKSA9PiAwLFxuXHRfcmVzZXJ2ZWRQcm9wcyA9IHt9LFxuXHRfbGF6eVR3ZWVucyA9IFtdLFxuXHRfbGF6eUxvb2t1cCA9IHt9LFxuXHRfbGFzdFJlbmRlcmVkRnJhbWUsXG5cdF9wbHVnaW5zID0ge30sXG5cdF9lZmZlY3RzID0ge30sXG5cdF9uZXh0R0NGcmFtZSA9IDMwLFxuXHRfaGFybmVzc1BsdWdpbnMgPSBbXSxcblx0X2NhbGxiYWNrTmFtZXMgPSBcIlwiLFxuXHRfaGFybmVzcyA9IHRhcmdldHMgPT4ge1xuXHRcdGxldCB0YXJnZXQgPSB0YXJnZXRzWzBdLFxuXHRcdFx0aGFybmVzc1BsdWdpbiwgaTtcblx0XHRfaXNPYmplY3QodGFyZ2V0KSB8fCBfaXNGdW5jdGlvbih0YXJnZXQpIHx8ICh0YXJnZXRzID0gW3RhcmdldHNdKTtcblx0XHRpZiAoIShoYXJuZXNzUGx1Z2luID0gKHRhcmdldC5fZ3NhcCB8fCB7fSkuaGFybmVzcykpIHsgLy8gZmluZCB0aGUgZmlyc3QgdGFyZ2V0IHdpdGggYSBoYXJuZXNzLiBXZSBhc3N1bWUgdGFyZ2V0cyBwYXNzZWQgaW50byBhbiBhbmltYXRpb24gd2lsbCBiZSBvZiBzaW1pbGFyIHR5cGUsIG1lYW5pbmcgdGhlIHNhbWUga2luZCBvZiBoYXJuZXNzIGNhbiBiZSB1c2VkIGZvciB0aGVtIGFsbCAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uKVxuXHRcdFx0aSA9IF9oYXJuZXNzUGx1Z2lucy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tICYmICFfaGFybmVzc1BsdWdpbnNbaV0udGFyZ2V0VGVzdCh0YXJnZXQpKSB7XHR9XG5cdFx0XHRoYXJuZXNzUGx1Z2luID0gX2hhcm5lc3NQbHVnaW5zW2ldO1xuXHRcdH1cblx0XHRpID0gdGFyZ2V0cy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0KHRhcmdldHNbaV0gJiYgKHRhcmdldHNbaV0uX2dzYXAgfHwgKHRhcmdldHNbaV0uX2dzYXAgPSBuZXcgR1NDYWNoZSh0YXJnZXRzW2ldLCBoYXJuZXNzUGx1Z2luKSkpKSB8fCB0YXJnZXRzLnNwbGljZShpLCAxKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldHM7XG5cdH0sXG5cdF9nZXRDYWNoZSA9IHRhcmdldCA9PiB0YXJnZXQuX2dzYXAgfHwgX2hhcm5lc3ModG9BcnJheSh0YXJnZXQpKVswXS5fZ3NhcCxcblx0X2dldFByb3BlcnR5ID0gKHRhcmdldCwgcHJvcGVydHksIHYpID0+ICh2ID0gdGFyZ2V0W3Byb3BlcnR5XSkgJiYgX2lzRnVuY3Rpb24odikgPyB0YXJnZXRbcHJvcGVydHldKCkgOiAoX2lzVW5kZWZpbmVkKHYpICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShwcm9wZXJ0eSkpIHx8IHYsXG5cdF9mb3JFYWNoTmFtZSA9IChuYW1lcywgZnVuYykgPT4gKChuYW1lcyA9IG5hbWVzLnNwbGl0KFwiLFwiKSkuZm9yRWFjaChmdW5jKSkgfHwgbmFtZXMsIC8vc3BsaXQgYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBuYW1lcyBpbnRvIGFuIGFycmF5LCB0aGVuIHJ1biBhIGZvckVhY2goKSBmdW5jdGlvbiBhbmQgcmV0dXJuIHRoZSBzcGxpdCBhcnJheSAodGhpcyBpcyBqdXN0IGEgd2F5IHRvIGNvbnNvbGlkYXRlL3Nob3J0ZW4gc29tZSBjb2RlKS5cblx0X3JvdW5kID0gdmFsdWUgPT4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMDAwMCkgLyAxMDAwMDAgfHwgMCxcblx0X2FycmF5Q29udGFpbnNBbnkgPSAodG9TZWFyY2gsIHRvRmluZCkgPT4geyAvL3NlYXJjaGVzIG9uZSBhcnJheSB0byBmaW5kIG1hdGNoZXMgZm9yIGFueSBvZiB0aGUgaXRlbXMgaW4gdGhlIHRvRmluZCBhcnJheS4gQXMgc29vbiBhcyBvbmUgaXMgZm91bmQsIGl0IHJldHVybnMgdHJ1ZS4gSXQgZG9lcyBOT1QgcmV0dXJuIGFsbCB0aGUgbWF0Y2hlczsgaXQncyBzaW1wbHkgYSBib29sZWFuIHNlYXJjaC5cblx0XHRsZXQgbCA9IHRvRmluZC5sZW5ndGgsXG5cdFx0XHRpID0gMDtcblx0XHRmb3IgKDsgdG9TZWFyY2guaW5kZXhPZih0b0ZpbmRbaV0pIDwgMCAmJiArK2kgPCBsOykgeyB9XG5cdFx0cmV0dXJuIChpIDwgbCk7XG5cdH0sXG5cdF9sYXp5UmVuZGVyID0gKCkgPT4ge1xuXHRcdGxldCBsID0gX2xhenlUd2VlbnMubGVuZ3RoLFxuXHRcdFx0YSA9IF9sYXp5VHdlZW5zLnNsaWNlKDApLFxuXHRcdFx0aSwgdHdlZW47XG5cdFx0X2xhenlMb29rdXAgPSB7fTtcblx0XHRfbGF6eVR3ZWVucy5sZW5ndGggPSAwO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdHR3ZWVuID0gYVtpXTtcblx0XHRcdHR3ZWVuICYmIHR3ZWVuLl9sYXp5ICYmICh0d2Vlbi5yZW5kZXIodHdlZW4uX2xhenlbMF0sIHR3ZWVuLl9sYXp5WzFdLCB0cnVlKS5fbGF6eSA9IDApO1xuXHRcdH1cblx0fSxcblx0X2xhenlTYWZlUmVuZGVyID0gKGFuaW1hdGlvbiwgdGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSA9PiB7XG5cdFx0X2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7XG5cdFx0YW5pbWF0aW9uLnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdF9sYXp5VHdlZW5zLmxlbmd0aCAmJiBfbGF6eVJlbmRlcigpOyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gc29tZW9uZSBjYWxscyBzZWVrKCkgb3IgdGltZSgpIG9yIHByb2dyZXNzKCksIHRoZXkgZXhwZWN0IGFuIGltbWVkaWF0ZSByZW5kZXIuXG5cdH0sXG5cdF9udW1lcmljSWZQb3NzaWJsZSA9IHZhbHVlID0+IHtcblx0XHRsZXQgbiA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXHRcdHJldHVybiAobiB8fCBuID09PSAwKSAmJiAodmFsdWUgKyBcIlwiKS5tYXRjaChfZGVsaW1pdGVkVmFsdWVFeHApLmxlbmd0aCA8IDIgPyBuIDogX2lzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xuXHR9LFxuXHRfcGFzc1Rocm91Z2ggPSBwID0+IHAsXG5cdF9zZXREZWZhdWx0cyA9IChvYmosIGRlZmF1bHRzKSA9PiB7XG5cdFx0Zm9yIChsZXQgcCBpbiBkZWZhdWx0cykge1xuXHRcdFx0KHAgaW4gb2JqKSB8fCAob2JqW3BdID0gZGVmYXVsdHNbcF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXHRfc2V0S2V5ZnJhbWVEZWZhdWx0cyA9IChvYmosIGRlZmF1bHRzKSA9PiB7XG5cdFx0Zm9yIChsZXQgcCBpbiBkZWZhdWx0cykge1xuXHRcdFx0KHAgaW4gb2JqKSB8fCBwID09PSBcImR1cmF0aW9uXCIgfHwgcCA9PT0gXCJlYXNlXCIgfHwgKG9ialtwXSA9IGRlZmF1bHRzW3BdKTtcblx0XHR9XG5cdH0sXG5cdF9tZXJnZSA9IChiYXNlLCB0b01lcmdlKSA9PiB7XG5cdFx0Zm9yIChsZXQgcCBpbiB0b01lcmdlKSB7XG5cdFx0XHRiYXNlW3BdID0gdG9NZXJnZVtwXTtcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH0sXG5cdF9tZXJnZURlZXAgPSAoYmFzZSwgdG9NZXJnZSkgPT4ge1xuXHRcdGZvciAobGV0IHAgaW4gdG9NZXJnZSkge1xuXHRcdFx0cCAhPT0gXCJfX3Byb3RvX19cIiAmJiBwICE9PSBcImNvbnN0cnVjdG9yXCIgJiYgcCAhPT0gXCJwcm90b3R5cGVcIiAmJiAoYmFzZVtwXSA9IF9pc09iamVjdCh0b01lcmdlW3BdKSA/IF9tZXJnZURlZXAoYmFzZVtwXSB8fCAoYmFzZVtwXSA9IHt9KSwgdG9NZXJnZVtwXSkgOiB0b01lcmdlW3BdKTtcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH0sXG5cdF9jb3B5RXhjbHVkaW5nID0gKG9iaiwgZXhjbHVkaW5nKSA9PiB7XG5cdFx0bGV0IGNvcHkgPSB7fSxcblx0XHRcdHA7XG5cdFx0Zm9yIChwIGluIG9iaikge1xuXHRcdFx0KHAgaW4gZXhjbHVkaW5nKSB8fCAoY29weVtwXSA9IG9ialtwXSk7XG5cdFx0fVxuXHRcdHJldHVybiBjb3B5O1xuXHR9LFxuXHRfaW5oZXJpdERlZmF1bHRzID0gdmFycyA9PiB7XG5cdFx0bGV0IHBhcmVudCA9IHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZSxcblx0XHRcdGZ1bmMgPSB2YXJzLmtleWZyYW1lcyA/IF9zZXRLZXlmcmFtZURlZmF1bHRzIDogX3NldERlZmF1bHRzO1xuXHRcdGlmIChfaXNOb3RGYWxzZSh2YXJzLmluaGVyaXQpKSB7XG5cdFx0XHR3aGlsZSAocGFyZW50KSB7XG5cdFx0XHRcdGZ1bmModmFycywgcGFyZW50LnZhcnMuZGVmYXVsdHMpO1xuXHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50IHx8IHBhcmVudC5fZHA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB2YXJzO1xuXHR9LFxuXHRfYXJyYXlzTWF0Y2ggPSAoYTEsIGEyKSA9PiB7XG5cdFx0bGV0IGkgPSBhMS5sZW5ndGgsXG5cdFx0XHRtYXRjaCA9IGkgPT09IGEyLmxlbmd0aDtcblx0XHR3aGlsZSAobWF0Y2ggJiYgaS0tICYmIGExW2ldID09PSBhMltpXSkgeyB9XG5cdFx0cmV0dXJuIGkgPCAwO1xuXHR9LFxuXHRfYWRkTGlua2VkTGlzdEl0ZW0gPSAocGFyZW50LCBjaGlsZCwgZmlyc3RQcm9wID0gXCJfZmlyc3RcIiwgbGFzdFByb3AgPSBcIl9sYXN0XCIsIHNvcnRCeSkgPT4ge1xuXHRcdGxldCBwcmV2ID0gcGFyZW50W2xhc3RQcm9wXSxcblx0XHRcdHQ7XG5cdFx0aWYgKHNvcnRCeSkge1xuXHRcdFx0dCA9IGNoaWxkW3NvcnRCeV07XG5cdFx0XHR3aGlsZSAocHJldiAmJiBwcmV2W3NvcnRCeV0gPiB0KSB7XG5cdFx0XHRcdHByZXYgPSBwcmV2Ll9wcmV2O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAocHJldikge1xuXHRcdFx0Y2hpbGQuX25leHQgPSBwcmV2Ll9uZXh0O1xuXHRcdFx0cHJldi5fbmV4dCA9IGNoaWxkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaGlsZC5fbmV4dCA9IHBhcmVudFtmaXJzdFByb3BdO1xuXHRcdFx0cGFyZW50W2ZpcnN0UHJvcF0gPSBjaGlsZDtcblx0XHR9XG5cdFx0aWYgKGNoaWxkLl9uZXh0KSB7XG5cdFx0XHRjaGlsZC5fbmV4dC5fcHJldiA9IGNoaWxkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXJlbnRbbGFzdFByb3BdID0gY2hpbGQ7XG5cdFx0fVxuXHRcdGNoaWxkLl9wcmV2ID0gcHJldjtcblx0XHRjaGlsZC5wYXJlbnQgPSBjaGlsZC5fZHAgPSBwYXJlbnQ7XG5cdFx0cmV0dXJuIGNoaWxkO1xuXHR9LFxuXHRfcmVtb3ZlTGlua2VkTGlzdEl0ZW0gPSAocGFyZW50LCBjaGlsZCwgZmlyc3RQcm9wID0gXCJfZmlyc3RcIiwgbGFzdFByb3AgPSBcIl9sYXN0XCIpID0+IHtcblx0XHRsZXQgcHJldiA9IGNoaWxkLl9wcmV2LFxuXHRcdFx0bmV4dCA9IGNoaWxkLl9uZXh0O1xuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRwcmV2Ll9uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2UgaWYgKHBhcmVudFtmaXJzdFByb3BdID09PSBjaGlsZCkge1xuXHRcdFx0cGFyZW50W2ZpcnN0UHJvcF0gPSBuZXh0O1xuXHRcdH1cblx0XHRpZiAobmV4dCkge1xuXHRcdFx0bmV4dC5fcHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIGlmIChwYXJlbnRbbGFzdFByb3BdID09PSBjaGlsZCkge1xuXHRcdFx0cGFyZW50W2xhc3RQcm9wXSA9IHByZXY7XG5cdFx0fVxuXHRcdGNoaWxkLl9uZXh0ID0gY2hpbGQuX3ByZXYgPSBjaGlsZC5wYXJlbnQgPSBudWxsOyAvLyBkb24ndCBkZWxldGUgdGhlIF9kcCBqdXN0IHNvIHdlIGNhbiByZXZlcnQgaWYgbmVjZXNzYXJ5LiBCdXQgcGFyZW50IHNob3VsZCBiZSBudWxsIHRvIGluZGljYXRlIHRoZSBpdGVtIGlzbid0IGluIGEgbGlua2VkIGxpc3QuXG5cdH0sXG5cdF9yZW1vdmVGcm9tUGFyZW50ID0gKGNoaWxkLCBvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlKSA9PiB7XG5cdFx0Y2hpbGQucGFyZW50ICYmICghb25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSB8fCBjaGlsZC5wYXJlbnQuYXV0b1JlbW92ZUNoaWxkcmVuKSAmJiBjaGlsZC5wYXJlbnQucmVtb3ZlKGNoaWxkKTtcblx0XHRjaGlsZC5fYWN0ID0gMDtcblx0fSxcblx0X3VuY2FjaGUgPSAoYW5pbWF0aW9uLCBjaGlsZCkgPT4ge1xuXHRcdGlmIChhbmltYXRpb24gJiYgKCFjaGlsZCB8fCBjaGlsZC5fZW5kID4gYW5pbWF0aW9uLl9kdXIgfHwgY2hpbGQuX3N0YXJ0IDwgMCkpIHsgLy8gcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBpZiBhIGNoaWxkIGFuaW1hdGlvbiBpcyBwYXNzZWQgaW4gd2Ugc2hvdWxkIG9ubHkgdW5jYWNoZSBpZiB0aGF0IGNoaWxkIEVYVEVORFMgdGhlIGFuaW1hdGlvbiAoaXRzIGVuZCB0aW1lIGlzIGJleW9uZCB0aGUgZW5kKVxuXHRcdFx0bGV0IGEgPSBhbmltYXRpb247XG5cdFx0XHR3aGlsZSAoYSkge1xuXHRcdFx0XHRhLl9kaXJ0eSA9IDE7XG5cdFx0XHRcdGEgPSBhLnBhcmVudDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGFuaW1hdGlvbjtcblx0fSxcblx0X3JlY2FjaGVBbmNlc3RvcnMgPSBhbmltYXRpb24gPT4ge1xuXHRcdGxldCBwYXJlbnQgPSBhbmltYXRpb24ucGFyZW50O1xuXHRcdHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkgeyAvL3NvbWV0aW1lcyB3ZSBtdXN0IGZvcmNlIGEgcmUtc29ydCBvZiBhbGwgY2hpbGRyZW4gYW5kIHVwZGF0ZSB0aGUgZHVyYXRpb24vdG90YWxEdXJhdGlvbiBvZiBhbGwgYW5jZXN0b3IgdGltZWxpbmVzIGltbWVkaWF0ZWx5IGluIGNhc2UsIGZvciBleGFtcGxlLCBpbiB0aGUgbWlkZGxlIG9mIGEgcmVuZGVyIGxvb3AsIG9uZSB0d2VlbiBhbHRlcnMgYW5vdGhlciB0d2VlbidzIHRpbWVTY2FsZSB3aGljaCBzaG92ZXMgaXRzIHN0YXJ0VGltZSBiZWZvcmUgMCwgZm9yY2luZyB0aGUgcGFyZW50IHRpbWVsaW5lIHRvIHNoaWZ0IGFyb3VuZCBhbmQgc2hpZnRDaGlsZHJlbigpIHdoaWNoIGNvdWxkIGFmZmVjdCB0aGF0IG5leHQgdHdlZW4ncyByZW5kZXIgKHN0YXJ0VGltZSkuIERvZXNuJ3QgbWF0dGVyIGZvciB0aGUgcm9vdCB0aW1lbGluZSB0aG91Z2guXG5cdFx0XHRwYXJlbnQuX2RpcnR5ID0gMTtcblx0XHRcdHBhcmVudC50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gYW5pbWF0aW9uO1xuXHR9LFxuXHRfaGFzTm9QYXVzZWRBbmNlc3RvcnMgPSBhbmltYXRpb24gPT4gIWFuaW1hdGlvbiB8fCAoYW5pbWF0aW9uLl90cyAmJiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoYW5pbWF0aW9uLnBhcmVudCkpLFxuXHRfZWxhcHNlZEN5Y2xlRHVyYXRpb24gPSBhbmltYXRpb24gPT4gYW5pbWF0aW9uLl9yZXBlYXQgPyBfYW5pbWF0aW9uQ3ljbGUoYW5pbWF0aW9uLl90VGltZSwgKGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbigpICsgYW5pbWF0aW9uLl9yRGVsYXkpKSAqIGFuaW1hdGlvbiA6IDAsXG5cdC8vIGZlZWQgaW4gdGhlIHRvdGFsVGltZSBhbmQgY3ljbGVEdXJhdGlvbiBhbmQgaXQnbGwgcmV0dXJuIHRoZSBjeWNsZSAoaXRlcmF0aW9uIG1pbnVzIDEpIGFuZCBpZiB0aGUgcGxheWhlYWQgaXMgZXhhY3RseSBhdCB0aGUgdmVyeSBFTkQsIGl0IHdpbGwgTk9UIGJ1bXAgdXAgdG8gdGhlIG5leHQgY3ljbGUuXG5cdF9hbmltYXRpb25DeWNsZSA9ICh0VGltZSwgY3ljbGVEdXJhdGlvbikgPT4ge1xuXHRcdGxldCB3aG9sZSA9IE1hdGguZmxvb3IodFRpbWUgLz0gY3ljbGVEdXJhdGlvbik7XG5cdFx0cmV0dXJuIHRUaW1lICYmICh3aG9sZSA9PT0gdFRpbWUpID8gd2hvbGUgLSAxIDogd2hvbGU7XG5cdH0sXG5cdF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lID0gKHBhcmVudFRpbWUsIGNoaWxkKSA9PiAocGFyZW50VGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgKyAoY2hpbGQuX3RzID49IDAgPyAwIDogKGNoaWxkLl9kaXJ0eSA/IGNoaWxkLnRvdGFsRHVyYXRpb24oKSA6IGNoaWxkLl90RHVyKSksXG5cdF9zZXRFbmQgPSBhbmltYXRpb24gPT4gKGFuaW1hdGlvbi5fZW5kID0gX3JvdW5kKGFuaW1hdGlvbi5fc3RhcnQgKyAoKGFuaW1hdGlvbi5fdER1ciAvIE1hdGguYWJzKGFuaW1hdGlvbi5fdHMgfHwgYW5pbWF0aW9uLl9ydHMgfHwgX3RpbnlOdW0pKSB8fCAwKSkpLFxuXHRfYWxpZ25QbGF5aGVhZCA9IChhbmltYXRpb24sIHRvdGFsVGltZSkgPT4geyAvLyBhZGp1c3RzIHRoZSBhbmltYXRpb24ncyBfc3RhcnQgYW5kIF9lbmQgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCB0b3RhbFRpbWUgKG9ubHkgaWYgdGhlIHBhcmVudCdzIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUgYW5kIHRoZSBhbmltYXRpb24gaXNuJ3QgcGF1c2VkKS4gSXQgZG9lc24ndCBkbyBhbnkgcmVuZGVyaW5nIG9yIGZvcmNpbmcgdGhpbmdzIGJhY2sgaW50byBwYXJlbnQgdGltZWxpbmVzLCBldGMuIC0gdGhhdCdzIHdoYXQgdG90YWxUaW1lKCkgaXMgZm9yLlxuXHRcdGxldCBwYXJlbnQgPSBhbmltYXRpb24uX2RwO1xuXHRcdGlmIChwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nICYmIGFuaW1hdGlvbi5fdHMpIHtcblx0XHRcdGFuaW1hdGlvbi5fc3RhcnQgPSBfcm91bmQocGFyZW50Ll90aW1lIC0gKGFuaW1hdGlvbi5fdHMgPiAwID8gdG90YWxUaW1lIC8gYW5pbWF0aW9uLl90cyA6ICgoYW5pbWF0aW9uLl9kaXJ0eSA/IGFuaW1hdGlvbi50b3RhbER1cmF0aW9uKCkgOiBhbmltYXRpb24uX3REdXIpIC0gdG90YWxUaW1lKSAvIC1hbmltYXRpb24uX3RzKSk7XG5cdFx0XHRfc2V0RW5kKGFuaW1hdGlvbik7XG5cdFx0XHRwYXJlbnQuX2RpcnR5IHx8IF91bmNhY2hlKHBhcmVudCwgYW5pbWF0aW9uKTsgLy9mb3IgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQuIElmIHRoZSBwYXJlbnQncyBjYWNoZSBpcyBhbHJlYWR5IGRpcnR5LCBpdCBhbHJlYWR5IHRvb2sgY2FyZSBvZiBtYXJraW5nIHRoZSBhbmNlc3RvcnMgYXMgZGlydHkgdG9vLCBzbyBza2lwIHRoZSBmdW5jdGlvbiBjYWxsIGhlcmUuXG5cdFx0fVxuXHRcdHJldHVybiBhbmltYXRpb247XG5cdH0sXG5cdC8qXG5cdF90b3RhbFRpbWVUb1RpbWUgPSAoY2xhbXBlZFRvdGFsVGltZSwgZHVyYXRpb24sIHJlcGVhdCwgcmVwZWF0RGVsYXksIHlveW8pID0+IHtcblx0XHRsZXQgY3ljbGVEdXJhdGlvbiA9IGR1cmF0aW9uICsgcmVwZWF0RGVsYXksXG5cdFx0XHR0aW1lID0gX3JvdW5kKGNsYW1wZWRUb3RhbFRpbWUgJSBjeWNsZUR1cmF0aW9uKTtcblx0XHRpZiAodGltZSA+IGR1cmF0aW9uKSB7XG5cdFx0XHR0aW1lID0gZHVyYXRpb247XG5cdFx0fVxuXHRcdHJldHVybiAoeW95byAmJiAofn4oY2xhbXBlZFRvdGFsVGltZSAvIGN5Y2xlRHVyYXRpb24pICYgMSkpID8gZHVyYXRpb24gLSB0aW1lIDogdGltZTtcblx0fSxcblx0Ki9cblx0X3Bvc3RBZGRDaGVja3MgPSAodGltZWxpbmUsIGNoaWxkKSA9PiB7XG5cdFx0bGV0IHQ7XG5cdFx0aWYgKGNoaWxkLl90aW1lIHx8IChjaGlsZC5faW5pdHRlZCAmJiAhY2hpbGQuX2R1cikpIHsgLy9pbiBjYXNlLCBmb3IgZXhhbXBsZSwgdGhlIF9zdGFydCBpcyBtb3ZlZCBvbiBhIHR3ZWVuIHRoYXQgaGFzIGFscmVhZHkgcmVuZGVyZWQuIEltYWdpbmUgaXQncyBhdCBpdHMgZW5kIHN0YXRlLCB0aGVuIHRoZSBzdGFydFRpbWUgaXMgbW92ZWQgV0FZIGxhdGVyIChhZnRlciB0aGUgZW5kIG9mIHRoaXMgdGltZWxpbmUpLCBpdCBzaG91bGQgcmVuZGVyIGF0IGl0cyBiZWdpbm5pbmcuXG5cdFx0XHR0ID0gX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUodGltZWxpbmUucmF3VGltZSgpLCBjaGlsZCk7XG5cdFx0XHRpZiAoIWNoaWxkLl9kdXIgfHwgX2NsYW1wKDAsIGNoaWxkLnRvdGFsRHVyYXRpb24oKSwgdCkgLSBjaGlsZC5fdFRpbWUgPiBfdGlueU51bSkge1xuXHRcdFx0XHRjaGlsZC5yZW5kZXIodCwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vaWYgdGhlIHRpbWVsaW5lIGhhcyBhbHJlYWR5IGVuZGVkIGJ1dCB0aGUgaW5zZXJ0ZWQgdHdlZW4vdGltZWxpbmUgZXh0ZW5kcyB0aGUgZHVyYXRpb24sIHdlIHNob3VsZCBlbmFibGUgdGhpcyB0aW1lbGluZSBhZ2FpbiBzbyB0aGF0IGl0IHJlbmRlcnMgcHJvcGVybHkuIFdlIHNob3VsZCBhbHNvIGFsaWduIHRoZSBwbGF5aGVhZCB3aXRoIHRoZSBwYXJlbnQgdGltZWxpbmUncyB3aGVuIGFwcHJvcHJpYXRlLlxuXHRcdGlmIChfdW5jYWNoZSh0aW1lbGluZSwgY2hpbGQpLl9kcCAmJiB0aW1lbGluZS5faW5pdHRlZCAmJiB0aW1lbGluZS5fdGltZSA+PSB0aW1lbGluZS5fZHVyICYmIHRpbWVsaW5lLl90cykge1xuXHRcdFx0Ly9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3JzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZC4uLlxuXHRcdFx0aWYgKHRpbWVsaW5lLl9kdXIgPCB0aW1lbGluZS5kdXJhdGlvbigpKSB7XG5cdFx0XHRcdHQgPSB0aW1lbGluZTtcblx0XHRcdFx0d2hpbGUgKHQuX2RwKSB7XG5cdFx0XHRcdFx0KHQucmF3VGltZSgpID49IDApICYmIHQudG90YWxUaW1lKHQuX3RUaW1lKTsgLy9tb3ZlcyB0aGUgdGltZWxpbmUgKHNoaWZ0cyBpdHMgc3RhcnRUaW1lKSBpZiBuZWNlc3NhcnksIGFuZCBhbHNvIGVuYWJsZXMgaXQuIElmIGl0J3MgY3VycmVudGx5IHplcm8sIHRob3VnaCwgaXQgbWF5IG5vdCBiZSBzY2hlZHVsZWQgdG8gcmVuZGVyIHVudGlsIGxhdGVyIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSBpdCB0byBhbGlnbiB3aXRoIHRoZSBjdXJyZW50IHBsYXloZWFkIHBvc2l0aW9uLiBPbmx5IG1vdmUgdG8gY2F0Y2ggdXAgd2l0aCB0aGUgcGxheWhlYWQuXG5cdFx0XHRcdFx0dCA9IHQuX2RwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aW1lbGluZS5felRpbWUgPSAtX3RpbnlOdW07IC8vIGhlbHBzIGVuc3VyZSB0aGF0IHRoZSBuZXh0IHJlbmRlcigpIHdpbGwgYmUgZm9yY2VkIChjcm9zc2luZ1N0YXJ0ID0gdHJ1ZSBpbiByZW5kZXIoKSksIGV2ZW4gaWYgdGhlIGR1cmF0aW9uIGhhc24ndCBjaGFuZ2VkICh3ZSdyZSBhZGRpbmcgYSBjaGlsZCB3aGljaCB3b3VsZCBuZWVkIHRvIGdldCByZW5kZXJlZCkuIERlZmluaXRlbHkgYW4gZWRnZSBjYXNlLiBOb3RlOiB3ZSBNVVNUIGRvIHRoaXMgQUZURVIgdGhlIGxvb3AgYWJvdmUgd2hlcmUgdGhlIHRvdGFsVGltZSgpIG1pZ2h0IHRyaWdnZXIgYSByZW5kZXIoKSBiZWNhdXNlIHRoaXMgX2FkZFRvVGltZWxpbmUoKSBtZXRob2QgZ2V0cyBjYWxsZWQgZnJvbSB0aGUgQW5pbWF0aW9uIGNvbnN0cnVjdG9yLCBCRUZPUkUgdHdlZW5zIGV2ZW4gcmVjb3JkIHRoZWlyIHRhcmdldHMsIGV0Yy4gc28gd2Ugd291bGRuJ3Qgd2FudCB0aGluZ3MgdG8gZ2V0IHRyaWdnZXJlZCBpbiB0aGUgd3Jvbmcgb3JkZXIuXG5cdFx0fVxuXHR9LFxuXHRfYWRkVG9UaW1lbGluZSA9ICh0aW1lbGluZSwgY2hpbGQsIHBvc2l0aW9uLCBza2lwQ2hlY2tzKSA9PiB7XG5cdFx0Y2hpbGQucGFyZW50ICYmIF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkKTtcblx0XHRjaGlsZC5fc3RhcnQgPSBfcm91bmQoKF9pc051bWJlcihwb3NpdGlvbikgPyBwb3NpdGlvbiA6IHBvc2l0aW9uIHx8IHRpbWVsaW5lICE9PSBfZ2xvYmFsVGltZWxpbmUgPyBfcGFyc2VQb3NpdGlvbih0aW1lbGluZSwgcG9zaXRpb24sIGNoaWxkKSA6IHRpbWVsaW5lLl90aW1lKSArIGNoaWxkLl9kZWxheSk7XG5cdFx0Y2hpbGQuX2VuZCA9IF9yb3VuZChjaGlsZC5fc3RhcnQgKyAoKGNoaWxkLnRvdGFsRHVyYXRpb24oKSAvIE1hdGguYWJzKGNoaWxkLnRpbWVTY2FsZSgpKSkgfHwgMCkpO1xuXHRcdF9hZGRMaW5rZWRMaXN0SXRlbSh0aW1lbGluZSwgY2hpbGQsIFwiX2ZpcnN0XCIsIFwiX2xhc3RcIiwgdGltZWxpbmUuX3NvcnQgPyBcIl9zdGFydFwiIDogMCk7XG5cdFx0X2lzRnJvbU9yRnJvbVN0YXJ0KGNoaWxkKSB8fCAodGltZWxpbmUuX3JlY2VudCA9IGNoaWxkKTtcblx0XHRza2lwQ2hlY2tzIHx8IF9wb3N0QWRkQ2hlY2tzKHRpbWVsaW5lLCBjaGlsZCk7XG5cdFx0cmV0dXJuIHRpbWVsaW5lO1xuXHR9LFxuXHRfc2Nyb2xsVHJpZ2dlciA9IChhbmltYXRpb24sIHRyaWdnZXIpID0+IChfZ2xvYmFscy5TY3JvbGxUcmlnZ2VyIHx8IF9taXNzaW5nUGx1Z2luKFwic2Nyb2xsVHJpZ2dlclwiLCB0cmlnZ2VyKSkgJiYgX2dsb2JhbHMuU2Nyb2xsVHJpZ2dlci5jcmVhdGUodHJpZ2dlciwgYW5pbWF0aW9uKSxcblx0X2F0dGVtcHRJbml0VHdlZW4gPSAodHdlZW4sIHRvdGFsVGltZSwgZm9yY2UsIHN1cHByZXNzRXZlbnRzKSA9PiB7XG5cdFx0X2luaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lKTtcblx0XHRpZiAoIXR3ZWVuLl9pbml0dGVkKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0aWYgKCFmb3JjZSAmJiB0d2Vlbi5fcHQgJiYgKCh0d2Vlbi5fZHVyICYmIHR3ZWVuLnZhcnMubGF6eSAhPT0gZmFsc2UpIHx8ICghdHdlZW4uX2R1ciAmJiB0d2Vlbi52YXJzLmxhenkpKSAmJiBfbGFzdFJlbmRlcmVkRnJhbWUgIT09IF90aWNrZXIuZnJhbWUpIHtcblx0XHRcdF9sYXp5VHdlZW5zLnB1c2godHdlZW4pO1xuXHRcdFx0dHdlZW4uX2xhenkgPSBbdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50c107XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdH0sXG5cdF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQgPSAoe3BhcmVudH0pID0+IHBhcmVudCAmJiBwYXJlbnQuX3RzICYmIHBhcmVudC5faW5pdHRlZCAmJiAhcGFyZW50Ll9sb2NrICYmIChwYXJlbnQucmF3VGltZSgpIDwgMCB8fCBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KHBhcmVudCkpLCAvLyBjaGVjayBwYXJlbnQncyBfbG9jayBiZWNhdXNlIHdoZW4gYSB0aW1lbGluZSByZXBlYXRzL3lveW9zIGFuZCBkb2VzIGl0cyBhcnRpZmljaWFsIHdyYXBwaW5nLCB3ZSBzaG91bGRuJ3QgZm9yY2UgdGhlIHJhdGlvIGJhY2sgdG8gMFxuXHRfaXNGcm9tT3JGcm9tU3RhcnQgPSAoe2RhdGF9KSA9PiBkYXRhID09PSBcImlzRnJvbVN0YXJ0XCIgfHwgZGF0YSA9PT0gXCJpc1N0YXJ0XCIsXG5cdF9yZW5kZXJaZXJvRHVyYXRpb25Ud2VlbiA9ICh0d2VlbiwgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpID0+IHtcblx0XHRsZXQgcHJldlJhdGlvID0gdHdlZW4ucmF0aW8sXG5cdFx0XHRyYXRpbyA9IHRvdGFsVGltZSA8IDAgfHwgKCF0b3RhbFRpbWUgJiYgKCghdHdlZW4uX3N0YXJ0ICYmIF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQodHdlZW4pICYmICEoIXR3ZWVuLl9pbml0dGVkICYmIF9pc0Zyb21PckZyb21TdGFydCh0d2VlbikpKSB8fCAoKHR3ZWVuLl90cyA8IDAgfHwgdHdlZW4uX2RwLl90cyA8IDApICYmICFfaXNGcm9tT3JGcm9tU3RhcnQodHdlZW4pKSkpID8gMCA6IDEsIC8vIGlmIHRoZSB0d2VlbiBvciBpdHMgcGFyZW50IGlzIHJldmVyc2VkIGFuZCB0aGUgdG90YWxUaW1lIGlzIDAsIHdlIHNob3VsZCBnbyB0byBhIHJhdGlvIG9mIDAuIEVkZ2UgY2FzZTogaWYgYSBmcm9tKCkgb3IgZnJvbVRvKCkgc3RhZ2dlciB0d2VlbiBpcyBwbGFjZWQgbGF0ZXIgaW4gYSB0aW1lbGluZSwgdGhlIFwic3RhcnRBdFwiIHplcm8tZHVyYXRpb24gdHdlZW4gY291bGQgaW5pdGlhbGx5IHJlbmRlciBhdCBhIHRpbWUgd2hlbiB0aGUgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgaXMgdGVjaG5pY2FsbHkgQkVGT1JFIHdoZXJlIHRoaXMgdHdlZW4gaXMsIHNvIG1ha2Ugc3VyZSB0aGF0IGFueSBcImZyb21cIiBhbmQgXCJmcm9tVG9cIiBzdGFydEF0IHR3ZWVucyBhcmUgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUgYXQgYSByYXRpbyBvZiAxLlxuXHRcdFx0cmVwZWF0RGVsYXkgPSB0d2Vlbi5fckRlbGF5LFxuXHRcdFx0dFRpbWUgPSAwLFxuXHRcdFx0cHQsIGl0ZXJhdGlvbiwgcHJldkl0ZXJhdGlvbjtcblx0XHRpZiAocmVwZWF0RGVsYXkgJiYgdHdlZW4uX3JlcGVhdCkgeyAvLyBpbiBjYXNlIHRoZXJlJ3MgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIHRoYXQgaGFzIGEgcmVwZWF0IHdpdGggYSByZXBlYXREZWxheVxuXHRcdFx0dFRpbWUgPSBfY2xhbXAoMCwgdHdlZW4uX3REdXIsIHRvdGFsVGltZSk7XG5cdFx0XHRpdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodFRpbWUsIHJlcGVhdERlbGF5KTtcblx0XHRcdHByZXZJdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodHdlZW4uX3RUaW1lLCByZXBlYXREZWxheSk7XG5cdFx0XHR0d2Vlbi5feW95byAmJiAoaXRlcmF0aW9uICYgMSkgJiYgKHJhdGlvID0gMSAtIHJhdGlvKTtcblx0XHRcdGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24pIHtcblx0XHRcdFx0cHJldlJhdGlvID0gMSAtIHJhdGlvO1xuXHRcdFx0XHR0d2Vlbi52YXJzLnJlcGVhdFJlZnJlc2ggJiYgdHdlZW4uX2luaXR0ZWQgJiYgdHdlZW4uaW52YWxpZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAocmF0aW8gIT09IHByZXZSYXRpbyB8fCBmb3JjZSB8fCB0d2Vlbi5felRpbWUgPT09IF90aW55TnVtIHx8ICghdG90YWxUaW1lICYmIHR3ZWVuLl96VGltZSkpIHtcblx0XHRcdGlmICghdHdlZW4uX2luaXR0ZWQgJiYgX2F0dGVtcHRJbml0VHdlZW4odHdlZW4sIHRvdGFsVGltZSwgZm9yY2UsIHN1cHByZXNzRXZlbnRzKSkgeyAvLyBpZiB3ZSByZW5kZXIgdGhlIHZlcnkgYmVnaW5uaW5nICh0aW1lID09IDApIG9mIGEgZnJvbVRvKCksIHdlIG11c3QgZm9yY2UgdGhlIHJlbmRlciAobm9ybWFsIHR3ZWVucyB3b3VsZG4ndCBuZWVkIHRvIHJlbmRlciBhdCBhIHRpbWUgb2YgMCB3aGVuIHRoZSBwcmV2VGltZSB3YXMgYWxzbyAwKS4gVGhpcyBpcyBhbHNvIG1hbmRhdG9yeSB0byBtYWtlIHN1cmUgb3ZlcndyaXRpbmcga2lja3MgaW4gaW1tZWRpYXRlbHkuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHByZXZJdGVyYXRpb24gPSB0d2Vlbi5felRpbWU7XG5cdFx0XHR0d2Vlbi5felRpbWUgPSB0b3RhbFRpbWUgfHwgKHN1cHByZXNzRXZlbnRzID8gX3RpbnlOdW0gOiAwKTsgLy8gd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuXG5cdFx0XHRzdXBwcmVzc0V2ZW50cyB8fCAoc3VwcHJlc3NFdmVudHMgPSB0b3RhbFRpbWUgJiYgIXByZXZJdGVyYXRpb24pOyAvLyBpZiBpdCB3YXMgcmVuZGVyZWQgcHJldmlvdXNseSBhdCBleGFjdGx5IDAgKF96VGltZSkgYW5kIG5vdyB0aGUgcGxheWhlYWQgaXMgbW92aW5nIGF3YXksIERPTidUIGZpcmUgY2FsbGJhY2tzIG90aGVyd2lzZSB0aGV5J2xsIHNlZW0gbGlrZSBkdXBsaWNhdGVzLlxuXHRcdFx0dHdlZW4ucmF0aW8gPSByYXRpbztcblx0XHRcdHR3ZWVuLl9mcm9tICYmIChyYXRpbyA9IDEgLSByYXRpbyk7XG5cdFx0XHR0d2Vlbi5fdGltZSA9IDA7XG5cdFx0XHR0d2Vlbi5fdFRpbWUgPSB0VGltZTtcblx0XHRcdHB0ID0gdHdlZW4uX3B0O1xuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdHB0LnIocmF0aW8sIHB0LmQpO1xuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0dHdlZW4uX3N0YXJ0QXQgJiYgdG90YWxUaW1lIDwgMCAmJiB0d2Vlbi5fc3RhcnRBdC5yZW5kZXIodG90YWxUaW1lLCB0cnVlLCB0cnVlKTtcblx0XHRcdHR3ZWVuLl9vblVwZGF0ZSAmJiAhc3VwcHJlc3NFdmVudHMgJiYgX2NhbGxiYWNrKHR3ZWVuLCBcIm9uVXBkYXRlXCIpO1xuXHRcdFx0dFRpbWUgJiYgdHdlZW4uX3JlcGVhdCAmJiAhc3VwcHJlc3NFdmVudHMgJiYgdHdlZW4ucGFyZW50ICYmIF9jYWxsYmFjayh0d2VlbiwgXCJvblJlcGVhdFwiKTtcblx0XHRcdGlmICgodG90YWxUaW1lID49IHR3ZWVuLl90RHVyIHx8IHRvdGFsVGltZSA8IDApICYmIHR3ZWVuLnJhdGlvID09PSByYXRpbykge1xuXHRcdFx0XHRyYXRpbyAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0d2VlbiwgMSk7XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0XHRfY2FsbGJhY2sodHdlZW4sIChyYXRpbyA/IFwib25Db21wbGV0ZVwiIDogXCJvblJldmVyc2VDb21wbGV0ZVwiKSwgdHJ1ZSk7XG5cdFx0XHRcdFx0dHdlZW4uX3Byb20gJiYgdHdlZW4uX3Byb20oKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIXR3ZWVuLl96VGltZSkge1xuXHRcdFx0dHdlZW4uX3pUaW1lID0gdG90YWxUaW1lO1xuXHRcdH1cblx0fSxcblx0X2ZpbmROZXh0UGF1c2VUd2VlbiA9IChhbmltYXRpb24sIHByZXZUaW1lLCB0aW1lKSA9PiB7XG5cdFx0bGV0IGNoaWxkO1xuXHRcdGlmICh0aW1lID4gcHJldlRpbWUpIHtcblx0XHRcdGNoaWxkID0gYW5pbWF0aW9uLl9maXJzdDtcblx0XHRcdHdoaWxlIChjaGlsZCAmJiBjaGlsZC5fc3RhcnQgPD0gdGltZSkge1xuXHRcdFx0XHRpZiAoIWNoaWxkLl9kdXIgJiYgY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgY2hpbGQuX3N0YXJ0ID4gcHJldlRpbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hpbGQgPSBjaGlsZC5fbmV4dDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2hpbGQgPSBhbmltYXRpb24uX2xhc3Q7XG5cdFx0XHR3aGlsZSAoY2hpbGQgJiYgY2hpbGQuX3N0YXJ0ID49IHRpbWUpIHtcblx0XHRcdFx0aWYgKCFjaGlsZC5fZHVyICYmIGNoaWxkLmRhdGEgPT09IFwiaXNQYXVzZVwiICYmIGNoaWxkLl9zdGFydCA8IHByZXZUaW1lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNoaWxkID0gY2hpbGQuX3ByZXY7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRfc2V0RHVyYXRpb24gPSAoYW5pbWF0aW9uLCBkdXJhdGlvbiwgc2tpcFVuY2FjaGUsIGxlYXZlUGxheWhlYWQpID0+IHtcblx0XHRsZXQgcmVwZWF0ID0gYW5pbWF0aW9uLl9yZXBlYXQsXG5cdFx0XHRkdXIgPSBfcm91bmQoZHVyYXRpb24pIHx8IDAsXG5cdFx0XHR0b3RhbFByb2dyZXNzID0gYW5pbWF0aW9uLl90VGltZSAvIGFuaW1hdGlvbi5fdER1cjtcblx0XHR0b3RhbFByb2dyZXNzICYmICFsZWF2ZVBsYXloZWFkICYmIChhbmltYXRpb24uX3RpbWUgKj0gZHVyIC8gYW5pbWF0aW9uLl9kdXIpO1xuXHRcdGFuaW1hdGlvbi5fZHVyID0gZHVyO1xuXHRcdGFuaW1hdGlvbi5fdER1ciA9ICFyZXBlYXQgPyBkdXIgOiByZXBlYXQgPCAwID8gMWUxMCA6IF9yb3VuZChkdXIgKiAocmVwZWF0ICsgMSkgKyAoYW5pbWF0aW9uLl9yRGVsYXkgKiByZXBlYXQpKTtcblx0XHR0b3RhbFByb2dyZXNzICYmICFsZWF2ZVBsYXloZWFkID8gX2FsaWduUGxheWhlYWQoYW5pbWF0aW9uLCAoYW5pbWF0aW9uLl90VGltZSA9IGFuaW1hdGlvbi5fdER1ciAqIHRvdGFsUHJvZ3Jlc3MpKSA6IGFuaW1hdGlvbi5wYXJlbnQgJiYgX3NldEVuZChhbmltYXRpb24pO1xuXHRcdHNraXBVbmNhY2hlIHx8IF91bmNhY2hlKGFuaW1hdGlvbi5wYXJlbnQsIGFuaW1hdGlvbik7XG5cdFx0cmV0dXJuIGFuaW1hdGlvbjtcblx0fSxcblx0X29uVXBkYXRlVG90YWxEdXJhdGlvbiA9IGFuaW1hdGlvbiA9PiAoYW5pbWF0aW9uIGluc3RhbmNlb2YgVGltZWxpbmUpID8gX3VuY2FjaGUoYW5pbWF0aW9uKSA6IF9zZXREdXJhdGlvbihhbmltYXRpb24sIGFuaW1hdGlvbi5fZHVyKSxcblx0X3plcm9Qb3NpdGlvbiA9IHtfc3RhcnQ6MCwgZW5kVGltZTpfZW1wdHlGdW5jLCB0b3RhbER1cmF0aW9uOl9lbXB0eUZ1bmN9LFxuXHRfcGFyc2VQb3NpdGlvbiA9IChhbmltYXRpb24sIHBvc2l0aW9uLCBwZXJjZW50QW5pbWF0aW9uKSA9PiB7XG5cdFx0bGV0IGxhYmVscyA9IGFuaW1hdGlvbi5sYWJlbHMsXG5cdFx0XHRyZWNlbnQgPSBhbmltYXRpb24uX3JlY2VudCB8fCBfemVyb1Bvc2l0aW9uLFxuXHRcdFx0Y2xpcHBlZER1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uKCkgPj0gX2JpZ051bSA/IHJlY2VudC5lbmRUaW1lKGZhbHNlKSA6IGFuaW1hdGlvbi5fZHVyLCAvL2luIGNhc2UgdGhlcmUncyBhIGNoaWxkIHRoYXQgaW5maW5pdGVseSByZXBlYXRzLCB1c2VycyBhbG1vc3QgbmV2ZXIgaW50ZW5kIGZvciB0aGUgaW5zZXJ0aW9uIHBvaW50IG9mIGEgbmV3IGNoaWxkIHRvIGJlIGJhc2VkIG9uIGEgU1VQRVIgbG9uZyB2YWx1ZSBsaWtlIHRoYXQgc28gd2UgY2xpcCBpdCBhbmQgYXNzdW1lIHRoZSBtb3N0IHJlY2VudGx5LWFkZGVkIGNoaWxkJ3MgZW5kVGltZSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuXHRcdFx0aSwgb2Zmc2V0LCBpc1BlcmNlbnQ7XG5cdFx0aWYgKF9pc1N0cmluZyhwb3NpdGlvbikgJiYgKGlzTmFOKHBvc2l0aW9uKSB8fCAocG9zaXRpb24gaW4gbGFiZWxzKSkpIHsgLy9pZiB0aGUgc3RyaW5nIGlzIGEgbnVtYmVyIGxpa2UgXCIxXCIsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgbGFiZWwgd2l0aCB0aGF0IG5hbWUsIG90aGVyd2lzZSBpbnRlcnByZXQgaXQgYXMgYSBudW1iZXIgKGFic29sdXRlIHZhbHVlKS5cblx0XHRcdG9mZnNldCA9IHBvc2l0aW9uLmNoYXJBdCgwKTtcblx0XHRcdGlzUGVyY2VudCA9IHBvc2l0aW9uLnN1YnN0cigtMSkgPT09IFwiJVwiO1xuXHRcdFx0aSA9IHBvc2l0aW9uLmluZGV4T2YoXCI9XCIpO1xuXHRcdFx0aWYgKG9mZnNldCA9PT0gXCI8XCIgfHwgb2Zmc2V0ID09PSBcIj5cIikge1xuXHRcdFx0XHRpID49IDAgJiYgKHBvc2l0aW9uID0gcG9zaXRpb24ucmVwbGFjZSgvPS8sIFwiXCIpKTtcblx0XHRcdFx0cmV0dXJuIChvZmZzZXQgPT09IFwiPFwiID8gcmVjZW50Ll9zdGFydCA6IHJlY2VudC5lbmRUaW1lKHJlY2VudC5fcmVwZWF0ID49IDApKSArIChwYXJzZUZsb2F0KHBvc2l0aW9uLnN1YnN0cigxKSkgfHwgMCkgKiAoaXNQZXJjZW50ID8gKGkgPCAwID8gcmVjZW50IDogcGVyY2VudEFuaW1hdGlvbikudG90YWxEdXJhdGlvbigpIC8gMTAwIDogMSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaSA8IDApIHtcblx0XHRcdFx0KHBvc2l0aW9uIGluIGxhYmVscykgfHwgKGxhYmVsc1twb3NpdGlvbl0gPSBjbGlwcGVkRHVyYXRpb24pO1xuXHRcdFx0XHRyZXR1cm4gbGFiZWxzW3Bvc2l0aW9uXTtcblx0XHRcdH1cblx0XHRcdG9mZnNldCA9IHBhcnNlRmxvYXQocG9zaXRpb24uY2hhckF0KGktMSkgKyBwb3NpdGlvbi5zdWJzdHIoaSsxKSk7XG5cdFx0XHRpZiAoaXNQZXJjZW50ICYmIHBlcmNlbnRBbmltYXRpb24pIHtcblx0XHRcdFx0b2Zmc2V0ID0gb2Zmc2V0IC8gMTAwICogKF9pc0FycmF5KHBlcmNlbnRBbmltYXRpb24pID8gcGVyY2VudEFuaW1hdGlvblswXSA6IHBlcmNlbnRBbmltYXRpb24pLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAoaSA+IDEpID8gX3BhcnNlUG9zaXRpb24oYW5pbWF0aW9uLCBwb3NpdGlvbi5zdWJzdHIoMCwgaS0xKSwgcGVyY2VudEFuaW1hdGlvbikgKyBvZmZzZXQgOiBjbGlwcGVkRHVyYXRpb24gKyBvZmZzZXQ7XG5cdFx0fVxuXHRcdHJldHVybiAocG9zaXRpb24gPT0gbnVsbCkgPyBjbGlwcGVkRHVyYXRpb24gOiArcG9zaXRpb247XG5cdH0sXG5cdF9jcmVhdGVUd2VlblR5cGUgPSAodHlwZSwgcGFyYW1zLCB0aW1lbGluZSkgPT4ge1xuXHRcdGxldCBpc0xlZ2FjeSA9IF9pc051bWJlcihwYXJhbXNbMV0pLFxuXHRcdFx0dmFyc0luZGV4ID0gKGlzTGVnYWN5ID8gMiA6IDEpICsgKHR5cGUgPCAyID8gMCA6IDEpLFxuXHRcdFx0dmFycyA9IHBhcmFtc1t2YXJzSW5kZXhdLFxuXHRcdFx0aXJWYXJzLCBwYXJlbnQ7XG5cdFx0aXNMZWdhY3kgJiYgKHZhcnMuZHVyYXRpb24gPSBwYXJhbXNbMV0pO1xuXHRcdHZhcnMucGFyZW50ID0gdGltZWxpbmU7XG5cdFx0aWYgKHR5cGUpIHtcblx0XHRcdGlyVmFycyA9IHZhcnM7XG5cdFx0XHRwYXJlbnQgPSB0aW1lbGluZTtcblx0XHRcdHdoaWxlIChwYXJlbnQgJiYgIShcImltbWVkaWF0ZVJlbmRlclwiIGluIGlyVmFycykpIHsgLy8gaW5oZXJpdGFuY2UgaGFzbid0IGhhcHBlbmVkIHlldCwgYnV0IHNvbWVvbmUgbWF5IGhhdmUgc2V0IGEgZGVmYXVsdCBpbiBhbiBhbmNlc3RvciB0aW1lbGluZS4gV2UgY291bGQgZG8gdmFycy5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZShfaW5oZXJpdERlZmF1bHRzKHZhcnMpLmltbWVkaWF0ZVJlbmRlcikgYnV0IHRoYXQnZCBleGFjdCBhIHNsaWdodCBwZXJmb3JtYW5jZSBwZW5hbHR5IGJlY2F1c2UgX2luaGVyaXREZWZhdWx0cygpIGFsc28gcnVucyBpbiB0aGUgVHdlZW4gY29uc3RydWN0b3IuIFdlJ3JlIHBheWluZyBhIHNtYWxsIGtiIHByaWNlIGhlcmUgdG8gZ2FpbiBzcGVlZC5cblx0XHRcdFx0aXJWYXJzID0gcGFyZW50LnZhcnMuZGVmYXVsdHMgfHwge307XG5cdFx0XHRcdHBhcmVudCA9IF9pc05vdEZhbHNlKHBhcmVudC52YXJzLmluaGVyaXQpICYmIHBhcmVudC5wYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKGlyVmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuXHRcdFx0dHlwZSA8IDIgPyAodmFycy5ydW5CYWNrd2FyZHMgPSAxKSA6ICh2YXJzLnN0YXJ0QXQgPSBwYXJhbXNbdmFyc0luZGV4IC0gMV0pOyAvLyBcImZyb21cIiB2YXJzXG5cdFx0fVxuXHRcdHJldHVybiBuZXcgVHdlZW4ocGFyYW1zWzBdLCB2YXJzLCBwYXJhbXNbdmFyc0luZGV4ICsgMV0pO1xuXHR9LFxuXHRfY29uZGl0aW9uYWxSZXR1cm4gPSAodmFsdWUsIGZ1bmMpID0+IHZhbHVlIHx8IHZhbHVlID09PSAwID8gZnVuYyh2YWx1ZSkgOiBmdW5jLFxuXHRfY2xhbXAgPSAobWluLCBtYXgsIHZhbHVlKSA9PiB2YWx1ZSA8IG1pbiA/IG1pbiA6IHZhbHVlID4gbWF4ID8gbWF4IDogdmFsdWUsXG5cdGdldFVuaXQgPSB2YWx1ZSA9PiB7XG5cdFx0aWYgKHR5cGVvZih2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH1cblx0XHRsZXQgdiA9IF91bml0RXhwLmV4ZWModmFsdWUpO1xuXHRcdHJldHVybiB2ID8gdmFsdWUuc3Vic3RyKHYuaW5kZXggKyB2WzBdLmxlbmd0aCkgOiBcIlwiO1xuXHR9LCAvLyBub3RlOiBwcm90ZWN0IGFnYWluc3QgcGFkZGVkIG51bWJlcnMgYXMgc3RyaW5ncywgbGlrZSBcIjEwMC4xMDBcIi4gVGhhdCBzaG91bGRuJ3QgcmV0dXJuIFwiMDBcIiBhcyB0aGUgdW5pdC4gSWYgaXQncyBudW1lcmljLCByZXR1cm4gbm8gdW5pdC5cblx0Y2xhbXAgPSAobWluLCBtYXgsIHZhbHVlKSA9PiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIHYgPT4gX2NsYW1wKG1pbiwgbWF4LCB2KSksXG5cdF9zbGljZSA9IFtdLnNsaWNlLFxuXHRfaXNBcnJheUxpa2UgPSAodmFsdWUsIG5vbkVtcHR5KSA9PiB2YWx1ZSAmJiAoX2lzT2JqZWN0KHZhbHVlKSAmJiBcImxlbmd0aFwiIGluIHZhbHVlICYmICgoIW5vbkVtcHR5ICYmICF2YWx1ZS5sZW5ndGgpIHx8ICgodmFsdWUubGVuZ3RoIC0gMSkgaW4gdmFsdWUgJiYgX2lzT2JqZWN0KHZhbHVlWzBdKSkpICYmICF2YWx1ZS5ub2RlVHlwZSAmJiB2YWx1ZSAhPT0gX3dpbiksXG5cdF9mbGF0dGVuID0gKGFyLCBsZWF2ZVN0cmluZ3MsIGFjY3VtdWxhdG9yID0gW10pID0+IGFyLmZvckVhY2godmFsdWUgPT4gKF9pc1N0cmluZyh2YWx1ZSkgJiYgIWxlYXZlU3RyaW5ncykgfHwgX2lzQXJyYXlMaWtlKHZhbHVlLCAxKSA/IGFjY3VtdWxhdG9yLnB1c2goLi4udG9BcnJheSh2YWx1ZSkpIDogYWNjdW11bGF0b3IucHVzaCh2YWx1ZSkpIHx8IGFjY3VtdWxhdG9yLFxuXHQvL3Rha2VzIGFueSB2YWx1ZSBhbmQgcmV0dXJucyBhbiBhcnJheS4gSWYgaXQncyBhIHN0cmluZyAoYW5kIGxlYXZlU3RyaW5ncyBpc24ndCB0cnVlKSwgaXQnbGwgdXNlIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoKSBhbmQgY29udmVydCB0aGF0IHRvIGFuIGFycmF5LiBJdCdsbCBhbHNvIGFjY2VwdCBpdGVyYWJsZXMgbGlrZSBqUXVlcnkgb2JqZWN0cy5cblx0dG9BcnJheSA9ICh2YWx1ZSwgc2NvcGUsIGxlYXZlU3RyaW5ncykgPT4gX2lzU3RyaW5nKHZhbHVlKSAmJiAhbGVhdmVTdHJpbmdzICYmIChfY29yZUluaXR0ZWQgfHwgIV93YWtlKCkpID8gX3NsaWNlLmNhbGwoKHNjb3BlIHx8IF9kb2MpLnF1ZXJ5U2VsZWN0b3JBbGwodmFsdWUpLCAwKSA6IF9pc0FycmF5KHZhbHVlKSA/IF9mbGF0dGVuKHZhbHVlLCBsZWF2ZVN0cmluZ3MpIDogX2lzQXJyYXlMaWtlKHZhbHVlKSA/IF9zbGljZS5jYWxsKHZhbHVlLCAwKSA6IHZhbHVlID8gW3ZhbHVlXSA6IFtdLFxuXHRzZWxlY3RvciA9IHZhbHVlID0+IHtcblx0XHR2YWx1ZSA9IHRvQXJyYXkodmFsdWUpWzBdIHx8IF93YXJuKFwiSW52YWxpZCBzY29wZVwiKSB8fCB7fTtcblx0XHRyZXR1cm4gdiA9PiB7XG5cdFx0XHRsZXQgZWwgPSB2YWx1ZS5jdXJyZW50IHx8IHZhbHVlLm5hdGl2ZUVsZW1lbnQgfHwgdmFsdWU7XG5cdFx0XHRyZXR1cm4gdG9BcnJheSh2LCBlbC5xdWVyeVNlbGVjdG9yQWxsID8gZWwgOiBlbCA9PT0gdmFsdWUgPyBfd2FybihcIkludmFsaWQgc2NvcGVcIikgfHwgX2RvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpIDogdmFsdWUpO1xuXHRcdH07XG5cdH0sXG5cdHNodWZmbGUgPSBhID0+IGEuc29ydCgoKSA9PiAuNSAtIE1hdGgucmFuZG9tKCkpLCAvLyBhbHRlcm5hdGl2ZSB0aGF0J3MgYSBiaXQgZmFzdGVyIGFuZCBtb3JlIHJlbGlhYmx5IGRpdmVyc2UgYnV0IGJpZ2dlcjogICBmb3IgKGxldCBqLCB2LCBpID0gYS5sZW5ndGg7IGk7IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBpKSwgdiA9IGFbLS1pXSwgYVtpXSA9IGFbal0sIGFbal0gPSB2KTsgcmV0dXJuIGE7XG5cdC8vZm9yIGRpc3RyaWJ1dGluZyB2YWx1ZXMgYWNyb3NzIGFuIGFycmF5LiBDYW4gYWNjZXB0IGEgbnVtYmVyLCBhIGZ1bmN0aW9uIG9yIChtb3N0IGNvbW1vbmx5KSBhIGZ1bmN0aW9uIHdoaWNoIGNhbiBjb250YWluIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczoge2Jhc2UsIGFtb3VudCwgZnJvbSwgZWFzZSwgZ3JpZCwgYXhpcywgbGVuZ3RoLCBlYWNofS4gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZXhwZWN0cyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6IGluZGV4LCB0YXJnZXQsIGFycmF5LiBSZWNvZ25pemVzIHRoZSBmb2xsb3dpbmdcblx0ZGlzdHJpYnV0ZSA9IHYgPT4ge1xuXHRcdGlmIChfaXNGdW5jdGlvbih2KSkge1xuXHRcdFx0cmV0dXJuIHY7XG5cdFx0fVxuXHRcdGxldCB2YXJzID0gX2lzT2JqZWN0KHYpID8gdiA6IHtlYWNoOnZ9LCAvL246MSBpcyBqdXN0IHRvIGluZGljYXRlIHYgd2FzIGEgbnVtYmVyOyB3ZSBsZXZlcmFnZSB0aGF0IGxhdGVyIHRvIHNldCB2IGFjY29yZGluZyB0byB0aGUgbGVuZ3RoIHdlIGdldC4gSWYgYSBudW1iZXIgaXMgcGFzc2VkIGluLCB3ZSB0cmVhdCBpdCBsaWtlIHRoZSBvbGQgc3RhZ2dlciB2YWx1ZSB3aGVyZSAwLjEsIGZvciBleGFtcGxlLCB3b3VsZCBtZWFuIHRoYXQgdGhpbmdzIHdvdWxkIGJlIGRpc3RyaWJ1dGVkIHdpdGggMC4xIGJldHdlZW4gZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSByYXRoZXIgdGhhbiBhIHRvdGFsIFwiYW1vdW50XCIgdGhhdCdzIGNodW5rZWQgb3V0IGFtb25nIHRoZW0gYWxsLlxuXHRcdFx0ZWFzZSA9IF9wYXJzZUVhc2UodmFycy5lYXNlKSxcblx0XHRcdGZyb20gPSB2YXJzLmZyb20gfHwgMCxcblx0XHRcdGJhc2UgPSBwYXJzZUZsb2F0KHZhcnMuYmFzZSkgfHwgMCxcblx0XHRcdGNhY2hlID0ge30sXG5cdFx0XHRpc0RlY2ltYWwgPSAoZnJvbSA+IDAgJiYgZnJvbSA8IDEpLFxuXHRcdFx0cmF0aW9zID0gaXNOYU4oZnJvbSkgfHwgaXNEZWNpbWFsLFxuXHRcdFx0YXhpcyA9IHZhcnMuYXhpcyxcblx0XHRcdHJhdGlvWCA9IGZyb20sXG5cdFx0XHRyYXRpb1kgPSBmcm9tO1xuXHRcdGlmIChfaXNTdHJpbmcoZnJvbSkpIHtcblx0XHRcdHJhdGlvWCA9IHJhdGlvWSA9IHtjZW50ZXI6LjUsIGVkZ2VzOi41LCBlbmQ6MX1bZnJvbV0gfHwgMDtcblx0XHR9IGVsc2UgaWYgKCFpc0RlY2ltYWwgJiYgcmF0aW9zKSB7XG5cdFx0XHRyYXRpb1ggPSBmcm9tWzBdO1xuXHRcdFx0cmF0aW9ZID0gZnJvbVsxXTtcblx0XHR9XG5cdFx0cmV0dXJuIChpLCB0YXJnZXQsIGEpID0+IHtcblx0XHRcdGxldCBsID0gKGEgfHwgdmFycykubGVuZ3RoLFxuXHRcdFx0XHRkaXN0YW5jZXMgPSBjYWNoZVtsXSxcblx0XHRcdFx0b3JpZ2luWCwgb3JpZ2luWSwgeCwgeSwgZCwgaiwgbWF4LCBtaW4sIHdyYXBBdDtcblx0XHRcdGlmICghZGlzdGFuY2VzKSB7XG5cdFx0XHRcdHdyYXBBdCA9ICh2YXJzLmdyaWQgPT09IFwiYXV0b1wiKSA/IDAgOiAodmFycy5ncmlkIHx8IFsxLCBfYmlnTnVtXSlbMV07XG5cdFx0XHRcdGlmICghd3JhcEF0KSB7XG5cdFx0XHRcdFx0bWF4ID0gLV9iaWdOdW07XG5cdFx0XHRcdFx0d2hpbGUgKG1heCA8IChtYXggPSBhW3dyYXBBdCsrXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KSAmJiB3cmFwQXQgPCBsKSB7IH1cblx0XHRcdFx0XHR3cmFwQXQtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkaXN0YW5jZXMgPSBjYWNoZVtsXSA9IFtdO1xuXHRcdFx0XHRvcmlnaW5YID0gcmF0aW9zID8gKE1hdGgubWluKHdyYXBBdCwgbCkgKiByYXRpb1gpIC0gLjUgOiBmcm9tICUgd3JhcEF0O1xuXHRcdFx0XHRvcmlnaW5ZID0gcmF0aW9zID8gbCAqIHJhdGlvWSAvIHdyYXBBdCAtIC41IDogKGZyb20gLyB3cmFwQXQpIHwgMDtcblx0XHRcdFx0bWF4ID0gMDtcblx0XHRcdFx0bWluID0gX2JpZ051bTtcblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuXHRcdFx0XHRcdHggPSAoaiAlIHdyYXBBdCkgLSBvcmlnaW5YO1xuXHRcdFx0XHRcdHkgPSBvcmlnaW5ZIC0gKChqIC8gd3JhcEF0KSB8IDApO1xuXHRcdFx0XHRcdGRpc3RhbmNlc1tqXSA9IGQgPSAhYXhpcyA/IF9zcXJ0KHggKiB4ICsgeSAqIHkpIDogTWF0aC5hYnMoKGF4aXMgPT09IFwieVwiKSA/IHkgOiB4KTtcblx0XHRcdFx0XHQoZCA+IG1heCkgJiYgKG1heCA9IGQpO1xuXHRcdFx0XHRcdChkIDwgbWluKSAmJiAobWluID0gZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0KGZyb20gPT09IFwicmFuZG9tXCIpICYmIHNodWZmbGUoZGlzdGFuY2VzKTtcblx0XHRcdFx0ZGlzdGFuY2VzLm1heCA9IG1heCAtIG1pbjtcblx0XHRcdFx0ZGlzdGFuY2VzLm1pbiA9IG1pbjtcblx0XHRcdFx0ZGlzdGFuY2VzLnYgPSBsID0gKHBhcnNlRmxvYXQodmFycy5hbW91bnQpIHx8IChwYXJzZUZsb2F0KHZhcnMuZWFjaCkgKiAod3JhcEF0ID4gbCA/IGwgLSAxIDogIWF4aXMgPyBNYXRoLm1heCh3cmFwQXQsIGwgLyB3cmFwQXQpIDogYXhpcyA9PT0gXCJ5XCIgPyBsIC8gd3JhcEF0IDogd3JhcEF0KSkgfHwgMCkgKiAoZnJvbSA9PT0gXCJlZGdlc1wiID8gLTEgOiAxKTtcblx0XHRcdFx0ZGlzdGFuY2VzLmIgPSAobCA8IDApID8gYmFzZSAtIGwgOiBiYXNlO1xuXHRcdFx0XHRkaXN0YW5jZXMudSA9IGdldFVuaXQodmFycy5hbW91bnQgfHwgdmFycy5lYWNoKSB8fCAwOyAvL3VuaXRcblx0XHRcdFx0ZWFzZSA9IChlYXNlICYmIGwgPCAwKSA/IF9pbnZlcnRFYXNlKGVhc2UpIDogZWFzZTtcblx0XHRcdH1cblx0XHRcdGwgPSAoKGRpc3RhbmNlc1tpXSAtIGRpc3RhbmNlcy5taW4pIC8gZGlzdGFuY2VzLm1heCkgfHwgMDtcblx0XHRcdHJldHVybiBfcm91bmQoZGlzdGFuY2VzLmIgKyAoZWFzZSA/IGVhc2UobCkgOiBsKSAqIGRpc3RhbmNlcy52KSArIGRpc3RhbmNlcy51OyAvL3JvdW5kIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kIGZsb2F0aW5nIHBvaW50IGVycm9yc1xuXHRcdH07XG5cdH0sXG5cdF9yb3VuZE1vZGlmaWVyID0gdiA9PiB7IC8vcGFzcyBpbiAwLjEgZ2V0IGEgZnVuY3Rpb24gdGhhdCdsbCByb3VuZCB0byB0aGUgbmVhcmVzdCB0ZW50aCwgb3IgNSB0byByb3VuZCB0byB0aGUgY2xvc2VzdCA1LCBvciAwLjAwMSB0byB0aGUgY2xvc2VzdCAxMDAwdGgsIGV0Yy5cblx0XHRsZXQgcCA9IHYgPCAxID8gTWF0aC5wb3coMTAsICh2ICsgXCJcIikubGVuZ3RoIC0gMikgOiAxOyAvL3RvIGF2b2lkIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChsaWtlIDI0ICogMC4xID09IDIuNDAwMDAwMDAwMDAwMDAwNCksIHdlIGNob3Agb2ZmIGF0IGEgc3BlY2lmaWMgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIChtdWNoIGZhc3RlciB0aGFuIHRvRml4ZWQoKVxuXHRcdHJldHVybiByYXcgPT4ge1xuXHRcdFx0bGV0IG4gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQocmF3KSAvIHYpICogdiAqIHA7XG5cdFx0XHRyZXR1cm4gKG4gLSBuICUgMSkgLyBwICsgKF9pc051bWJlcihyYXcpID8gMCA6IGdldFVuaXQocmF3KSk7IC8vIG4gLSBuICUgMSByZXBsYWNlcyBNYXRoLmZsb29yKCkgaW4gb3JkZXIgdG8gaGFuZGxlIG5lZ2F0aXZlIHZhbHVlcyBwcm9wZXJseS4gRm9yIGV4YW1wbGUsIE1hdGguZmxvb3IoLTE1MC4wMDAwMDAwMDAwMDAwMykgaXMgMTUxIVxuXHRcdH07XG5cdH0sXG5cdHNuYXAgPSAoc25hcFRvLCB2YWx1ZSkgPT4ge1xuXHRcdGxldCBpc0FycmF5ID0gX2lzQXJyYXkoc25hcFRvKSxcblx0XHRcdHJhZGl1cywgaXMyRDtcblx0XHRpZiAoIWlzQXJyYXkgJiYgX2lzT2JqZWN0KHNuYXBUbykpIHtcblx0XHRcdHJhZGl1cyA9IGlzQXJyYXkgPSBzbmFwVG8ucmFkaXVzIHx8IF9iaWdOdW07XG5cdFx0XHRpZiAoc25hcFRvLnZhbHVlcykge1xuXHRcdFx0XHRzbmFwVG8gPSB0b0FycmF5KHNuYXBUby52YWx1ZXMpO1xuXHRcdFx0XHRpZiAoKGlzMkQgPSAhX2lzTnVtYmVyKHNuYXBUb1swXSkpKSB7XG5cdFx0XHRcdFx0cmFkaXVzICo9IHJhZGl1czsgLy9wZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gc28gd2UgZG9uJ3QgaGF2ZSB0byBNYXRoLnNxcnQoKSBpbiB0aGUgbG9vcC5cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c25hcFRvID0gX3JvdW5kTW9kaWZpZXIoc25hcFRvLmluY3JlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsICFpc0FycmF5ID8gX3JvdW5kTW9kaWZpZXIoc25hcFRvKSA6IF9pc0Z1bmN0aW9uKHNuYXBUbykgPyByYXcgPT4ge2lzMkQgPSBzbmFwVG8ocmF3KTsgcmV0dXJuIE1hdGguYWJzKGlzMkQgLSByYXcpIDw9IHJhZGl1cyA/IGlzMkQgOiByYXc7IH0gOiByYXcgPT4ge1xuXHRcdFx0bGV0IHggPSBwYXJzZUZsb2F0KGlzMkQgPyByYXcueCA6IHJhdyksXG5cdFx0XHRcdHkgPSBwYXJzZUZsb2F0KGlzMkQgPyByYXcueSA6IDApLFxuXHRcdFx0XHRtaW4gPSBfYmlnTnVtLFxuXHRcdFx0XHRjbG9zZXN0ID0gMCxcblx0XHRcdFx0aSA9IHNuYXBUby5sZW5ndGgsXG5cdFx0XHRcdGR4LCBkeTtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0aWYgKGlzMkQpIHtcblx0XHRcdFx0XHRkeCA9IHNuYXBUb1tpXS54IC0geDtcblx0XHRcdFx0XHRkeSA9IHNuYXBUb1tpXS55IC0geTtcblx0XHRcdFx0XHRkeCA9IGR4ICogZHggKyBkeSAqIGR5O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGR4ID0gTWF0aC5hYnMoc25hcFRvW2ldIC0geCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGR4IDwgbWluKSB7XG5cdFx0XHRcdFx0bWluID0gZHg7XG5cdFx0XHRcdFx0Y2xvc2VzdCA9IGk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNsb3Nlc3QgPSAoIXJhZGl1cyB8fCBtaW4gPD0gcmFkaXVzKSA/IHNuYXBUb1tjbG9zZXN0XSA6IHJhdztcblx0XHRcdHJldHVybiAoaXMyRCB8fCBjbG9zZXN0ID09PSByYXcgfHwgX2lzTnVtYmVyKHJhdykpID8gY2xvc2VzdCA6IGNsb3Nlc3QgKyBnZXRVbml0KHJhdyk7XG5cdFx0fSk7XG5cdH0sXG5cdHJhbmRvbSA9IChtaW4sIG1heCwgcm91bmRpbmdJbmNyZW1lbnQsIHJldHVybkZ1bmN0aW9uKSA9PiBfY29uZGl0aW9uYWxSZXR1cm4oX2lzQXJyYXkobWluKSA/ICFtYXggOiByb3VuZGluZ0luY3JlbWVudCA9PT0gdHJ1ZSA/ICEhKHJvdW5kaW5nSW5jcmVtZW50ID0gMCkgOiAhcmV0dXJuRnVuY3Rpb24sICgpID0+IF9pc0FycmF5KG1pbikgPyBtaW5bfn4oTWF0aC5yYW5kb20oKSAqIG1pbi5sZW5ndGgpXSA6IChyb3VuZGluZ0luY3JlbWVudCA9IHJvdW5kaW5nSW5jcmVtZW50IHx8IDFlLTUpICYmIChyZXR1cm5GdW5jdGlvbiA9IHJvdW5kaW5nSW5jcmVtZW50IDwgMSA/IDEwICoqICgocm91bmRpbmdJbmNyZW1lbnQgKyBcIlwiKS5sZW5ndGggLSAyKSA6IDEpICYmIChNYXRoLmZsb29yKE1hdGgucm91bmQoKG1pbiAtIHJvdW5kaW5nSW5jcmVtZW50IC8gMiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgcm91bmRpbmdJbmNyZW1lbnQgKiAuOTkpKSAvIHJvdW5kaW5nSW5jcmVtZW50KSAqIHJvdW5kaW5nSW5jcmVtZW50ICogcmV0dXJuRnVuY3Rpb24pIC8gcmV0dXJuRnVuY3Rpb24pKSxcblx0cGlwZSA9ICguLi5mdW5jdGlvbnMpID0+IHZhbHVlID0+IGZ1bmN0aW9ucy5yZWR1Y2UoKHYsIGYpID0+IGYodiksIHZhbHVlKSxcblx0dW5pdGl6ZSA9IChmdW5jLCB1bml0KSA9PiB2YWx1ZSA9PiBmdW5jKHBhcnNlRmxvYXQodmFsdWUpKSArICh1bml0IHx8IGdldFVuaXQodmFsdWUpKSxcblx0bm9ybWFsaXplID0gKG1pbiwgbWF4LCB2YWx1ZSkgPT4gbWFwUmFuZ2UobWluLCBtYXgsIDAsIDEsIHZhbHVlKSxcblx0X3dyYXBBcnJheSA9IChhLCB3cmFwcGVyLCB2YWx1ZSkgPT4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBpbmRleCA9PiBhW35+d3JhcHBlcihpbmRleCldKSxcblx0d3JhcCA9IGZ1bmN0aW9uKG1pbiwgbWF4LCB2YWx1ZSkgeyAvLyBOT1RFOiB3cmFwKCkgQ0FOTk9UIGJlIGFuIGFycm93IGZ1bmN0aW9uISBBIHZlcnkgb2RkIGNvbXBpbGluZyBidWcgY2F1c2VzIHByb2JsZW1zICh1bnJlbGF0ZWQgdG8gR1NBUCkuXG5cdFx0bGV0IHJhbmdlID0gbWF4IC0gbWluO1xuXHRcdHJldHVybiBfaXNBcnJheShtaW4pID8gX3dyYXBBcnJheShtaW4sIHdyYXAoMCwgbWluLmxlbmd0aCksIG1heCkgOiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIHZhbHVlID0+ICgocmFuZ2UgKyAodmFsdWUgLSBtaW4pICUgcmFuZ2UpICUgcmFuZ2UpICsgbWluKTtcblx0fSxcblx0d3JhcFlveW8gPSAobWluLCBtYXgsIHZhbHVlKSA9PiB7XG5cdFx0bGV0IHJhbmdlID0gbWF4IC0gbWluLFxuXHRcdFx0dG90YWwgPSByYW5nZSAqIDI7XG5cdFx0cmV0dXJuIF9pc0FycmF5KG1pbikgPyBfd3JhcEFycmF5KG1pbiwgd3JhcFlveW8oMCwgbWluLmxlbmd0aCAtIDEpLCBtYXgpIDogX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCB2YWx1ZSA9PiB7XG5cdFx0XHR2YWx1ZSA9ICh0b3RhbCArICh2YWx1ZSAtIG1pbikgJSB0b3RhbCkgJSB0b3RhbCB8fCAwO1xuXHRcdFx0cmV0dXJuIG1pbiArICgodmFsdWUgPiByYW5nZSkgPyAodG90YWwgLSB2YWx1ZSkgOiB2YWx1ZSk7XG5cdFx0fSk7XG5cdH0sXG5cdF9yZXBsYWNlUmFuZG9tID0gdmFsdWUgPT4geyAvL3JlcGxhY2VzIGFsbCBvY2N1cnJlbmNlcyBvZiByYW5kb20oLi4uKSBpbiBhIHN0cmluZyB3aXRoIHRoZSBjYWxjdWxhdGVkIHJhbmRvbSB2YWx1ZS4gY2FuIGJlIGEgcmFuZ2UgbGlrZSByYW5kb20oLTEwMCwgMTAwLCA1KSBvciBhbiBhcnJheSBsaWtlIHJhbmRvbShbMCwgMTAwLCA1MDBdKVxuXHRcdGxldCBwcmV2ID0gMCxcblx0XHRcdHMgPSBcIlwiLFxuXHRcdFx0aSwgbnVtcywgZW5kLCBpc0FycmF5O1xuXHRcdHdoaWxlICh+KGkgPSB2YWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiLCBwcmV2KSkpIHtcblx0XHRcdGVuZCA9IHZhbHVlLmluZGV4T2YoXCIpXCIsIGkpO1xuXHRcdFx0aXNBcnJheSA9IHZhbHVlLmNoYXJBdChpICsgNykgPT09IFwiW1wiO1xuXHRcdFx0bnVtcyA9IHZhbHVlLnN1YnN0cihpICsgNywgZW5kIC0gaSAtIDcpLm1hdGNoKGlzQXJyYXkgPyBfZGVsaW1pdGVkVmFsdWVFeHAgOiBfc3RyaWN0TnVtRXhwKTtcblx0XHRcdHMgKz0gdmFsdWUuc3Vic3RyKHByZXYsIGkgLSBwcmV2KSArIHJhbmRvbShpc0FycmF5ID8gbnVtcyA6ICtudW1zWzBdLCBpc0FycmF5ID8gMCA6ICtudW1zWzFdLCArbnVtc1syXSB8fCAxZS01KTtcblx0XHRcdHByZXYgPSBlbmQgKyAxO1xuXHRcdH1cblx0XHRyZXR1cm4gcyArIHZhbHVlLnN1YnN0cihwcmV2LCB2YWx1ZS5sZW5ndGggLSBwcmV2KTtcblx0fSxcblx0bWFwUmFuZ2UgPSAoaW5NaW4sIGluTWF4LCBvdXRNaW4sIG91dE1heCwgdmFsdWUpID0+IHtcblx0XHRsZXQgaW5SYW5nZSA9IGluTWF4IC0gaW5NaW4sXG5cdFx0XHRvdXRSYW5nZSA9IG91dE1heCAtIG91dE1pbjtcblx0XHRyZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCB2YWx1ZSA9PiBvdXRNaW4gKyAoKCgodmFsdWUgLSBpbk1pbikgLyBpblJhbmdlKSAqIG91dFJhbmdlKSB8fCAwKSk7XG5cdH0sXG5cdGludGVycG9sYXRlID0gKHN0YXJ0LCBlbmQsIHByb2dyZXNzLCBtdXRhdGUpID0+IHtcblx0XHRsZXQgZnVuYyA9IGlzTmFOKHN0YXJ0ICsgZW5kKSA/IDAgOiBwID0+ICgxIC0gcCkgKiBzdGFydCArIHAgKiBlbmQ7XG5cdFx0aWYgKCFmdW5jKSB7XG5cdFx0XHRsZXQgaXNTdHJpbmcgPSBfaXNTdHJpbmcoc3RhcnQpLFxuXHRcdFx0XHRtYXN0ZXIgPSB7fSxcblx0XHRcdFx0cCwgaSwgaW50ZXJwb2xhdG9ycywgbCwgaWw7XG5cdFx0XHRwcm9ncmVzcyA9PT0gdHJ1ZSAmJiAobXV0YXRlID0gMSkgJiYgKHByb2dyZXNzID0gbnVsbCk7XG5cdFx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdFx0c3RhcnQgPSB7cDogc3RhcnR9O1xuXHRcdFx0XHRlbmQgPSB7cDogZW5kfTtcblxuXHRcdFx0fSBlbHNlIGlmIChfaXNBcnJheShzdGFydCkgJiYgIV9pc0FycmF5KGVuZCkpIHtcblx0XHRcdFx0aW50ZXJwb2xhdG9ycyA9IFtdO1xuXHRcdFx0XHRsID0gc3RhcnQubGVuZ3RoO1xuXHRcdFx0XHRpbCA9IGwgLSAyO1xuXHRcdFx0XHRmb3IgKGkgPSAxOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0aW50ZXJwb2xhdG9ycy5wdXNoKGludGVycG9sYXRlKHN0YXJ0W2ktMV0sIHN0YXJ0W2ldKSk7IC8vYnVpbGQgdGhlIGludGVycG9sYXRvcnMgdXAgZnJvbnQgYXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gc28gdGhhdCB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgbWFueSB0aW1lcywgaXQgY2FuIGp1c3QgcmV1c2UgdGhlbS5cblx0XHRcdFx0fVxuXHRcdFx0XHRsLS07XG5cdFx0XHRcdGZ1bmMgPSBwID0+IHtcblx0XHRcdFx0XHRwICo9IGw7XG5cdFx0XHRcdFx0bGV0IGkgPSBNYXRoLm1pbihpbCwgfn5wKTtcblx0XHRcdFx0XHRyZXR1cm4gaW50ZXJwb2xhdG9yc1tpXShwIC0gaSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHByb2dyZXNzID0gZW5kO1xuXHRcdFx0fSBlbHNlIGlmICghbXV0YXRlKSB7XG5cdFx0XHRcdHN0YXJ0ID0gX21lcmdlKF9pc0FycmF5KHN0YXJ0KSA/IFtdIDoge30sIHN0YXJ0KTtcblx0XHRcdH1cblx0XHRcdGlmICghaW50ZXJwb2xhdG9ycykge1xuXHRcdFx0XHRmb3IgKHAgaW4gZW5kKSB7XG5cdFx0XHRcdFx0X2FkZFByb3BUd2Vlbi5jYWxsKG1hc3Rlciwgc3RhcnQsIHAsIFwiZ2V0XCIsIGVuZFtwXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnVuYyA9IHAgPT4gX3JlbmRlclByb3BUd2VlbnMocCwgbWFzdGVyKSB8fCAoaXNTdHJpbmcgPyBzdGFydC5wIDogc3RhcnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHByb2dyZXNzLCBmdW5jKTtcblx0fSxcblx0X2dldExhYmVsSW5EaXJlY3Rpb24gPSAodGltZWxpbmUsIGZyb21UaW1lLCBiYWNrd2FyZCkgPT4geyAvL3VzZWQgZm9yIG5leHRMYWJlbCgpIGFuZCBwcmV2aW91c0xhYmVsKClcblx0XHRsZXQgbGFiZWxzID0gdGltZWxpbmUubGFiZWxzLFxuXHRcdFx0bWluID0gX2JpZ051bSxcblx0XHRcdHAsIGRpc3RhbmNlLCBsYWJlbDtcblx0XHRmb3IgKHAgaW4gbGFiZWxzKSB7XG5cdFx0XHRkaXN0YW5jZSA9IGxhYmVsc1twXSAtIGZyb21UaW1lO1xuXHRcdFx0aWYgKChkaXN0YW5jZSA8IDApID09PSAhIWJhY2t3YXJkICYmIGRpc3RhbmNlICYmIG1pbiA+IChkaXN0YW5jZSA9IE1hdGguYWJzKGRpc3RhbmNlKSkpIHtcblx0XHRcdFx0bGFiZWwgPSBwO1xuXHRcdFx0XHRtaW4gPSBkaXN0YW5jZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGxhYmVsO1xuXHR9LFxuXHRfY2FsbGJhY2sgPSAoYW5pbWF0aW9uLCB0eXBlLCBleGVjdXRlTGF6eUZpcnN0KSA9PiB7XG5cdFx0bGV0IHYgPSBhbmltYXRpb24udmFycyxcblx0XHRcdGNhbGxiYWNrID0gdlt0eXBlXSxcblx0XHRcdHBhcmFtcywgc2NvcGU7XG5cdFx0aWYgKCFjYWxsYmFjaykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRwYXJhbXMgPSB2W3R5cGUgKyBcIlBhcmFtc1wiXTtcblx0XHRzY29wZSA9IHYuY2FsbGJhY2tTY29wZSB8fCBhbmltYXRpb247XG5cdFx0ZXhlY3V0ZUxhenlGaXJzdCAmJiBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvblVwZGF0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cdFx0cmV0dXJuIHBhcmFtcyA/IGNhbGxiYWNrLmFwcGx5KHNjb3BlLCBwYXJhbXMpIDogY2FsbGJhY2suY2FsbChzY29wZSk7XG5cdH0sXG5cdF9pbnRlcnJ1cHQgPSBhbmltYXRpb24gPT4ge1xuXHRcdF9yZW1vdmVGcm9tUGFyZW50KGFuaW1hdGlvbik7XG5cdFx0YW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIgJiYgYW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIua2lsbChmYWxzZSk7XG5cdFx0YW5pbWF0aW9uLnByb2dyZXNzKCkgPCAxICYmIF9jYWxsYmFjayhhbmltYXRpb24sIFwib25JbnRlcnJ1cHRcIik7XG5cdFx0cmV0dXJuIGFuaW1hdGlvbjtcblx0fSxcblx0X3F1aWNrVHdlZW4sXG5cdF9jcmVhdGVQbHVnaW4gPSBjb25maWcgPT4ge1xuXHRcdGNvbmZpZyA9ICFjb25maWcubmFtZSAmJiBjb25maWcuZGVmYXVsdCB8fCBjb25maWc7IC8vVU1EIHBhY2thZ2luZyB3cmFwcyB0aGluZ3Mgb2RkbHksIHNvIGZvciBleGFtcGxlIE1vdGlvblBhdGhIZWxwZXIgYmVjb21lcyB7TW90aW9uUGF0aEhlbHBlcjpNb3Rpb25QYXRoSGVscGVyLCBkZWZhdWx0Ok1vdGlvblBhdGhIZWxwZXJ9LlxuXHRcdGxldCBuYW1lID0gY29uZmlnLm5hbWUsXG5cdFx0XHRpc0Z1bmMgPSBfaXNGdW5jdGlvbihjb25maWcpLFxuXHRcdFx0UGx1Z2luID0gKG5hbWUgJiYgIWlzRnVuYyAmJiBjb25maWcuaW5pdCkgPyBmdW5jdGlvbigpIHsgdGhpcy5fcHJvcHMgPSBbXTsgfSA6IGNvbmZpZywgLy9pbiBjYXNlIHNvbWVvbmUgcGFzc2VzIGluIGFuIG9iamVjdCB0aGF0J3Mgbm90IGEgcGx1Z2luLCBsaWtlIEN1c3RvbUVhc2Vcblx0XHRcdGluc3RhbmNlRGVmYXVsdHMgPSB7aW5pdDpfZW1wdHlGdW5jLCByZW5kZXI6X3JlbmRlclByb3BUd2VlbnMsIGFkZDpfYWRkUHJvcFR3ZWVuLCBraWxsOl9raWxsUHJvcFR3ZWVuc09mLCBtb2RpZmllcjpfYWRkUGx1Z2luTW9kaWZpZXIsIHJhd1ZhcnM6MH0sXG5cdFx0XHRzdGF0aWNzID0ge3RhcmdldFRlc3Q6MCwgZ2V0OjAsIGdldFNldHRlcjpfZ2V0U2V0dGVyLCBhbGlhc2VzOnt9LCByZWdpc3RlcjowfTtcblx0XHRfd2FrZSgpO1xuXHRcdGlmIChjb25maWcgIT09IFBsdWdpbikge1xuXHRcdFx0aWYgKF9wbHVnaW5zW25hbWVdKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdF9zZXREZWZhdWx0cyhQbHVnaW4sIF9zZXREZWZhdWx0cyhfY29weUV4Y2x1ZGluZyhjb25maWcsIGluc3RhbmNlRGVmYXVsdHMpLCBzdGF0aWNzKSk7IC8vc3RhdGljIG1ldGhvZHNcblx0XHRcdF9tZXJnZShQbHVnaW4ucHJvdG90eXBlLCBfbWVyZ2UoaW5zdGFuY2VEZWZhdWx0cywgX2NvcHlFeGNsdWRpbmcoY29uZmlnLCBzdGF0aWNzKSkpOyAvL2luc3RhbmNlIG1ldGhvZHNcblx0XHRcdF9wbHVnaW5zWyhQbHVnaW4ucHJvcCA9IG5hbWUpXSA9IFBsdWdpbjtcblx0XHRcdGlmIChjb25maWcudGFyZ2V0VGVzdCkge1xuXHRcdFx0XHRfaGFybmVzc1BsdWdpbnMucHVzaChQbHVnaW4pO1xuXHRcdFx0XHRfcmVzZXJ2ZWRQcm9wc1tuYW1lXSA9IDE7XG5cdFx0XHR9XG5cdFx0XHRuYW1lID0gKG5hbWUgPT09IFwiY3NzXCIgPyBcIkNTU1wiIDogbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpKSArIFwiUGx1Z2luXCI7IC8vZm9yIHRoZSBnbG9iYWwgbmFtZS4gXCJtb3Rpb25QYXRoXCIgc2hvdWxkIGJlY29tZSBNb3Rpb25QYXRoUGx1Z2luXG5cdFx0fVxuXHRcdF9hZGRHbG9iYWwobmFtZSwgUGx1Z2luKTtcblx0XHRjb25maWcucmVnaXN0ZXIgJiYgY29uZmlnLnJlZ2lzdGVyKGdzYXAsIFBsdWdpbiwgUHJvcFR3ZWVuKTtcblx0fSxcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDT0xPUlNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXHRfMjU1ID0gMjU1LFxuXHRfY29sb3JMb29rdXAgPSB7XG5cdFx0YXF1YTpbMCxfMjU1LF8yNTVdLFxuXHRcdGxpbWU6WzAsXzI1NSwwXSxcblx0XHRzaWx2ZXI6WzE5MiwxOTIsMTkyXSxcblx0XHRibGFjazpbMCwwLDBdLFxuXHRcdG1hcm9vbjpbMTI4LDAsMF0sXG5cdFx0dGVhbDpbMCwxMjgsMTI4XSxcblx0XHRibHVlOlswLDAsXzI1NV0sXG5cdFx0bmF2eTpbMCwwLDEyOF0sXG5cdFx0d2hpdGU6W18yNTUsXzI1NSxfMjU1XSxcblx0XHRvbGl2ZTpbMTI4LDEyOCwwXSxcblx0XHR5ZWxsb3c6W18yNTUsXzI1NSwwXSxcblx0XHRvcmFuZ2U6W18yNTUsMTY1LDBdLFxuXHRcdGdyYXk6WzEyOCwxMjgsMTI4XSxcblx0XHRwdXJwbGU6WzEyOCwwLDEyOF0sXG5cdFx0Z3JlZW46WzAsMTI4LDBdLFxuXHRcdHJlZDpbXzI1NSwwLDBdLFxuXHRcdHBpbms6W18yNTUsMTkyLDIwM10sXG5cdFx0Y3lhbjpbMCxfMjU1LF8yNTVdLFxuXHRcdHRyYW5zcGFyZW50OltfMjU1LF8yNTUsXzI1NSwwXVxuXHR9LFxuXHRfaHVlID0gKGgsIG0xLCBtMikgPT4ge1xuXHRcdGggPSAoaCA8IDApID8gaCArIDEgOiAoaCA+IDEpID8gaCAtIDEgOiBoO1xuXHRcdHJldHVybiAoKCgoaCAqIDYgPCAxKSA/IG0xICsgKG0yIC0gbTEpICogaCAqIDYgOiAoaCA8IC41KSA/IG0yIDogKGggKiAzIDwgMikgPyBtMSArIChtMiAtIG0xKSAqICgyIC8gMyAtIGgpICogNiA6IG0xKSAqIF8yNTUpICsgLjUpIHwgMDtcblx0fSxcblx0c3BsaXRDb2xvciA9ICh2LCB0b0hTTCwgZm9yY2VBbHBoYSkgPT4ge1xuXHRcdGxldCBhID0gIXYgPyBfY29sb3JMb29rdXAuYmxhY2sgOiBfaXNOdW1iZXIodikgPyBbdiA+PiAxNiwgKHYgPj4gOCkgJiBfMjU1LCB2ICYgXzI1NV0gOiAwLFxuXHRcdFx0ciwgZywgYiwgaCwgcywgbCwgbWF4LCBtaW4sIGQsIHdhc0hTTDtcblx0XHRpZiAoIWEpIHtcblx0XHRcdGlmICh2LnN1YnN0cigtMSkgPT09IFwiLFwiKSB7IC8vc29tZXRpbWVzIGEgdHJhaWxpbmcgY29tbWEgaXMgaW5jbHVkZWQgYW5kIHdlIHNob3VsZCBjaG9wIGl0IG9mZiAodHlwaWNhbGx5IGZyb20gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiB2YWx1ZXMgbGlrZSBhIHRleHRTaGFkb3c6XCIycHggMnB4IDJweCBibHVlLCA1cHggNXB4IDVweCByZ2IoMjU1LDAsMClcIiAtIGluIHRoaXMgZXhhbXBsZSBcImJsdWUsXCIgaGFzIGEgdHJhaWxpbmcgY29tbWEuIFdlIGNvdWxkIHN0cmlwIGl0IG91dCBpbnNpZGUgcGFyc2VDb21wbGV4KCkgYnV0IHdlJ2QgbmVlZCB0byBkbyBpdCB0byB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIHBsdXMgaXQgd291bGRuJ3QgcHJvdmlkZSBwcm90ZWN0aW9uIGZyb20gb3RoZXIgcG90ZW50aWFsIHNjZW5hcmlvcyBsaWtlIGlmIHRoZSB1c2VyIHBhc3NlcyBpbiBhIHNpbWlsYXIgdmFsdWUuXG5cdFx0XHRcdHYgPSB2LnN1YnN0cigwLCB2Lmxlbmd0aCAtIDEpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKF9jb2xvckxvb2t1cFt2XSkge1xuXHRcdFx0XHRhID0gX2NvbG9yTG9va3VwW3ZdO1xuXHRcdFx0fSBlbHNlIGlmICh2LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcblx0XHRcdFx0aWYgKHYubGVuZ3RoIDwgNikgeyAvL2ZvciBzaG9ydGhhbmQgbGlrZSAjOUYwIG9yICM5RjBGIChjb3VsZCBoYXZlIGFscGhhKVxuXHRcdFx0XHRcdHIgPSB2LmNoYXJBdCgxKTtcblx0XHRcdFx0XHRnID0gdi5jaGFyQXQoMik7XG5cdFx0XHRcdFx0YiA9IHYuY2hhckF0KDMpO1xuXHRcdFx0XHRcdHYgPSBcIiNcIiArIHIgKyByICsgZyArIGcgKyBiICsgYiArICh2Lmxlbmd0aCA9PT0gNSA/IHYuY2hhckF0KDQpICsgdi5jaGFyQXQoNCkgOiBcIlwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodi5sZW5ndGggPT09IDkpIHsgLy8gaGV4IHdpdGggYWxwaGEsIGxpa2UgI2ZkNWU1M2ZmXG5cdFx0XHRcdFx0YSA9IHBhcnNlSW50KHYuc3Vic3RyKDEsIDYpLCAxNik7XG5cdFx0XHRcdFx0cmV0dXJuIFthID4+IDE2LCAoYSA+PiA4KSAmIF8yNTUsIGEgJiBfMjU1LCBwYXJzZUludCh2LnN1YnN0cig3KSwgMTYpIC8gMjU1XTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2ID0gcGFyc2VJbnQodi5zdWJzdHIoMSksIDE2KTtcblx0XHRcdFx0YSA9IFt2ID4+IDE2LCAodiA+PiA4KSAmIF8yNTUsIHYgJiBfMjU1XTtcblx0XHRcdH0gZWxzZSBpZiAodi5zdWJzdHIoMCwgMykgPT09IFwiaHNsXCIpIHtcblx0XHRcdFx0YSA9IHdhc0hTTCA9IHYubWF0Y2goX3N0cmljdE51bUV4cCk7XG5cdFx0XHRcdGlmICghdG9IU0wpIHtcblx0XHRcdFx0XHRoID0gKCthWzBdICUgMzYwKSAvIDM2MDtcblx0XHRcdFx0XHRzID0gK2FbMV0gLyAxMDA7XG5cdFx0XHRcdFx0bCA9ICthWzJdIC8gMTAwO1xuXHRcdFx0XHRcdGcgPSAobCA8PSAuNSkgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG5cdFx0XHRcdFx0ciA9IGwgKiAyIC0gZztcblx0XHRcdFx0XHRhLmxlbmd0aCA+IDMgJiYgKGFbM10gKj0gMSk7IC8vY2FzdCBhcyBudW1iZXJcblx0XHRcdFx0XHRhWzBdID0gX2h1ZShoICsgMSAvIDMsIHIsIGcpO1xuXHRcdFx0XHRcdGFbMV0gPSBfaHVlKGgsIHIsIGcpO1xuXHRcdFx0XHRcdGFbMl0gPSBfaHVlKGggLSAxIC8gMywgciwgZyk7XG5cdFx0XHRcdH0gZWxzZSBpZiAofnYuaW5kZXhPZihcIj1cIikpIHsgLy9pZiByZWxhdGl2ZSB2YWx1ZXMgYXJlIGZvdW5kLCBqdXN0IHJldHVybiB0aGUgcmF3IHN0cmluZ3Mgd2l0aCB0aGUgcmVsYXRpdmUgcHJlZml4ZXMgaW4gcGxhY2UuXG5cdFx0XHRcdFx0YSA9IHYubWF0Y2goX251bUV4cCk7XG5cdFx0XHRcdFx0Zm9yY2VBbHBoYSAmJiBhLmxlbmd0aCA8IDQgJiYgKGFbM10gPSAxKTtcblx0XHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YSA9IHYubWF0Y2goX3N0cmljdE51bUV4cCkgfHwgX2NvbG9yTG9va3VwLnRyYW5zcGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0YSA9IGEubWFwKE51bWJlcik7XG5cdFx0fVxuXHRcdGlmICh0b0hTTCAmJiAhd2FzSFNMKSB7XG5cdFx0XHRyID0gYVswXSAvIF8yNTU7XG5cdFx0XHRnID0gYVsxXSAvIF8yNTU7XG5cdFx0XHRiID0gYVsyXSAvIF8yNTU7XG5cdFx0XHRtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcblx0XHRcdG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHRcdFx0bCA9IChtYXggKyBtaW4pIC8gMjtcblx0XHRcdGlmIChtYXggPT09IG1pbikge1xuXHRcdFx0XHRoID0gcyA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkID0gbWF4IC0gbWluO1xuXHRcdFx0XHRzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG5cdFx0XHRcdGggPSAobWF4ID09PSByKSA/IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApIDogKG1heCA9PT0gZykgPyAoYiAtIHIpIC8gZCArIDIgOiAociAtIGcpIC8gZCArIDQ7XG5cdFx0XHRcdGggKj0gNjA7XG5cdFx0XHR9XG5cdFx0XHRhWzBdID0gfn4oaCArIC41KTtcblx0XHRcdGFbMV0gPSB+fihzICogMTAwICsgLjUpO1xuXHRcdFx0YVsyXSA9IH5+KGwgKiAxMDAgKyAuNSk7XG5cdFx0fVxuXHRcdGZvcmNlQWxwaGEgJiYgYS5sZW5ndGggPCA0ICYmIChhWzNdID0gMSk7XG5cdFx0cmV0dXJuIGE7XG5cdH0sXG5cdF9jb2xvck9yZGVyRGF0YSA9IHYgPT4geyAvLyBzdHJpcHMgb3V0IHRoZSBjb2xvcnMgZnJvbSB0aGUgc3RyaW5nLCBmaW5kcyBhbGwgdGhlIG51bWVyaWMgc2xvdHMgKHdpdGggdW5pdHMpIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRob3NlLiBUaGUgQXJyYXkgYWxzbyBoYXMgYSBcImNcIiBwcm9wZXJ0eSB3aGljaCBpcyBhbiBBcnJheSBvZiB0aGUgaW5kZXggdmFsdWVzIHdoZXJlIHRoZSBjb2xvcnMgYmVsb25nLiBUaGlzIGlzIHRvIGhlbHAgd29yayBhcm91bmQgaXNzdWVzIHdoZXJlIHRoZXJlJ3MgYSBtaXMtbWF0Y2hlZCBvcmRlciBvZiBjb2xvci9udW1lcmljIGRhdGEgbGlrZSBkcm9wLXNoYWRvdygjZjAwIDBweCAxcHggMnB4KSBhbmQgZHJvcC1zaGFkb3coMHggMXB4IDJweCAjZjAwKS4gVGhpcyBpcyBiYXNpY2FsbHkgYSBoZWxwZXIgZnVuY3Rpb24gdXNlZCBpbiBfZm9ybWF0Q29sb3JzKClcblx0XHRsZXQgdmFsdWVzID0gW10sXG5cdFx0XHRjID0gW10sXG5cdFx0XHRpID0gLTE7XG5cdFx0di5zcGxpdChfY29sb3JFeHApLmZvckVhY2godiA9PiB7XG5cdFx0XHRsZXQgYSA9IHYubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcblx0XHRcdHZhbHVlcy5wdXNoKC4uLmEpO1xuXHRcdFx0Yy5wdXNoKGkgKz0gYS5sZW5ndGggKyAxKTtcblx0XHR9KTtcblx0XHR2YWx1ZXMuYyA9IGM7XG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblx0X2Zvcm1hdENvbG9ycyA9IChzLCB0b0hTTCwgb3JkZXJNYXRjaERhdGEpID0+IHtcblx0XHRsZXQgcmVzdWx0ID0gXCJcIixcblx0XHRcdGNvbG9ycyA9IChzICsgcmVzdWx0KS5tYXRjaChfY29sb3JFeHApLFxuXHRcdFx0dHlwZSA9IHRvSFNMID8gXCJoc2xhKFwiIDogXCJyZ2JhKFwiLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRjLCBzaGVsbCwgZCwgbDtcblx0XHRpZiAoIWNvbG9ycykge1xuXHRcdFx0cmV0dXJuIHM7XG5cdFx0fVxuXHRcdGNvbG9ycyA9IGNvbG9ycy5tYXAoY29sb3IgPT4gKGNvbG9yID0gc3BsaXRDb2xvcihjb2xvciwgdG9IU0wsIDEpKSAmJiB0eXBlICsgKHRvSFNMID8gY29sb3JbMF0gKyBcIixcIiArIGNvbG9yWzFdICsgXCIlLFwiICsgY29sb3JbMl0gKyBcIiUsXCIgKyBjb2xvclszXSA6IGNvbG9yLmpvaW4oXCIsXCIpKSArIFwiKVwiKTtcblx0XHRpZiAob3JkZXJNYXRjaERhdGEpIHtcblx0XHRcdGQgPSBfY29sb3JPcmRlckRhdGEocyk7XG5cdFx0XHRjID0gb3JkZXJNYXRjaERhdGEuYztcblx0XHRcdGlmIChjLmpvaW4ocmVzdWx0KSAhPT0gZC5jLmpvaW4ocmVzdWx0KSkge1xuXHRcdFx0XHRzaGVsbCA9IHMucmVwbGFjZShfY29sb3JFeHAsIFwiMVwiKS5zcGxpdChfbnVtV2l0aFVuaXRFeHApO1xuXHRcdFx0XHRsID0gc2hlbGwubGVuZ3RoIC0gMTtcblx0XHRcdFx0Zm9yICg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRyZXN1bHQgKz0gc2hlbGxbaV0gKyAofmMuaW5kZXhPZihpKSA/IGNvbG9ycy5zaGlmdCgpIHx8IHR5cGUgKyBcIjAsMCwwLDApXCIgOiAoZC5sZW5ndGggPyBkIDogY29sb3JzLmxlbmd0aCA/IGNvbG9ycyA6IG9yZGVyTWF0Y2hEYXRhKS5zaGlmdCgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIXNoZWxsKSB7XG5cdFx0XHRzaGVsbCA9IHMuc3BsaXQoX2NvbG9yRXhwKTtcblx0XHRcdGwgPSBzaGVsbC5sZW5ndGggLSAxO1xuXHRcdFx0Zm9yICg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0cmVzdWx0ICs9IHNoZWxsW2ldICsgY29sb3JzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0ICsgc2hlbGxbbF07XG5cdH0sXG5cdF9jb2xvckV4cCA9IChmdW5jdGlvbigpIHtcblx0XHRsZXQgcyA9IFwiKD86XFxcXGIoPzooPzpyZ2J8cmdiYXxoc2x8aHNsYSlcXFxcKC4rP1xcXFwpKXxcXFxcQiMoPzpbMC05YS1mXXszLDR9KXsxLDJ9XFxcXGJcIiwgLy93ZSdsbCBkeW5hbWljYWxseSBidWlsZCB0aGlzIFJlZ3VsYXIgRXhwcmVzc2lvbiB0byBjb25zZXJ2ZSBmaWxlIHNpemUuIEFmdGVyIGJ1aWxkaW5nIGl0LCBpdCB3aWxsIGJlIGFibGUgdG8gZmluZCByZ2IoKSwgcmdiYSgpLCAjIChoZXhhZGVjaW1hbCksIGFuZCBuYW1lZCBjb2xvciB2YWx1ZXMgbGlrZSByZWQsIGJsdWUsIHB1cnBsZSwgZXRjLixcblx0XHRcdHA7XG5cdFx0Zm9yIChwIGluIF9jb2xvckxvb2t1cCkge1xuXHRcdFx0cyArPSBcInxcIiArIHAgKyBcIlxcXFxiXCI7XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgUmVnRXhwKHMgKyBcIilcIiwgXCJnaVwiKTtcblx0fSkoKSxcblx0X2hzbEV4cCA9IC9oc2xbYV0/XFwoLyxcblx0X2NvbG9yU3RyaW5nRmlsdGVyID0gYSA9PiB7XG5cdFx0bGV0IGNvbWJpbmVkID0gYS5qb2luKFwiIFwiKSxcblx0XHRcdHRvSFNMO1xuXHRcdF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXHRcdGlmIChfY29sb3JFeHAudGVzdChjb21iaW5lZCkpIHtcblx0XHRcdHRvSFNMID0gX2hzbEV4cC50ZXN0KGNvbWJpbmVkKTtcblx0XHRcdGFbMV0gPSBfZm9ybWF0Q29sb3JzKGFbMV0sIHRvSFNMKTtcblx0XHRcdGFbMF0gPSBfZm9ybWF0Q29sb3JzKGFbMF0sIHRvSFNMLCBfY29sb3JPcmRlckRhdGEoYVsxXSkpOyAvLyBtYWtlIHN1cmUgdGhlIG9yZGVyIG9mIG51bWJlcnMvY29sb3JzIG1hdGNoIHdpdGggdGhlIEVORCB2YWx1ZS5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fSxcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUSUNLRVJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0X3RpY2tlckFjdGl2ZSxcblx0X3RpY2tlciA9IChmdW5jdGlvbigpIHtcblx0XHRsZXQgX2dldFRpbWUgPSBEYXRlLm5vdyxcblx0XHRcdF9sYWdUaHJlc2hvbGQgPSA1MDAsXG5cdFx0XHRfYWRqdXN0ZWRMYWcgPSAzMyxcblx0XHRcdF9zdGFydFRpbWUgPSBfZ2V0VGltZSgpLFxuXHRcdFx0X2xhc3RVcGRhdGUgPSBfc3RhcnRUaW1lLFxuXHRcdFx0X2dhcCA9IDEwMDAgLyAyNDAsXG5cdFx0XHRfbmV4dFRpbWUgPSBfZ2FwLFxuXHRcdFx0X2xpc3RlbmVycyA9IFtdLFxuXHRcdFx0X2lkLCBfcmVxLCBfcmFmLCBfc2VsZiwgX2RlbHRhLCBfaSxcblx0XHRcdF90aWNrID0gdiA9PiB7XG5cdFx0XHRcdGxldCBlbGFwc2VkID0gX2dldFRpbWUoKSAtIF9sYXN0VXBkYXRlLFxuXHRcdFx0XHRcdG1hbnVhbCA9IHYgPT09IHRydWUsXG5cdFx0XHRcdFx0b3ZlcmxhcCwgZGlzcGF0Y2gsIHRpbWUsIGZyYW1lO1xuXHRcdFx0XHRlbGFwc2VkID4gX2xhZ1RocmVzaG9sZCAmJiAoX3N0YXJ0VGltZSArPSBlbGFwc2VkIC0gX2FkanVzdGVkTGFnKTtcblx0XHRcdFx0X2xhc3RVcGRhdGUgKz0gZWxhcHNlZDtcblx0XHRcdFx0dGltZSA9IF9sYXN0VXBkYXRlIC0gX3N0YXJ0VGltZTtcblx0XHRcdFx0b3ZlcmxhcCA9IHRpbWUgLSBfbmV4dFRpbWU7XG5cdFx0XHRcdGlmIChvdmVybGFwID4gMCB8fCBtYW51YWwpIHtcblx0XHRcdFx0XHRmcmFtZSA9ICsrX3NlbGYuZnJhbWU7XG5cdFx0XHRcdFx0X2RlbHRhID0gdGltZSAtIF9zZWxmLnRpbWUgKiAxMDAwO1xuXHRcdFx0XHRcdF9zZWxmLnRpbWUgPSB0aW1lID0gdGltZSAvIDEwMDA7XG5cdFx0XHRcdFx0X25leHRUaW1lICs9IG92ZXJsYXAgKyAob3ZlcmxhcCA+PSBfZ2FwID8gNCA6IF9nYXAgLSBvdmVybGFwKTtcblx0XHRcdFx0XHRkaXNwYXRjaCA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWFudWFsIHx8IChfaWQgPSBfcmVxKF90aWNrKSk7IC8vbWFrZSBzdXJlIHRoZSByZXF1ZXN0IGlzIG1hZGUgYmVmb3JlIHdlIGRpc3BhdGNoIHRoZSBcInRpY2tcIiBldmVudCBzbyB0aGF0IHRpbWluZyBpcyBtYWludGFpbmVkLiBPdGhlcndpc2UsIGlmIHByb2Nlc3NpbmcgdGhlIFwidGlja1wiIHJlcXVpcmVzIGEgYnVuY2ggb2YgdGltZSAobGlrZSAxNW1zKSBhbmQgd2UncmUgdXNpbmcgYSBzZXRUaW1lb3V0KCkgdGhhdCdzIGJhc2VkIG9uIDE2LjdtcywgaXQnZCB0ZWNobmljYWxseSB0YWtlIDMxLjdtcyBiZXR3ZWVuIGZyYW1lcyBvdGhlcndpc2UuXG5cdFx0XHRcdGlmIChkaXNwYXRjaCkge1xuXHRcdFx0XHRcdGZvciAoX2kgPSAwOyBfaSA8IF9saXN0ZW5lcnMubGVuZ3RoOyBfaSsrKSB7IC8vIHVzZSBfaSBhbmQgY2hlY2sgX2xpc3RlbmVycy5sZW5ndGggaW5zdGVhZCBvZiBhIHZhcmlhYmxlIGJlY2F1c2UgYSBsaXN0ZW5lciBjb3VsZCBnZXQgcmVtb3ZlZCBkdXJpbmcgdGhlIGxvb3AsIGFuZCBpZiB0aGF0IGhhcHBlbnMgdG8gYW4gZWxlbWVudCBsZXNzIHRoYW4gdGhlIGN1cnJlbnQgaW5kZXgsIGl0J2QgdGhyb3cgdGhpbmdzIG9mZiBpbiB0aGUgbG9vcC5cblx0XHRcdFx0XHRcdF9saXN0ZW5lcnNbX2ldKHRpbWUsIF9kZWx0YSwgZnJhbWUsIHYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRfc2VsZiA9IHtcblx0XHRcdHRpbWU6MCxcblx0XHRcdGZyYW1lOjAsXG5cdFx0XHR0aWNrKCkge1xuXHRcdFx0XHRfdGljayh0cnVlKTtcblx0XHRcdH0sXG5cdFx0XHRkZWx0YVJhdGlvKGZwcykge1xuXHRcdFx0XHRyZXR1cm4gX2RlbHRhIC8gKDEwMDAgLyAoZnBzIHx8IDYwKSk7XG5cdFx0XHR9LFxuXHRcdFx0d2FrZSgpIHtcblx0XHRcdFx0aWYgKF9jb3JlUmVhZHkpIHtcblx0XHRcdFx0XHRpZiAoIV9jb3JlSW5pdHRlZCAmJiBfd2luZG93RXhpc3RzKCkpIHtcblx0XHRcdFx0XHRcdF93aW4gPSBfY29yZUluaXR0ZWQgPSB3aW5kb3c7XG5cdFx0XHRcdFx0XHRfZG9jID0gX3dpbi5kb2N1bWVudCB8fCB7fTtcblx0XHRcdFx0XHRcdF9nbG9iYWxzLmdzYXAgPSBnc2FwO1xuXHRcdFx0XHRcdFx0KF93aW4uZ3NhcFZlcnNpb25zIHx8IChfd2luLmdzYXBWZXJzaW9ucyA9IFtdKSkucHVzaChnc2FwLnZlcnNpb24pO1xuXHRcdFx0XHRcdFx0X2luc3RhbGwoX2luc3RhbGxTY29wZSB8fCBfd2luLkdyZWVuU29ja0dsb2JhbHMgfHwgKCFfd2luLmdzYXAgJiYgX3dpbikgfHwge30pO1xuXHRcdFx0XHRcdFx0X3JhZiA9IF93aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfaWQgJiYgX3NlbGYuc2xlZXAoKTtcblx0XHRcdFx0XHRfcmVxID0gX3JhZiB8fCAoZiA9PiBzZXRUaW1lb3V0KGYsIChfbmV4dFRpbWUgLSBfc2VsZi50aW1lICogMTAwMCArIDEpIHwgMCkpO1xuXHRcdFx0XHRcdF90aWNrZXJBY3RpdmUgPSAxO1xuXHRcdFx0XHRcdF90aWNrKDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2xlZXAoKSB7XG5cdFx0XHRcdChfcmFmID8gX3dpbi5jYW5jZWxBbmltYXRpb25GcmFtZSA6IGNsZWFyVGltZW91dCkoX2lkKTtcblx0XHRcdFx0X3RpY2tlckFjdGl2ZSA9IDA7XG5cdFx0XHRcdF9yZXEgPSBfZW1wdHlGdW5jO1xuXHRcdFx0fSxcblx0XHRcdGxhZ1Ntb290aGluZyh0aHJlc2hvbGQsIGFkanVzdGVkTGFnKSB7XG5cdFx0XHRcdF9sYWdUaHJlc2hvbGQgPSB0aHJlc2hvbGQgfHwgKDEgLyBfdGlueU51bSk7IC8vemVybyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYmFzaWNhbGx5IHVubGltaXRlZFxuXHRcdFx0XHRfYWRqdXN0ZWRMYWcgPSBNYXRoLm1pbihhZGp1c3RlZExhZywgX2xhZ1RocmVzaG9sZCwgMCk7XG5cdFx0XHR9LFxuXHRcdFx0ZnBzKGZwcykge1xuXHRcdFx0XHRfZ2FwID0gMTAwMCAvIChmcHMgfHwgMjQwKTtcblx0XHRcdFx0X25leHRUaW1lID0gX3NlbGYudGltZSAqIDEwMDAgKyBfZ2FwO1xuXHRcdFx0fSxcblx0XHRcdGFkZChjYWxsYmFjaykge1xuXHRcdFx0XHRfbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spIDwgMCAmJiBfbGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xuXHRcdFx0XHRfd2FrZSgpO1xuXHRcdFx0fSxcblx0XHRcdHJlbW92ZShjYWxsYmFjaykge1xuXHRcdFx0XHRsZXQgaTtcblx0XHRcdFx0fihpID0gX2xpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKSkgJiYgX2xpc3RlbmVycy5zcGxpY2UoaSwgMSkgJiYgX2kgPj0gaSAmJiBfaS0tO1xuXHRcdFx0fSxcblx0XHRcdF9saXN0ZW5lcnM6X2xpc3RlbmVyc1xuXHRcdH07XG5cdFx0cmV0dXJuIF9zZWxmO1xuXHR9KSgpLFxuXHRfd2FrZSA9ICgpID0+ICFfdGlja2VyQWN0aXZlICYmIF90aWNrZXIud2FrZSgpLCAvL2Fsc28gZW5zdXJlcyB0aGUgY29yZSBjbGFzc2VzIGFyZSBpbml0aWFsaXplZC5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKlxuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIEVBU0lOR1xuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qL1xuXHRfZWFzZU1hcCA9IHt9LFxuXHRfY3VzdG9tRWFzZUV4cCA9IC9eW1xcZC5cXC1NXVtcXGQuXFwtLFxcc10vLFxuXHRfcXVvdGVzRXhwID0gL1tcIiddL2csXG5cdF9wYXJzZU9iamVjdEluU3RyaW5nID0gdmFsdWUgPT4geyAvL3Rha2VzIGEgc3RyaW5nIGxpa2UgXCJ7d2lnZ2xlczoxMCwgdHlwZTphbnRpY2lwYXRlfSlcIiBhbmQgdHVybnMgaXQgaW50byBhIHJlYWwgb2JqZWN0LiBOb3RpY2UgaXQgZW5kcyBpbiBcIilcIiBhbmQgaW5jbHVkZXMgdGhlIHt9IHdyYXBwZXJzLiBUaGlzIGlzIGJlY2F1c2Ugd2Ugb25seSB1c2UgdGhpcyBmdW5jdGlvbiBmb3IgcGFyc2luZyBlYXNlIGNvbmZpZ3MgYW5kIHByaW9yaXRpemVkIG9wdGltaXphdGlvbiByYXRoZXIgdGhhbiByZXVzYWJpbGl0eS5cblx0XHRsZXQgb2JqID0ge30sXG5cdFx0XHRzcGxpdCA9IHZhbHVlLnN1YnN0cigxLCB2YWx1ZS5sZW5ndGgtMykuc3BsaXQoXCI6XCIpLFxuXHRcdFx0a2V5ID0gc3BsaXRbMF0sXG5cdFx0XHRpID0gMSxcblx0XHRcdGwgPSBzcGxpdC5sZW5ndGgsXG5cdFx0XHRpbmRleCwgdmFsLCBwYXJzZWRWYWw7XG5cdFx0Zm9yICg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhbCA9IHNwbGl0W2ldO1xuXHRcdFx0aW5kZXggPSBpICE9PSBsLTEgPyB2YWwubGFzdEluZGV4T2YoXCIsXCIpIDogdmFsLmxlbmd0aDtcblx0XHRcdHBhcnNlZFZhbCA9IHZhbC5zdWJzdHIoMCwgaW5kZXgpO1xuXHRcdFx0b2JqW2tleV0gPSBpc05hTihwYXJzZWRWYWwpID8gcGFyc2VkVmFsLnJlcGxhY2UoX3F1b3Rlc0V4cCwgXCJcIikudHJpbSgpIDogK3BhcnNlZFZhbDtcblx0XHRcdGtleSA9IHZhbC5zdWJzdHIoaW5kZXgrMSkudHJpbSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXHRfdmFsdWVJblBhcmVudGhlc2VzID0gdmFsdWUgPT4ge1xuXHRcdGxldCBvcGVuID0gdmFsdWUuaW5kZXhPZihcIihcIikgKyAxLFxuXHRcdFx0Y2xvc2UgPSB2YWx1ZS5pbmRleE9mKFwiKVwiKSxcblx0XHRcdG5lc3RlZCA9IHZhbHVlLmluZGV4T2YoXCIoXCIsIG9wZW4pO1xuXHRcdHJldHVybiB2YWx1ZS5zdWJzdHJpbmcob3Blbiwgfm5lc3RlZCAmJiBuZXN0ZWQgPCBjbG9zZSA/IHZhbHVlLmluZGV4T2YoXCIpXCIsIGNsb3NlICsgMSkgOiBjbG9zZSk7XG5cdH0sXG5cdF9jb25maWdFYXNlRnJvbVN0cmluZyA9IG5hbWUgPT4geyAvL25hbWUgY2FuIGJlIGEgc3RyaW5nIGxpa2UgXCJlbGFzdGljLm91dCgxLDAuNSlcIiwgYW5kIHBhc3MgaW4gX2Vhc2VNYXAgYXMgb2JqIGFuZCBpdCdsbCBwYXJzZSBpdCBvdXQgYW5kIGNhbGwgdGhlIGFjdHVhbCBmdW5jdGlvbiBsaWtlIF9lYXNlTWFwLkVsYXN0aWMuZWFzZU91dC5jb25maWcoMSwwLjUpLiBJdCB3aWxsIGFsc28gcGFyc2UgY3VzdG9tIGVhc2Ugc3RyaW5ncyBhcyBsb25nIGFzIEN1c3RvbUVhc2UgaXMgbG9hZGVkIGFuZCByZWdpc3RlcmVkIChpbnRlcm5hbGx5IGFzIF9lYXNlTWFwLl9DRSkuXG5cdFx0bGV0IHNwbGl0ID0gKG5hbWUgKyBcIlwiKS5zcGxpdChcIihcIiksXG5cdFx0XHRlYXNlID0gX2Vhc2VNYXBbc3BsaXRbMF1dO1xuXHRcdHJldHVybiAoZWFzZSAmJiBzcGxpdC5sZW5ndGggPiAxICYmIGVhc2UuY29uZmlnKSA/IGVhc2UuY29uZmlnLmFwcGx5KG51bGwsIH5uYW1lLmluZGV4T2YoXCJ7XCIpID8gW19wYXJzZU9iamVjdEluU3RyaW5nKHNwbGl0WzFdKV0gOiBfdmFsdWVJblBhcmVudGhlc2VzKG5hbWUpLnNwbGl0KFwiLFwiKS5tYXAoX251bWVyaWNJZlBvc3NpYmxlKSkgOiAoX2Vhc2VNYXAuX0NFICYmIF9jdXN0b21FYXNlRXhwLnRlc3QobmFtZSkpID8gX2Vhc2VNYXAuX0NFKFwiXCIsIG5hbWUpIDogZWFzZTtcblx0fSxcblx0X2ludmVydEVhc2UgPSBlYXNlID0+IHAgPT4gMSAtIGVhc2UoMSAtIHApLFxuXHQvLyBhbGxvdyB5b3lvRWFzZSB0byBiZSBzZXQgaW4gY2hpbGRyZW4gYW5kIGhhdmUgdGhvc2UgYWZmZWN0ZWQgd2hlbiB0aGUgcGFyZW50L2FuY2VzdG9yIHRpbWVsaW5lIHlveW9zLlxuXHRfcHJvcGFnYXRlWW95b0Vhc2UgPSAodGltZWxpbmUsIGlzWW95bykgPT4ge1xuXHRcdGxldCBjaGlsZCA9IHRpbWVsaW5lLl9maXJzdCwgZWFzZTtcblx0XHR3aGlsZSAoY2hpbGQpIHtcblx0XHRcdGlmIChjaGlsZCBpbnN0YW5jZW9mIFRpbWVsaW5lKSB7XG5cdFx0XHRcdF9wcm9wYWdhdGVZb3lvRWFzZShjaGlsZCwgaXNZb3lvKTtcblx0XHRcdH0gZWxzZSBpZiAoY2hpbGQudmFycy55b3lvRWFzZSAmJiAoIWNoaWxkLl95b3lvIHx8ICFjaGlsZC5fcmVwZWF0KSAmJiBjaGlsZC5feW95byAhPT0gaXNZb3lvKSB7XG5cdFx0XHRcdGlmIChjaGlsZC50aW1lbGluZSkge1xuXHRcdFx0XHRcdF9wcm9wYWdhdGVZb3lvRWFzZShjaGlsZC50aW1lbGluZSwgaXNZb3lvKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlYXNlID0gY2hpbGQuX2Vhc2U7XG5cdFx0XHRcdFx0Y2hpbGQuX2Vhc2UgPSBjaGlsZC5feUVhc2U7XG5cdFx0XHRcdFx0Y2hpbGQuX3lFYXNlID0gZWFzZTtcblx0XHRcdFx0XHRjaGlsZC5feW95byA9IGlzWW95bztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2hpbGQgPSBjaGlsZC5fbmV4dDtcblx0XHR9XG5cdH0sXG5cdF9wYXJzZUVhc2UgPSAoZWFzZSwgZGVmYXVsdEVhc2UpID0+ICFlYXNlID8gZGVmYXVsdEVhc2UgOiAoX2lzRnVuY3Rpb24oZWFzZSkgPyBlYXNlIDogX2Vhc2VNYXBbZWFzZV0gfHwgX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nKGVhc2UpKSB8fCBkZWZhdWx0RWFzZSxcblx0X2luc2VydEVhc2UgPSAobmFtZXMsIGVhc2VJbiwgZWFzZU91dCA9IHAgPT4gMSAtIGVhc2VJbigxIC0gcCksIGVhc2VJbk91dCA9IChwID0+IHAgPCAuNSA/IGVhc2VJbihwICogMikgLyAyIDogMSAtIGVhc2VJbigoMSAtIHApICogMikgLyAyKSkgPT4ge1xuXHRcdGxldCBlYXNlID0ge2Vhc2VJbiwgZWFzZU91dCwgZWFzZUluT3V0fSxcblx0XHRcdGxvd2VyY2FzZU5hbWU7XG5cdFx0X2ZvckVhY2hOYW1lKG5hbWVzLCBuYW1lID0+IHtcblx0XHRcdF9lYXNlTWFwW25hbWVdID0gX2dsb2JhbHNbbmFtZV0gPSBlYXNlO1xuXHRcdFx0X2Vhc2VNYXBbKGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkpXSA9IGVhc2VPdXQ7XG5cdFx0XHRmb3IgKGxldCBwIGluIGVhc2UpIHtcblx0XHRcdFx0X2Vhc2VNYXBbbG93ZXJjYXNlTmFtZSArIChwID09PSBcImVhc2VJblwiID8gXCIuaW5cIiA6IHAgPT09IFwiZWFzZU91dFwiID8gXCIub3V0XCIgOiBcIi5pbk91dFwiKV0gPSBfZWFzZU1hcFtuYW1lICsgXCIuXCIgKyBwXSA9IGVhc2VbcF07XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGVhc2U7XG5cdH0sXG5cdF9lYXNlSW5PdXRGcm9tT3V0ID0gZWFzZU91dCA9PiAocCA9PiBwIDwgLjUgPyAoMSAtIGVhc2VPdXQoMSAtIChwICogMikpKSAvIDIgOiAuNSArIGVhc2VPdXQoKHAgLSAuNSkgKiAyKSAvIDIpLFxuXHRfY29uZmlnRWxhc3RpYyA9ICh0eXBlLCBhbXBsaXR1ZGUsIHBlcmlvZCkgPT4ge1xuXHRcdGxldCBwMSA9IChhbXBsaXR1ZGUgPj0gMSkgPyBhbXBsaXR1ZGUgOiAxLCAvL25vdGU6IGlmIGFtcGxpdHVkZSBpcyA8IDEsIHdlIHNpbXBseSBhZGp1c3QgdGhlIHBlcmlvZCBmb3IgYSBtb3JlIG5hdHVyYWwgZmVlbC4gT3RoZXJ3aXNlIHRoZSBtYXRoIGRvZXNuJ3Qgd29yayByaWdodCBhbmQgdGhlIGN1cnZlIHN0YXJ0cyBhdCAxLlxuXHRcdFx0cDIgPSAocGVyaW9kIHx8ICh0eXBlID8gLjMgOiAuNDUpKSAvIChhbXBsaXR1ZGUgPCAxID8gYW1wbGl0dWRlIDogMSksXG5cdFx0XHRwMyA9IHAyIC8gXzJQSSAqIChNYXRoLmFzaW4oMSAvIHAxKSB8fCAwKSxcblx0XHRcdGVhc2VPdXQgPSBwID0+IHAgPT09IDEgPyAxIDogcDEgKiAoMiAqKiAoLTEwICogcCkpICogX3NpbigocCAtIHAzKSAqIHAyKSArIDEsXG5cdFx0XHRlYXNlID0gKHR5cGUgPT09IFwib3V0XCIpID8gZWFzZU91dCA6ICh0eXBlID09PSBcImluXCIpID8gcCA9PiAxIC0gZWFzZU91dCgxIC0gcCkgOiBfZWFzZUluT3V0RnJvbU91dChlYXNlT3V0KTtcblx0XHRwMiA9IF8yUEkgLyBwMjsgLy9wcmVjYWxjdWxhdGUgdG8gb3B0aW1pemVcblx0XHRlYXNlLmNvbmZpZyA9IChhbXBsaXR1ZGUsIHBlcmlvZCkgPT4gX2NvbmZpZ0VsYXN0aWModHlwZSwgYW1wbGl0dWRlLCBwZXJpb2QpO1xuXHRcdHJldHVybiBlYXNlO1xuXHR9LFxuXHRfY29uZmlnQmFjayA9ICh0eXBlLCBvdmVyc2hvb3QgPSAxLjcwMTU4KSA9PiB7XG5cdFx0bGV0IGVhc2VPdXQgPSBwID0+IHAgPyAoKC0tcCkgKiBwICogKChvdmVyc2hvb3QgKyAxKSAqIHAgKyBvdmVyc2hvb3QpICsgMSkgOiAwLFxuXHRcdFx0ZWFzZSA9ICh0eXBlID09PSBcIm91dFwiKSA/IGVhc2VPdXQgOiAodHlwZSA9PT0gXCJpblwiKSA/IHAgPT4gMSAtIGVhc2VPdXQoMSAtIHApIDogX2Vhc2VJbk91dEZyb21PdXQoZWFzZU91dCk7XG5cdFx0ZWFzZS5jb25maWcgPSBvdmVyc2hvb3QgPT4gX2NvbmZpZ0JhY2sodHlwZSwgb3ZlcnNob290KTtcblx0XHRyZXR1cm4gZWFzZTtcblx0fTtcblx0Ly8gYSBjaGVhcGVyIChrYiBhbmQgY3B1KSBidXQgbW9yZSBtaWxkIHdheSB0byBnZXQgYSBwYXJhbWV0ZXJpemVkIHdlaWdodGVkIGVhc2UgYnkgZmVlZGluZyBpbiBhIHZhbHVlIGJldHdlZW4gLTEgKGVhc2VJbikgYW5kIDEgKGVhc2VPdXQpIHdoZXJlIDAgaXMgbGluZWFyLlxuXHQvLyBfd2VpZ2h0ZWRFYXNlID0gcmF0aW8gPT4ge1xuXHQvLyBcdGxldCB5ID0gMC41ICsgcmF0aW8gLyAyO1xuXHQvLyBcdHJldHVybiBwID0+ICgyICogKDEgLSBwKSAqIHAgKiB5ICsgcCAqIHApO1xuXHQvLyB9LFxuXHQvLyBhIHN0cm9uZ2VyIChidXQgbW9yZSBleHBlbnNpdmUga2IvY3B1KSBwYXJhbWV0ZXJpemVkIHdlaWdodGVkIGVhc2UgdGhhdCBsZXRzIHlvdSBmZWVkIGluIGEgdmFsdWUgYmV0d2VlbiAtMSAoZWFzZUluKSBhbmQgMSAoZWFzZU91dCkgd2hlcmUgMCBpcyBsaW5lYXIuXG5cdC8vIF93ZWlnaHRlZEVhc2VTdHJvbmcgPSByYXRpbyA9PiB7XG5cdC8vIFx0cmF0aW8gPSAuNSArIHJhdGlvIC8gMjtcblx0Ly8gXHRsZXQgbyA9IDEgLyAzICogKHJhdGlvIDwgLjUgPyByYXRpbyA6IDEgLSByYXRpbyksXG5cdC8vIFx0XHRiID0gcmF0aW8gLSBvLFxuXHQvLyBcdFx0YyA9IHJhdGlvICsgbztcblx0Ly8gXHRyZXR1cm4gcCA9PiBwID09PSAxID8gcCA6IDMgKiBiICogKDEgLSBwKSAqICgxIC0gcCkgKiBwICsgMyAqIGMgKiAoMSAtIHApICogcCAqIHAgKyBwICogcCAqIHA7XG5cdC8vIH07XG5cbl9mb3JFYWNoTmFtZShcIkxpbmVhcixRdWFkLEN1YmljLFF1YXJ0LFF1aW50LFN0cm9uZ1wiLCAobmFtZSwgaSkgPT4ge1xuXHRsZXQgcG93ZXIgPSBpIDwgNSA/IGkgKyAxIDogaTtcblx0X2luc2VydEVhc2UobmFtZSArIFwiLFBvd2VyXCIgKyAocG93ZXIgLSAxKSwgaSA/IHAgPT4gcCAqKiBwb3dlciA6IHAgPT4gcCwgcCA9PiAxIC0gKDEgLSBwKSAqKiBwb3dlciwgcCA9PiBwIDwgLjUgPyAocCAqIDIpICoqIHBvd2VyIC8gMiA6IDEgLSAoKDEgLSBwKSAqIDIpICoqIHBvd2VyIC8gMik7XG59KTtcbl9lYXNlTWFwLkxpbmVhci5lYXNlTm9uZSA9IF9lYXNlTWFwLm5vbmUgPSBfZWFzZU1hcC5MaW5lYXIuZWFzZUluO1xuX2luc2VydEVhc2UoXCJFbGFzdGljXCIsIF9jb25maWdFbGFzdGljKFwiaW5cIiksIF9jb25maWdFbGFzdGljKFwib3V0XCIpLCBfY29uZmlnRWxhc3RpYygpKTtcbigobiwgYykgPT4ge1xuXHRsZXQgbjEgPSAxIC8gYyxcblx0XHRuMiA9IDIgKiBuMSxcblx0XHRuMyA9IDIuNSAqIG4xLFxuXHRcdGVhc2VPdXQgPSBwID0+IChwIDwgbjEpID8gbiAqIHAgKiBwIDogKHAgPCBuMikgPyBuICogKHAgLSAxLjUgLyBjKSAqKiAyICsgLjc1IDogKHAgPCBuMykgPyBuICogKHAgLT0gMi4yNSAvIGMpICogcCArIC45Mzc1IDogbiAqIChwIC0gMi42MjUgLyBjKSAqKiAyICsgLjk4NDM3NTtcblx0X2luc2VydEVhc2UoXCJCb3VuY2VcIiwgcCA9PiAxIC0gZWFzZU91dCgxIC0gcCksIGVhc2VPdXQpO1xufSkoNy41NjI1LCAyLjc1KTtcbl9pbnNlcnRFYXNlKFwiRXhwb1wiLCBwID0+IHAgPyAyICoqICgxMCAqIChwIC0gMSkpIDogMCk7XG5faW5zZXJ0RWFzZShcIkNpcmNcIiwgcCA9PiAtKF9zcXJ0KDEgLSAocCAqIHApKSAtIDEpKTtcbl9pbnNlcnRFYXNlKFwiU2luZVwiLCBwID0+IHAgPT09IDEgPyAxIDogLV9jb3MocCAqIF9IQUxGX1BJKSArIDEpO1xuX2luc2VydEVhc2UoXCJCYWNrXCIsIF9jb25maWdCYWNrKFwiaW5cIiksIF9jb25maWdCYWNrKFwib3V0XCIpLCBfY29uZmlnQmFjaygpKTtcbl9lYXNlTWFwLlN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuc3RlcHMgPSBfZ2xvYmFscy5TdGVwcGVkRWFzZSA9IHtcblx0Y29uZmlnKHN0ZXBzID0gMSwgaW1tZWRpYXRlU3RhcnQpIHtcblx0XHRsZXQgcDEgPSAxIC8gc3RlcHMsXG5cdFx0XHRwMiA9IHN0ZXBzICsgKGltbWVkaWF0ZVN0YXJ0ID8gMCA6IDEpLFxuXHRcdFx0cDMgPSBpbW1lZGlhdGVTdGFydCA/IDEgOiAwLFxuXHRcdFx0bWF4ID0gMSAtIF90aW55TnVtO1xuXHRcdHJldHVybiBwID0+ICgoKHAyICogX2NsYW1wKDAsIG1heCwgcCkpIHwgMCkgKyBwMykgKiBwMTtcblx0fVxufTtcbl9kZWZhdWx0cy5lYXNlID0gX2Vhc2VNYXBbXCJxdWFkLm91dFwiXTtcblxuXG5fZm9yRWFjaE5hbWUoXCJvbkNvbXBsZXRlLG9uVXBkYXRlLG9uU3RhcnQsb25SZXBlYXQsb25SZXZlcnNlQ29tcGxldGUsb25JbnRlcnJ1cHRcIiwgbmFtZSA9PiBfY2FsbGJhY2tOYW1lcyArPSBuYW1lICsgXCIsXCIgKyBuYW1lICsgXCJQYXJhbXMsXCIpO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ0FDSEVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbmV4cG9ydCBjbGFzcyBHU0NhY2hlIHtcblxuXHRjb25zdHJ1Y3Rvcih0YXJnZXQsIGhhcm5lc3MpIHtcblx0XHR0aGlzLmlkID0gX2dzSUQrKztcblx0XHR0YXJnZXQuX2dzYXAgPSB0aGlzO1xuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdHRoaXMuaGFybmVzcyA9IGhhcm5lc3M7XG5cdFx0dGhpcy5nZXQgPSBoYXJuZXNzID8gaGFybmVzcy5nZXQgOiBfZ2V0UHJvcGVydHk7XG5cdFx0dGhpcy5zZXQgPSBoYXJuZXNzID8gaGFybmVzcy5nZXRTZXR0ZXIgOiBfZ2V0U2V0dGVyO1xuXHR9XG5cbn1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQU5JTUFUSU9OXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmV4cG9ydCBjbGFzcyBBbmltYXRpb24ge1xuXG5cdGNvbnN0cnVjdG9yKHZhcnMpIHtcblx0XHR0aGlzLnZhcnMgPSB2YXJzO1xuXHRcdHRoaXMuX2RlbGF5ID0gK3ZhcnMuZGVsYXkgfHwgMDtcblx0XHRpZiAoKHRoaXMuX3JlcGVhdCA9IHZhcnMucmVwZWF0ID09PSBJbmZpbml0eSA/IC0yIDogdmFycy5yZXBlYXQgfHwgMCkpIHsgLy8gVE9ETzogcmVwZWF0OiBJbmZpbml0eSBvbiBhIHRpbWVsaW5lJ3MgY2hpbGRyZW4gbXVzdCBmbGFnIHRoYXQgdGltZWxpbmUgaW50ZXJuYWxseSBhbmQgYWZmZWN0IGl0cyB0b3RhbER1cmF0aW9uLCBvdGhlcndpc2UgaXQnbGwgc3RvcCBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uIHdoZW4gcmVhY2hpbmcgdGhlIHN0YXJ0LlxuXHRcdFx0dGhpcy5fckRlbGF5ID0gdmFycy5yZXBlYXREZWxheSB8fCAwO1xuXHRcdFx0dGhpcy5feW95byA9ICEhdmFycy55b3lvIHx8ICEhdmFycy55b3lvRWFzZTtcblx0XHR9XG5cdFx0dGhpcy5fdHMgPSAxO1xuXHRcdF9zZXREdXJhdGlvbih0aGlzLCArdmFycy5kdXJhdGlvbiwgMSwgMSk7XG5cdFx0dGhpcy5kYXRhID0gdmFycy5kYXRhO1xuXHRcdF90aWNrZXJBY3RpdmUgfHwgX3RpY2tlci53YWtlKCk7XG5cdH1cblxuXHRkZWxheSh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMCkge1xuXHRcdFx0dGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgJiYgKHRoaXMuc3RhcnRUaW1lKHRoaXMuX3N0YXJ0ICsgdmFsdWUgLSB0aGlzLl9kZWxheSkpO1xuXHRcdFx0dGhpcy5fZGVsYXkgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fZGVsYXk7XG5cdH1cblxuXHRkdXJhdGlvbih2YWx1ZSkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbER1cmF0aW9uKHRoaXMuX3JlcGVhdCA+IDAgPyB2YWx1ZSArICh2YWx1ZSArIHRoaXMuX3JEZWxheSkgKiB0aGlzLl9yZXBlYXQgOiB2YWx1ZSkgOiB0aGlzLnRvdGFsRHVyYXRpb24oKSAmJiB0aGlzLl9kdXI7XG5cdH1cblxuXHR0b3RhbER1cmF0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdER1cjtcblx0XHR9XG5cdFx0dGhpcy5fZGlydHkgPSAwO1xuXHRcdHJldHVybiBfc2V0RHVyYXRpb24odGhpcywgdGhpcy5fcmVwZWF0IDwgMCA/IHZhbHVlIDogKHZhbHVlIC0gKHRoaXMuX3JlcGVhdCAqIHRoaXMuX3JEZWxheSkpIC8gKHRoaXMuX3JlcGVhdCArIDEpKTtcblx0fVxuXG5cdHRvdGFsVGltZSh0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0X3dha2UoKTtcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiB0aGlzLl90VGltZTtcblx0XHR9XG5cdFx0bGV0IHBhcmVudCA9IHRoaXMuX2RwO1xuXHRcdGlmIChwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nICYmIHRoaXMuX3RzKSB7XG5cdFx0XHRfYWxpZ25QbGF5aGVhZCh0aGlzLCB0b3RhbFRpbWUpO1xuXHRcdFx0IXBhcmVudC5fZHAgfHwgcGFyZW50LnBhcmVudCB8fCBfcG9zdEFkZENoZWNrcyhwYXJlbnQsIHRoaXMpOyAvLyBlZGdlIGNhc2U6IGlmIHRoaXMgaXMgYSBjaGlsZCBvZiBhIHRpbWVsaW5lIHRoYXQgYWxyZWFkeSBjb21wbGV0ZWQsIGZvciBleGFtcGxlLCB3ZSBtdXN0IHJlLWFjdGl2YXRlIHRoZSBwYXJlbnQuXG5cdFx0XHQvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvciB0aW1lbGluZXMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLCB3ZSBzaG91bGQgcmVzZXQgdGhlaXIgdG90YWxUaW1lKCkgd2hpY2ggd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZXkncmUgbGluZWQgdXAgcHJvcGVybHkgYW5kIGVuYWJsZWQuIFNraXAgZm9yIGFuaW1hdGlvbnMgdGhhdCBhcmUgb24gdGhlIHJvb3QgKHdhc3RlZnVsKS4gRXhhbXBsZTogYSBUaW1lbGluZUxpdGUuZXhwb3J0Um9vdCgpIGlzIHBlcmZvcm1lZCB3aGVuIHRoZXJlJ3MgYSBwYXVzZWQgdHdlZW4gb24gdGhlIHJvb3QsIHRoZSBleHBvcnQgd2lsbCBub3QgY29tcGxldGUgdW50aWwgdGhhdCB0d2VlbiBpcyB1bnBhdXNlZCwgYnV0IGltYWdpbmUgYSBjaGlsZCBnZXRzIHJlc3RhcnRlZCBsYXRlciwgYWZ0ZXIgYWxsIFt1bnBhdXNlZF0gdHdlZW5zIGhhdmUgY29tcGxldGVkLiBUaGUgc3RhcnQgb2YgdGhhdCBjaGlsZCB3b3VsZCBnZXQgcHVzaGVkIG91dCwgYnV0IG9uZSBvZiB0aGUgYW5jZXN0b3JzIG1heSBoYXZlIGNvbXBsZXRlZC5cblx0XHRcdHdoaWxlIChwYXJlbnQucGFyZW50KSB7XG5cdFx0XHRcdGlmIChwYXJlbnQucGFyZW50Ll90aW1lICE9PSBwYXJlbnQuX3N0YXJ0ICsgKHBhcmVudC5fdHMgPj0gMCA/IHBhcmVudC5fdFRpbWUgLyBwYXJlbnQuX3RzIDogKHBhcmVudC50b3RhbER1cmF0aW9uKCkgLSBwYXJlbnQuX3RUaW1lKSAvIC1wYXJlbnQuX3RzKSkge1xuXHRcdFx0XHRcdHBhcmVudC50b3RhbFRpbWUocGFyZW50Ll90VGltZSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudDtcblx0XHRcdH1cblx0XHRcdGlmICghdGhpcy5wYXJlbnQgJiYgdGhpcy5fZHAuYXV0b1JlbW92ZUNoaWxkcmVuICYmICgodGhpcy5fdHMgPiAwICYmIHRvdGFsVGltZSA8IHRoaXMuX3REdXIpIHx8ICh0aGlzLl90cyA8IDAgJiYgdG90YWxUaW1lID4gMCkgfHwgKCF0aGlzLl90RHVyICYmICF0b3RhbFRpbWUpICkpIHsgLy9pZiB0aGUgYW5pbWF0aW9uIGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCwgcHV0IGl0IGJhY2sgaW50byBpdHMgbGFzdCBwYXJlbnQgKHJlY29yZGVkIGFzIF9kcCBmb3IgZXhhY3RseSBjYXNlcyBsaWtlIHRoaXMpLiBMaW1pdCB0byBwYXJlbnRzIHdpdGggYXV0b1JlbW92ZUNoaWxkcmVuIChsaWtlIGdsb2JhbFRpbWVsaW5lKSBzbyB0aGF0IGlmIHRoZSB1c2VyIG1hbnVhbGx5IHJlbW92ZXMgYW4gYW5pbWF0aW9uIGZyb20gYSB0aW1lbGluZSBhbmQgdGhlbiBhbHRlcnMgaXRzIHBsYXloZWFkLCBpdCBkb2Vzbid0IGdldCBhZGRlZCBiYWNrIGluLlxuXHRcdFx0XHRfYWRkVG9UaW1lbGluZSh0aGlzLl9kcCwgdGhpcywgdGhpcy5fc3RhcnQgLSB0aGlzLl9kZWxheSk7XG5cdFx0XHR9XG5cdFx0fVxuICAgICAgICBpZiAodGhpcy5fdFRpbWUgIT09IHRvdGFsVGltZSB8fCAoIXRoaXMuX2R1ciAmJiAhc3VwcHJlc3NFdmVudHMpIHx8ICh0aGlzLl9pbml0dGVkICYmIE1hdGguYWJzKHRoaXMuX3pUaW1lKSA9PT0gX3RpbnlOdW0pIHx8ICghdG90YWxUaW1lICYmICF0aGlzLl9pbml0dGVkICYmICh0aGlzLmFkZCB8fCB0aGlzLl9wdExvb2t1cCkpKSB7IC8vIGNoZWNrIGZvciBfcHRMb29rdXAgb24gYSBUd2VlbiBpbnN0YW5jZSB0byBlbnN1cmUgaXQgaGFzIGFjdHVhbGx5IGZpbmlzaGVkIGJlaW5nIGluc3RhbnRpYXRlZCwgb3RoZXJ3aXNlIGlmIHRoaXMucmV2ZXJzZSgpIGdldHMgY2FsbGVkIGluIHRoZSBBbmltYXRpb24gY29uc3RydWN0b3IsIGl0IGNvdWxkIHRyaWdnZXIgYSByZW5kZXIoKSBoZXJlIGV2ZW4gdGhvdWdoIHRoZSBfdGFyZ2V0cyB3ZXJlbid0IHBvcHVsYXRlZCwgdGh1cyB3aGVuIF9pbml0KCkgaXMgY2FsbGVkIHRoZXJlIHdvbid0IGJlIGFueSBQcm9wVHdlZW5zIChpdCdsbCBhY3QgbGlrZSB0aGUgdHdlZW4gaXMgbm9uLWZ1bmN0aW9uYWwpXG4gICAgICAgIFx0dGhpcy5fdHMgfHwgKHRoaXMuX3BUaW1lID0gdG90YWxUaW1lKTsgLy8gb3RoZXJ3aXNlLCBpZiBhbiBhbmltYXRpb24gaXMgcGF1c2VkLCB0aGVuIHRoZSBwbGF5aGVhZCBpcyBtb3ZlZCBiYWNrIHRvIHplcm8sIHRoZW4gcmVzdW1lZCwgaXQnZCByZXZlcnQgYmFjayB0byB0aGUgb3JpZ2luYWwgdGltZSBhdCB0aGUgcGF1c2Vcblx0ICAgICAgICAvL2lmICghdGhpcy5fbG9jaykgeyAvLyBhdm9pZCBlbmRsZXNzIHJlY3Vyc2lvbiAobm90IHN1cmUgd2UgbmVlZCB0aGlzIHlldCBvciBpZiBpdCdzIHdvcnRoIHRoZSBwZXJmb3JtYW5jZSBoaXQpXG5cdFx0ICAgIC8vICAgdGhpcy5fbG9jayA9IDE7XG5cdFx0ICAgICAgICBfbGF6eVNhZmVSZW5kZXIodGhpcywgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0ICAgIC8vICAgdGhpcy5fbG9jayA9IDA7XG5cdCAgICAgICAgLy99XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0dGltZSh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKChNYXRoLm1pbih0aGlzLnRvdGFsRHVyYXRpb24oKSwgdmFsdWUgKyBfZWxhcHNlZEN5Y2xlRHVyYXRpb24odGhpcykpICUgdGhpcy5fZHVyKSB8fCAodmFsdWUgPyB0aGlzLl9kdXIgOiAwKSwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy5fdGltZTsgLy8gbm90ZTogaWYgdGhlIG1vZHVsdXMgcmVzdWx0cyBpbiAwLCB0aGUgcGxheWhlYWQgY291bGQgYmUgZXhhY3RseSBhdCB0aGUgZW5kIG9yIHRoZSBiZWdpbm5pbmcsIGFuZCB3ZSBhbHdheXMgZGVmZXIgdG8gdGhlIEVORCB3aXRoIGEgbm9uLXplcm8gdmFsdWUsIG90aGVyd2lzZSBpZiB5b3Ugc2V0IHRoZSB0aW1lKCkgdG8gdGhlIHZlcnkgZW5kIChkdXJhdGlvbigpKSwgaXQgd291bGQgcmVuZGVyIGF0IHRoZSBTVEFSVCFcblx0fVxuXG5cdHRvdGFsUHJvZ3Jlc3ModmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZSggdGhpcy50b3RhbER1cmF0aW9uKCkgKiB2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy50b3RhbER1cmF0aW9uKCkgPyBNYXRoLm1pbigxLCB0aGlzLl90VGltZSAvIHRoaXMuX3REdXIpIDogdGhpcy5yYXRpbztcblx0fVxuXG5cdHByb2dyZXNzKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUoIHRoaXMuZHVyYXRpb24oKSAqICh0aGlzLl95b3lvICYmICEodGhpcy5pdGVyYXRpb24oKSAmIDEpID8gMSAtIHZhbHVlIDogdmFsdWUpICsgX2VsYXBzZWRDeWNsZUR1cmF0aW9uKHRoaXMpLCBzdXBwcmVzc0V2ZW50cykgOiAodGhpcy5kdXJhdGlvbigpID8gTWF0aC5taW4oMSwgdGhpcy5fdGltZSAvIHRoaXMuX2R1cikgOiB0aGlzLnJhdGlvKTtcblx0fVxuXG5cdGl0ZXJhdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRsZXQgY3ljbGVEdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKSArIHRoaXMuX3JEZWxheTtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMuX3RpbWUgKyAodmFsdWUgLSAxKSAqIGN5Y2xlRHVyYXRpb24sIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbikgKyAxIDogMTtcblx0fVxuXG5cdC8vIHBvdGVudGlhbCBmdXR1cmUgYWRkaXRpb246XG5cdC8vIGlzUGxheWluZ0JhY2t3YXJkcygpIHtcblx0Ly8gXHRsZXQgYW5pbWF0aW9uID0gdGhpcyxcblx0Ly8gXHRcdG9yaWVudGF0aW9uID0gMTsgLy8gMSA9IGZvcndhcmQsIC0xID0gYmFja3dhcmRcblx0Ly8gXHR3aGlsZSAoYW5pbWF0aW9uKSB7XG5cdC8vIFx0XHRvcmllbnRhdGlvbiAqPSBhbmltYXRpb24ucmV2ZXJzZWQoKSB8fCAoYW5pbWF0aW9uLnJlcGVhdCgpICYmICEoYW5pbWF0aW9uLml0ZXJhdGlvbigpICYgMSkpID8gLTEgOiAxO1xuXHQvLyBcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uLnBhcmVudDtcblx0Ly8gXHR9XG5cdC8vIFx0cmV0dXJuIG9yaWVudGF0aW9uIDwgMDtcblx0Ly8gfVxuXG5cdHRpbWVTY2FsZSh2YWx1ZSkge1xuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3J0cyA9PT0gLV90aW55TnVtID8gMCA6IHRoaXMuX3J0czsgLy8gcmVjb3JkZWQgdGltZVNjYWxlLiBTcGVjaWFsIGNhc2U6IGlmIHNvbWVvbmUgY2FsbHMgcmV2ZXJzZSgpIG9uIGFuIGFuaW1hdGlvbiB3aXRoIHRpbWVTY2FsZSBvZiAwLCB3ZSBhc3NpZ24gaXQgLV90aW55TnVtIHRvIHJlbWVtYmVyIGl0J3MgcmV2ZXJzZWQuXG5cdFx0fVxuXHRcdGlmICh0aGlzLl9ydHMgPT09IHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0bGV0IHRUaW1lID0gdGhpcy5wYXJlbnQgJiYgdGhpcy5fdHMgPyBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSh0aGlzLnBhcmVudC5fdGltZSwgdGhpcykgOiB0aGlzLl90VGltZTsgLy8gbWFrZSBzdXJlIHRvIGRvIHRoZSBwYXJlbnRUb0NoaWxkVG90YWxUaW1lKCkgQkVGT1JFIHNldHRpbmcgdGhlIG5ldyBfdHMgYmVjYXVzZSB0aGUgb2xkIG9uZSBtdXN0IGJlIHVzZWQgaW4gdGhhdCBjYWxjdWxhdGlvbi5cblxuXHRcdC8vIGZ1dHVyZSBhZGRpdGlvbj8gVXAgc2lkZTogZmFzdCBhbmQgbWluaW1hbCBmaWxlIHNpemUuIERvd24gc2lkZTogb25seSB3b3JrcyBvbiB0aGlzIGFuaW1hdGlvbjsgaWYgYSB0aW1lbGluZSBpcyByZXZlcnNlZCwgZm9yIGV4YW1wbGUsIGl0cyBjaGlsZHJlbnMnIG9uUmV2ZXJzZSB3b3VsZG4ndCBnZXQgY2FsbGVkLlxuXHRcdC8vKCt2YWx1ZSA8IDAgJiYgdGhpcy5fcnRzID49IDApICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmV2ZXJzZVwiLCB0cnVlKTtcblxuXHRcdC8vIHByaW9yaXRpemUgcmVuZGVyaW5nIHdoZXJlIHRoZSBwYXJlbnQncyBwbGF5aGVhZCBsaW5lcyB1cCBpbnN0ZWFkIG9mIHRoaXMuX3RUaW1lIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgYSB0d2VlbiB0aGF0J3MgYW5pbWF0aW5nIGFub3RoZXIgdHdlZW4ncyB0aW1lU2NhbGUgaW4gdGhlIHNhbWUgcmVuZGVyaW5nIGxvb3AgKHNhbWUgcGFyZW50KSwgdGh1cyBpZiB0aGUgdGltZVNjYWxlIHR3ZWVuIHJlbmRlcnMgZmlyc3QsIGl0IHdvdWxkIGFsdGVyIF9zdGFydCBCRUZPUkUgX3RUaW1lIHdhcyBzZXQgb24gdGhhdCB0aWNrIChpbiB0aGUgcmVuZGVyaW5nIGxvb3ApLCBlZmZlY3RpdmVseSBmcmVlemluZyBpdCB1bnRpbCB0aGUgdGltZVNjYWxlIHR3ZWVuIGZpbmlzaGVzLlxuXHRcdHRoaXMuX3J0cyA9ICt2YWx1ZSB8fCAwO1xuXHRcdHRoaXMuX3RzID0gKHRoaXMuX3BzIHx8IHZhbHVlID09PSAtX3RpbnlOdW0pID8gMCA6IHRoaXMuX3J0czsgLy8gX3RzIGlzIHRoZSBmdW5jdGlvbmFsIHRpbWVTY2FsZSB3aGljaCB3b3VsZCBiZSAwIGlmIHRoZSBhbmltYXRpb24gaXMgcGF1c2VkLlxuXHRcdHJldHVybiBfcmVjYWNoZUFuY2VzdG9ycyh0aGlzLnRvdGFsVGltZShfY2xhbXAoLXRoaXMuX2RlbGF5LCB0aGlzLl90RHVyLCB0VGltZSksIHRydWUpKTtcblx0fVxuXG5cdHBhdXNlZCh2YWx1ZSkge1xuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3BzO1xuXHRcdH1cblx0XHRpZiAodGhpcy5fcHMgIT09IHZhbHVlKSB7XG5cdFx0XHR0aGlzLl9wcyA9IHZhbHVlO1xuXHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdHRoaXMuX3BUaW1lID0gdGhpcy5fdFRpbWUgfHwgTWF0aC5tYXgoLXRoaXMuX2RlbGF5LCB0aGlzLnJhd1RpbWUoKSk7IC8vIGlmIHRoZSBwYXVzZSBvY2N1cnMgZHVyaW5nIHRoZSBkZWxheSBwaGFzZSwgbWFrZSBzdXJlIHRoYXQncyBmYWN0b3JlZCBpbiB3aGVuIHJlc3VtaW5nLlxuXHRcdFx0XHR0aGlzLl90cyA9IHRoaXMuX2FjdCA9IDA7IC8vIF90cyBpcyB0aGUgZnVuY3Rpb25hbCB0aW1lU2NhbGUsIHNvIGEgcGF1c2VkIHR3ZWVuIHdvdWxkIGVmZmVjdGl2ZWx5IGhhdmUgYSB0aW1lU2NhbGUgb2YgMC4gV2UgcmVjb3JkIHRoZSBcInJlYWxcIiB0aW1lU2NhbGUgYXMgX3J0cyAocmVjb3JkZWQgdGltZSBzY2FsZSlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF93YWtlKCk7XG5cdFx0XHRcdHRoaXMuX3RzID0gdGhpcy5fcnRzO1xuXHRcdFx0XHQvL29ubHkgZGVmZXIgdG8gX3BUaW1lIChwYXVzZVRpbWUpIGlmIHRUaW1lIGlzIHplcm8uIFJlbWVtYmVyLCBzb21lb25lIGNvdWxkIHBhdXNlKCkgYW4gYW5pbWF0aW9uLCB0aGVuIHNjcnViIHRoZSBwbGF5aGVhZCBhbmQgcmVzdW1lKCkuIElmIHRoZSBwYXJlbnQgZG9lc24ndCBoYXZlIHNtb290aENoaWxkVGltaW5nLCB3ZSByZW5kZXIgYXQgdGhlIHJhd1RpbWUoKSBiZWNhdXNlIHRoZSBzdGFydFRpbWUgd29uJ3QgZ2V0IHVwZGF0ZWQuXG5cdFx0XHRcdHRoaXMudG90YWxUaW1lKHRoaXMucGFyZW50ICYmICF0aGlzLnBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyA/IHRoaXMucmF3VGltZSgpIDogdGhpcy5fdFRpbWUgfHwgdGhpcy5fcFRpbWUsICh0aGlzLnByb2dyZXNzKCkgPT09IDEpICYmICh0aGlzLl90VGltZSAtPSBfdGlueU51bSkgJiYgTWF0aC5hYnModGhpcy5felRpbWUpICE9PSBfdGlueU51bSk7IC8vIGVkZ2UgY2FzZTogYW5pbWF0aW9uLnByb2dyZXNzKDEpLnBhdXNlKCkucGxheSgpIHdvdWxkbid0IHJlbmRlciBhZ2FpbiBiZWNhdXNlIHRoZSBwbGF5aGVhZCBpcyBhbHJlYWR5IGF0IHRoZSBlbmQsIGJ1dCB0aGUgY2FsbCB0byB0b3RhbFRpbWUoKSBiZWxvdyB3aWxsIGFkZCBpdCBiYWNrIHRvIGl0cyBwYXJlbnQuLi5hbmQgbm90IHJlbW92ZSBpdCBhZ2FpbiAoc2luY2UgcmVtb3Zpbmcgb25seSBoYXBwZW5zIHVwb24gcmVuZGVyaW5nIGF0IGEgbmV3IHRpbWUpLiBPZmZzZXR0aW5nIHRoZSBfdFRpbWUgc2xpZ2h0bHkgaXMgZG9uZSBzaW1wbHkgdG8gY2F1c2UgdGhlIGZpbmFsIHJlbmRlciBpbiB0b3RhbFRpbWUoKSB0aGF0J2xsIHBvcCBpdCBvZmYgaXRzIHRpbWVsaW5lIChpZiBhdXRvUmVtb3ZlQ2hpbGRyZW4gaXMgdHJ1ZSwgb2YgY291cnNlKS4gQ2hlY2sgdG8gbWFrZSBzdXJlIF96VGltZSBpc24ndCAtX3RpbnlOdW0gdG8gYXZvaWQgYW4gZWRnZSBjYXNlIHdoZXJlIHRoZSBwbGF5aGVhZCBpcyBwdXNoZWQgdG8gdGhlIGVuZCBidXQgSU5TSURFIGEgdHdlZW4vY2FsbGJhY2ssIHRoZSB0aW1lbGluZSBpdHNlbGYgaXMgcGF1c2VkIHRodXMgaGFsdGluZyByZW5kZXJpbmcgYW5kIGxlYXZpbmcgYSBmZXcgdW5yZW5kZXJlZC4gV2hlbiByZXN1bWluZywgaXQgd291bGRuJ3QgcmVuZGVyIHRob3NlIG90aGVyd2lzZS5cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRzdGFydFRpbWUodmFsdWUpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5fc3RhcnQgPSB2YWx1ZTtcblx0XHRcdGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLl9kcDtcblx0XHRcdHBhcmVudCAmJiAocGFyZW50Ll9zb3J0IHx8ICF0aGlzLnBhcmVudCkgJiYgX2FkZFRvVGltZWxpbmUocGFyZW50LCB0aGlzLCB2YWx1ZSAtIHRoaXMuX2RlbGF5KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fc3RhcnQ7XG5cdH1cblxuXHRlbmRUaW1lKGluY2x1ZGVSZXBlYXRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0YXJ0ICsgKF9pc05vdEZhbHNlKGluY2x1ZGVSZXBlYXRzKSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5kdXJhdGlvbigpKSAvIE1hdGguYWJzKHRoaXMuX3RzKTtcblx0fVxuXG5cdHJhd1RpbWUod3JhcFJlcGVhdHMpIHtcblx0XHRsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHA7IC8vIF9kcCA9IGRldGFjaGVkIHBhcmVudFxuXHRcdHJldHVybiAhcGFyZW50ID8gdGhpcy5fdFRpbWUgOiAod3JhcFJlcGVhdHMgJiYgKCF0aGlzLl90cyB8fCAodGhpcy5fcmVwZWF0ICYmIHRoaXMuX3RpbWUgJiYgdGhpcy50b3RhbFByb2dyZXNzKCkgPCAxKSkpID8gdGhpcy5fdFRpbWUgJSAodGhpcy5fZHVyICsgdGhpcy5fckRlbGF5KSA6ICF0aGlzLl90cyA/IHRoaXMuX3RUaW1lIDogX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUocGFyZW50LnJhd1RpbWUod3JhcFJlcGVhdHMpLCB0aGlzKTtcblx0fVxuXG5cdGdsb2JhbFRpbWUocmF3VGltZSkge1xuXHRcdGxldCBhbmltYXRpb24gPSB0aGlzLFxuXHRcdFx0dGltZSA9IGFyZ3VtZW50cy5sZW5ndGggPyByYXdUaW1lIDogYW5pbWF0aW9uLnJhd1RpbWUoKTtcblx0XHR3aGlsZSAoYW5pbWF0aW9uKSB7XG5cdFx0XHR0aW1lID0gYW5pbWF0aW9uLl9zdGFydCArIHRpbWUgLyAoYW5pbWF0aW9uLl90cyB8fCAxKTtcblx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5fZHA7XG5cdFx0fVxuXHRcdHJldHVybiB0aW1lO1xuXHR9XG5cblx0cmVwZWF0KHZhbHVlKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuX3JlcGVhdCA9IHZhbHVlID09PSBJbmZpbml0eSA/IC0yIDogdmFsdWU7XG5cdFx0XHRyZXR1cm4gX29uVXBkYXRlVG90YWxEdXJhdGlvbih0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3JlcGVhdCA9PT0gLTIgPyBJbmZpbml0eSA6IHRoaXMuX3JlcGVhdDtcblx0fVxuXG5cdHJlcGVhdERlbGF5KHZhbHVlKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuX3JEZWxheSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24odGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9yRGVsYXk7XG5cdH1cblxuXHR5b3lvKHZhbHVlKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuX3lveW8gPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5feW95bztcblx0fVxuXG5cdHNlZWsocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSwgX2lzTm90RmFsc2Uoc3VwcHJlc3NFdmVudHMpKTtcblx0fVxuXG5cdHJlc3RhcnQoaW5jbHVkZURlbGF5LCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdHJldHVybiB0aGlzLnBsYXkoKS50b3RhbFRpbWUoaW5jbHVkZURlbGF5ID8gLXRoaXMuX2RlbGF5IDogMCwgX2lzTm90RmFsc2Uoc3VwcHJlc3NFdmVudHMpKTtcblx0fVxuXG5cdHBsYXkoZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRmcm9tICE9IG51bGwgJiYgdGhpcy5zZWVrKGZyb20sIHN1cHByZXNzRXZlbnRzKTtcblx0XHRyZXR1cm4gdGhpcy5yZXZlcnNlZChmYWxzZSkucGF1c2VkKGZhbHNlKTtcblx0fVxuXG5cdHJldmVyc2UoZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRmcm9tICE9IG51bGwgJiYgdGhpcy5zZWVrKGZyb20gfHwgdGhpcy50b3RhbER1cmF0aW9uKCksIHN1cHByZXNzRXZlbnRzKTtcblx0XHRyZXR1cm4gdGhpcy5yZXZlcnNlZCh0cnVlKS5wYXVzZWQoZmFsc2UpO1xuXHR9XG5cblx0cGF1c2UoYXRUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdGF0VGltZSAhPSBudWxsICYmIHRoaXMuc2VlayhhdFRpbWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHRyZXR1cm4gdGhpcy5wYXVzZWQodHJ1ZSk7XG5cdH1cblxuXHRyZXN1bWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGF1c2VkKGZhbHNlKTtcblx0fVxuXG5cdHJldmVyc2VkKHZhbHVlKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdCEhdmFsdWUgIT09IHRoaXMucmV2ZXJzZWQoKSAmJiB0aGlzLnRpbWVTY2FsZSgtdGhpcy5fcnRzIHx8ICh2YWx1ZSA/IC1fdGlueU51bSA6IDApKTsgLy8gaW4gY2FzZSB0aW1lU2NhbGUgaXMgemVybywgcmV2ZXJzaW5nIHdvdWxkIGhhdmUgbm8gZWZmZWN0IHNvIHdlIHVzZSBfdGlueU51bS5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fcnRzIDwgMDtcblx0fVxuXG5cdGludmFsaWRhdGUoKSB7XG5cdFx0dGhpcy5faW5pdHRlZCA9IHRoaXMuX2FjdCA9IDA7XG5cdFx0dGhpcy5felRpbWUgPSAtX3RpbnlOdW07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRpc0FjdGl2ZSgpIHtcblx0XHRsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHAsXG5cdFx0XHRzdGFydCA9IHRoaXMuX3N0YXJ0LFxuXHRcdFx0cmF3VGltZTtcblx0XHRyZXR1cm4gISEoIXBhcmVudCB8fCAodGhpcy5fdHMgJiYgdGhpcy5faW5pdHRlZCAmJiBwYXJlbnQuaXNBY3RpdmUoKSAmJiAocmF3VGltZSA9IHBhcmVudC5yYXdUaW1lKHRydWUpKSA+PSBzdGFydCAmJiByYXdUaW1lIDwgdGhpcy5lbmRUaW1lKHRydWUpIC0gX3RpbnlOdW0pKTtcblx0fVxuXG5cdGV2ZW50Q2FsbGJhY2sodHlwZSwgY2FsbGJhY2ssIHBhcmFtcykge1xuXHRcdGxldCB2YXJzID0gdGhpcy52YXJzO1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0aWYgKCFjYWxsYmFjaykge1xuXHRcdFx0XHRkZWxldGUgdmFyc1t0eXBlXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhcnNbdHlwZV0gPSBjYWxsYmFjaztcblx0XHRcdFx0cGFyYW1zICYmICh2YXJzW3R5cGUgKyBcIlBhcmFtc1wiXSA9IHBhcmFtcyk7XG5cdFx0XHRcdHR5cGUgPT09IFwib25VcGRhdGVcIiAmJiAodGhpcy5fb25VcGRhdGUgPSBjYWxsYmFjayk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0cmV0dXJuIHZhcnNbdHlwZV07XG5cdH1cblxuXHR0aGVuKG9uRnVsZmlsbGVkKSB7XG5cdFx0bGV0IHNlbGYgPSB0aGlzO1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcblx0XHRcdGxldCBmID0gX2lzRnVuY3Rpb24ob25GdWxmaWxsZWQpID8gb25GdWxmaWxsZWQgOiBfcGFzc1Rocm91Z2gsXG5cdFx0XHRcdF9yZXNvbHZlID0gKCkgPT4ge1xuXHRcdFx0XHRcdGxldCBfdGhlbiA9IHNlbGYudGhlbjtcblx0XHRcdFx0XHRzZWxmLnRoZW4gPSBudWxsOyAvLyB0ZW1wb3JhcmlseSBudWxsIHRoZSB0aGVuKCkgbWV0aG9kIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JlZW5zb2NrL0dTQVAvaXNzdWVzLzMyMilcblx0XHRcdFx0XHRfaXNGdW5jdGlvbihmKSAmJiAoZiA9IGYoc2VsZikpICYmIChmLnRoZW4gfHwgZiA9PT0gc2VsZikgJiYgKHNlbGYudGhlbiA9IF90aGVuKTtcblx0XHRcdFx0XHRyZXNvbHZlKGYpO1xuXHRcdFx0XHRcdHNlbGYudGhlbiA9IF90aGVuO1xuXHRcdFx0XHR9O1xuXHRcdFx0aWYgKHNlbGYuX2luaXR0ZWQgJiYgKHNlbGYudG90YWxQcm9ncmVzcygpID09PSAxICYmIHNlbGYuX3RzID49IDApIHx8ICghc2VsZi5fdFRpbWUgJiYgc2VsZi5fdHMgPCAwKSkge1xuXHRcdFx0XHRfcmVzb2x2ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5fcHJvbSA9IF9yZXNvbHZlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0a2lsbCgpIHtcblx0XHRfaW50ZXJydXB0KHRoaXMpO1xuXHR9XG5cbn1cblxuX3NldERlZmF1bHRzKEFuaW1hdGlvbi5wcm90b3R5cGUsIHtfdGltZTowLCBfc3RhcnQ6MCwgX2VuZDowLCBfdFRpbWU6MCwgX3REdXI6MCwgX2RpcnR5OjAsIF9yZXBlYXQ6MCwgX3lveW86ZmFsc2UsIHBhcmVudDpudWxsLCBfaW5pdHRlZDpmYWxzZSwgX3JEZWxheTowLCBfdHM6MSwgX2RwOjAsIHJhdGlvOjAsIF96VGltZTotX3RpbnlOdW0sIF9wcm9tOjAsIF9wczpmYWxzZSwgX3J0czoxfSk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVElNRUxJTkVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5leHBvcnQgY2xhc3MgVGltZWxpbmUgZXh0ZW5kcyBBbmltYXRpb24ge1xuXG5cdGNvbnN0cnVjdG9yKHZhcnMgPSB7fSwgcG9zaXRpb24pIHtcblx0XHRzdXBlcih2YXJzKTtcblx0XHR0aGlzLmxhYmVscyA9IHt9O1xuXHRcdHRoaXMuc21vb3RoQ2hpbGRUaW1pbmcgPSAhIXZhcnMuc21vb3RoQ2hpbGRUaW1pbmc7XG5cdFx0dGhpcy5hdXRvUmVtb3ZlQ2hpbGRyZW4gPSAhIXZhcnMuYXV0b1JlbW92ZUNoaWxkcmVuO1xuXHRcdHRoaXMuX3NvcnQgPSBfaXNOb3RGYWxzZSh2YXJzLnNvcnRDaGlsZHJlbik7XG5cdFx0X2dsb2JhbFRpbWVsaW5lICYmIF9hZGRUb1RpbWVsaW5lKHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZSwgdGhpcywgcG9zaXRpb24pO1xuXHRcdHZhcnMucmV2ZXJzZWQgJiYgdGhpcy5yZXZlcnNlKCk7XG5cdFx0dmFycy5wYXVzZWQgJiYgdGhpcy5wYXVzZWQodHJ1ZSk7XG5cdFx0dmFycy5zY3JvbGxUcmlnZ2VyICYmIF9zY3JvbGxUcmlnZ2VyKHRoaXMsIHZhcnMuc2Nyb2xsVHJpZ2dlcik7XG5cdH1cblxuXHR0byh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuXHRcdF9jcmVhdGVUd2VlblR5cGUoMCwgYXJndW1lbnRzLCB0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGZyb20odGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcblx0XHRfY3JlYXRlVHdlZW5UeXBlKDEsIGFyZ3VtZW50cywgdGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRmcm9tVG8odGFyZ2V0cywgZnJvbVZhcnMsIHRvVmFycywgcG9zaXRpb24pIHtcblx0XHRfY3JlYXRlVHdlZW5UeXBlKDIsIGFyZ3VtZW50cywgdGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRzZXQodGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcblx0XHR2YXJzLmR1cmF0aW9uID0gMDtcblx0XHR2YXJzLnBhcmVudCA9IHRoaXM7XG5cdFx0X2luaGVyaXREZWZhdWx0cyh2YXJzKS5yZXBlYXREZWxheSB8fCAodmFycy5yZXBlYXQgPSAwKTtcblx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICEhdmFycy5pbW1lZGlhdGVSZW5kZXI7XG5cdFx0bmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSwgMSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRjYWxsKGNhbGxiYWNrLCBwYXJhbXMsIHBvc2l0aW9uKSB7XG5cdFx0cmV0dXJuIF9hZGRUb1RpbWVsaW5lKHRoaXMsIFR3ZWVuLmRlbGF5ZWRDYWxsKDAsIGNhbGxiYWNrLCBwYXJhbXMpLCBwb3NpdGlvbik7XG5cdH1cblxuXHQvL09OTFkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkhIE1heWJlIGRlbGV0ZT9cblx0c3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuXHRcdHZhcnMuZHVyYXRpb24gPSBkdXJhdGlvbjtcblx0XHR2YXJzLnN0YWdnZXIgPSB2YXJzLnN0YWdnZXIgfHwgc3RhZ2dlcjtcblx0XHR2YXJzLm9uQ29tcGxldGUgPSBvbkNvbXBsZXRlQWxsO1xuXHRcdHZhcnMub25Db21wbGV0ZVBhcmFtcyA9IG9uQ29tcGxldGVBbGxQYXJhbXM7XG5cdFx0dmFycy5wYXJlbnQgPSB0aGlzO1xuXHRcdG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbikpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0c3RhZ2dlckZyb20odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKSB7XG5cdFx0dmFycy5ydW5CYWNrd2FyZHMgPSAxO1xuXHRcdF9pbmhlcml0RGVmYXVsdHModmFycykuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UodmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuXHRcdHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpO1xuXHR9XG5cblx0c3RhZ2dlckZyb21Ubyh0YXJnZXRzLCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpIHtcblx0XHR0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuXHRcdF9pbmhlcml0RGVmYXVsdHModG9WYXJzKS5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZSh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyKTtcblx0XHRyZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpO1xuXHR9XG5cblx0cmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0bGV0IHByZXZUaW1lID0gdGhpcy5fdGltZSxcblx0XHRcdHREdXIgPSB0aGlzLl9kaXJ0eSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5fdER1cixcblx0XHRcdGR1ciA9IHRoaXMuX2R1cixcblx0XHRcdHRUaW1lID0gKHRoaXMgIT09IF9nbG9iYWxUaW1lbGluZSAmJiB0b3RhbFRpbWUgPiB0RHVyIC0gX3RpbnlOdW0gJiYgdG90YWxUaW1lID49IDApID8gdER1ciA6ICh0b3RhbFRpbWUgPCBfdGlueU51bSkgPyAwIDogdG90YWxUaW1lLFxuXHRcdFx0Y3Jvc3NpbmdTdGFydCA9ICh0aGlzLl96VGltZSA8IDApICE9PSAodG90YWxUaW1lIDwgMCkgJiYgKHRoaXMuX2luaXR0ZWQgfHwgIWR1ciksXG5cdFx0XHR0aW1lLCBjaGlsZCwgbmV4dCwgaXRlcmF0aW9uLCBjeWNsZUR1cmF0aW9uLCBwcmV2UGF1c2VkLCBwYXVzZVR3ZWVuLCB0aW1lU2NhbGUsIHByZXZTdGFydCwgcHJldkl0ZXJhdGlvbiwgeW95bywgaXNZb3lvO1xuXHRcdGlmICh0VGltZSAhPT0gdGhpcy5fdFRpbWUgfHwgZm9yY2UgfHwgY3Jvc3NpbmdTdGFydCkge1xuXHRcdFx0aWYgKHByZXZUaW1lICE9PSB0aGlzLl90aW1lICYmIGR1cikgeyAvL2lmIHRvdGFsRHVyYXRpb24oKSBmaW5kcyBhIGNoaWxkIHdpdGggYSBuZWdhdGl2ZSBzdGFydFRpbWUgYW5kIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUsIHRoaW5ncyBnZXQgc2hpZnRlZCBhcm91bmQgaW50ZXJuYWxseSBzbyB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgdGltZSBhY2NvcmRpbmdseS4gRm9yIGV4YW1wbGUsIGlmIGEgdHdlZW4gc3RhcnRzIGF0IC0zMCB3ZSBtdXN0IHNoaWZ0IEVWRVJZVEhJTkcgZm9yd2FyZCAzMCBzZWNvbmRzIGFuZCBtb3ZlIHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUgYmFja3dhcmQgYnkgMzAgc2Vjb25kcyBzbyB0aGF0IHRoaW5ncyBhbGlnbiB3aXRoIHRoZSBwbGF5aGVhZCAobm8ganVtcCkuXG5cdFx0XHRcdHRUaW1lICs9IHRoaXMuX3RpbWUgLSBwcmV2VGltZTtcblx0XHRcdFx0dG90YWxUaW1lICs9IHRoaXMuX3RpbWUgLSBwcmV2VGltZTtcblx0XHRcdH1cblx0XHRcdHRpbWUgPSB0VGltZTtcblx0XHRcdHByZXZTdGFydCA9IHRoaXMuX3N0YXJ0O1xuXHRcdFx0dGltZVNjYWxlID0gdGhpcy5fdHM7XG5cdFx0XHRwcmV2UGF1c2VkID0gIXRpbWVTY2FsZTtcblx0XHRcdGlmIChjcm9zc2luZ1N0YXJ0KSB7XG5cdFx0XHRcdGR1ciB8fCAocHJldlRpbWUgPSB0aGlzLl96VGltZSk7XG5cdFx0XHRcdCAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LlxuXHRcdFx0XHQodG90YWxUaW1lIHx8ICFzdXBwcmVzc0V2ZW50cykgJiYgKHRoaXMuX3pUaW1lID0gdG90YWxUaW1lKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9yZXBlYXQpIHsgLy9hZGp1c3QgdGhlIHRpbWUgZm9yIHJlcGVhdHMgYW5kIHlveW9zXG5cdFx0XHRcdHlveW8gPSB0aGlzLl95b3lvO1xuXHRcdFx0XHRjeWNsZUR1cmF0aW9uID0gZHVyICsgdGhpcy5fckRlbGF5O1xuXHRcdFx0XHRpZiAodGhpcy5fcmVwZWF0IDwgLTEgJiYgdG90YWxUaW1lIDwgMCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZShjeWNsZUR1cmF0aW9uICogMTAwICsgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRpbWUgPSBfcm91bmQodFRpbWUgJSBjeWNsZUR1cmF0aW9uKTsgLy9yb3VuZCB0byBhdm9pZCBmbG9hdGluZyBwb2ludCBlcnJvcnMuICg0ICUgMC44IHNob3VsZCBiZSAwIGJ1dCBzb21lIGJyb3dzZXJzIHJlcG9ydCBpdCBhcyAwLjc5OTk5OTk5ISlcblx0XHRcdFx0aWYgKHRUaW1lID09PSB0RHVyKSB7IC8vIHRoZSB0RHVyID09PSB0VGltZSBpcyBmb3IgZWRnZSBjYXNlcyB3aGVyZSB0aGVyZSdzIGEgbGVuZ3RoeSBkZWNpbWFsIG9uIHRoZSBkdXJhdGlvbiBhbmQgaXQgbWF5IHJlYWNoIHRoZSB2ZXJ5IGVuZCBidXQgdGhlIHRpbWUgaXMgcmVuZGVyZWQgYXMgbm90LXF1aXRlLXRoZXJlIChyZW1lbWJlciwgdER1ciBpcyByb3VuZGVkIHRvIDQgZGVjaW1hbHMgd2hlcmVhcyBkdXIgaXNuJ3QpXG5cdFx0XHRcdFx0aXRlcmF0aW9uID0gdGhpcy5fcmVwZWF0O1xuXHRcdFx0XHRcdHRpbWUgPSBkdXI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aXRlcmF0aW9uID0gfn4odFRpbWUgLyBjeWNsZUR1cmF0aW9uKTtcblx0XHRcdFx0XHRpZiAoaXRlcmF0aW9uICYmIGl0ZXJhdGlvbiA9PT0gdFRpbWUgLyBjeWNsZUR1cmF0aW9uKSB7XG5cdFx0XHRcdFx0XHR0aW1lID0gZHVyO1xuXHRcdFx0XHRcdFx0aXRlcmF0aW9uLS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRpbWUgPiBkdXIgJiYgKHRpbWUgPSBkdXIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHByZXZJdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodGhpcy5fdFRpbWUsIGN5Y2xlRHVyYXRpb24pO1xuXHRcdFx0XHQhcHJldlRpbWUgJiYgdGhpcy5fdFRpbWUgJiYgcHJldkl0ZXJhdGlvbiAhPT0gaXRlcmF0aW9uICYmIChwcmV2SXRlcmF0aW9uID0gaXRlcmF0aW9uKTsgLy8gZWRnZSBjYXNlIC0gaWYgc29tZW9uZSBkb2VzIGFkZFBhdXNlKCkgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIGEgcmVwZWF0aW5nIHRpbWVsaW5lLCB0aGF0IHBhdXNlIGlzIHRlY2huaWNhbGx5IGF0IHRoZSBzYW1lIHNwb3QgYXMgdGhlIGVuZCB3aGljaCBjYXVzZXMgdGhpcy5fdGltZSB0byBnZXQgc2V0IHRvIDAgd2hlbiB0aGUgdG90YWxUaW1lIHdvdWxkIG5vcm1hbGx5IHBsYWNlIHRoZSBwbGF5aGVhZCBhdCB0aGUgZW5kLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMzgyMy1jbG9zaW5nLW5hdi1hbmltYXRpb24tbm90LXdvcmtpbmctb24taWUtYW5kLWlwaG9uZS02LW1heWJlLW90aGVyLW9sZGVyLWJyb3dzZXIvP3RhYj1jb21tZW50cyNjb21tZW50LTExMzAwNVxuXHRcdFx0XHRpZiAoeW95byAmJiAoaXRlcmF0aW9uICYgMSkpIHtcblx0XHRcdFx0XHR0aW1lID0gZHVyIC0gdGltZTtcblx0XHRcdFx0XHRpc1lveW8gPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8qXG5cdFx0XHRcdG1ha2Ugc3VyZSBjaGlsZHJlbiBhdCB0aGUgZW5kL2JlZ2lubmluZyBvZiB0aGUgdGltZWxpbmUgYXJlIHJlbmRlcmVkIHByb3Blcmx5LiBJZiwgZm9yIGV4YW1wbGUsXG5cdFx0XHRcdGEgMy1zZWNvbmQgbG9uZyB0aW1lbGluZSByZW5kZXJlZCBhdCAyLjkgc2Vjb25kcyBwcmV2aW91c2x5LCBhbmQgbm93IHJlbmRlcnMgYXQgMy4yIHNlY29uZHMgKHdoaWNoXG5cdFx0XHRcdHdvdWxkIGdldCB0cmFuc2xhdGVkIHRvIDIuOCBzZWNvbmRzIGlmIHRoZSB0aW1lbGluZSB5b3lvcyBvciAwLjIgc2Vjb25kcyBpZiBpdCBqdXN0IHJlcGVhdHMpLCB0aGVyZVxuXHRcdFx0XHRjb3VsZCBiZSBhIGNhbGxiYWNrIG9yIGEgc2hvcnQgdHdlZW4gdGhhdCdzIGF0IDIuOTUgb3IgMyBzZWNvbmRzIGluIHdoaWNoIHdvdWxkbid0IHJlbmRlci4gU29cblx0XHRcdFx0d2UgbmVlZCB0byBwdXNoIHRoZSB0aW1lbGluZSB0byB0aGUgZW5kIChhbmQvb3IgYmVnaW5uaW5nIGRlcGVuZGluZyBvbiBpdHMgeW95byB2YWx1ZSkuIEFsc28gd2UgbXVzdFxuXHRcdFx0XHRlbnN1cmUgdGhhdCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb3IgZW5kIG9mIHRoZSBUaW1lbGluZSB3b3JrLlxuXHRcdFx0XHQqL1xuXHRcdFx0XHRpZiAoaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uICYmICF0aGlzLl9sb2NrKSB7XG5cdFx0XHRcdFx0bGV0IHJld2luZGluZyA9ICh5b3lvICYmIChwcmV2SXRlcmF0aW9uICYgMSkpLFxuXHRcdFx0XHRcdFx0ZG9lc1dyYXAgPSAocmV3aW5kaW5nID09PSAoeW95byAmJiAoaXRlcmF0aW9uICYgMSkpKTtcblx0XHRcdFx0XHRpdGVyYXRpb24gPCBwcmV2SXRlcmF0aW9uICYmIChyZXdpbmRpbmcgPSAhcmV3aW5kaW5nKTtcblx0XHRcdFx0XHRwcmV2VGltZSA9IHJld2luZGluZyA/IDAgOiBkdXI7XG5cdFx0XHRcdFx0dGhpcy5fbG9jayA9IDE7XG5cdFx0XHRcdFx0dGhpcy5yZW5kZXIocHJldlRpbWUgfHwgKGlzWW95byA/IDAgOiBfcm91bmQoaXRlcmF0aW9uICogY3ljbGVEdXJhdGlvbikpLCBzdXBwcmVzc0V2ZW50cywgIWR1cikuX2xvY2sgPSAwO1xuXHRcdFx0XHRcdHRoaXMuX3RUaW1lID0gdFRpbWU7IC8vIGlmIGEgdXNlciBnZXRzIHRoZSBpdGVyYXRpb24oKSBpbnNpZGUgdGhlIG9uUmVwZWF0LCBmb3IgZXhhbXBsZSwgaXQgc2hvdWxkIGJlIGFjY3VyYXRlLlxuXHRcdFx0XHRcdCFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnBhcmVudCAmJiBfY2FsbGJhY2sodGhpcywgXCJvblJlcGVhdFwiKTtcblx0XHRcdFx0XHR0aGlzLnZhcnMucmVwZWF0UmVmcmVzaCAmJiAhaXNZb3lvICYmICh0aGlzLmludmFsaWRhdGUoKS5fbG9jayA9IDEpO1xuXHRcdFx0XHRcdGlmICgocHJldlRpbWUgJiYgcHJldlRpbWUgIT09IHRoaXMuX3RpbWUpIHx8IHByZXZQYXVzZWQgIT09ICF0aGlzLl90cyB8fCAodGhpcy52YXJzLm9uUmVwZWF0ICYmICF0aGlzLnBhcmVudCAmJiAhdGhpcy5fYWN0KSkgeyAvLyBpZiBwcmV2VGltZSBpcyAwIGFuZCB3ZSByZW5kZXIgYXQgdGhlIHZlcnkgZW5kLCBfdGltZSB3aWxsIGJlIHRoZSBlbmQsIHRodXMgd29uJ3QgbWF0Y2guIFNvIGluIHRoaXMgZWRnZSBjYXNlLCBwcmV2VGltZSB3b24ndCBtYXRjaCBfdGltZSBidXQgdGhhdCdzIG9rYXkuIElmIGl0IGdldHMga2lsbGVkIGluIHRoZSBvblJlcGVhdCwgZWplY3QgYXMgd2VsbC5cblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkdXIgPSB0aGlzLl9kdXI7IC8vIGluIGNhc2UgdGhlIGR1cmF0aW9uIGNoYW5nZWQgaW4gdGhlIG9uUmVwZWF0XG5cdFx0XHRcdFx0dER1ciA9IHRoaXMuX3REdXI7XG5cdFx0XHRcdFx0aWYgKGRvZXNXcmFwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9sb2NrID0gMjtcblx0XHRcdFx0XHRcdHByZXZUaW1lID0gcmV3aW5kaW5nID8gZHVyIDogLTAuMDAwMTtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyKHByZXZUaW1lLCB0cnVlKTtcblx0XHRcdFx0XHRcdHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgdGhpcy5pbnZhbGlkYXRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2xvY2sgPSAwO1xuXHRcdFx0XHRcdGlmICghdGhpcy5fdHMgJiYgIXByZXZQYXVzZWQpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvL2luIG9yZGVyIGZvciB5b3lvRWFzZSB0byB3b3JrIHByb3Blcmx5IHdoZW4gdGhlcmUncyBhIHN0YWdnZXIsIHdlIG11c3Qgc3dhcCBvdXQgdGhlIGVhc2UgaW4gZWFjaCBzdWItdHdlZW4uXG5cdFx0XHRcdFx0X3Byb3BhZ2F0ZVlveW9FYXNlKHRoaXMsIGlzWW95byk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9oYXNQYXVzZSAmJiAhdGhpcy5fZm9yY2luZyAmJiB0aGlzLl9sb2NrIDwgMikge1xuXHRcdFx0XHRwYXVzZVR3ZWVuID0gX2ZpbmROZXh0UGF1c2VUd2Vlbih0aGlzLCBfcm91bmQocHJldlRpbWUpLCBfcm91bmQodGltZSkpO1xuXHRcdFx0XHRpZiAocGF1c2VUd2Vlbikge1xuXHRcdFx0XHRcdHRUaW1lIC09IHRpbWUgLSAodGltZSA9IHBhdXNlVHdlZW4uX3N0YXJ0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl90VGltZSA9IHRUaW1lO1xuXHRcdFx0dGhpcy5fdGltZSA9IHRpbWU7XG5cdFx0XHR0aGlzLl9hY3QgPSAhdGltZVNjYWxlOyAvL2FzIGxvbmcgYXMgaXQncyBub3QgcGF1c2VkLCBmb3JjZSBpdCB0byBiZSBhY3RpdmUgc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIGluZGVwZW5kZW50IG9mIHRoZSBwYXJlbnQgdGltZWxpbmUsIGl0J2xsIGJlIGZvcmNlZCB0byByZS1yZW5kZXIgb24gdGhlIG5leHQgdGljay5cblxuXHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkKSB7XG5cdFx0XHRcdHRoaXMuX29uVXBkYXRlID0gdGhpcy52YXJzLm9uVXBkYXRlO1xuXHRcdFx0XHR0aGlzLl9pbml0dGVkID0gMTtcblx0XHRcdFx0dGhpcy5felRpbWUgPSB0b3RhbFRpbWU7XG5cdFx0XHRcdHByZXZUaW1lID0gMDsgLy8gdXBvbiBpbml0LCB0aGUgcGxheWhlYWQgc2hvdWxkIGFsd2F5cyBnbyBmb3J3YXJkOyBzb21lb25lIGNvdWxkIGludmFsaWRhdGUoKSBhIGNvbXBsZXRlZCB0aW1lbGluZSBhbmQgdGhlbiBpZiB0aGV5IHJlc3RhcnQoKSwgdGhhdCB3b3VsZCBtYWtlIGNoaWxkIHR3ZWVucyByZW5kZXIgaW4gcmV2ZXJzZSBvcmRlciB3aGljaCBjb3VsZCBsb2NrIGluIHRoZSB3cm9uZyBzdGFydGluZyB2YWx1ZXMgaWYgdGhleSBidWlsZCBvbiBlYWNoIG90aGVyLCBsaWtlIHRsLnRvKG9iaiwge3g6IDEwMH0pLnRvKG9iaiwge3g6IDB9KS5cblx0XHRcdH1cblx0XHRcdGlmICghcHJldlRpbWUgJiYgdGltZSAmJiAhc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0X2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcblx0XHRcdFx0aWYgKHRoaXMuX3RUaW1lICE9PSB0VGltZSkgeyAvLyBpbiBjYXNlIHRoZSBvblN0YXJ0IHRyaWdnZXJlZCBhIHJlbmRlciBhdCBhIGRpZmZlcmVudCBzcG90LCBlamVjdC4gTGlrZSBpZiBzb21lb25lIGRpZCBhbmltYXRpb24ucGF1c2UoMC41KSBvciBzb21ldGhpbmcgaW5zaWRlIHRoZSBvblN0YXJ0LlxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodGltZSA+PSBwcmV2VGltZSAmJiB0b3RhbFRpbWUgPj0gMCkge1xuXHRcdFx0XHRjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHR3aGlsZSAoY2hpbGQpIHtcblx0XHRcdFx0XHRuZXh0ID0gY2hpbGQuX25leHQ7XG5cdFx0XHRcdFx0aWYgKChjaGlsZC5fYWN0IHx8IHRpbWUgPj0gY2hpbGQuX3N0YXJ0KSAmJiBjaGlsZC5fdHMgJiYgcGF1c2VUd2VlbiAhPT0gY2hpbGQpIHtcblx0XHRcdFx0XHRcdGlmIChjaGlsZC5wYXJlbnQgIT09IHRoaXMpIHsgLy8gYW4gZXh0cmVtZSBlZGdlIGNhc2UgLSB0aGUgY2hpbGQncyByZW5kZXIgY291bGQgZG8gc29tZXRoaW5nIGxpa2Uga2lsbCgpIHRoZSBcIm5leHRcIiBvbmUgaW4gdGhlIGxpbmtlZCBsaXN0LCBvciByZXBhcmVudCBpdC4gSW4gdGhhdCBjYXNlIHdlIG11c3QgcmUtaW5pdGlhdGUgdGhlIHdob2xlIHJlbmRlciB0byBiZSBzYWZlLlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2hpbGQucmVuZGVyKGNoaWxkLl90cyA+IDAgPyAodGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgOiAoY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpICsgKHRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0aWYgKHRpbWUgIT09IHRoaXMuX3RpbWUgfHwgKCF0aGlzLl90cyAmJiAhcHJldlBhdXNlZCkpIHsgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuXHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuID0gMDtcblx0XHRcdFx0XHRcdFx0bmV4dCAmJiAodFRpbWUgKz0gKHRoaXMuX3pUaW1lID0gLV90aW55TnVtKSk7ICAvLyBpdCBkaWRuJ3QgZmluaXNoIHJlbmRlcmluZywgc28gZmxhZyB6VGltZSBhcyBuZWdhdGl2ZSBzbyB0aGF0IHNvIHRoYXQgdGhlIG5leHQgdGltZSByZW5kZXIoKSBpcyBjYWxsZWQgaXQnbGwgYmUgZm9yY2VkICh0byByZW5kZXIgYW55IHJlbWFpbmluZyBjaGlsZHJlbilcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNoaWxkID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hpbGQgPSB0aGlzLl9sYXN0O1xuXHRcdFx0XHRsZXQgYWRqdXN0ZWRUaW1lID0gdG90YWxUaW1lIDwgMCA/IHRvdGFsVGltZSA6IHRpbWU7IC8vd2hlbiB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBiZXlvbmQgdGhlIHN0YXJ0IG9mIHRoaXMgdGltZWxpbmUsIHdlIG11c3QgcGFzcyB0aGF0IGluZm9ybWF0aW9uIGRvd24gdG8gdGhlIGNoaWxkIGFuaW1hdGlvbnMgc28gdGhhdCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBrbm93IHdoZXRoZXIgdG8gcmVuZGVyIHRoZWlyIHN0YXJ0aW5nIG9yIGVuZGluZyB2YWx1ZXMuXG5cdFx0XHRcdHdoaWxlIChjaGlsZCkge1xuXHRcdFx0XHRcdG5leHQgPSBjaGlsZC5fcHJldjtcblx0XHRcdFx0XHRpZiAoKGNoaWxkLl9hY3QgfHwgYWRqdXN0ZWRUaW1lIDw9IGNoaWxkLl9lbmQpICYmIGNoaWxkLl90cyAmJiBwYXVzZVR3ZWVuICE9PSBjaGlsZCkge1xuXHRcdFx0XHRcdFx0aWYgKGNoaWxkLnBhcmVudCAhPT0gdGhpcykgeyAvLyBhbiBleHRyZW1lIGVkZ2UgY2FzZSAtIHRoZSBjaGlsZCdzIHJlbmRlciBjb3VsZCBkbyBzb21ldGhpbmcgbGlrZSBraWxsKCkgdGhlIFwibmV4dFwiIG9uZSBpbiB0aGUgbGlua2VkIGxpc3QsIG9yIHJlcGFyZW50IGl0LiBJbiB0aGF0IGNhc2Ugd2UgbXVzdCByZS1pbml0aWF0ZSB0aGUgd2hvbGUgcmVuZGVyIHRvIGJlIHNhZmUuXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjaGlsZC5yZW5kZXIoY2hpbGQuX3RzID4gMCA/IChhZGp1c3RlZFRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzIDogKGNoaWxkLl9kaXJ0eSA/IGNoaWxkLnRvdGFsRHVyYXRpb24oKSA6IGNoaWxkLl90RHVyKSArIChhZGp1c3RlZFRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0aWYgKHRpbWUgIT09IHRoaXMuX3RpbWUgfHwgKCF0aGlzLl90cyAmJiAhcHJldlBhdXNlZCkpIHsgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuXHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuID0gMDtcblx0XHRcdFx0XHRcdFx0bmV4dCAmJiAodFRpbWUgKz0gKHRoaXMuX3pUaW1lID0gYWRqdXN0ZWRUaW1lID8gLV90aW55TnVtIDogX3RpbnlOdW0pKTsgLy8gaXQgZGlkbid0IGZpbmlzaCByZW5kZXJpbmcsIHNvIGFkanVzdCB6VGltZSBzbyB0aGF0IHNvIHRoYXQgdGhlIG5leHQgdGltZSByZW5kZXIoKSBpcyBjYWxsZWQgaXQnbGwgYmUgZm9yY2VkICh0byByZW5kZXIgYW55IHJlbWFpbmluZyBjaGlsZHJlbilcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNoaWxkID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHBhdXNlVHdlZW4gJiYgIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdHRoaXMucGF1c2UoKTtcblx0XHRcdFx0cGF1c2VUd2Vlbi5yZW5kZXIodGltZSA+PSBwcmV2VGltZSA/IDAgOiAtX3RpbnlOdW0pLl96VGltZSA9IHRpbWUgPj0gcHJldlRpbWUgPyAxIDogLTE7XG5cdFx0XHRcdGlmICh0aGlzLl90cykgeyAvL3RoZSBjYWxsYmFjayByZXN1bWVkIHBsYXliYWNrISBTbyBzaW5jZSB3ZSBtYXkgaGF2ZSBoZWxkIGJhY2sgdGhlIHBsYXloZWFkIGR1ZSB0byB3aGVyZSB0aGUgcGF1c2UgaXMgcG9zaXRpb25lZCwgZ28gYWhlYWQgYW5kIGp1bXAgdG8gd2hlcmUgaXQncyBTVVBQT1NFRCB0byBiZSAoaWYgbm8gcGF1c2UgaGFwcGVuZWQpLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0ID0gcHJldlN0YXJ0OyAvL2lmIHRoZSBwYXVzZSB3YXMgYXQgYW4gZWFybGllciB0aW1lIGFuZCB0aGUgdXNlciByZXN1bWVkIGluIHRoZSBjYWxsYmFjaywgaXQgY291bGQgcmVwb3NpdGlvbiB0aGUgdGltZWxpbmUgKGNoYW5naW5nIGl0cyBzdGFydFRpbWUpLCB0aHJvd2luZyB0aGluZ3Mgb2ZmIHNsaWdodGx5LCBzbyB3ZSBtYWtlIHN1cmUgdGhlIF9zdGFydCBkb2Vzbid0IHNoaWZ0LlxuXHRcdFx0XHRcdF9zZXRFbmQodGhpcyk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uVXBkYXRlXCIsIHRydWUpO1xuXHRcdFx0aWYgKCh0VGltZSA9PT0gdER1ciAmJiB0RHVyID49IHRoaXMudG90YWxEdXJhdGlvbigpKSB8fCAoIXRUaW1lICYmIHByZXZUaW1lKSkgaWYgKHByZXZTdGFydCA9PT0gdGhpcy5fc3RhcnQgfHwgTWF0aC5hYnModGltZVNjYWxlKSAhPT0gTWF0aC5hYnModGhpcy5fdHMpKSBpZiAoIXRoaXMuX2xvY2spIHtcblx0XHRcdFx0KHRvdGFsVGltZSB8fCAhZHVyKSAmJiAoKHRUaW1lID09PSB0RHVyICYmIHRoaXMuX3RzID4gMCkgfHwgKCF0VGltZSAmJiB0aGlzLl90cyA8IDApKSAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0aGlzLCAxKTsgLy8gZG9uJ3QgcmVtb3ZlIGlmIHRoZSB0aW1lbGluZSBpcyByZXZlcnNlZCBhbmQgdGhlIHBsYXloZWFkIGlzbid0IGF0IDAsIG90aGVyd2lzZSB0bC5wcm9ncmVzcygxKS5yZXZlcnNlKCkgd29uJ3Qgd29yay4gT25seSByZW1vdmUgaWYgdGhlIHBsYXloZWFkIGlzIGF0IHRoZSBlbmQgYW5kIHRpbWVTY2FsZSBpcyBwb3NpdGl2ZSwgb3IgaWYgdGhlIHBsYXloZWFkIGlzIGF0IDAgYW5kIHRoZSB0aW1lU2NhbGUgaXMgbmVnYXRpdmUuXG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMgJiYgISh0b3RhbFRpbWUgPCAwICYmICFwcmV2VGltZSkgJiYgKHRUaW1lIHx8IHByZXZUaW1lIHx8ICF0RHVyKSkge1xuXHRcdFx0XHRcdF9jYWxsYmFjayh0aGlzLCAodFRpbWUgPT09IHREdXIgJiYgdG90YWxUaW1lID49IDAgPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiksIHRydWUpO1xuXHRcdFx0XHRcdHRoaXMuX3Byb20gJiYgISh0VGltZSA8IHREdXIgJiYgdGhpcy50aW1lU2NhbGUoKSA+IDApICYmIHRoaXMuX3Byb20oKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGFkZChjaGlsZCwgcG9zaXRpb24pIHtcblx0XHRfaXNOdW1iZXIocG9zaXRpb24pIHx8IChwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uLCBjaGlsZCkpO1xuXHRcdGlmICghKGNoaWxkIGluc3RhbmNlb2YgQW5pbWF0aW9uKSkge1xuXHRcdFx0aWYgKF9pc0FycmF5KGNoaWxkKSkge1xuXHRcdFx0XHRjaGlsZC5mb3JFYWNoKG9iaiA9PiB0aGlzLmFkZChvYmosIHBvc2l0aW9uKSk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdFx0aWYgKF9pc1N0cmluZyhjaGlsZCkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkTGFiZWwoY2hpbGQsIHBvc2l0aW9uKTtcblx0XHRcdH1cblx0XHRcdGlmIChfaXNGdW5jdGlvbihjaGlsZCkpIHtcblx0XHRcdFx0Y2hpbGQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjaGlsZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMgIT09IGNoaWxkID8gX2FkZFRvVGltZWxpbmUodGhpcywgY2hpbGQsIHBvc2l0aW9uKSA6IHRoaXM7IC8vZG9uJ3QgYWxsb3cgYSB0aW1lbGluZSB0byBiZSBhZGRlZCB0byBpdHNlbGYgYXMgYSBjaGlsZCFcblx0fVxuXG5cdGdldENoaWxkcmVuKG5lc3RlZCA9IHRydWUsIHR3ZWVucyA9IHRydWUsIHRpbWVsaW5lcyA9IHRydWUsIGlnbm9yZUJlZm9yZVRpbWUgPSAtX2JpZ051bSkge1xuXHRcdGxldCBhID0gW10sXG5cdFx0XHRjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuXHRcdHdoaWxlIChjaGlsZCkge1xuXHRcdFx0aWYgKGNoaWxkLl9zdGFydCA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRcdGlmIChjaGlsZCBpbnN0YW5jZW9mIFR3ZWVuKSB7XG5cdFx0XHRcdFx0dHdlZW5zICYmIGEucHVzaChjaGlsZCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGltZWxpbmVzICYmIGEucHVzaChjaGlsZCk7XG5cdFx0XHRcdFx0bmVzdGVkICYmIGEucHVzaCguLi5jaGlsZC5nZXRDaGlsZHJlbih0cnVlLCB0d2VlbnMsIHRpbWVsaW5lcykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjaGlsZCA9IGNoaWxkLl9uZXh0O1xuXHRcdH1cblx0XHRyZXR1cm4gYTtcblx0fVxuXG5cdGdldEJ5SWQoaWQpIHtcblx0XHRsZXQgYW5pbWF0aW9ucyA9IHRoaXMuZ2V0Q2hpbGRyZW4oMSwgMSwgMSksXG5cdFx0XHRpID0gYW5pbWF0aW9ucy5sZW5ndGg7XG5cdFx0d2hpbGUoaS0tKSB7XG5cdFx0XHRpZiAoYW5pbWF0aW9uc1tpXS52YXJzLmlkID09PSBpZCkge1xuXHRcdFx0XHRyZXR1cm4gYW5pbWF0aW9uc1tpXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZW1vdmUoY2hpbGQpIHtcblx0XHRpZiAoX2lzU3RyaW5nKGNoaWxkKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVtb3ZlTGFiZWwoY2hpbGQpO1xuXHRcdH1cblx0XHRpZiAoX2lzRnVuY3Rpb24oY2hpbGQpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5raWxsVHdlZW5zT2YoY2hpbGQpO1xuXHRcdH1cblx0XHRfcmVtb3ZlTGlua2VkTGlzdEl0ZW0odGhpcywgY2hpbGQpO1xuXHRcdGlmIChjaGlsZCA9PT0gdGhpcy5fcmVjZW50KSB7XG5cdFx0XHR0aGlzLl9yZWNlbnQgPSB0aGlzLl9sYXN0O1xuXHRcdH1cblx0XHRyZXR1cm4gX3VuY2FjaGUodGhpcyk7XG5cdH1cblxuXHR0b3RhbFRpbWUodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3RUaW1lO1xuXHRcdH1cblx0XHR0aGlzLl9mb3JjaW5nID0gMTtcblx0XHRpZiAoIXRoaXMuX2RwICYmIHRoaXMuX3RzKSB7IC8vc3BlY2lhbCBjYXNlIGZvciB0aGUgZ2xvYmFsIHRpbWVsaW5lIChvciBhbnkgb3RoZXIgdGhhdCBoYXMgbm8gcGFyZW50IG9yIGRldGFjaGVkIHBhcmVudCkuXG5cdFx0XHR0aGlzLl9zdGFydCA9IF9yb3VuZChfdGlja2VyLnRpbWUgLSAodGhpcy5fdHMgPiAwID8gdG90YWxUaW1lIC8gdGhpcy5fdHMgOiAodGhpcy50b3RhbER1cmF0aW9uKCkgLSB0b3RhbFRpbWUpIC8gLXRoaXMuX3RzKSk7XG5cdFx0fVxuXHRcdHN1cGVyLnRvdGFsVGltZSh0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHR0aGlzLl9mb3JjaW5nID0gMDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGFkZExhYmVsKGxhYmVsLCBwb3NpdGlvbikge1xuXHRcdHRoaXMubGFiZWxzW2xhYmVsXSA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHJlbW92ZUxhYmVsKGxhYmVsKSB7XG5cdFx0ZGVsZXRlIHRoaXMubGFiZWxzW2xhYmVsXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGFkZFBhdXNlKHBvc2l0aW9uLCBjYWxsYmFjaywgcGFyYW1zKSB7XG5cdFx0bGV0IHQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjayB8fCBfZW1wdHlGdW5jLCBwYXJhbXMpO1xuXHRcdHQuZGF0YSA9IFwiaXNQYXVzZVwiO1xuXHRcdHRoaXMuX2hhc1BhdXNlID0gMTtcblx0XHRyZXR1cm4gX2FkZFRvVGltZWxpbmUodGhpcywgdCwgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pKTtcblx0fVxuXG5cdHJlbW92ZVBhdXNlKHBvc2l0aW9uKSB7XG5cdFx0bGV0IGNoaWxkID0gdGhpcy5fZmlyc3Q7XG5cdFx0cG9zaXRpb24gPSBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XG5cdFx0d2hpbGUgKGNoaWxkKSB7XG5cdFx0XHRpZiAoY2hpbGQuX3N0YXJ0ID09PSBwb3NpdGlvbiAmJiBjaGlsZC5kYXRhID09PSBcImlzUGF1c2VcIikge1xuXHRcdFx0XHRfcmVtb3ZlRnJvbVBhcmVudChjaGlsZCk7XG5cdFx0XHR9XG5cdFx0XHRjaGlsZCA9IGNoaWxkLl9uZXh0O1xuXHRcdH1cblx0fVxuXG5cdGtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSkge1xuXHRcdGxldCB0d2VlbnMgPSB0aGlzLmdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpLFxuXHRcdFx0aSA9IHR3ZWVucy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0KF9vdmVyd3JpdGluZ1R3ZWVuICE9PSB0d2VlbnNbaV0pICYmIHR3ZWVuc1tpXS5raWxsKHRhcmdldHMsIHByb3BzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRnZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSB7XG5cdFx0bGV0IGEgPSBbXSxcblx0XHRcdHBhcnNlZFRhcmdldHMgPSB0b0FycmF5KHRhcmdldHMpLFxuXHRcdFx0Y2hpbGQgPSB0aGlzLl9maXJzdCxcblx0XHRcdGlzR2xvYmFsVGltZSA9IF9pc051bWJlcihvbmx5QWN0aXZlKSwgLy8gYSBudW1iZXIgaXMgaW50ZXJwcmV0ZWQgYXMgYSBnbG9iYWwgdGltZS4gSWYgdGhlIGFuaW1hdGlvbiBzcGFuc1xuXHRcdFx0Y2hpbGRyZW47XG5cdFx0d2hpbGUgKGNoaWxkKSB7XG5cdFx0XHRpZiAoY2hpbGQgaW5zdGFuY2VvZiBUd2Vlbikge1xuXHRcdFx0XHRpZiAoX2FycmF5Q29udGFpbnNBbnkoY2hpbGQuX3RhcmdldHMsIHBhcnNlZFRhcmdldHMpICYmIChpc0dsb2JhbFRpbWUgPyAoIV9vdmVyd3JpdGluZ1R3ZWVuIHx8IChjaGlsZC5faW5pdHRlZCAmJiBjaGlsZC5fdHMpKSAmJiBjaGlsZC5nbG9iYWxUaW1lKDApIDw9IG9ubHlBY3RpdmUgJiYgY2hpbGQuZ2xvYmFsVGltZShjaGlsZC50b3RhbER1cmF0aW9uKCkpID4gb25seUFjdGl2ZSA6ICFvbmx5QWN0aXZlIHx8IGNoaWxkLmlzQWN0aXZlKCkpKSB7IC8vIG5vdGU6IGlmIHRoaXMgaXMgZm9yIG92ZXJ3cml0aW5nLCBpdCBzaG91bGQgb25seSBiZSBmb3IgdHdlZW5zIHRoYXQgYXJlbid0IHBhdXNlZCBhbmQgYXJlIGluaXR0ZWQuXG5cdFx0XHRcdFx0YS5wdXNoKGNoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICgoY2hpbGRyZW4gPSBjaGlsZC5nZXRUd2VlbnNPZihwYXJzZWRUYXJnZXRzLCBvbmx5QWN0aXZlKSkubGVuZ3RoKSB7XG5cdFx0XHRcdGEucHVzaCguLi5jaGlsZHJlbik7XG5cdFx0XHR9XG5cdFx0XHRjaGlsZCA9IGNoaWxkLl9uZXh0O1xuXHRcdH1cblx0XHRyZXR1cm4gYTtcblx0fVxuXG5cdC8vIHBvdGVudGlhbCBmdXR1cmUgZmVhdHVyZSAtIHRhcmdldHMoKSBvbiB0aW1lbGluZXNcblx0Ly8gdGFyZ2V0cygpIHtcblx0Ly8gXHRsZXQgcmVzdWx0ID0gW107XG5cdC8vIFx0dGhpcy5nZXRDaGlsZHJlbih0cnVlLCB0cnVlLCBmYWxzZSkuZm9yRWFjaCh0ID0+IHJlc3VsdC5wdXNoKC4uLnQudGFyZ2V0cygpKSk7XG5cdC8vIFx0cmV0dXJuIHJlc3VsdC5maWx0ZXIoKHYsIGkpID0+IHJlc3VsdC5pbmRleE9mKHYpID09PSBpKTtcblx0Ly8gfVxuXG5cdHR3ZWVuVG8ocG9zaXRpb24sIHZhcnMpIHtcblx0XHR2YXJzID0gdmFycyB8fCB7fTtcblx0XHRsZXQgdGwgPSB0aGlzLFxuXHRcdFx0ZW5kVGltZSA9IF9wYXJzZVBvc2l0aW9uKHRsLCBwb3NpdGlvbiksXG5cdFx0XHR7IHN0YXJ0QXQsIG9uU3RhcnQsIG9uU3RhcnRQYXJhbXMsIGltbWVkaWF0ZVJlbmRlciB9ID0gdmFycyxcblx0XHRcdGluaXR0ZWQsXG5cdFx0XHR0d2VlbiA9IFR3ZWVuLnRvKHRsLCBfc2V0RGVmYXVsdHMoe1xuXHRcdFx0XHRlYXNlOiB2YXJzLmVhc2UgfHwgXCJub25lXCIsXG5cdFx0XHRcdGxhenk6IGZhbHNlLFxuXHRcdFx0XHRpbW1lZGlhdGVSZW5kZXI6IGZhbHNlLFxuXHRcdFx0XHR0aW1lOiBlbmRUaW1lLFxuXHRcdFx0XHRvdmVyd3JpdGU6IFwiYXV0b1wiLFxuXHRcdFx0XHRkdXJhdGlvbjogdmFycy5kdXJhdGlvbiB8fCAoTWF0aC5hYnMoKGVuZFRpbWUgLSAoKHN0YXJ0QXQgJiYgXCJ0aW1lXCIgaW4gc3RhcnRBdCkgPyBzdGFydEF0LnRpbWUgOiB0bC5fdGltZSkpIC8gdGwudGltZVNjYWxlKCkpKSB8fCBfdGlueU51bSxcblx0XHRcdFx0b25TdGFydDogKCkgPT4ge1xuXHRcdFx0XHRcdHRsLnBhdXNlKCk7XG5cdFx0XHRcdFx0aWYgKCFpbml0dGVkKSB7XG5cdFx0XHRcdFx0XHRsZXQgZHVyYXRpb24gPSB2YXJzLmR1cmF0aW9uIHx8IE1hdGguYWJzKChlbmRUaW1lIC0gKChzdGFydEF0ICYmIFwidGltZVwiIGluIHN0YXJ0QXQpID8gc3RhcnRBdC50aW1lIDogdGwuX3RpbWUpKSAvIHRsLnRpbWVTY2FsZSgpKTtcblx0XHRcdFx0XHRcdCh0d2Vlbi5fZHVyICE9PSBkdXJhdGlvbikgJiYgX3NldER1cmF0aW9uKHR3ZWVuLCBkdXJhdGlvbiwgMCwgMSkucmVuZGVyKHR3ZWVuLl90aW1lLCB0cnVlLCB0cnVlKTtcblx0XHRcdFx0XHRcdGluaXR0ZWQgPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvblN0YXJ0ICYmIG9uU3RhcnQuYXBwbHkodHdlZW4sIG9uU3RhcnRQYXJhbXMgfHwgW10pOyAvL2luIGNhc2UgdGhlIHVzZXIgaGFkIGFuIG9uU3RhcnQgaW4gdGhlIHZhcnMgLSB3ZSBkb24ndCB3YW50IHRvIG92ZXJ3cml0ZSBpdC5cblx0XHRcdFx0fVxuXHRcdFx0fSwgdmFycykpO1xuXHRcdHJldHVybiBpbW1lZGlhdGVSZW5kZXIgPyB0d2Vlbi5yZW5kZXIoMCkgOiB0d2Vlbjtcblx0fVxuXG5cdHR3ZWVuRnJvbVRvKGZyb21Qb3NpdGlvbiwgdG9Qb3NpdGlvbiwgdmFycykge1xuXHRcdHJldHVybiB0aGlzLnR3ZWVuVG8odG9Qb3NpdGlvbiwgX3NldERlZmF1bHRzKHtzdGFydEF0Ont0aW1lOl9wYXJzZVBvc2l0aW9uKHRoaXMsIGZyb21Qb3NpdGlvbil9fSwgdmFycykpO1xuXHR9XG5cblx0cmVjZW50KCkge1xuXHRcdHJldHVybiB0aGlzLl9yZWNlbnQ7XG5cdH1cblxuXHRuZXh0TGFiZWwoYWZ0ZXJUaW1lID0gdGhpcy5fdGltZSkge1xuXHRcdHJldHVybiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aGlzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBhZnRlclRpbWUpKTtcblx0fVxuXG5cdHByZXZpb3VzTGFiZWwoYmVmb3JlVGltZSA9IHRoaXMuX3RpbWUpIHtcblx0XHRyZXR1cm4gX2dldExhYmVsSW5EaXJlY3Rpb24odGhpcywgX3BhcnNlUG9zaXRpb24odGhpcywgYmVmb3JlVGltZSksIDEpO1xuXHR9XG5cblx0Y3VycmVudExhYmVsKHZhbHVlKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnNlZWsodmFsdWUsIHRydWUpIDogdGhpcy5wcmV2aW91c0xhYmVsKHRoaXMuX3RpbWUgKyBfdGlueU51bSk7XG5cdH1cblxuXHRzaGlmdENoaWxkcmVuKGFtb3VudCwgYWRqdXN0TGFiZWxzLCBpZ25vcmVCZWZvcmVUaW1lID0gMCkge1xuXHRcdGxldCBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuXHRcdFx0bGFiZWxzID0gdGhpcy5sYWJlbHMsXG5cdFx0XHRwO1xuXHRcdHdoaWxlIChjaGlsZCkge1xuXHRcdFx0aWYgKGNoaWxkLl9zdGFydCA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRcdGNoaWxkLl9zdGFydCArPSBhbW91bnQ7XG5cdFx0XHRcdGNoaWxkLl9lbmQgKz0gYW1vdW50O1xuXHRcdFx0fVxuXHRcdFx0Y2hpbGQgPSBjaGlsZC5fbmV4dDtcblx0XHR9XG5cdFx0aWYgKGFkanVzdExhYmVscykge1xuXHRcdFx0Zm9yIChwIGluIGxhYmVscykge1xuXHRcdFx0XHRpZiAobGFiZWxzW3BdID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdFx0XHRsYWJlbHNbcF0gKz0gYW1vdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfdW5jYWNoZSh0aGlzKTtcblx0fVxuXG5cdGludmFsaWRhdGUoKSB7XG5cdFx0bGV0IGNoaWxkID0gdGhpcy5fZmlyc3Q7XG5cdFx0dGhpcy5fbG9jayA9IDA7XG5cdFx0d2hpbGUgKGNoaWxkKSB7XG5cdFx0XHRjaGlsZC5pbnZhbGlkYXRlKCk7XG5cdFx0XHRjaGlsZCA9IGNoaWxkLl9uZXh0O1xuXHRcdH1cblx0XHRyZXR1cm4gc3VwZXIuaW52YWxpZGF0ZSgpO1xuXHR9XG5cblx0Y2xlYXIoaW5jbHVkZUxhYmVscyA9IHRydWUpIHtcblx0XHRsZXQgY2hpbGQgPSB0aGlzLl9maXJzdCxcblx0XHRcdG5leHQ7XG5cdFx0d2hpbGUgKGNoaWxkKSB7XG5cdFx0XHRuZXh0ID0gY2hpbGQuX25leHQ7XG5cdFx0XHR0aGlzLnJlbW92ZShjaGlsZCk7XG5cdFx0XHRjaGlsZCA9IG5leHQ7XG5cdFx0fVxuXHRcdHRoaXMuX2RwICYmICh0aGlzLl90aW1lID0gdGhpcy5fdFRpbWUgPSB0aGlzLl9wVGltZSA9IDApO1xuXHRcdGluY2x1ZGVMYWJlbHMgJiYgKHRoaXMubGFiZWxzID0ge30pO1xuXHRcdHJldHVybiBfdW5jYWNoZSh0aGlzKTtcblx0fVxuXG5cdHRvdGFsRHVyYXRpb24odmFsdWUpIHtcblx0XHRsZXQgbWF4ID0gMCxcblx0XHRcdHNlbGYgPSB0aGlzLFxuXHRcdFx0Y2hpbGQgPSBzZWxmLl9sYXN0LFxuXHRcdFx0cHJldlN0YXJ0ID0gX2JpZ051bSxcblx0XHRcdHByZXYsIHN0YXJ0LCBwYXJlbnQ7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBzZWxmLnRpbWVTY2FsZSgoc2VsZi5fcmVwZWF0IDwgMCA/IHNlbGYuZHVyYXRpb24oKSA6IHNlbGYudG90YWxEdXJhdGlvbigpKSAvIChzZWxmLnJldmVyc2VkKCkgPyAtdmFsdWUgOiB2YWx1ZSkpO1xuXHRcdH1cblx0XHRpZiAoc2VsZi5fZGlydHkpIHtcblx0XHRcdHBhcmVudCA9IHNlbGYucGFyZW50O1xuXHRcdFx0d2hpbGUgKGNoaWxkKSB7XG5cdFx0XHRcdHByZXYgPSBjaGlsZC5fcHJldjsgLy9yZWNvcmQgaXQgaGVyZSBpbiBjYXNlIHRoZSB0d2VlbiBjaGFuZ2VzIHBvc2l0aW9uIGluIHRoZSBzZXF1ZW5jZS4uLlxuXHRcdFx0XHRjaGlsZC5fZGlydHkgJiYgY2hpbGQudG90YWxEdXJhdGlvbigpOyAvL2NvdWxkIGNoYW5nZSB0aGUgdHdlZW4uX3N0YXJ0VGltZSwgc28gbWFrZSBzdXJlIHRoZSBhbmltYXRpb24ncyBjYWNoZSBpcyBjbGVhbiBiZWZvcmUgYW5hbHl6aW5nIGl0LlxuXHRcdFx0XHRzdGFydCA9IGNoaWxkLl9zdGFydDtcblx0XHRcdFx0aWYgKHN0YXJ0ID4gcHJldlN0YXJ0ICYmIHNlbGYuX3NvcnQgJiYgY2hpbGQuX3RzICYmICFzZWxmLl9sb2NrKSB7IC8vaW4gY2FzZSBvbmUgb2YgdGhlIHR3ZWVucyBzaGlmdGVkIG91dCBvZiBvcmRlciwgaXQgbmVlZHMgdG8gYmUgcmUtaW5zZXJ0ZWQgaW50byB0aGUgY29ycmVjdCBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2Vcblx0XHRcdFx0XHRzZWxmLl9sb2NrID0gMTsgLy9wcmV2ZW50IGVuZGxlc3MgcmVjdXJzaXZlIGNhbGxzIC0gdGhlcmUgYXJlIG1ldGhvZHMgdGhhdCBnZXQgdHJpZ2dlcmVkIHRoYXQgY2hlY2sgZHVyYXRpb24vdG90YWxEdXJhdGlvbiB3aGVuIHdlIGFkZCgpLlxuXHRcdFx0XHRcdF9hZGRUb1RpbWVsaW5lKHNlbGYsIGNoaWxkLCBzdGFydCAtIGNoaWxkLl9kZWxheSwgMSkuX2xvY2sgPSAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHByZXZTdGFydCA9IHN0YXJ0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzdGFydCA8IDAgJiYgY2hpbGQuX3RzKSB7IC8vY2hpbGRyZW4gYXJlbid0IGFsbG93ZWQgdG8gaGF2ZSBuZWdhdGl2ZSBzdGFydFRpbWVzIHVubGVzcyBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlLCBzbyBhZGp1c3QgaGVyZSBpZiBvbmUgaXMgZm91bmQuXG5cdFx0XHRcdFx0bWF4IC09IHN0YXJ0O1xuXHRcdFx0XHRcdGlmICgoIXBhcmVudCAmJiAhc2VsZi5fZHApIHx8IChwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nKSkge1xuXHRcdFx0XHRcdFx0c2VsZi5fc3RhcnQgKz0gc3RhcnQgLyBzZWxmLl90cztcblx0XHRcdFx0XHRcdHNlbGYuX3RpbWUgLT0gc3RhcnQ7XG5cdFx0XHRcdFx0XHRzZWxmLl90VGltZSAtPSBzdGFydDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VsZi5zaGlmdENoaWxkcmVuKC1zdGFydCwgZmFsc2UsIC0xZTk5OSk7XG5cdFx0XHRcdFx0cHJldlN0YXJ0ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGlsZC5fZW5kID4gbWF4ICYmIGNoaWxkLl90cyAmJiAobWF4ID0gY2hpbGQuX2VuZCk7XG5cdFx0XHRcdGNoaWxkID0gcHJldjtcblx0XHRcdH1cblx0XHRcdF9zZXREdXJhdGlvbihzZWxmLCAoc2VsZiA9PT0gX2dsb2JhbFRpbWVsaW5lICYmIHNlbGYuX3RpbWUgPiBtYXgpID8gc2VsZi5fdGltZSA6IG1heCwgMSwgMSk7XG5cdFx0XHRzZWxmLl9kaXJ0eSA9IDA7XG5cdFx0fVxuXHRcdHJldHVybiBzZWxmLl90RHVyO1xuXHR9XG5cblx0c3RhdGljIHVwZGF0ZVJvb3QodGltZSkge1xuXHRcdGlmIChfZ2xvYmFsVGltZWxpbmUuX3RzKSB7XG5cdFx0XHRfbGF6eVNhZmVSZW5kZXIoX2dsb2JhbFRpbWVsaW5lLCBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSh0aW1lLCBfZ2xvYmFsVGltZWxpbmUpKTtcblx0XHRcdF9sYXN0UmVuZGVyZWRGcmFtZSA9IF90aWNrZXIuZnJhbWU7XG5cdFx0fVxuXHRcdGlmIChfdGlja2VyLmZyYW1lID49IF9uZXh0R0NGcmFtZSkge1xuXHRcdFx0X25leHRHQ0ZyYW1lICs9IF9jb25maWcuYXV0b1NsZWVwIHx8IDEyMDtcblx0XHRcdGxldCBjaGlsZCA9IF9nbG9iYWxUaW1lbGluZS5fZmlyc3Q7XG5cdFx0XHRpZiAoIWNoaWxkIHx8ICFjaGlsZC5fdHMpIGlmIChfY29uZmlnLmF1dG9TbGVlcCAmJiBfdGlja2VyLl9saXN0ZW5lcnMubGVuZ3RoIDwgMikge1xuXHRcdFx0XHR3aGlsZSAoY2hpbGQgJiYgIWNoaWxkLl90cykge1xuXHRcdFx0XHRcdGNoaWxkID0gY2hpbGQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hpbGQgfHwgX3RpY2tlci5zbGVlcCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG59XG5cbl9zZXREZWZhdWx0cyhUaW1lbGluZS5wcm90b3R5cGUsIHtfbG9jazowLCBfaGFzUGF1c2U6MCwgX2ZvcmNpbmc6MH0pO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmxldCBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2VlbiA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgc2V0dGVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSkgeyAvL25vdGU6IHdlIGNhbGwgX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4uY2FsbCh0d2Vlbkluc3RhbmNlLi4uKSB0byBlbnN1cmUgdGhhdCBpdCdzIHNjb3BlZCBwcm9wZXJseS4gV2UgbWF5IGNhbGwgaXQgZnJvbSB3aXRoaW4gYSBwbHVnaW4gdG9vLCB0aHVzIFwidGhpc1wiIHdvdWxkIHJlZmVyIHRvIHRoZSBwbHVnaW4uXG5cdFx0bGV0IHB0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LCBwcm9wLCAwLCAxLCBfcmVuZGVyQ29tcGxleFN0cmluZywgbnVsbCwgc2V0dGVyKSxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdG1hdGNoSW5kZXggPSAwLFxuXHRcdFx0cmVzdWx0LFx0c3RhcnROdW1zLCBjb2xvciwgZW5kTnVtLCBjaHVuaywgc3RhcnROdW0sIGhhc1JhbmRvbSwgYTtcblx0XHRwdC5iID0gc3RhcnQ7XG5cdFx0cHQuZSA9IGVuZDtcblx0XHRzdGFydCArPSBcIlwiOyAvL2Vuc3VyZSB2YWx1ZXMgYXJlIHN0cmluZ3Ncblx0XHRlbmQgKz0gXCJcIjtcblx0XHRpZiAoKGhhc1JhbmRvbSA9IH5lbmQuaW5kZXhPZihcInJhbmRvbShcIikpKSB7XG5cdFx0XHRlbmQgPSBfcmVwbGFjZVJhbmRvbShlbmQpO1xuXHRcdH1cblx0XHRpZiAoc3RyaW5nRmlsdGVyKSB7XG5cdFx0XHRhID0gW3N0YXJ0LCBlbmRdO1xuXHRcdFx0c3RyaW5nRmlsdGVyKGEsIHRhcmdldCwgcHJvcCk7IC8vcGFzcyBhbiBhcnJheSB3aXRoIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHZhbHVlcyBhbmQgbGV0IHRoZSBmaWx0ZXIgZG8gd2hhdGV2ZXIgaXQgbmVlZHMgdG8gdGhlIHZhbHVlcy5cblx0XHRcdHN0YXJ0ID0gYVswXTtcblx0XHRcdGVuZCA9IGFbMV07XG5cdFx0fVxuXHRcdHN0YXJ0TnVtcyA9IHN0YXJ0Lm1hdGNoKF9jb21wbGV4U3RyaW5nTnVtRXhwKSB8fCBbXTtcblx0XHR3aGlsZSAoKHJlc3VsdCA9IF9jb21wbGV4U3RyaW5nTnVtRXhwLmV4ZWMoZW5kKSkpIHtcblx0XHRcdGVuZE51bSA9IHJlc3VsdFswXTtcblx0XHRcdGNodW5rID0gZW5kLnN1YnN0cmluZyhpbmRleCwgcmVzdWx0LmluZGV4KTtcblx0XHRcdGlmIChjb2xvcikge1xuXHRcdFx0XHRjb2xvciA9IChjb2xvciArIDEpICUgNTtcblx0XHRcdH0gZWxzZSBpZiAoY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJyZ2JhKFwiKSB7XG5cdFx0XHRcdGNvbG9yID0gMTtcblx0XHRcdH1cblx0XHRcdGlmIChlbmROdW0gIT09IHN0YXJ0TnVtc1ttYXRjaEluZGV4KytdKSB7XG5cdFx0XHRcdHN0YXJ0TnVtID0gcGFyc2VGbG9hdChzdGFydE51bXNbbWF0Y2hJbmRleC0xXSkgfHwgMDtcblx0XHRcdFx0Ly90aGVzZSBuZXN0ZWQgUHJvcFR3ZWVucyBhcmUgaGFuZGxlZCBpbiBhIHNwZWNpYWwgd2F5IC0gd2UnbGwgbmV2ZXIgYWN0dWFsbHkgY2FsbCBhIHJlbmRlciBvciBzZXR0ZXIgbWV0aG9kIG9uIHRoZW0uIFdlJ2xsIGp1c3QgbG9vcCB0aHJvdWdoIHRoZW0gaW4gdGhlIHBhcmVudCBjb21wbGV4IHN0cmluZyBQcm9wVHdlZW4ncyByZW5kZXIgbWV0aG9kLlxuXHRcdFx0XHRwdC5fcHQgPSB7XG5cdFx0XHRcdFx0X25leHQ6cHQuX3B0LFxuXHRcdFx0XHRcdHA6KGNodW5rIHx8IG1hdGNoSW5kZXggPT09IDEpID8gY2h1bmsgOiBcIixcIiwgLy9ub3RlOiBTVkcgc3BlYyBhbGxvd3Mgb21pc3Npb24gb2YgY29tbWEvc3BhY2Ugd2hlbiBhIG5lZ2F0aXZlIHNpZ24gaXMgd2VkZ2VkIGJldHdlZW4gdHdvIG51bWJlcnMsIGxpa2UgMi41LTUuMyBpbnN0ZWFkIG9mIDIuNSwtNS4zIGJ1dCB3aGVuIHR3ZWVuaW5nLCB0aGUgbmVnYXRpdmUgdmFsdWUgbWF5IHN3aXRjaCB0byBwb3NpdGl2ZSwgc28gd2UgaW5zZXJ0IHRoZSBjb21tYSBqdXN0IGluIGNhc2UuXG5cdFx0XHRcdFx0czpzdGFydE51bSxcblx0XHRcdFx0XHRjOmVuZE51bS5jaGFyQXQoMSkgPT09IFwiPVwiID8gcGFyc2VGbG9hdChlbmROdW0uc3Vic3RyKDIpKSAqIChlbmROdW0uY2hhckF0KDApID09PSBcIi1cIiA/IC0xIDogMSkgOiBwYXJzZUZsb2F0KGVuZE51bSkgLSBzdGFydE51bSxcblx0XHRcdFx0XHRtOihjb2xvciAmJiBjb2xvciA8IDQpID8gTWF0aC5yb3VuZCA6IDBcblx0XHRcdFx0fTtcblx0XHRcdFx0aW5kZXggPSBfY29tcGxleFN0cmluZ051bUV4cC5sYXN0SW5kZXg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHB0LmMgPSAoaW5kZXggPCBlbmQubGVuZ3RoKSA/IGVuZC5zdWJzdHJpbmcoaW5kZXgsIGVuZC5sZW5ndGgpIDogXCJcIjsgLy93ZSB1c2UgdGhlIFwiY1wiIG9mIHRoZSBQcm9wVHdlZW4gdG8gc3RvcmUgdGhlIGZpbmFsIHBhcnQgb2YgdGhlIHN0cmluZyAoYWZ0ZXIgdGhlIGxhc3QgbnVtYmVyKVxuXHRcdHB0LmZwID0gZnVuY1BhcmFtO1xuXHRcdGlmIChfcmVsRXhwLnRlc3QoZW5kKSB8fCBoYXNSYW5kb20pIHtcblx0XHRcdHB0LmUgPSAwOyAvL2lmIHRoZSBlbmQgc3RyaW5nIGNvbnRhaW5zIHJlbGF0aXZlIHZhbHVlcyBvciBkeW5hbWljIHJhbmRvbSguLi4pIHZhbHVlcywgZGVsZXRlIHRoZSBlbmQgaXQgc28gdGhhdCBvbiB0aGUgZmluYWwgcmVuZGVyIHdlIGRvbid0IGFjdHVhbGx5IHNldCBpdCB0byB0aGUgc3RyaW5nIHdpdGggKz0gb3IgLT0gY2hhcmFjdGVycyAoZm9yY2VzIGl0IHRvIHVzZSB0aGUgY2FsY3VsYXRlZCB2YWx1ZSkuXG5cdFx0fVxuXHRcdHRoaXMuX3B0ID0gcHQ7IC8vc3RhcnQgdGhlIGxpbmtlZCBsaXN0IHdpdGggdGhpcyBuZXcgUHJvcFR3ZWVuLiBSZW1lbWJlciwgd2UgY2FsbCBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHR3ZWVuSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblx0XHRyZXR1cm4gcHQ7XG5cdH0sXG5cdF9hZGRQcm9wVHdlZW4gPSBmdW5jdGlvbih0YXJnZXQsIHByb3AsIHN0YXJ0LCBlbmQsIGluZGV4LCB0YXJnZXRzLCBtb2RpZmllciwgc3RyaW5nRmlsdGVyLCBmdW5jUGFyYW0pIHtcblx0XHRfaXNGdW5jdGlvbihlbmQpICYmIChlbmQgPSBlbmQoaW5kZXggfHwgMCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG5cdFx0bGV0IGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtwcm9wXSxcblx0XHRcdHBhcnNlZFN0YXJ0ID0gKHN0YXJ0ICE9PSBcImdldFwiKSA/IHN0YXJ0IDogIV9pc0Z1bmN0aW9uKGN1cnJlbnRWYWx1ZSkgPyBjdXJyZW50VmFsdWUgOiAoZnVuY1BhcmFtID8gdGFyZ2V0Wyhwcm9wLmluZGV4T2YoXCJzZXRcIikgfHwgIV9pc0Z1bmN0aW9uKHRhcmdldFtcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKSkgPyBwcm9wIDogXCJnZXRcIiArIHByb3Auc3Vic3RyKDMpXShmdW5jUGFyYW0pIDogdGFyZ2V0W3Byb3BdKCkpLFxuXHRcdFx0c2V0dGVyID0gIV9pc0Z1bmN0aW9uKGN1cnJlbnRWYWx1ZSkgPyBfc2V0dGVyUGxhaW4gOiBmdW5jUGFyYW0gPyBfc2V0dGVyRnVuY1dpdGhQYXJhbSA6IF9zZXR0ZXJGdW5jLFxuXHRcdFx0cHQ7XG5cdFx0aWYgKF9pc1N0cmluZyhlbmQpKSB7XG5cdFx0XHRpZiAofmVuZC5pbmRleE9mKFwicmFuZG9tKFwiKSkge1xuXHRcdFx0XHRlbmQgPSBfcmVwbGFjZVJhbmRvbShlbmQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVuZC5jaGFyQXQoMSkgPT09IFwiPVwiKSB7XG5cdFx0XHRcdHB0ID0gcGFyc2VGbG9hdChwYXJzZWRTdGFydCkgKyBwYXJzZUZsb2F0KGVuZC5zdWJzdHIoMikpICogKGVuZC5jaGFyQXQoMCkgPT09IFwiLVwiID8gLTEgOiAxKSArIChnZXRVbml0KHBhcnNlZFN0YXJ0KSB8fCAwKTtcblx0XHRcdFx0aWYgKHB0IHx8IHB0ID09PSAwKSB7IC8vIHRvIGF2b2lkIGlzTmFOLCBsaWtlIGlmIHNvbWVvbmUgcGFzc2VzIGluIGEgdmFsdWUgbGlrZSBcIiE9IHdoYXRldmVyXCJcblx0XHRcdFx0XHRlbmQgPSBwdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAocGFyc2VkU3RhcnQgIT09IGVuZCkge1xuXHRcdFx0aWYgKCFpc05hTihwYXJzZWRTdGFydCAqIGVuZCkgJiYgZW5kICE9PSBcIlwiKSB7IC8vIGZ1biBmYWN0OiBhbnkgbnVtYmVyIG11bHRpcGxpZWQgYnkgXCJcIiBpcyBldmFsdWF0ZWQgYXMgdGhlIG51bWJlciAwIVxuXHRcdFx0XHRwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldCwgcHJvcCwgK3BhcnNlZFN0YXJ0IHx8IDAsIGVuZCAtIChwYXJzZWRTdGFydCB8fCAwKSwgdHlwZW9mKGN1cnJlbnRWYWx1ZSkgPT09IFwiYm9vbGVhblwiID8gX3JlbmRlckJvb2xlYW4gOiBfcmVuZGVyUGxhaW4sIDAsIHNldHRlcik7XG5cdFx0XHRcdGZ1bmNQYXJhbSAmJiAocHQuZnAgPSBmdW5jUGFyYW0pO1xuXHRcdFx0XHRtb2RpZmllciAmJiBwdC5tb2RpZmllcihtb2RpZmllciwgdGhpcywgdGFyZ2V0KTtcblx0XHRcdFx0cmV0dXJuICh0aGlzLl9wdCA9IHB0KTtcblx0XHRcdH1cblx0XHRcdCFjdXJyZW50VmFsdWUgJiYgIShwcm9wIGluIHRhcmdldCkgJiYgX21pc3NpbmdQbHVnaW4ocHJvcCwgZW5kKTtcblx0XHRcdHJldHVybiBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHRoaXMsIHRhcmdldCwgcHJvcCwgcGFyc2VkU3RhcnQsIGVuZCwgc2V0dGVyLCBzdHJpbmdGaWx0ZXIgfHwgX2NvbmZpZy5zdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSk7XG5cdFx0fVxuXHR9LFxuXHQvL2NyZWF0ZXMgYSBjb3B5IG9mIHRoZSB2YXJzIG9iamVjdCBhbmQgcHJvY2Vzc2VzIGFueSBmdW5jdGlvbi1iYXNlZCB2YWx1ZXMgKHB1dHRpbmcgdGhlIHJlc3VsdGluZyB2YWx1ZXMgZGlyZWN0bHkgaW50byB0aGUgY29weSkgYXMgd2VsbCBhcyBzdHJpbmdzIHdpdGggXCJyYW5kb20oKVwiIGluIHRoZW0uIEl0IGRvZXMgTk9UIHByb2Nlc3MgcmVsYXRpdmUgdmFsdWVzLlxuXHRfcHJvY2Vzc1ZhcnMgPSAodmFycywgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cywgdHdlZW4pID0+IHtcblx0XHRfaXNGdW5jdGlvbih2YXJzKSAmJiAodmFycyA9IF9wYXJzZUZ1bmNPclN0cmluZyh2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykpO1xuXHRcdGlmICghX2lzT2JqZWN0KHZhcnMpIHx8ICh2YXJzLnN0eWxlICYmIHZhcnMubm9kZVR5cGUpIHx8IF9pc0FycmF5KHZhcnMpIHx8IF9pc1R5cGVkQXJyYXkodmFycykpIHtcblx0XHRcdHJldHVybiBfaXNTdHJpbmcodmFycykgPyBfcGFyc2VGdW5jT3JTdHJpbmcodmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIDogdmFycztcblx0XHR9XG5cdFx0bGV0IGNvcHkgPSB7fSxcblx0XHRcdHA7XG5cdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdGNvcHlbcF0gPSBfcGFyc2VGdW5jT3JTdHJpbmcodmFyc1twXSwgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gY29weTtcblx0fSxcblx0X2NoZWNrUGx1Z2luID0gKHByb3BlcnR5LCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykgPT4ge1xuXHRcdGxldCBwbHVnaW4sIHB0LCBwdExvb2t1cCwgaTtcblx0XHRpZiAoX3BsdWdpbnNbcHJvcGVydHldICYmIChwbHVnaW4gPSBuZXcgX3BsdWdpbnNbcHJvcGVydHldKCkpLmluaXQodGFyZ2V0LCBwbHVnaW4ucmF3VmFycyA/IHZhcnNbcHJvcGVydHldIDogX3Byb2Nlc3NWYXJzKHZhcnNbcHJvcGVydHldLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzLCB0d2VlbiksIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykgIT09IGZhbHNlKSB7XG5cdFx0XHR0d2Vlbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4odHdlZW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAxLCBwbHVnaW4ucmVuZGVyLCBwbHVnaW4sIDAsIHBsdWdpbi5wcmlvcml0eSk7XG5cdFx0XHRpZiAodHdlZW4gIT09IF9xdWlja1R3ZWVuKSB7XG5cdFx0XHRcdHB0TG9va3VwID0gdHdlZW4uX3B0TG9va3VwW3R3ZWVuLl90YXJnZXRzLmluZGV4T2YodGFyZ2V0KV07IC8vbm90ZTogd2UgY2FuJ3QgdXNlIHR3ZWVuLl9wdExvb2t1cFtpbmRleF0gYmVjYXVzZSBmb3Igc3RhZ2dlcmVkIHR3ZWVucywgdGhlIGluZGV4IGZyb20gdGhlIGZ1bGxUYXJnZXRzIGFycmF5IHdvbid0IG1hdGNoIHdoYXQgaXQgaXMgaW4gZWFjaCBpbmRpdmlkdWFsIHR3ZWVuIHRoYXQgc3Bhd25zIGZyb20gdGhlIHN0YWdnZXIuXG5cdFx0XHRcdGkgPSBwbHVnaW4uX3Byb3BzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdHB0TG9va3VwW3BsdWdpbi5fcHJvcHNbaV1dID0gcHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHBsdWdpbjtcblx0fSxcblx0X292ZXJ3cml0aW5nVHdlZW4sIC8vc3RvcmUgYSByZWZlcmVuY2UgdGVtcG9yYXJpbHkgc28gd2UgY2FuIGF2b2lkIG92ZXJ3cml0aW5nIGl0c2VsZi5cblx0X2luaXRUd2VlbiA9ICh0d2VlbiwgdGltZSkgPT4ge1xuXHRcdGxldCB2YXJzID0gdHdlZW4udmFycyxcblx0XHRcdHsgZWFzZSwgc3RhcnRBdCwgaW1tZWRpYXRlUmVuZGVyLCBsYXp5LCBvblVwZGF0ZSwgb25VcGRhdGVQYXJhbXMsIGNhbGxiYWNrU2NvcGUsIHJ1bkJhY2t3YXJkcywgeW95b0Vhc2UsIGtleWZyYW1lcywgYXV0b1JldmVydCB9ID0gdmFycyxcblx0XHRcdGR1ciA9IHR3ZWVuLl9kdXIsXG5cdFx0XHRwcmV2U3RhcnRBdCA9IHR3ZWVuLl9zdGFydEF0LFxuXHRcdFx0dGFyZ2V0cyA9IHR3ZWVuLl90YXJnZXRzLFxuXHRcdFx0cGFyZW50ID0gdHdlZW4ucGFyZW50LFxuXHRcdFx0Ly93aGVuIGEgc3RhZ2dlciAob3IgZnVuY3Rpb24tYmFzZWQgZHVyYXRpb24vZGVsYXkpIGlzIG9uIGEgVHdlZW4gaW5zdGFuY2UsIHdlIGNyZWF0ZSBhIG5lc3RlZCB0aW1lbGluZSB3aGljaCBtZWFucyB0aGF0IHRoZSBcInRhcmdldHNcIiBvZiB0aGF0IHR3ZWVuIGRvbid0IHJlZmxlY3QgdGhlIHBhcmVudC4gVGhpcyBmdW5jdGlvbiBhbGxvd3MgdXMgdG8gZGlzY2VybiB3aGVuIGl0J3MgYSBuZXN0ZWQgdHdlZW4gYW5kIGluIHRoYXQgY2FzZSwgcmV0dXJuIHRoZSBmdWxsIHRhcmdldHMgYXJyYXkgc28gdGhhdCBmdW5jdGlvbi1iYXNlZCB2YWx1ZXMgZ2V0IGNhbGN1bGF0ZWQgcHJvcGVybHkuXG5cdFx0XHRmdWxsVGFyZ2V0cyA9IChwYXJlbnQgJiYgcGFyZW50LmRhdGEgPT09IFwibmVzdGVkXCIpID8gcGFyZW50LnBhcmVudC5fdGFyZ2V0cyA6IHRhcmdldHMsXG5cdFx0XHRhdXRvT3ZlcndyaXRlID0gKHR3ZWVuLl9vdmVyd3JpdGUgPT09IFwiYXV0b1wiKSAmJiAhX3N1cHByZXNzT3ZlcndyaXRlcyxcblx0XHRcdHRsID0gdHdlZW4udGltZWxpbmUsXG5cdFx0XHRjbGVhblZhcnMsIGksIHAsIHB0LCB0YXJnZXQsIGhhc1ByaW9yaXR5LCBnc0RhdGEsIGhhcm5lc3MsIHBsdWdpbiwgcHRMb29rdXAsIGluZGV4LCBoYXJuZXNzVmFycywgb3ZlcndyaXR0ZW47XG5cdFx0dGwgJiYgKCFrZXlmcmFtZXMgfHwgIWVhc2UpICYmIChlYXNlID0gXCJub25lXCIpO1xuXHRcdHR3ZWVuLl9lYXNlID0gX3BhcnNlRWFzZShlYXNlLCBfZGVmYXVsdHMuZWFzZSk7XG5cdFx0dHdlZW4uX3lFYXNlID0geW95b0Vhc2UgPyBfaW52ZXJ0RWFzZShfcGFyc2VFYXNlKHlveW9FYXNlID09PSB0cnVlID8gZWFzZSA6IHlveW9FYXNlLCBfZGVmYXVsdHMuZWFzZSkpIDogMDtcblx0XHRpZiAoeW95b0Vhc2UgJiYgdHdlZW4uX3lveW8gJiYgIXR3ZWVuLl9yZXBlYXQpIHsgLy90aGVyZSBtdXN0IGhhdmUgYmVlbiBhIHBhcmVudCB0aW1lbGluZSB3aXRoIHlveW86dHJ1ZSB0aGF0IGlzIGN1cnJlbnRseSBpbiBpdHMgeW95byBwaGFzZSwgc28gZmxpcCB0aGUgZWFzZXMuXG5cdFx0XHR5b3lvRWFzZSA9IHR3ZWVuLl95RWFzZTtcblx0XHRcdHR3ZWVuLl95RWFzZSA9IHR3ZWVuLl9lYXNlO1xuXHRcdFx0dHdlZW4uX2Vhc2UgPSB5b3lvRWFzZTtcblx0XHR9XG5cdFx0dHdlZW4uX2Zyb20gPSAhdGwgJiYgISF2YXJzLnJ1bkJhY2t3YXJkczsgLy9uZXN0ZWQgdGltZWxpbmVzIHNob3VsZCBuZXZlciBydW4gYmFja3dhcmRzIC0gdGhlIGJhY2t3YXJkcy1uZXNzIGlzIGluIHRoZSBjaGlsZCB0d2VlbnMuXG5cdFx0aWYgKCF0bCkgeyAvL2lmIHRoZXJlJ3MgYW4gaW50ZXJuYWwgdGltZWxpbmUsIHNraXAgYWxsIHRoZSBwYXJzaW5nIGJlY2F1c2Ugd2UgcGFzc2VkIHRoYXQgdGFzayBkb3duIHRoZSBjaGFpbi5cblx0XHRcdGhhcm5lc3MgPSB0YXJnZXRzWzBdID8gX2dldENhY2hlKHRhcmdldHNbMF0pLmhhcm5lc3MgOiAwO1xuXHRcdFx0aGFybmVzc1ZhcnMgPSBoYXJuZXNzICYmIHZhcnNbaGFybmVzcy5wcm9wXTsgLy9zb21lb25lIG1heSBuZWVkIHRvIHNwZWNpZnkgQ1NTLXNwZWNpZmljIHZhbHVlcyBBTkQgbm9uLUNTUyB2YWx1ZXMsIGxpa2UgaWYgdGhlIGVsZW1lbnQgaGFzIGFuIFwieFwiIHByb3BlcnR5IHBsdXMgaXQncyBhIHN0YW5kYXJkIERPTSBlbGVtZW50LiBXZSBhbGxvdyBwZW9wbGUgdG8gZGlzdGluZ3Vpc2ggYnkgd3JhcHBpbmcgcGx1Z2luLXNwZWNpZmljIHN0dWZmIGluIGEgY3NzOnt9IG9iamVjdCBmb3IgZXhhbXBsZS5cblx0XHRcdGNsZWFuVmFycyA9IF9jb3B5RXhjbHVkaW5nKHZhcnMsIF9yZXNlcnZlZFByb3BzKTtcblx0XHRcdHByZXZTdGFydEF0ICYmIHByZXZTdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSkua2lsbCgpO1xuXHRcdFx0aWYgKHN0YXJ0QXQpIHtcblx0XHRcdFx0X3JlbW92ZUZyb21QYXJlbnQodHdlZW4uX3N0YXJ0QXQgPSBUd2Vlbi5zZXQodGFyZ2V0cywgX3NldERlZmF1bHRzKHtkYXRhOiBcImlzU3RhcnRcIiwgb3ZlcndyaXRlOiBmYWxzZSwgcGFyZW50OiBwYXJlbnQsIGltbWVkaWF0ZVJlbmRlcjogdHJ1ZSwgbGF6eTogX2lzTm90RmFsc2UobGF6eSksIHN0YXJ0QXQ6IG51bGwsIGRlbGF5OiAwLCBvblVwZGF0ZTogb25VcGRhdGUsIG9uVXBkYXRlUGFyYW1zOiBvblVwZGF0ZVBhcmFtcywgY2FsbGJhY2tTY29wZTogY2FsbGJhY2tTY29wZSwgc3RhZ2dlcjogMH0sIHN0YXJ0QXQpKSk7IC8vY29weSB0aGUgcHJvcGVydGllcy92YWx1ZXMgaW50byBhIG5ldyBvYmplY3QgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSB2YXIgdG8gPSB7eDowfSwgZnJvbSA9IHt4OjUwMH07IHRpbWVsaW5lLmZyb21UbyhlLCBmcm9tLCB0bykuZnJvbVRvKGUsIHRvLCBmcm9tKTtcblx0XHRcdFx0KHRpbWUgPCAwICYmICFpbW1lZGlhdGVSZW5kZXIgJiYgIWF1dG9SZXZlcnQpICYmIHR3ZWVuLl9zdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSk7IC8vIHJhcmUgZWRnZSBjYXNlLCBsaWtlIGlmIGEgcmVuZGVyIGlzIGZvcmNlZCBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uIG9mIGEgbm9uLWluaXR0ZWQgdHdlZW4uXG5cdFx0XHRcdGlmIChpbW1lZGlhdGVSZW5kZXIpIHtcblx0XHRcdFx0XHQodGltZSA+IDApICYmICFhdXRvUmV2ZXJ0ICYmICh0d2Vlbi5fc3RhcnRBdCA9IDApOyAvL3R3ZWVucyB0aGF0IHJlbmRlciBpbW1lZGlhdGVseSAobGlrZSBtb3N0IGZyb20oKSBhbmQgZnJvbVRvKCkgdHdlZW5zKSBzaG91bGRuJ3QgcmV2ZXJ0IHdoZW4gdGhlaXIgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSBzdGFydFRpbWUgYmVjYXVzZSB0aGUgaW5pdGlhbCByZW5kZXIgY291bGQgaGF2ZSBoYXBwZW5lZCBhbnl0aW1lIGFuZCBpdCBzaG91bGRuJ3QgYmUgZGlyZWN0bHkgY29ycmVsYXRlZCB0byB0aGlzIHR3ZWVuJ3Mgc3RhcnRUaW1lLiBJbWFnaW5lIHNldHRpbmcgdXAgYSBjb21wbGV4IGFuaW1hdGlvbiB3aGVyZSB0aGUgYmVnaW5uaW5nIHN0YXRlcyBvZiB2YXJpb3VzIG9iamVjdHMgYXJlIHJlbmRlcmVkIGltbWVkaWF0ZWx5IGJ1dCB0aGUgdHdlZW4gZG9lc24ndCBoYXBwZW4gZm9yIHF1aXRlIHNvbWUgdGltZSAtIGlmIHdlIHJldmVydCB0byB0aGUgc3RhcnRpbmcgdmFsdWVzIGFzIHNvb24gYXMgdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgcGFzdCB0aGUgdHdlZW4ncyBzdGFydFRpbWUsIGl0IHdpbGwgdGhyb3cgdGhpbmdzIG9mZiB2aXN1YWxseS4gUmV2ZXJzaW9uIHNob3VsZCBvbmx5IGhhcHBlbiBpbiBUaW1lbGluZSBpbnN0YW5jZXMgd2hlcmUgaW1tZWRpYXRlUmVuZGVyIHdhcyBmYWxzZSBvciB3aGVuIGF1dG9SZXZlcnQgaXMgZXhwbGljaXRseSBzZXQgdG8gdHJ1ZS5cblx0XHRcdFx0XHRpZiAoZHVyICYmIHRpbWUgPD0gMCkge1xuXHRcdFx0XHRcdFx0dGltZSAmJiAodHdlZW4uX3pUaW1lID0gdGltZSk7XG5cdFx0XHRcdFx0XHRyZXR1cm47IC8vd2Ugc2tpcCBpbml0aWFsaXphdGlvbiBoZXJlIHNvIHRoYXQgb3ZlcndyaXRpbmcgZG9lc24ndCBvY2N1ciB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zLiBPdGhlcndpc2UsIGlmIHlvdSBjcmVhdGUgc2V2ZXJhbCBpbW1lZGlhdGVSZW5kZXI6dHJ1ZSB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0L3Byb3BlcnRpZXMgdG8gZHJvcCBpbnRvIGEgVGltZWxpbmUsIHRoZSBsYXN0IG9uZSBjcmVhdGVkIHdvdWxkIG92ZXJ3cml0ZSB0aGUgZmlyc3Qgb25lcyBiZWNhdXNlIHRoZXkgZGlkbid0IGdldCBwbGFjZWQgaW50byB0aGUgdGltZWxpbmUgeWV0IGJlZm9yZSB0aGUgZmlyc3QgcmVuZGVyIG9jY3VycyBhbmQga2lja3MgaW4gb3ZlcndyaXRpbmcuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGlmICh0aW1lID4gMCkge1xuXHRcdFx0XHRcdC8vIFx0YXV0b1JldmVydCB8fCAodHdlZW4uX3N0YXJ0QXQgPSAwKTsgLy90d2VlbnMgdGhhdCByZW5kZXIgaW1tZWRpYXRlbHkgKGxpa2UgbW9zdCBmcm9tKCkgYW5kIGZyb21UbygpIHR3ZWVucykgc2hvdWxkbid0IHJldmVydCB3aGVuIHRoZWlyIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgcGFzdCB0aGUgc3RhcnRUaW1lIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIGNvdWxkIGhhdmUgaGFwcGVuZWQgYW55dGltZSBhbmQgaXQgc2hvdWxkbid0IGJlIGRpcmVjdGx5IGNvcnJlbGF0ZWQgdG8gdGhpcyB0d2VlbidzIHN0YXJ0VGltZS4gSW1hZ2luZSBzZXR0aW5nIHVwIGEgY29tcGxleCBhbmltYXRpb24gd2hlcmUgdGhlIGJlZ2lubmluZyBzdGF0ZXMgb2YgdmFyaW91cyBvYmplY3RzIGFyZSByZW5kZXJlZCBpbW1lZGlhdGVseSBidXQgdGhlIHR3ZWVuIGRvZXNuJ3QgaGFwcGVuIGZvciBxdWl0ZSBzb21lIHRpbWUgLSBpZiB3ZSByZXZlcnQgdG8gdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcyBzb29uIGFzIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHR3ZWVuJ3Mgc3RhcnRUaW1lLCBpdCB3aWxsIHRocm93IHRoaW5ncyBvZmYgdmlzdWFsbHkuIFJldmVyc2lvbiBzaG91bGQgb25seSBoYXBwZW4gaW4gVGltZWxpbmUgaW5zdGFuY2VzIHdoZXJlIGltbWVkaWF0ZVJlbmRlciB3YXMgZmFsc2Ugb3Igd2hlbiBhdXRvUmV2ZXJ0IGlzIGV4cGxpY2l0bHkgc2V0IHRvIHRydWUuXG5cdFx0XHRcdFx0Ly8gfSBlbHNlIGlmIChkdXIgJiYgISh0aW1lIDwgMCAmJiBwcmV2U3RhcnRBdCkpIHtcblx0XHRcdFx0XHQvLyBcdHRpbWUgJiYgKHR3ZWVuLl96VGltZSA9IHRpbWUpO1xuXHRcdFx0XHRcdC8vIFx0cmV0dXJuOyAvL3dlIHNraXAgaW5pdGlhbGl6YXRpb24gaGVyZSBzbyB0aGF0IG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb2NjdXIgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucy4gT3RoZXJ3aXNlLCBpZiB5b3UgY3JlYXRlIHNldmVyYWwgaW1tZWRpYXRlUmVuZGVyOnRydWUgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldC9wcm9wZXJ0aWVzIHRvIGRyb3AgaW50byBhIFRpbWVsaW5lLCB0aGUgbGFzdCBvbmUgY3JlYXRlZCB3b3VsZCBvdmVyd3JpdGUgdGhlIGZpcnN0IG9uZXMgYmVjYXVzZSB0aGV5IGRpZG4ndCBnZXQgcGxhY2VkIGludG8gdGhlIHRpbWVsaW5lIHlldCBiZWZvcmUgdGhlIGZpcnN0IHJlbmRlciBvY2N1cnMgYW5kIGtpY2tzIGluIG92ZXJ3cml0aW5nLlxuXHRcdFx0XHRcdC8vIH1cblx0XHRcdFx0fSBlbHNlIGlmIChhdXRvUmV2ZXJ0ID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdHR3ZWVuLl9zdGFydEF0ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChydW5CYWNrd2FyZHMgJiYgZHVyKSB7XG5cdFx0XHRcdC8vZnJvbSgpIHR3ZWVucyBtdXN0IGJlIGhhbmRsZWQgdW5pcXVlbHk6IHRoZWlyIGJlZ2lubmluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZCBidXQgd2UgZG9uJ3Qgd2FudCBvdmVyd3JpdGluZyB0byBvY2N1ciB5ZXQgKHdoZW4gdGltZSBpcyBzdGlsbCAwKS4gV2FpdCB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zIGJlZm9yZSBkb2luZyBhbGwgdGhlIHJvdXRpbmVzIGxpa2Ugb3ZlcndyaXRpbmcuIEF0IHRoYXQgdGltZSwgd2Ugc2hvdWxkIHJlbmRlciBhdCB0aGUgRU5EIG9mIHRoZSB0d2VlbiB0byBlbnN1cmUgdGhhdCB0aGluZ3MgaW5pdGlhbGl6ZSBjb3JyZWN0bHkgKHJlbWVtYmVyLCBmcm9tKCkgdHdlZW5zIGdvIGJhY2t3YXJkcylcblx0XHRcdFx0aWYgKHByZXZTdGFydEF0KSB7XG5cdFx0XHRcdFx0IWF1dG9SZXZlcnQgJiYgKHR3ZWVuLl9zdGFydEF0ID0gMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGltZSAmJiAoaW1tZWRpYXRlUmVuZGVyID0gZmFsc2UpOyAvL2luIHJhcmUgY2FzZXMgKGxpa2UgaWYgYSBmcm9tKCkgdHdlZW4gcnVucyBhbmQgdGhlbiBpcyBpbnZhbGlkYXRlKCktZWQpLCBpbW1lZGlhdGVSZW5kZXIgY291bGQgYmUgdHJ1ZSBidXQgdGhlIGluaXRpYWwgZm9yY2VkLXJlbmRlciBnZXRzIHNraXBwZWQsIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSB0aGUgcmVuZGVyIGluIHRoaXMgY29udGV4dCB3aGVuIHRoZSBfdGltZSBpcyBncmVhdGVyIHRoYW4gMFxuXHRcdFx0XHRcdHAgPSBfc2V0RGVmYXVsdHMoe1xuXHRcdFx0XHRcdFx0b3ZlcndyaXRlOiBmYWxzZSxcblx0XHRcdFx0XHRcdGRhdGE6IFwiaXNGcm9tU3RhcnRcIiwgLy93ZSB0YWcgdGhlIHR3ZWVuIHdpdGggYXMgXCJpc0Zyb21TdGFydFwiIHNvIHRoYXQgaWYgW2luc2lkZSBhIHBsdWdpbl0gd2UgbmVlZCB0byBvbmx5IGRvIHNvbWV0aGluZyBhdCB0aGUgdmVyeSBFTkQgb2YgYSB0d2Vlbiwgd2UgaGF2ZSBhIHdheSBvZiBpZGVudGlmeWluZyB0aGlzIHR3ZWVuIGFzIG1lcmVseSB0aGUgb25lIHRoYXQncyBzZXR0aW5nIHRoZSBiZWdpbm5pbmcgdmFsdWVzIGZvciBhIFwiZnJvbSgpXCIgdHdlZW4uIEZvciBleGFtcGxlLCBjbGVhclByb3BzIGluIENTU1BsdWdpbiBzaG91bGQgb25seSBnZXQgYXBwbGllZCBhdCB0aGUgdmVyeSBFTkQgb2YgYSB0d2VlbiBhbmQgd2l0aG91dCB0aGlzIHRhZywgZnJvbSguLi57aGVpZ2h0OjEwMCwgY2xlYXJQcm9wczpcImhlaWdodFwiLCBkZWxheToxfSkgd291bGQgd2lwZSB0aGUgaGVpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHR3ZWVuIGFuZCBhZnRlciAxIHNlY29uZCwgaXQnZCBraWNrIGJhY2sgaW4uXG5cdFx0XHRcdFx0XHRsYXp5OiBpbW1lZGlhdGVSZW5kZXIgJiYgX2lzTm90RmFsc2UobGF6eSksXG5cdFx0XHRcdFx0XHRpbW1lZGlhdGVSZW5kZXI6IGltbWVkaWF0ZVJlbmRlciwgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyByZW5kZXIgaW1tZWRpYXRlbHkgYnkgZGVmYXVsdCwgYnV0IGlmIHdlJ3JlIG5vdCBzcGVjaWZpY2FsbHkgaW5zdHJ1Y3RlZCB0byByZW5kZXIgdGhpcyB0d2VlbiBpbW1lZGlhdGVseSwgd2Ugc2hvdWxkIHNraXAgdGhpcyBhbmQgbWVyZWx5IF9pbml0KCkgdG8gcmVjb3JkIHRoZSBzdGFydGluZyB2YWx1ZXMgKHJlbmRlcmluZyB0aGVtIGltbWVkaWF0ZWx5IHdvdWxkIHB1c2ggdGhlbSB0byBjb21wbGV0aW9uIHdoaWNoIGlzIHdhc3RlZnVsIGluIHRoYXQgY2FzZSAtIHdlJ2QgaGF2ZSB0byByZW5kZXIoLTEpIGltbWVkaWF0ZWx5IGFmdGVyKVxuXHRcdFx0XHRcdFx0c3RhZ2dlcjogMCxcblx0XHRcdFx0XHRcdHBhcmVudDogcGFyZW50IC8vZW5zdXJlcyB0aGF0IG5lc3RlZCB0d2VlbnMgdGhhdCBoYWQgYSBzdGFnZ2VyIGFyZSBoYW5kbGVkIHByb3Blcmx5LCBsaWtlIGdzYXAuZnJvbShcIi5jbGFzc1wiLCB7eTpnc2FwLnV0aWxzLndyYXAoWy0xMDAsMTAwXSl9KVxuXHRcdFx0XHRcdH0sIGNsZWFuVmFycyk7XG5cdFx0XHRcdFx0aGFybmVzc1ZhcnMgJiYgKHBbaGFybmVzcy5wcm9wXSA9IGhhcm5lc3NWYXJzKTsgLy8gaW4gY2FzZSBzb21lb25lIGRvZXMgc29tZXRoaW5nIGxpa2UgLmZyb20oLi4uLCB7Y3NzOnt9fSlcblx0XHRcdFx0XHRfcmVtb3ZlRnJvbVBhcmVudCh0d2Vlbi5fc3RhcnRBdCA9IFR3ZWVuLnNldCh0YXJnZXRzLCBwKSk7XG5cdFx0XHRcdFx0KHRpbWUgPCAwKSAmJiB0d2Vlbi5fc3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpOyAvLyByYXJlIGVkZ2UgY2FzZSwgbGlrZSBpZiBhIHJlbmRlciBpcyBmb3JjZWQgaW4gdGhlIG5lZ2F0aXZlIGRpcmVjdGlvbiBvZiBhIG5vbi1pbml0dGVkIGZyb20oKSB0d2Vlbi5cblx0XHRcdFx0XHRpZiAoIWltbWVkaWF0ZVJlbmRlcikge1xuXHRcdFx0XHRcdFx0X2luaXRUd2Vlbih0d2Vlbi5fc3RhcnRBdCwgX3RpbnlOdW0pOyAvL2Vuc3VyZXMgdGhhdCB0aGUgaW5pdGlhbCB2YWx1ZXMgYXJlIHJlY29yZGVkXG5cdFx0XHRcdFx0fSBlbHNlIGlmICghdGltZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dHdlZW4uX3B0ID0gMDtcblx0XHRcdGxhenkgPSAoZHVyICYmIF9pc05vdEZhbHNlKGxhenkpKSB8fCAobGF6eSAmJiAhZHVyKTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRhcmdldCA9IHRhcmdldHNbaV07XG5cdFx0XHRcdGdzRGF0YSA9IHRhcmdldC5fZ3NhcCB8fCBfaGFybmVzcyh0YXJnZXRzKVtpXS5fZ3NhcDtcblx0XHRcdFx0dHdlZW4uX3B0TG9va3VwW2ldID0gcHRMb29rdXAgPSB7fTtcblx0XHRcdFx0X2xhenlMb29rdXBbZ3NEYXRhLmlkXSAmJiBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTsgLy9pZiBvdGhlciB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0IGhhdmUgcmVjZW50bHkgaW5pdHRlZCBidXQgaGF2ZW4ndCByZW5kZXJlZCB5ZXQsIHdlJ3ZlIGdvdCB0byBmb3JjZSB0aGUgcmVuZGVyIHNvIHRoYXQgdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcmUgY29ycmVjdCAoaW1hZ2luZSBwb3B1bGF0aW5nIGEgdGltZWxpbmUgd2l0aCBhIGJ1bmNoIG9mIHNlcXVlbnRpYWwgdHdlZW5zIGFuZCB0aGVuIGp1bXBpbmcgdG8gdGhlIGVuZClcblx0XHRcdFx0aW5kZXggPSBmdWxsVGFyZ2V0cyA9PT0gdGFyZ2V0cyA/IGkgOiBmdWxsVGFyZ2V0cy5pbmRleE9mKHRhcmdldCk7XG5cdFx0XHRcdGlmIChoYXJuZXNzICYmIChwbHVnaW4gPSBuZXcgaGFybmVzcygpKS5pbml0KHRhcmdldCwgaGFybmVzc1ZhcnMgfHwgY2xlYW5WYXJzLCB0d2VlbiwgaW5kZXgsIGZ1bGxUYXJnZXRzKSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHR0d2Vlbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4odHdlZW4uX3B0LCB0YXJnZXQsIHBsdWdpbi5uYW1lLCAwLCAxLCBwbHVnaW4ucmVuZGVyLCBwbHVnaW4sIDAsIHBsdWdpbi5wcmlvcml0eSk7XG5cdFx0XHRcdFx0cGx1Z2luLl9wcm9wcy5mb3JFYWNoKG5hbWUgPT4ge3B0TG9va3VwW25hbWVdID0gcHQ7fSk7XG5cdFx0XHRcdFx0cGx1Z2luLnByaW9yaXR5ICYmIChoYXNQcmlvcml0eSA9IDEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaGFybmVzcyB8fCBoYXJuZXNzVmFycykge1xuXHRcdFx0XHRcdGZvciAocCBpbiBjbGVhblZhcnMpIHtcblx0XHRcdFx0XHRcdGlmIChfcGx1Z2luc1twXSAmJiAocGx1Z2luID0gX2NoZWNrUGx1Z2luKHAsIGNsZWFuVmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIGZ1bGxUYXJnZXRzKSkpIHtcblx0XHRcdFx0XHRcdFx0cGx1Z2luLnByaW9yaXR5ICYmIChoYXNQcmlvcml0eSA9IDEpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cHRMb29rdXBbcF0gPSBwdCA9IF9hZGRQcm9wVHdlZW4uY2FsbCh0d2VlbiwgdGFyZ2V0LCBwLCBcImdldFwiLCBjbGVhblZhcnNbcF0sIGluZGV4LCBmdWxsVGFyZ2V0cywgMCwgdmFycy5zdHJpbmdGaWx0ZXIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0d2Vlbi5fb3AgJiYgdHdlZW4uX29wW2ldICYmIHR3ZWVuLmtpbGwodGFyZ2V0LCB0d2Vlbi5fb3BbaV0pO1xuXHRcdFx0XHRpZiAoYXV0b092ZXJ3cml0ZSAmJiB0d2Vlbi5fcHQpIHtcblx0XHRcdFx0XHRfb3ZlcndyaXRpbmdUd2VlbiA9IHR3ZWVuO1xuXHRcdFx0XHRcdF9nbG9iYWxUaW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0LCBwdExvb2t1cCwgdHdlZW4uZ2xvYmFsVGltZSgwKSk7IC8vQWxzbyBtYWtlIHN1cmUgdGhlIG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb3ZlcndyaXRlIFRISVMgdHdlZW4hISFcblx0XHRcdFx0XHRvdmVyd3JpdHRlbiA9ICF0d2Vlbi5wYXJlbnQ7XG5cdFx0XHRcdFx0X292ZXJ3cml0aW5nVHdlZW4gPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuLl9wdCAmJiBsYXp5ICYmIChfbGF6eUxvb2t1cFtnc0RhdGEuaWRdID0gMSk7XG5cdFx0XHR9XG5cdFx0XHRoYXNQcmlvcml0eSAmJiBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5KHR3ZWVuKTtcblx0XHRcdHR3ZWVuLl9vbkluaXQgJiYgdHdlZW4uX29uSW5pdCh0d2Vlbik7IC8vcGx1Z2lucyBsaWtlIFJvdW5kUHJvcHMgbXVzdCB3YWl0IHVudGlsIEFMTCBvZiB0aGUgUHJvcFR3ZWVucyBhcmUgaW5zdGFudGlhdGVkLiBJbiB0aGUgcGx1Z2luJ3MgaW5pdCgpIGZ1bmN0aW9uLCBpdCBzZXRzIHRoZSBfb25Jbml0IG9uIHRoZSB0d2VlbiBpbnN0YW5jZS4gTWF5IG5vdCBiZSBwcmV0dHkvaW50dWl0aXZlLCBidXQgaXQncyBmYXN0IGFuZCBrZWVwcyBmaWxlIHNpemUgZG93bi5cblx0XHR9XG5cdFx0dHdlZW4uX29uVXBkYXRlID0gb25VcGRhdGU7XG5cdFx0dHdlZW4uX2luaXR0ZWQgPSAoIXR3ZWVuLl9vcCB8fCB0d2Vlbi5fcHQpICYmICFvdmVyd3JpdHRlbjsgLy8gaWYgb3ZlcndyaXR0ZW5Qcm9wcyByZXN1bHRlZCBpbiB0aGUgZW50aXJlIHR3ZWVuIGJlaW5nIGtpbGxlZCwgZG8gTk9UIGZsYWcgaXQgYXMgaW5pdHRlZCBvciBlbHNlIGl0IG1heSByZW5kZXIgZm9yIG9uZSB0aWNrLlxuXHR9LFxuXHRfYWRkQWxpYXNlc1RvVmFycyA9ICh0YXJnZXRzLCB2YXJzKSA9PiB7XG5cdFx0bGV0IGhhcm5lc3MgPSB0YXJnZXRzWzBdID8gX2dldENhY2hlKHRhcmdldHNbMF0pLmhhcm5lc3MgOiAwLFxuXHRcdFx0cHJvcGVydHlBbGlhc2VzID0gKGhhcm5lc3MgJiYgaGFybmVzcy5hbGlhc2VzKSxcblx0XHRcdGNvcHksIHAsIGksIGFsaWFzZXM7XG5cdFx0aWYgKCFwcm9wZXJ0eUFsaWFzZXMpIHtcblx0XHRcdHJldHVybiB2YXJzO1xuXHRcdH1cblx0XHRjb3B5ID0gX21lcmdlKHt9LCB2YXJzKTtcblx0XHRmb3IgKHAgaW4gcHJvcGVydHlBbGlhc2VzKSB7XG5cdFx0XHRpZiAocCBpbiBjb3B5KSB7XG5cdFx0XHRcdGFsaWFzZXMgPSBwcm9wZXJ0eUFsaWFzZXNbcF0uc3BsaXQoXCIsXCIpO1xuXHRcdFx0XHRpID0gYWxpYXNlcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlKGktLSkge1xuXHRcdFx0XHRcdGNvcHlbYWxpYXNlc1tpXV0gPSBjb3B5W3BdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cdFx0cmV0dXJuIGNvcHk7XG5cdH0sXG5cdF9wYXJzZUZ1bmNPclN0cmluZyA9ICh2YWx1ZSwgdHdlZW4sIGksIHRhcmdldCwgdGFyZ2V0cykgPT4gKF9pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwodHdlZW4sIGksIHRhcmdldCwgdGFyZ2V0cykgOiAoX2lzU3RyaW5nKHZhbHVlKSAmJiB+dmFsdWUuaW5kZXhPZihcInJhbmRvbShcIikpID8gX3JlcGxhY2VSYW5kb20odmFsdWUpIDogdmFsdWUpLFxuXHRfc3RhZ2dlclR3ZWVuUHJvcHMgPSBfY2FsbGJhY2tOYW1lcyArIFwicmVwZWF0LHJlcGVhdERlbGF5LHlveW8scmVwZWF0UmVmcmVzaCx5b3lvRWFzZVwiLFxuXHRfc3RhZ2dlclByb3BzVG9Ta2lwID0gKF9zdGFnZ2VyVHdlZW5Qcm9wcyArIFwiLGlkLHN0YWdnZXIsZGVsYXksZHVyYXRpb24scGF1c2VkLHNjcm9sbFRyaWdnZXJcIikuc3BsaXQoXCIsXCIpO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVFdFRU5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuZXhwb3J0IGNsYXNzIFR3ZWVuIGV4dGVuZHMgQW5pbWF0aW9uIHtcblxuXHRjb25zdHJ1Y3Rvcih0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbiwgc2tpcEluaGVyaXQpIHtcblx0XHRpZiAodHlwZW9mKHZhcnMpID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHRwb3NpdGlvbi5kdXJhdGlvbiA9IHZhcnM7XG5cdFx0XHR2YXJzID0gcG9zaXRpb247XG5cdFx0XHRwb3NpdGlvbiA9IG51bGw7XG5cdFx0fVxuXHRcdHN1cGVyKHNraXBJbmhlcml0ID8gdmFycyA6IF9pbmhlcml0RGVmYXVsdHModmFycykpO1xuXHRcdGxldCB7IGR1cmF0aW9uLCBkZWxheSwgaW1tZWRpYXRlUmVuZGVyLCBzdGFnZ2VyLCBvdmVyd3JpdGUsIGtleWZyYW1lcywgZGVmYXVsdHMsIHNjcm9sbFRyaWdnZXIsIHlveW9FYXNlIH0gPSB0aGlzLnZhcnMsXG5cdFx0XHRwYXJlbnQgPSB2YXJzLnBhcmVudCB8fCBfZ2xvYmFsVGltZWxpbmUsXG5cdFx0XHRwYXJzZWRUYXJnZXRzID0gKF9pc0FycmF5KHRhcmdldHMpIHx8IF9pc1R5cGVkQXJyYXkodGFyZ2V0cykgPyBfaXNOdW1iZXIodGFyZ2V0c1swXSkgOiAoXCJsZW5ndGhcIiBpbiB2YXJzKSkgPyBbdGFyZ2V0c10gOiB0b0FycmF5KHRhcmdldHMpLCAvLyBlZGdlIGNhc2U6IHNvbWVvbmUgbWlnaHQgdHJ5IGFuaW1hdGluZyB0aGUgXCJsZW5ndGhcIiBvZiBhbiBvYmplY3Qgd2l0aCBhIFwibGVuZ3RoXCIgcHJvcGVydHkgdGhhdCdzIGluaXRpYWxseSBzZXQgdG8gMCBzbyBkb24ndCBpbnRlcnByZXQgdGhhdCBhcyBhbiBlbXB0eSBBcnJheS1saWtlIG9iamVjdC5cblx0XHRcdHRsLCBpLCBjb3B5LCBsLCBwLCBjdXJUYXJnZXQsIHN0YWdnZXJGdW5jLCBzdGFnZ2VyVmFyc1RvTWVyZ2U7XG5cdFx0dGhpcy5fdGFyZ2V0cyA9IHBhcnNlZFRhcmdldHMubGVuZ3RoID8gX2hhcm5lc3MocGFyc2VkVGFyZ2V0cykgOiBfd2FybihcIkdTQVAgdGFyZ2V0IFwiICsgdGFyZ2V0cyArIFwiIG5vdCBmb3VuZC4gaHR0cHM6Ly9ncmVlbnNvY2suY29tXCIsICFfY29uZmlnLm51bGxUYXJnZXRXYXJuKSB8fCBbXTtcblx0XHR0aGlzLl9wdExvb2t1cCA9IFtdOyAvL1Byb3BUd2VlbiBsb29rdXAuIEFuIGFycmF5IGNvbnRhaW5pbmcgYW4gb2JqZWN0IGZvciBlYWNoIHRhcmdldCwgaGF2aW5nIGtleXMgZm9yIGVhY2ggdHdlZW5pbmcgcHJvcGVydHlcblx0XHR0aGlzLl9vdmVyd3JpdGUgPSBvdmVyd3JpdGU7XG5cdFx0aWYgKGtleWZyYW1lcyB8fCBzdGFnZ2VyIHx8IF9pc0Z1bmNPclN0cmluZyhkdXJhdGlvbikgfHwgX2lzRnVuY09yU3RyaW5nKGRlbGF5KSkge1xuXHRcdFx0dmFycyA9IHRoaXMudmFycztcblx0XHRcdHRsID0gdGhpcy50aW1lbGluZSA9IG5ldyBUaW1lbGluZSh7ZGF0YTpcIm5lc3RlZFwiLCBkZWZhdWx0czpkZWZhdWx0cyB8fCB7fX0pO1xuXHRcdFx0dGwua2lsbCgpO1xuXHRcdFx0dGwucGFyZW50ID0gdGwuX2RwID0gdGhpcztcblx0XHRcdHRsLl9zdGFydCA9IDA7XG5cdFx0XHRpZiAoa2V5ZnJhbWVzKSB7XG5cdFx0XHRcdF9zZXREZWZhdWx0cyh0bC52YXJzLmRlZmF1bHRzLCB7ZWFzZTpcIm5vbmVcIn0pO1xuXHRcdFx0XHRzdGFnZ2VyID8gcGFyc2VkVGFyZ2V0cy5mb3JFYWNoKCh0LCBpKSA9PiBrZXlmcmFtZXMuZm9yRWFjaCgoZnJhbWUsIGopID0+IHRsLnRvKHQsIGZyYW1lLCBqID8gXCI+XCIgOiBpICogc3RhZ2dlcikpKSA6IGtleWZyYW1lcy5mb3JFYWNoKGZyYW1lID0+IHRsLnRvKHBhcnNlZFRhcmdldHMsIGZyYW1lLCBcIj5cIikpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bCA9IHBhcnNlZFRhcmdldHMubGVuZ3RoO1xuXHRcdFx0XHRzdGFnZ2VyRnVuYyA9IHN0YWdnZXIgPyBkaXN0cmlidXRlKHN0YWdnZXIpIDogX2VtcHR5RnVuYztcblx0XHRcdFx0aWYgKF9pc09iamVjdChzdGFnZ2VyKSkgeyAvL3VzZXJzIGNhbiBwYXNzIGluIGNhbGxiYWNrcyBsaWtlIG9uU3RhcnQvb25Db21wbGV0ZSBpbiB0aGUgc3RhZ2dlciBvYmplY3QuIFRoZXNlIHNob3VsZCBmaXJlIHdpdGggZWFjaCBpbmRpdmlkdWFsIHR3ZWVuLlxuXHRcdFx0XHRcdGZvciAocCBpbiBzdGFnZ2VyKSB7XG5cdFx0XHRcdFx0XHRpZiAofl9zdGFnZ2VyVHdlZW5Qcm9wcy5pbmRleE9mKHApKSB7XG5cdFx0XHRcdFx0XHRcdHN0YWdnZXJWYXJzVG9NZXJnZSB8fCAoc3RhZ2dlclZhcnNUb01lcmdlID0ge30pO1xuXHRcdFx0XHRcdFx0XHRzdGFnZ2VyVmFyc1RvTWVyZ2VbcF0gPSBzdGFnZ2VyW3BdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29weSA9IHt9O1xuXHRcdFx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdFx0XHRpZiAoX3N0YWdnZXJQcm9wc1RvU2tpcC5pbmRleE9mKHApIDwgMCkge1xuXHRcdFx0XHRcdFx0XHRjb3B5W3BdID0gdmFyc1twXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29weS5zdGFnZ2VyID0gMDtcblx0XHRcdFx0XHR5b3lvRWFzZSAmJiAoY29weS55b3lvRWFzZSA9IHlveW9FYXNlKTtcblx0XHRcdFx0XHRzdGFnZ2VyVmFyc1RvTWVyZ2UgJiYgX21lcmdlKGNvcHksIHN0YWdnZXJWYXJzVG9NZXJnZSk7XG5cdFx0XHRcdFx0Y3VyVGFyZ2V0ID0gcGFyc2VkVGFyZ2V0c1tpXTtcblx0XHRcdFx0XHQvL2Rvbid0IGp1c3QgY29weSBkdXJhdGlvbiBvciBkZWxheSBiZWNhdXNlIGlmIHRoZXkncmUgYSBzdHJpbmcgb3IgZnVuY3Rpb24sIHdlJ2QgZW5kIHVwIGluIGFuIGluZmluaXRlIGxvb3AgYmVjYXVzZSBfaXNGdW5jT3JTdHJpbmcoKSB3b3VsZCBldmFsdWF0ZSBhcyB0cnVlIGluIHRoZSBjaGlsZCB0d2VlbnMsIGVudGVyaW5nIHRoaXMgbG9vcCwgZXRjLiBTbyB3ZSBwYXJzZSB0aGUgdmFsdWUgc3RyYWlnaHQgZnJvbSB2YXJzIGFuZCBkZWZhdWx0IHRvIDAuXG5cdFx0XHRcdFx0Y29weS5kdXJhdGlvbiA9ICtfcGFyc2VGdW5jT3JTdHJpbmcoZHVyYXRpb24sIHRoaXMsIGksIGN1clRhcmdldCwgcGFyc2VkVGFyZ2V0cyk7XG5cdFx0XHRcdFx0Y29weS5kZWxheSA9ICgrX3BhcnNlRnVuY09yU3RyaW5nKGRlbGF5LCB0aGlzLCBpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpIHx8IDApIC0gdGhpcy5fZGVsYXk7XG5cdFx0XHRcdFx0aWYgKCFzdGFnZ2VyICYmIGwgPT09IDEgJiYgY29weS5kZWxheSkgeyAvLyBpZiBzb21lb25lIGRvZXMgZGVsYXk6XCJyYW5kb20oMSwgNSlcIiwgcmVwZWF0Oi0xLCBmb3IgZXhhbXBsZSwgdGhlIGRlbGF5IHNob3VsZG4ndCBiZSBpbnNpZGUgdGhlIHJlcGVhdC5cblx0XHRcdFx0XHRcdHRoaXMuX2RlbGF5ID0gZGVsYXkgPSBjb3B5LmRlbGF5O1xuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnQgKz0gZGVsYXk7XG5cdFx0XHRcdFx0XHRjb3B5LmRlbGF5ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGwudG8oY3VyVGFyZ2V0LCBjb3B5LCBzdGFnZ2VyRnVuYyhpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0bC5kdXJhdGlvbigpID8gKGR1cmF0aW9uID0gZGVsYXkgPSAwKSA6ICh0aGlzLnRpbWVsaW5lID0gMCk7IC8vIGlmIHRoZSB0aW1lbGluZSdzIGR1cmF0aW9uIGlzIDAsIHdlIGRvbid0IG5lZWQgYSB0aW1lbGluZSBpbnRlcm5hbGx5IVxuXHRcdFx0fVxuXHRcdFx0ZHVyYXRpb24gfHwgdGhpcy5kdXJhdGlvbigoZHVyYXRpb24gPSB0bC5kdXJhdGlvbigpKSk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy50aW1lbGluZSA9IDA7IC8vc3BlZWQgb3B0aW1pemF0aW9uLCBmYXN0ZXIgbG9va3VwcyAobm8gZ29pbmcgdXAgdGhlIHByb3RvdHlwZSBjaGFpbilcblx0XHR9XG5cblx0XHRpZiAob3ZlcndyaXRlID09PSB0cnVlICYmICFfc3VwcHJlc3NPdmVyd3JpdGVzKSB7XG5cdFx0XHRfb3ZlcndyaXRpbmdUd2VlbiA9IHRoaXM7XG5cdFx0XHRfZ2xvYmFsVGltZWxpbmUua2lsbFR3ZWVuc09mKHBhcnNlZFRhcmdldHMpO1xuXHRcdFx0X292ZXJ3cml0aW5nVHdlZW4gPSAwO1xuXHRcdH1cblx0XHRfYWRkVG9UaW1lbGluZShwYXJlbnQsIHRoaXMsIHBvc2l0aW9uKTtcblx0XHR2YXJzLnJldmVyc2VkICYmIHRoaXMucmV2ZXJzZSgpO1xuXHRcdHZhcnMucGF1c2VkICYmIHRoaXMucGF1c2VkKHRydWUpO1xuXHRcdGlmIChpbW1lZGlhdGVSZW5kZXIgfHwgKCFkdXJhdGlvbiAmJiAha2V5ZnJhbWVzICYmIHRoaXMuX3N0YXJ0ID09PSBfcm91bmQocGFyZW50Ll90aW1lKSAmJiBfaXNOb3RGYWxzZShpbW1lZGlhdGVSZW5kZXIpICYmIF9oYXNOb1BhdXNlZEFuY2VzdG9ycyh0aGlzKSAmJiBwYXJlbnQuZGF0YSAhPT0gXCJuZXN0ZWRcIikpIHtcblx0XHRcdHRoaXMuX3RUaW1lID0gLV90aW55TnVtOyAvL2ZvcmNlcyBhIHJlbmRlciB3aXRob3V0IGhhdmluZyB0byBzZXQgdGhlIHJlbmRlcigpIFwiZm9yY2VcIiBwYXJhbWV0ZXIgdG8gdHJ1ZSBiZWNhdXNlIHdlIHdhbnQgdG8gYWxsb3cgbGF6eWluZyBieSBkZWZhdWx0ICh1c2luZyB0aGUgXCJmb3JjZVwiIHBhcmFtZXRlciBhbHdheXMgZm9yY2VzIGFuIGltbWVkaWF0ZSBmdWxsIHJlbmRlcilcblx0XHRcdHRoaXMucmVuZGVyKE1hdGgubWF4KDAsIC1kZWxheSkpOyAvL2luIGNhc2UgZGVsYXkgaXMgbmVnYXRpdmVcblx0XHR9XG5cdFx0c2Nyb2xsVHJpZ2dlciAmJiBfc2Nyb2xsVHJpZ2dlcih0aGlzLCBzY3JvbGxUcmlnZ2VyKTtcblx0fVxuXG5cdHJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdGxldCBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHR0RHVyID0gdGhpcy5fdER1cixcblx0XHRcdGR1ciA9IHRoaXMuX2R1cixcblx0XHRcdHRUaW1lID0gKHRvdGFsVGltZSA+IHREdXIgLSBfdGlueU51bSAmJiB0b3RhbFRpbWUgPj0gMCkgPyB0RHVyIDogKHRvdGFsVGltZSA8IF90aW55TnVtKSA/IDAgOiB0b3RhbFRpbWUsXG5cdFx0XHR0aW1lLCBwdCwgaXRlcmF0aW9uLCBjeWNsZUR1cmF0aW9uLCBwcmV2SXRlcmF0aW9uLCBpc1lveW8sIHJhdGlvLCB0aW1lbGluZSwgeW95b0Vhc2U7XG5cdFx0aWYgKCFkdXIpIHtcblx0XHRcdF9yZW5kZXJaZXJvRHVyYXRpb25Ud2Vlbih0aGlzLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0fSBlbHNlIGlmICh0VGltZSAhPT0gdGhpcy5fdFRpbWUgfHwgIXRvdGFsVGltZSB8fCBmb3JjZSB8fCAoIXRoaXMuX2luaXR0ZWQgJiYgdGhpcy5fdFRpbWUpIHx8ICh0aGlzLl9zdGFydEF0ICYmICh0aGlzLl96VGltZSA8IDApICE9PSAodG90YWxUaW1lIDwgMCkpKSB7IC8vdGhpcyBzZW5zZXMgaWYgd2UncmUgY3Jvc3Npbmcgb3ZlciB0aGUgc3RhcnQgdGltZSwgaW4gd2hpY2ggY2FzZSB3ZSBtdXN0IHJlY29yZCBfelRpbWUgYW5kIGZvcmNlIHRoZSByZW5kZXIsIGJ1dCB3ZSBkbyBpdCBpbiB0aGlzIGxlbmd0aHkgY29uZGl0aW9uYWwgd2F5IGZvciBwZXJmb3JtYW5jZSByZWFzb25zICh1c3VhbGx5IHdlIGNhbiBza2lwIHRoZSBjYWxjdWxhdGlvbnMpOiB0aGlzLl9pbml0dGVkICYmICh0aGlzLl96VGltZSA8IDApICE9PSAodG90YWxUaW1lIDwgMClcblx0XHRcdHRpbWUgPSB0VGltZTtcblx0XHRcdHRpbWVsaW5lID0gdGhpcy50aW1lbGluZTtcblx0XHRcdGlmICh0aGlzLl9yZXBlYXQpIHsgLy9hZGp1c3QgdGhlIHRpbWUgZm9yIHJlcGVhdHMgYW5kIHlveW9zXG5cdFx0XHRcdGN5Y2xlRHVyYXRpb24gPSBkdXIgKyB0aGlzLl9yRGVsYXk7XG5cdFx0XHRcdGlmICh0aGlzLl9yZXBlYXQgPCAtMSAmJiB0b3RhbFRpbWUgPCAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKGN5Y2xlRHVyYXRpb24gKiAxMDAgKyB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGltZSA9IF9yb3VuZCh0VGltZSAlIGN5Y2xlRHVyYXRpb24pOyAvL3JvdW5kIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IGVycm9ycy4gKDQgJSAwLjggc2hvdWxkIGJlIDAgYnV0IHNvbWUgYnJvd3NlcnMgcmVwb3J0IGl0IGFzIDAuNzk5OTk5OTkhKVxuXHRcdFx0XHRpZiAodFRpbWUgPT09IHREdXIpIHsgLy8gdGhlIHREdXIgPT09IHRUaW1lIGlzIGZvciBlZGdlIGNhc2VzIHdoZXJlIHRoZXJlJ3MgYSBsZW5ndGh5IGRlY2ltYWwgb24gdGhlIGR1cmF0aW9uIGFuZCBpdCBtYXkgcmVhY2ggdGhlIHZlcnkgZW5kIGJ1dCB0aGUgdGltZSBpcyByZW5kZXJlZCBhcyBub3QtcXVpdGUtdGhlcmUgKHJlbWVtYmVyLCB0RHVyIGlzIHJvdW5kZWQgdG8gNCBkZWNpbWFscyB3aGVyZWFzIGR1ciBpc24ndClcblx0XHRcdFx0XHRpdGVyYXRpb24gPSB0aGlzLl9yZXBlYXQ7XG5cdFx0XHRcdFx0dGltZSA9IGR1cjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpdGVyYXRpb24gPSB+fih0VGltZSAvIGN5Y2xlRHVyYXRpb24pO1xuXHRcdFx0XHRcdGlmIChpdGVyYXRpb24gJiYgaXRlcmF0aW9uID09PSB0VGltZSAvIGN5Y2xlRHVyYXRpb24pIHtcblx0XHRcdFx0XHRcdHRpbWUgPSBkdXI7XG5cdFx0XHRcdFx0XHRpdGVyYXRpb24tLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGltZSA+IGR1ciAmJiAodGltZSA9IGR1cik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aXNZb3lvID0gdGhpcy5feW95byAmJiAoaXRlcmF0aW9uICYgMSk7XG5cdFx0XHRcdGlmIChpc1lveW8pIHtcblx0XHRcdFx0XHR5b3lvRWFzZSA9IHRoaXMuX3lFYXNlO1xuXHRcdFx0XHRcdHRpbWUgPSBkdXIgLSB0aW1lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHByZXZJdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodGhpcy5fdFRpbWUsIGN5Y2xlRHVyYXRpb24pO1xuXHRcdFx0XHRpZiAodGltZSA9PT0gcHJldlRpbWUgJiYgIWZvcmNlICYmIHRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0XHQvL2NvdWxkIGJlIGR1cmluZyB0aGUgcmVwZWF0RGVsYXkgcGFydC4gTm8gbmVlZCB0byByZW5kZXIgYW5kIGZpcmUgY2FsbGJhY2tzLlxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24pIHtcblx0XHRcdFx0XHR0aW1lbGluZSAmJiB0aGlzLl95RWFzZSAmJiBfcHJvcGFnYXRlWW95b0Vhc2UodGltZWxpbmUsIGlzWW95byk7XG5cdFx0XHRcdFx0Ly9yZXBlYXRSZWZyZXNoIGZ1bmN0aW9uYWxpdHlcblx0XHRcdFx0XHRpZiAodGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgIWlzWW95byAmJiAhdGhpcy5fbG9jaykge1xuXHRcdFx0XHRcdFx0dGhpcy5fbG9jayA9IGZvcmNlID0gMTsgLy9mb3JjZSwgb3RoZXJ3aXNlIGlmIGxhenkgaXMgdHJ1ZSwgdGhlIF9hdHRlbXB0SW5pdFR3ZWVuKCkgd2lsbCByZXR1cm4gYW5kIHdlJ2xsIGp1bXAgb3V0IGFuZCBnZXQgY2F1Z2h0IGJvdW5jaW5nIG9uIGVhY2ggdGljay5cblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyKF9yb3VuZChjeWNsZUR1cmF0aW9uICogaXRlcmF0aW9uKSwgdHJ1ZSkuaW52YWxpZGF0ZSgpLl9sb2NrID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkKSB7XG5cdFx0XHRcdGlmIChfYXR0ZW1wdEluaXRUd2Vlbih0aGlzLCB0b3RhbFRpbWUgPCAwID8gdG90YWxUaW1lIDogdGltZSwgZm9yY2UsIHN1cHByZXNzRXZlbnRzKSkge1xuXHRcdFx0XHRcdHRoaXMuX3RUaW1lID0gMDsgLy8gaW4gY29uc3RydWN0b3IgaWYgaW1tZWRpYXRlUmVuZGVyIGlzIHRydWUsIHdlIHNldCBfdFRpbWUgdG8gLV90aW55TnVtIHRvIGhhdmUgdGhlIHBsYXloZWFkIGNyb3NzIHRoZSBzdGFydGluZyBwb2ludCBidXQgd2UgY2FuJ3QgbGVhdmUgX3RUaW1lIGFzIGEgbmVnYXRpdmUgbnVtYmVyLlxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkdXIgIT09IHRoaXMuX2R1cikgeyAvLyB3aGlsZSBpbml0dGluZywgYSBwbHVnaW4gbGlrZSBJbmVydGlhUGx1Z2luIG1pZ2h0IGFsdGVyIHRoZSBkdXJhdGlvbiwgc28gcmVydW4gZnJvbSB0aGUgc3RhcnQgdG8gZW5zdXJlIGV2ZXJ5dGhpbmcgcmVuZGVycyBhcyBpdCBzaG91bGQuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl90VGltZSA9IHRUaW1lO1xuXHRcdFx0dGhpcy5fdGltZSA9IHRpbWU7XG5cblx0XHRcdGlmICghdGhpcy5fYWN0ICYmIHRoaXMuX3RzKSB7XG5cdFx0XHRcdHRoaXMuX2FjdCA9IDE7IC8vYXMgbG9uZyBhcyBpdCdzIG5vdCBwYXVzZWQsIGZvcmNlIGl0IHRvIGJlIGFjdGl2ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgaW5kZXBlbmRlbnQgb2YgdGhlIHBhcmVudCB0aW1lbGluZSwgaXQnbGwgYmUgZm9yY2VkIHRvIHJlLXJlbmRlciBvbiB0aGUgbmV4dCB0aWNrLlxuXHRcdFx0XHR0aGlzLl9sYXp5ID0gMDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5yYXRpbyA9IHJhdGlvID0gKHlveW9FYXNlIHx8IHRoaXMuX2Vhc2UpKHRpbWUgLyBkdXIpO1xuXHRcdFx0aWYgKHRoaXMuX2Zyb20pIHtcblx0XHRcdFx0dGhpcy5yYXRpbyA9IHJhdGlvID0gMSAtIHJhdGlvO1xuXHRcdFx0fVxuXG5cdFx0XHR0aW1lICYmICFwcmV2VGltZSAmJiAhc3VwcHJlc3NFdmVudHMgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcblx0XHRcdGlmICh0aW1lICYmICFwcmV2VGltZSAmJiAhc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0X2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcblx0XHRcdFx0aWYgKHRoaXMuX3RUaW1lICE9PSB0VGltZSkgeyAvLyBpbiBjYXNlIHRoZSBvblN0YXJ0IHRyaWdnZXJlZCBhIHJlbmRlciBhdCBhIGRpZmZlcmVudCBzcG90LCBlamVjdC4gTGlrZSBpZiBzb21lb25lIGRpZCBhbmltYXRpb24ucGF1c2UoMC41KSBvciBzb21ldGhpbmcgaW5zaWRlIHRoZSBvblN0YXJ0LlxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHB0ID0gdGhpcy5fcHQ7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0cHQucihyYXRpbywgcHQuZCk7XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cblx0XHRcdCh0aW1lbGluZSAmJiB0aW1lbGluZS5yZW5kZXIodG90YWxUaW1lIDwgMCA/IHRvdGFsVGltZSA6ICF0aW1lICYmIGlzWW95byA/IC1fdGlueU51bSA6IHRpbWVsaW5lLl9kdXIgKiByYXRpbywgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSkgfHwgKHRoaXMuX3N0YXJ0QXQgJiYgKHRoaXMuX3pUaW1lID0gdG90YWxUaW1lKSk7XG5cblx0XHRcdGlmICh0aGlzLl9vblVwZGF0ZSAmJiAhc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0dG90YWxUaW1lIDwgMCAmJiB0aGlzLl9zdGFydEF0ICYmIHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRvdGFsVGltZSwgdHJ1ZSwgZm9yY2UpOyAvL25vdGU6IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSB0dWNrIHRoaXMgY29uZGl0aW9uYWwgbG9naWMgaW5zaWRlIGxlc3MgdHJhdmVsZWQgYXJlYXMgKG1vc3QgdHdlZW5zIGRvbid0IGhhdmUgYW4gb25VcGRhdGUpLiBXZSdkIGp1c3QgaGF2ZSBpdCBhdCB0aGUgZW5kIGJlZm9yZSB0aGUgb25Db21wbGV0ZSwgYnV0IHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQgYmVmb3JlIGFueSBvblVwZGF0ZSBpcyBjYWxsZWQsIHNvIHdlIEFMU08gcHV0IGl0IGhlcmUgYW5kIHRoZW4gaWYgaXQncyBub3QgY2FsbGVkLCB3ZSBkbyBzbyBsYXRlciBuZWFyIHRoZSBvbkNvbXBsZXRlLlxuXHRcdFx0XHRfY2FsbGJhY2sodGhpcywgXCJvblVwZGF0ZVwiKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcmVwZWF0ICYmIGl0ZXJhdGlvbiAhPT0gcHJldkl0ZXJhdGlvbiAmJiB0aGlzLnZhcnMub25SZXBlYXQgJiYgIXN1cHByZXNzRXZlbnRzICYmIHRoaXMucGFyZW50ICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmVwZWF0XCIpO1xuXG5cdFx0XHRpZiAoKHRUaW1lID09PSB0aGlzLl90RHVyIHx8ICF0VGltZSkgJiYgdGhpcy5fdFRpbWUgPT09IHRUaW1lKSB7XG5cdFx0XHRcdHRvdGFsVGltZSA8IDAgJiYgdGhpcy5fc3RhcnRBdCAmJiAhdGhpcy5fb25VcGRhdGUgJiYgdGhpcy5fc3RhcnRBdC5yZW5kZXIodG90YWxUaW1lLCB0cnVlLCB0cnVlKTtcblx0XHRcdFx0KHRvdGFsVGltZSB8fCAhZHVyKSAmJiAoKHRUaW1lID09PSB0aGlzLl90RHVyICYmIHRoaXMuX3RzID4gMCkgfHwgKCF0VGltZSAmJiB0aGlzLl90cyA8IDApKSAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0aGlzLCAxKTsgLy8gZG9uJ3QgcmVtb3ZlIGlmIHdlJ3JlIHJlbmRlcmluZyBhdCBleGFjdGx5IGEgdGltZSBvZiAwLCBhcyB0aGVyZSBjb3VsZCBiZSBhdXRvUmV2ZXJ0IHZhbHVlcyB0aGF0IHNob3VsZCBnZXQgc2V0IG9uIHRoZSBuZXh0IHRpY2sgKGlmIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIGJleW9uZCB0aGUgc3RhcnRUaW1lLCBuZWdhdGl2ZSB0b3RhbFRpbWUpLiBEb24ndCByZW1vdmUgaWYgdGhlIHRpbWVsaW5lIGlzIHJldmVyc2VkIGFuZCB0aGUgcGxheWhlYWQgaXNuJ3QgYXQgMCwgb3RoZXJ3aXNlIHRsLnByb2dyZXNzKDEpLnJldmVyc2UoKSB3b24ndCB3b3JrLiBPbmx5IHJlbW92ZSBpZiB0aGUgcGxheWhlYWQgaXMgYXQgdGhlIGVuZCBhbmQgdGltZVNjYWxlIGlzIHBvc2l0aXZlLCBvciBpZiB0aGUgcGxheWhlYWQgaXMgYXQgMCBhbmQgdGhlIHRpbWVTY2FsZSBpcyBuZWdhdGl2ZS5cblx0XHRcdCAgICBpZiAoIXN1cHByZXNzRXZlbnRzICYmICEodG90YWxUaW1lIDwgMCAmJiAhcHJldlRpbWUpICYmICh0VGltZSB8fCBwcmV2VGltZSkpIHsgLy8gaWYgcHJldlRpbWUgYW5kIHRUaW1lIGFyZSB6ZXJvLCB3ZSBzaG91bGRuJ3QgZmlyZSB0aGUgb25SZXZlcnNlQ29tcGxldGUuIFRoaXMgY291bGQgaGFwcGVuIGlmIHlvdSBnc2FwLnRvKC4uLiB7cGF1c2VkOnRydWV9KS5wbGF5KCk7XG5cdFx0XHRcdFx0X2NhbGxiYWNrKHRoaXMsICh0VGltZSA9PT0gdER1ciA/IFwib25Db21wbGV0ZVwiIDogXCJvblJldmVyc2VDb21wbGV0ZVwiKSwgdHJ1ZSk7XG5cdFx0XHRcdFx0dGhpcy5fcHJvbSAmJiAhKHRUaW1lIDwgdER1ciAmJiB0aGlzLnRpbWVTY2FsZSgpID4gMCkgJiYgdGhpcy5fcHJvbSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHR0YXJnZXRzKCkge1xuXHRcdHJldHVybiB0aGlzLl90YXJnZXRzO1xuXHR9XG5cblx0aW52YWxpZGF0ZSgpIHtcblx0XHR0aGlzLl9wdCA9IHRoaXMuX29wID0gdGhpcy5fc3RhcnRBdCA9IHRoaXMuX29uVXBkYXRlID0gdGhpcy5fbGF6eSA9IHRoaXMucmF0aW8gPSAwO1xuXHRcdHRoaXMuX3B0TG9va3VwID0gW107XG5cdFx0dGhpcy50aW1lbGluZSAmJiB0aGlzLnRpbWVsaW5lLmludmFsaWRhdGUoKTtcblx0XHRyZXR1cm4gc3VwZXIuaW52YWxpZGF0ZSgpO1xuXHR9XG5cblx0a2lsbCh0YXJnZXRzLCB2YXJzID0gXCJhbGxcIikge1xuXHRcdGlmICghdGFyZ2V0cyAmJiAoIXZhcnMgfHwgdmFycyA9PT0gXCJhbGxcIikpIHtcblx0XHRcdHRoaXMuX2xhenkgPSB0aGlzLl9wdCA9IDA7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnQgPyBfaW50ZXJydXB0KHRoaXMpIDogdGhpcztcblx0XHR9XG5cdFx0aWYgKHRoaXMudGltZWxpbmUpIHtcblx0XHRcdGxldCB0RHVyID0gdGhpcy50aW1lbGluZS50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHR0aGlzLnRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXRzLCB2YXJzLCBfb3ZlcndyaXRpbmdUd2VlbiAmJiBfb3ZlcndyaXRpbmdUd2Vlbi52YXJzLm92ZXJ3cml0ZSAhPT0gdHJ1ZSkuX2ZpcnN0IHx8IF9pbnRlcnJ1cHQodGhpcyk7IC8vIGlmIG5vdGhpbmcgaXMgbGVmdCB0d2VlbmluZywgaW50ZXJydXB0LlxuXHRcdFx0dGhpcy5wYXJlbnQgJiYgdER1ciAhPT0gdGhpcy50aW1lbGluZS50b3RhbER1cmF0aW9uKCkgJiYgX3NldER1cmF0aW9uKHRoaXMsIHRoaXMuX2R1ciAqIHRoaXMudGltZWxpbmUuX3REdXIgLyB0RHVyLCAwLCAxKTsgLy8gaWYgYSBuZXN0ZWQgdHdlZW4gaXMga2lsbGVkIHRoYXQgY2hhbmdlcyB0aGUgZHVyYXRpb24sIGl0IHNob3VsZCBhZmZlY3QgdGhpcyB0d2VlbidzIGR1cmF0aW9uLiBXZSBtdXN0IHVzZSB0aGUgcmF0aW8sIHRob3VnaCwgYmVjYXVzZSBzb21ldGltZXMgdGhlIGludGVybmFsIHRpbWVsaW5lIGlzIHN0cmV0Y2hlZCBsaWtlIGZvciBrZXlmcmFtZXMgd2hlcmUgdGhleSBkb24ndCBhbGwgYWRkIHVwIHRvIHdoYXRldmVyIHRoZSBwYXJlbnQgdHdlZW4ncyBkdXJhdGlvbiB3YXMgc2V0IHRvLlxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGxldCBwYXJzZWRUYXJnZXRzID0gdGhpcy5fdGFyZ2V0cyxcblx0XHRcdGtpbGxpbmdUYXJnZXRzID0gdGFyZ2V0cyA/IHRvQXJyYXkodGFyZ2V0cykgOiBwYXJzZWRUYXJnZXRzLFxuXHRcdFx0cHJvcFR3ZWVuTG9va3VwID0gdGhpcy5fcHRMb29rdXAsXG5cdFx0XHRmaXJzdFBUID0gdGhpcy5fcHQsXG5cdFx0XHRvdmVyd3JpdHRlblByb3BzLCBjdXJMb29rdXAsIGN1ck92ZXJ3cml0ZVByb3BzLCBwcm9wcywgcCwgcHQsIGk7XG5cdFx0aWYgKCghdmFycyB8fCB2YXJzID09PSBcImFsbFwiKSAmJiBfYXJyYXlzTWF0Y2gocGFyc2VkVGFyZ2V0cywga2lsbGluZ1RhcmdldHMpKSB7XG5cdFx0XHR2YXJzID09PSBcImFsbFwiICYmICh0aGlzLl9wdCA9IDApO1xuXHRcdFx0cmV0dXJuIF9pbnRlcnJ1cHQodGhpcyk7XG5cdFx0fVxuXHRcdG92ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9vcCA9IHRoaXMuX29wIHx8IFtdO1xuXHRcdGlmICh2YXJzICE9PSBcImFsbFwiKSB7IC8vc28gcGVvcGxlIGNhbiBwYXNzIGluIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXNcblx0XHRcdGlmIChfaXNTdHJpbmcodmFycykpIHtcblx0XHRcdFx0cCA9IHt9O1xuXHRcdFx0XHRfZm9yRWFjaE5hbWUodmFycywgbmFtZSA9PiBwW25hbWVdID0gMSk7XG5cdFx0XHRcdHZhcnMgPSBwO1xuXHRcdFx0fVxuXHRcdFx0dmFycyA9IF9hZGRBbGlhc2VzVG9WYXJzKHBhcnNlZFRhcmdldHMsIHZhcnMpO1xuXHRcdH1cblx0XHRpID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0aWYgKH5raWxsaW5nVGFyZ2V0cy5pbmRleE9mKHBhcnNlZFRhcmdldHNbaV0pKSB7XG5cdFx0XHRcdGN1ckxvb2t1cCA9IHByb3BUd2Vlbkxvb2t1cFtpXTtcblx0XHRcdFx0aWYgKHZhcnMgPT09IFwiYWxsXCIpIHtcblx0XHRcdFx0XHRvdmVyd3JpdHRlblByb3BzW2ldID0gdmFycztcblx0XHRcdFx0XHRwcm9wcyA9IGN1ckxvb2t1cDtcblx0XHRcdFx0XHRjdXJPdmVyd3JpdGVQcm9wcyA9IHt9O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN1ck92ZXJ3cml0ZVByb3BzID0gb3ZlcndyaXR0ZW5Qcm9wc1tpXSA9IG92ZXJ3cml0dGVuUHJvcHNbaV0gfHwge307XG5cdFx0XHRcdFx0cHJvcHMgPSB2YXJzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAocCBpbiBwcm9wcykge1xuXHRcdFx0XHRcdHB0ID0gY3VyTG9va3VwICYmIGN1ckxvb2t1cFtwXTtcblx0XHRcdFx0XHRpZiAocHQpIHtcblx0XHRcdFx0XHRcdGlmICghKFwia2lsbFwiIGluIHB0LmQpIHx8IHB0LmQua2lsbChwKSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRfcmVtb3ZlTGlua2VkTGlzdEl0ZW0odGhpcywgcHQsIFwiX3B0XCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZGVsZXRlIGN1ckxvb2t1cFtwXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGN1ck92ZXJ3cml0ZVByb3BzICE9PSBcImFsbFwiKSB7XG5cdFx0XHRcdFx0XHRjdXJPdmVyd3JpdGVQcm9wc1twXSA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2luaXR0ZWQgJiYgIXRoaXMuX3B0ICYmIGZpcnN0UFQgJiYgX2ludGVycnVwdCh0aGlzKTsgLy9pZiBhbGwgdHdlZW5pbmcgcHJvcGVydGllcyBhcmUga2lsbGVkLCBraWxsIHRoZSB0d2Vlbi4gV2l0aG91dCB0aGlzIGxpbmUsIGlmIHRoZXJlJ3MgYSB0d2VlbiB3aXRoIG11bHRpcGxlIHRhcmdldHMgYW5kIHRoZW4geW91IGtpbGxUd2VlbnNPZigpIGVhY2ggdGFyZ2V0IGluZGl2aWR1YWxseSwgdGhlIHR3ZWVuIHdvdWxkIHRlY2huaWNhbGx5IHN0aWxsIHJlbWFpbiBhY3RpdmUgYW5kIGZpcmUgaXRzIG9uQ29tcGxldGUgZXZlbiB0aG91Z2ggdGhlcmUgYXJlbid0IGFueSBtb3JlIHByb3BlcnRpZXMgdHdlZW5pbmcuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXG5cdHN0YXRpYyB0byh0YXJnZXRzLCB2YXJzKSB7XG5cdFx0cmV0dXJuIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzLCBhcmd1bWVudHNbMl0pO1xuXHR9XG5cblx0c3RhdGljIGZyb20odGFyZ2V0cywgdmFycykge1xuXHRcdHJldHVybiBfY3JlYXRlVHdlZW5UeXBlKDEsIGFyZ3VtZW50cyk7XG5cdH1cblxuXHRzdGF0aWMgZGVsYXllZENhbGwoZGVsYXksIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG5cdFx0cmV0dXJuIG5ldyBUd2VlbihjYWxsYmFjaywgMCwge2ltbWVkaWF0ZVJlbmRlcjpmYWxzZSwgbGF6eTpmYWxzZSwgb3ZlcndyaXRlOmZhbHNlLCBkZWxheTpkZWxheSwgb25Db21wbGV0ZTpjYWxsYmFjaywgb25SZXZlcnNlQ29tcGxldGU6Y2FsbGJhY2ssIG9uQ29tcGxldGVQYXJhbXM6cGFyYW1zLCBvblJldmVyc2VDb21wbGV0ZVBhcmFtczpwYXJhbXMsIGNhbGxiYWNrU2NvcGU6c2NvcGV9KTtcblx0fVxuXG5cdHN0YXRpYyBmcm9tVG8odGFyZ2V0cywgZnJvbVZhcnMsIHRvVmFycykge1xuXHRcdHJldHVybiBfY3JlYXRlVHdlZW5UeXBlKDIsIGFyZ3VtZW50cyk7XG5cdH1cblxuXHRzdGF0aWMgc2V0KHRhcmdldHMsIHZhcnMpIHtcblx0XHR2YXJzLmR1cmF0aW9uID0gMDtcblx0XHR2YXJzLnJlcGVhdERlbGF5IHx8ICh2YXJzLnJlcGVhdCA9IDApO1xuXHRcdHJldHVybiBuZXcgVHdlZW4odGFyZ2V0cywgdmFycyk7XG5cdH1cblxuXHRzdGF0aWMga2lsbFR3ZWVuc09mKHRhcmdldHMsIHByb3BzLCBvbmx5QWN0aXZlKSB7XG5cdFx0cmV0dXJuIF9nbG9iYWxUaW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpO1xuXHR9XG59XG5cbl9zZXREZWZhdWx0cyhUd2Vlbi5wcm90b3R5cGUsIHtfdGFyZ2V0czpbXSwgX2xhenk6MCwgX3N0YXJ0QXQ6MCwgX29wOjAsIF9vbkluaXQ6MH0pO1xuXG4vL2FkZCB0aGUgcGVydGluZW50IHRpbWVsaW5lIG1ldGhvZHMgdG8gVHdlZW4gaW5zdGFuY2VzIHNvIHRoYXQgdXNlcnMgY2FuIGNoYWluIGNvbnZlbmllbnRseSBhbmQgY3JlYXRlIGEgdGltZWxpbmUgYXV0b21hdGljYWxseS4gKHJlbW92ZWQgZHVlIHRvIGNvbmNlcm5zIHRoYXQgaXQnZCB1bHRpbWF0ZWx5IGFkZCB0byBtb3JlIGNvbmZ1c2lvbiBlc3BlY2lhbGx5IGZvciBiZWdpbm5lcnMpXG4vLyBfZm9yRWFjaE5hbWUoXCJ0byxmcm9tLGZyb21UbyxzZXQsY2FsbCxhZGQsYWRkTGFiZWwsYWRkUGF1c2VcIiwgbmFtZSA9PiB7XG4vLyBcdFR3ZWVuLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuLy8gXHRcdGxldCB0bCA9IG5ldyBUaW1lbGluZSgpO1xuLy8gXHRcdHJldHVybiBfYWRkVG9UaW1lbGluZSh0bCwgdGhpcylbbmFtZV0uYXBwbHkodGwsIHRvQXJyYXkoYXJndW1lbnRzKSk7XG4vLyBcdH1cbi8vIH0pO1xuXG4vL2ZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBMZXZlcmFnZSB0aGUgdGltZWxpbmUgY2FsbHMuXG5fZm9yRWFjaE5hbWUoXCJzdGFnZ2VyVG8sc3RhZ2dlckZyb20sc3RhZ2dlckZyb21Ub1wiLCBuYW1lID0+IHtcblx0VHdlZW5bbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRsZXQgdGwgPSBuZXcgVGltZWxpbmUoKSxcblx0XHRcdHBhcmFtcyA9IF9zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cdFx0cGFyYW1zLnNwbGljZShuYW1lID09PSBcInN0YWdnZXJGcm9tVG9cIiA/IDUgOiA0LCAwLCAwKTtcblx0XHRyZXR1cm4gdGxbbmFtZV0uYXBwbHkodGwsIHBhcmFtcyk7XG5cdH1cbn0pO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFBST1BUV0VFTlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xubGV0IF9zZXR0ZXJQbGFpbiA9ICh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkgPT4gdGFyZ2V0W3Byb3BlcnR5XSA9IHZhbHVlLFxuXHRfc2V0dGVyRnVuYyA9ICh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkgPT4gdGFyZ2V0W3Byb3BlcnR5XSh2YWx1ZSksXG5cdF9zZXR0ZXJGdW5jV2l0aFBhcmFtID0gKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhKSA9PiB0YXJnZXRbcHJvcGVydHldKGRhdGEuZnAsIHZhbHVlKSxcblx0X3NldHRlckF0dHJpYnV0ZSA9ICh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkgPT4gdGFyZ2V0LnNldEF0dHJpYnV0ZShwcm9wZXJ0eSwgdmFsdWUpLFxuXHRfZ2V0U2V0dGVyID0gKHRhcmdldCwgcHJvcGVydHkpID0+IF9pc0Z1bmN0aW9uKHRhcmdldFtwcm9wZXJ0eV0pID8gX3NldHRlckZ1bmMgOiBfaXNVbmRlZmluZWQodGFyZ2V0W3Byb3BlcnR5XSkgJiYgdGFyZ2V0LnNldEF0dHJpYnV0ZSA/IF9zZXR0ZXJBdHRyaWJ1dGUgOiBfc2V0dGVyUGxhaW4sXG5cdF9yZW5kZXJQbGFpbiA9IChyYXRpbywgZGF0YSkgPT4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwMDApIC8gMTAwMDAwMCwgZGF0YSksXG5cdF9yZW5kZXJCb29sZWFuID0gKHJhdGlvLCBkYXRhKSA9PiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgISEoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pLCBkYXRhKSxcblx0X3JlbmRlckNvbXBsZXhTdHJpbmcgPSBmdW5jdGlvbihyYXRpbywgZGF0YSkge1xuXHRcdGxldCBwdCA9IGRhdGEuX3B0LFxuXHRcdFx0cyA9IFwiXCI7XG5cdFx0aWYgKCFyYXRpbyAmJiBkYXRhLmIpIHsgLy9iID0gYmVnaW5uaW5nIHN0cmluZ1xuXHRcdFx0cyA9IGRhdGEuYjtcblx0XHR9IGVsc2UgaWYgKHJhdGlvID09PSAxICYmIGRhdGEuZSkgeyAvL2UgPSBlbmRpbmcgc3RyaW5nXG5cdFx0XHRzID0gZGF0YS5lO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0cyA9IHB0LnAgKyAocHQubSA/IHB0Lm0ocHQucyArIHB0LmMgKiByYXRpbykgOiAoTWF0aC5yb3VuZCgocHQucyArIHB0LmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCkpICsgczsgLy93ZSB1c2UgdGhlIFwicFwiIHByb3BlcnR5IGZvciB0aGUgdGV4dCBpbmJldHdlZW4gKGxpa2UgYSBzdWZmaXgpLiBBbmQgaW4gdGhlIGNvbnRleHQgb2YgYSBjb21wbGV4IHN0cmluZywgdGhlIG1vZGlmaWVyIChtKSBpcyB0eXBpY2FsbHkganVzdCBNYXRoLnJvdW5kKCksIGxpa2UgZm9yIFJHQiBjb2xvcnMuXG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRzICs9IGRhdGEuYzsgLy93ZSB1c2UgdGhlIFwiY1wiIG9mIHRoZSBQcm9wVHdlZW4gdG8gc3RvcmUgdGhlIGZpbmFsIGNodW5rIG9mIG5vbi1udW1lcmljIHRleHQuXG5cdFx0fVxuXHRcdGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBzLCBkYXRhKTtcblx0fSxcblx0X3JlbmRlclByb3BUd2VlbnMgPSBmdW5jdGlvbihyYXRpbywgZGF0YSkge1xuXHRcdGxldCBwdCA9IGRhdGEuX3B0O1xuXHRcdHdoaWxlIChwdCkge1xuXHRcdFx0cHQucihyYXRpbywgcHQuZCk7XG5cdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdH1cblx0fSxcblx0X2FkZFBsdWdpbk1vZGlmaWVyID0gZnVuY3Rpb24obW9kaWZpZXIsIHR3ZWVuLCB0YXJnZXQsIHByb3BlcnR5KSB7XG5cdFx0bGV0IHB0ID0gdGhpcy5fcHQsXG5cdFx0XHRuZXh0O1xuXHRcdHdoaWxlIChwdCkge1xuXHRcdFx0bmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0cHQucCA9PT0gcHJvcGVydHkgJiYgcHQubW9kaWZpZXIobW9kaWZpZXIsIHR3ZWVuLCB0YXJnZXQpO1xuXHRcdFx0cHQgPSBuZXh0O1xuXHRcdH1cblx0fSxcblx0X2tpbGxQcm9wVHdlZW5zT2YgPSBmdW5jdGlvbihwcm9wZXJ0eSkge1xuXHRcdGxldCBwdCA9IHRoaXMuX3B0LFxuXHRcdFx0aGFzTm9uRGVwZW5kZW50UmVtYWluaW5nLCBuZXh0O1xuXHRcdHdoaWxlIChwdCkge1xuXHRcdFx0bmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0aWYgKChwdC5wID09PSBwcm9wZXJ0eSAmJiAhcHQub3ApIHx8IHB0Lm9wID09PSBwcm9wZXJ0eSkge1xuXHRcdFx0XHRfcmVtb3ZlTGlua2VkTGlzdEl0ZW0odGhpcywgcHQsIFwiX3B0XCIpO1xuXHRcdFx0fSBlbHNlIGlmICghcHQuZGVwKSB7XG5cdFx0XHRcdGhhc05vbkRlcGVuZGVudFJlbWFpbmluZyA9IDE7XG5cdFx0XHR9XG5cdFx0XHRwdCA9IG5leHQ7XG5cdFx0fVxuXHRcdHJldHVybiAhaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nO1xuXHR9LFxuXHRfc2V0dGVyV2l0aE1vZGlmaWVyID0gKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhKSA9PiB7XG5cdFx0ZGF0YS5tU2V0KHRhcmdldCwgcHJvcGVydHksIGRhdGEubS5jYWxsKGRhdGEudHdlZW4sIHZhbHVlLCBkYXRhLm10KSwgZGF0YSk7XG5cdH0sXG5cdF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkgPSBwYXJlbnQgPT4ge1xuXHRcdGxldCBwdCA9IHBhcmVudC5fcHQsXG5cdFx0XHRuZXh0LCBwdDIsIGZpcnN0LCBsYXN0O1xuXHRcdC8vc29ydHMgdGhlIFByb3BUd2VlbiBsaW5rZWQgbGlzdCBpbiBvcmRlciBvZiBwcmlvcml0eSBiZWNhdXNlIHNvbWUgcGx1Z2lucyBuZWVkIHRvIGRvIHRoZWlyIHdvcmsgYWZ0ZXIgQUxMIG9mIHRoZSBQcm9wVHdlZW5zIHdlcmUgY3JlYXRlZCAobGlrZSBSb3VuZFByb3BzUGx1Z2luIGFuZCBNb2RpZmllcnNQbHVnaW4pXG5cdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRuZXh0ID0gcHQuX25leHQ7XG5cdFx0XHRwdDIgPSBmaXJzdDtcblx0XHRcdHdoaWxlIChwdDIgJiYgcHQyLnByID4gcHQucHIpIHtcblx0XHRcdFx0cHQyID0gcHQyLl9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKChwdC5fcHJldiA9IHB0MiA/IHB0Mi5fcHJldiA6IGxhc3QpKSB7XG5cdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gcHQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmaXJzdCA9IHB0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKChwdC5fbmV4dCA9IHB0MikpIHtcblx0XHRcdFx0cHQyLl9wcmV2ID0gcHQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsYXN0ID0gcHQ7XG5cdFx0XHR9XG5cdFx0XHRwdCA9IG5leHQ7XG5cdFx0fVxuXHRcdHBhcmVudC5fcHQgPSBmaXJzdDtcblx0fTtcblxuLy9Qcm9wVHdlZW4ga2V5OiB0ID0gdGFyZ2V0LCBwID0gcHJvcCwgciA9IHJlbmRlcmVyLCBkID0gZGF0YSwgcyA9IHN0YXJ0LCBjID0gY2hhbmdlLCBvcCA9IG92ZXJ3cml0ZVByb3BlcnR5IChPTkxZIHBvcHVsYXRlZCB3aGVuIGl0J3MgZGlmZmVyZW50IHRoYW4gcCksIHByID0gcHJpb3JpdHksIF9uZXh0L19wcmV2IGZvciB0aGUgbGlua2VkIGxpc3Qgc2libGluZ3MsIHNldCA9IHNldHRlciwgbSA9IG1vZGlmaWVyLCBtU2V0ID0gbW9kaWZpZXJTZXR0ZXIgKHRoZSBvcmlnaW5hbCBzZXR0ZXIsIGJlZm9yZSBhIG1vZGlmaWVyIHdhcyBhZGRlZClcbmV4cG9ydCBjbGFzcyBQcm9wVHdlZW4ge1xuXG5cdGNvbnN0cnVjdG9yKG5leHQsIHRhcmdldCwgcHJvcCwgc3RhcnQsIGNoYW5nZSwgcmVuZGVyZXIsIGRhdGEsIHNldHRlciwgcHJpb3JpdHkpIHtcblx0XHR0aGlzLnQgPSB0YXJnZXQ7XG5cdFx0dGhpcy5zID0gc3RhcnQ7XG5cdFx0dGhpcy5jID0gY2hhbmdlO1xuXHRcdHRoaXMucCA9IHByb3A7XG5cdFx0dGhpcy5yID0gcmVuZGVyZXIgfHwgX3JlbmRlclBsYWluO1xuXHRcdHRoaXMuZCA9IGRhdGEgfHwgdGhpcztcblx0XHR0aGlzLnNldCA9IHNldHRlciB8fCBfc2V0dGVyUGxhaW47XG5cdFx0dGhpcy5wciA9IHByaW9yaXR5IHx8IDA7XG5cdFx0dGhpcy5fbmV4dCA9IG5leHQ7XG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQuX3ByZXYgPSB0aGlzO1xuXHRcdH1cblx0fVxuXG5cdG1vZGlmaWVyKGZ1bmMsIHR3ZWVuLCB0YXJnZXQpIHtcblx0XHR0aGlzLm1TZXQgPSB0aGlzLm1TZXQgfHwgdGhpcy5zZXQ7IC8vaW4gY2FzZSBpdCB3YXMgYWxyZWFkeSBzZXQgKGEgUHJvcFR3ZWVuIGNhbiBvbmx5IGhhdmUgb25lIG1vZGlmaWVyKVxuXHRcdHRoaXMuc2V0ID0gX3NldHRlcldpdGhNb2RpZmllcjtcblx0XHR0aGlzLm0gPSBmdW5jO1xuXHRcdHRoaXMubXQgPSB0YXJnZXQ7IC8vbW9kaWZpZXIgdGFyZ2V0XG5cdFx0dGhpcy50d2VlbiA9IHR3ZWVuO1xuXHR9XG59XG5cblxuXG4vL0luaXRpYWxpemF0aW9uIHRhc2tzXG5fZm9yRWFjaE5hbWUoX2NhbGxiYWNrTmFtZXMgKyBcInBhcmVudCxkdXJhdGlvbixlYXNlLGRlbGF5LG92ZXJ3cml0ZSxydW5CYWNrd2FyZHMsc3RhcnRBdCx5b3lvLGltbWVkaWF0ZVJlbmRlcixyZXBlYXQscmVwZWF0RGVsYXksZGF0YSxwYXVzZWQscmV2ZXJzZWQsbGF6eSxjYWxsYmFja1Njb3BlLHN0cmluZ0ZpbHRlcixpZCx5b3lvRWFzZSxzdGFnZ2VyLGluaGVyaXQscmVwZWF0UmVmcmVzaCxrZXlmcmFtZXMsYXV0b1JldmVydCxzY3JvbGxUcmlnZ2VyXCIsIG5hbWUgPT4gX3Jlc2VydmVkUHJvcHNbbmFtZV0gPSAxKTtcbl9nbG9iYWxzLlR3ZWVuTWF4ID0gX2dsb2JhbHMuVHdlZW5MaXRlID0gVHdlZW47XG5fZ2xvYmFscy5UaW1lbGluZUxpdGUgPSBfZ2xvYmFscy5UaW1lbGluZU1heCA9IFRpbWVsaW5lO1xuX2dsb2JhbFRpbWVsaW5lID0gbmV3IFRpbWVsaW5lKHtzb3J0Q2hpbGRyZW46IGZhbHNlLCBkZWZhdWx0czogX2RlZmF1bHRzLCBhdXRvUmVtb3ZlQ2hpbGRyZW46IHRydWUsIGlkOlwicm9vdFwiLCBzbW9vdGhDaGlsZFRpbWluZzogdHJ1ZX0pO1xuX2NvbmZpZy5zdHJpbmdGaWx0ZXIgPSBfY29sb3JTdHJpbmdGaWx0ZXI7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBHU0FQXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5jb25zdCBfZ3NhcCA9IHtcblx0cmVnaXN0ZXJQbHVnaW4oLi4uYXJncykge1xuXHRcdGFyZ3MuZm9yRWFjaChjb25maWcgPT4gX2NyZWF0ZVBsdWdpbihjb25maWcpKTtcblx0fSxcblx0dGltZWxpbmUodmFycykge1xuXHRcdHJldHVybiBuZXcgVGltZWxpbmUodmFycyk7XG5cdH0sXG5cdGdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpIHtcblx0XHRyZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpO1xuXHR9LFxuXHRnZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSB7XG5cdFx0X2lzU3RyaW5nKHRhcmdldCkgJiYgKHRhcmdldCA9IHRvQXJyYXkodGFyZ2V0KVswXSk7IC8vaW4gY2FzZSBzZWxlY3RvciB0ZXh0IG9yIGFuIGFycmF5IGlzIHBhc3NlZCBpblxuXHRcdGxldCBnZXR0ZXIgPSBfZ2V0Q2FjaGUodGFyZ2V0IHx8IHt9KS5nZXQsXG5cdFx0XHRmb3JtYXQgPSB1bml0ID8gX3Bhc3NUaHJvdWdoIDogX251bWVyaWNJZlBvc3NpYmxlO1xuXHRcdHVuaXQgPT09IFwibmF0aXZlXCIgJiYgKHVuaXQgPSBcIlwiKTtcblx0XHRyZXR1cm4gIXRhcmdldCA/IHRhcmdldCA6ICFwcm9wZXJ0eSA/IChwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkgPT4gZm9ybWF0KCgoX3BsdWdpbnNbcHJvcGVydHldICYmIF9wbHVnaW5zW3Byb3BlcnR5XS5nZXQpIHx8IGdldHRlcikodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkpIDogZm9ybWF0KCgoX3BsdWdpbnNbcHJvcGVydHldICYmIF9wbHVnaW5zW3Byb3BlcnR5XS5nZXQpIHx8IGdldHRlcikodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkpO1xuXHR9LFxuXHRxdWlja1NldHRlcih0YXJnZXQsIHByb3BlcnR5LCB1bml0KSB7XG5cdFx0dGFyZ2V0ID0gdG9BcnJheSh0YXJnZXQpO1xuXHRcdGlmICh0YXJnZXQubGVuZ3RoID4gMSkge1xuXHRcdFx0bGV0IHNldHRlcnMgPSB0YXJnZXQubWFwKHQgPT4gZ3NhcC5xdWlja1NldHRlcih0LCBwcm9wZXJ0eSwgdW5pdCkpLFxuXHRcdFx0XHRsID0gc2V0dGVycy5sZW5ndGg7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT4ge1xuXHRcdFx0XHRsZXQgaSA9IGw7XG5cdFx0XHRcdHdoaWxlKGktLSkge1xuXHRcdFx0XHRcdHNldHRlcnNbaV0odmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRhcmdldCA9IHRhcmdldFswXSB8fCB7fTtcblx0XHRsZXQgUGx1Z2luID0gX3BsdWdpbnNbcHJvcGVydHldLFxuXHRcdFx0Y2FjaGUgPSBfZ2V0Q2FjaGUodGFyZ2V0KSxcblx0XHRcdHAgPSAoY2FjaGUuaGFybmVzcyAmJiAoY2FjaGUuaGFybmVzcy5hbGlhc2VzIHx8IHt9KVtwcm9wZXJ0eV0pIHx8IHByb3BlcnR5LCAvLyBpbiBjYXNlIGl0J3MgYW4gYWxpYXMsIGxpa2UgXCJyb3RhdGVcIiBmb3IgXCJyb3RhdGlvblwiLlxuXHRcdFx0c2V0dGVyID0gUGx1Z2luID8gdmFsdWUgPT4ge1xuXHRcdFx0XHRsZXQgcCA9IG5ldyBQbHVnaW4oKTtcblx0XHRcdFx0X3F1aWNrVHdlZW4uX3B0ID0gMDtcblx0XHRcdFx0cC5pbml0KHRhcmdldCwgdW5pdCA/IHZhbHVlICsgdW5pdCA6IHZhbHVlLCBfcXVpY2tUd2VlbiwgMCwgW3RhcmdldF0pO1xuXHRcdFx0XHRwLnJlbmRlcigxLCBwKTtcblx0XHRcdFx0X3F1aWNrVHdlZW4uX3B0ICYmIF9yZW5kZXJQcm9wVHdlZW5zKDEsIF9xdWlja1R3ZWVuKTtcblx0XHRcdH0gOiBjYWNoZS5zZXQodGFyZ2V0LCBwKTtcblx0XHRyZXR1cm4gUGx1Z2luID8gc2V0dGVyIDogdmFsdWUgPT4gc2V0dGVyKHRhcmdldCwgcCwgdW5pdCA/IHZhbHVlICsgdW5pdCA6IHZhbHVlLCBjYWNoZSwgMSk7XG5cdH0sXG5cdGlzVHdlZW5pbmcodGFyZ2V0cykge1xuXHRcdHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0VHdlZW5zT2YodGFyZ2V0cywgdHJ1ZSkubGVuZ3RoID4gMDtcblx0fSxcblx0ZGVmYXVsdHModmFsdWUpIHtcblx0XHR2YWx1ZSAmJiB2YWx1ZS5lYXNlICYmICh2YWx1ZS5lYXNlID0gX3BhcnNlRWFzZSh2YWx1ZS5lYXNlLCBfZGVmYXVsdHMuZWFzZSkpO1xuXHRcdHJldHVybiBfbWVyZ2VEZWVwKF9kZWZhdWx0cywgdmFsdWUgfHwge30pO1xuXHR9LFxuXHRjb25maWcodmFsdWUpIHtcblx0XHRyZXR1cm4gX21lcmdlRGVlcChfY29uZmlnLCB2YWx1ZSB8fCB7fSk7XG5cdH0sXG5cdHJlZ2lzdGVyRWZmZWN0KHtuYW1lLCBlZmZlY3QsIHBsdWdpbnMsIGRlZmF1bHRzLCBleHRlbmRUaW1lbGluZX0pIHtcblx0XHQocGx1Z2lucyB8fCBcIlwiKS5zcGxpdChcIixcIikuZm9yRWFjaChwbHVnaW5OYW1lID0+IHBsdWdpbk5hbWUgJiYgIV9wbHVnaW5zW3BsdWdpbk5hbWVdICYmICFfZ2xvYmFsc1twbHVnaW5OYW1lXSAmJiBfd2FybihuYW1lICsgXCIgZWZmZWN0IHJlcXVpcmVzIFwiICsgcGx1Z2luTmFtZSArIFwiIHBsdWdpbi5cIikpO1xuXHRcdF9lZmZlY3RzW25hbWVdID0gKHRhcmdldHMsIHZhcnMsIHRsKSA9PiBlZmZlY3QodG9BcnJheSh0YXJnZXRzKSwgX3NldERlZmF1bHRzKHZhcnMgfHwge30sIGRlZmF1bHRzKSwgdGwpO1xuXHRcdGlmIChleHRlbmRUaW1lbGluZSkge1xuXHRcdFx0VGltZWxpbmUucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24odGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkKF9lZmZlY3RzW25hbWVdKHRhcmdldHMsIF9pc09iamVjdCh2YXJzKSA/IHZhcnMgOiAocG9zaXRpb24gPSB2YXJzKSAmJiB7fSwgdGhpcyksIHBvc2l0aW9uKTtcblx0XHRcdH07XG5cdFx0fVxuXHR9LFxuXHRyZWdpc3RlckVhc2UobmFtZSwgZWFzZSkge1xuXHRcdF9lYXNlTWFwW25hbWVdID0gX3BhcnNlRWFzZShlYXNlKTtcblx0fSxcblx0cGFyc2VFYXNlKGVhc2UsIGRlZmF1bHRFYXNlKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBfcGFyc2VFYXNlKGVhc2UsIGRlZmF1bHRFYXNlKSA6IF9lYXNlTWFwO1xuXHR9LFxuXHRnZXRCeUlkKGlkKSB7XG5cdFx0cmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRCeUlkKGlkKTtcblx0fSxcblx0ZXhwb3J0Um9vdCh2YXJzID0ge30sIGluY2x1ZGVEZWxheWVkQ2FsbHMpIHtcblx0XHRsZXQgdGwgPSBuZXcgVGltZWxpbmUodmFycyksXG5cdFx0XHRjaGlsZCwgbmV4dDtcblx0XHR0bC5zbW9vdGhDaGlsZFRpbWluZyA9IF9pc05vdEZhbHNlKHZhcnMuc21vb3RoQ2hpbGRUaW1pbmcpO1xuXHRcdF9nbG9iYWxUaW1lbGluZS5yZW1vdmUodGwpO1xuXHRcdHRsLl9kcCA9IDA7IC8vb3RoZXJ3aXNlIGl0J2xsIGdldCByZS1hY3RpdmF0ZWQgd2hlbiBhZGRpbmcgY2hpbGRyZW4gYW5kIGJlIHJlLWludHJvZHVjZWQgaW50byBfZ2xvYmFsVGltZWxpbmUncyBsaW5rZWQgbGlzdCAodGhlbiBhZGRlZCB0byBpdHNlbGYpLlxuXHRcdHRsLl90aW1lID0gdGwuX3RUaW1lID0gX2dsb2JhbFRpbWVsaW5lLl90aW1lO1xuXHRcdGNoaWxkID0gX2dsb2JhbFRpbWVsaW5lLl9maXJzdDtcblx0XHR3aGlsZSAoY2hpbGQpIHtcblx0XHRcdG5leHQgPSBjaGlsZC5fbmV4dDtcblx0XHRcdGlmIChpbmNsdWRlRGVsYXllZENhbGxzIHx8ICEoIWNoaWxkLl9kdXIgJiYgY2hpbGQgaW5zdGFuY2VvZiBUd2VlbiAmJiBjaGlsZC52YXJzLm9uQ29tcGxldGUgPT09IGNoaWxkLl90YXJnZXRzWzBdKSkge1xuXHRcdFx0XHRfYWRkVG9UaW1lbGluZSh0bCwgY2hpbGQsIGNoaWxkLl9zdGFydCAtIGNoaWxkLl9kZWxheSk7XG5cdFx0XHR9XG5cdFx0XHRjaGlsZCA9IG5leHQ7XG5cdFx0fVxuXHRcdF9hZGRUb1RpbWVsaW5lKF9nbG9iYWxUaW1lbGluZSwgdGwsIDApO1xuXHRcdHJldHVybiB0bDtcblx0fSxcblx0dXRpbHM6IHsgd3JhcCwgd3JhcFlveW8sIGRpc3RyaWJ1dGUsIHJhbmRvbSwgc25hcCwgbm9ybWFsaXplLCBnZXRVbml0LCBjbGFtcCwgc3BsaXRDb2xvciwgdG9BcnJheSwgc2VsZWN0b3IsIG1hcFJhbmdlLCBwaXBlLCB1bml0aXplLCBpbnRlcnBvbGF0ZSwgc2h1ZmZsZSB9LFxuXHRpbnN0YWxsOiBfaW5zdGFsbCxcblx0ZWZmZWN0czogX2VmZmVjdHMsXG5cdHRpY2tlcjogX3RpY2tlcixcblx0dXBkYXRlUm9vdDogVGltZWxpbmUudXBkYXRlUm9vdCxcblx0cGx1Z2luczogX3BsdWdpbnMsXG5cdGdsb2JhbFRpbWVsaW5lOiBfZ2xvYmFsVGltZWxpbmUsXG5cdGNvcmU6IHtQcm9wVHdlZW4sIGdsb2JhbHM6IF9hZGRHbG9iYWwsIFR3ZWVuLCBUaW1lbGluZSwgQW5pbWF0aW9uLCBnZXRDYWNoZTogX2dldENhY2hlLCBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0sIHN1cHByZXNzT3ZlcndyaXRlczogdmFsdWUgPT4gX3N1cHByZXNzT3ZlcndyaXRlcyA9IHZhbHVlfVxufTtcblxuX2ZvckVhY2hOYW1lKFwidG8sZnJvbSxmcm9tVG8sZGVsYXllZENhbGwsc2V0LGtpbGxUd2VlbnNPZlwiLCBuYW1lID0+IF9nc2FwW25hbWVdID0gVHdlZW5bbmFtZV0pO1xuX3RpY2tlci5hZGQoVGltZWxpbmUudXBkYXRlUm9vdCk7XG5fcXVpY2tUd2VlbiA9IF9nc2FwLnRvKHt9LCB7ZHVyYXRpb246MH0pO1xuXG5cblxuXG4vLyAtLS0tIEVYVFJBIFBMVUdJTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5sZXQgX2dldFBsdWdpblByb3BUd2VlbiA9IChwbHVnaW4sIHByb3ApID0+IHtcblx0XHRsZXQgcHQgPSBwbHVnaW4uX3B0O1xuXHRcdHdoaWxlIChwdCAmJiBwdC5wICE9PSBwcm9wICYmIHB0Lm9wICE9PSBwcm9wICYmIHB0LmZwICE9PSBwcm9wKSB7XG5cdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdH1cblx0XHRyZXR1cm4gcHQ7XG5cdH0sXG5cdF9hZGRNb2RpZmllcnMgPSAodHdlZW4sIG1vZGlmaWVycykgPT4ge1xuXHRcdFx0bGV0XHR0YXJnZXRzID0gdHdlZW4uX3RhcmdldHMsXG5cdFx0XHRcdHAsIGksIHB0O1xuXHRcdFx0Zm9yIChwIGluIG1vZGlmaWVycykge1xuXHRcdFx0XHRpID0gdGFyZ2V0cy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRwdCA9IHR3ZWVuLl9wdExvb2t1cFtpXVtwXTtcblx0XHRcdFx0XHRpZiAocHQgJiYgKHB0ID0gcHQuZCkpIHtcblx0XHRcdFx0XHRcdGlmIChwdC5fcHQpIHsgLy8gaXMgYSBwbHVnaW5cblx0XHRcdFx0XHRcdFx0cHQgPSBfZ2V0UGx1Z2luUHJvcFR3ZWVuKHB0LCBwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHB0ICYmIHB0Lm1vZGlmaWVyICYmIHB0Lm1vZGlmaWVyKG1vZGlmaWVyc1twXSwgdHdlZW4sIHRhcmdldHNbaV0sIHApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHR9LFxuXHRfYnVpbGRNb2RpZmllclBsdWdpbiA9IChuYW1lLCBtb2RpZmllcikgPT4ge1xuXHRcdHJldHVybiB7XG5cdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0cmF3VmFyczogMSwgLy9kb24ndCBwcmUtcHJvY2VzcyBmdW5jdGlvbi1iYXNlZCB2YWx1ZXMgb3IgXCJyYW5kb20oKVwiIHN0cmluZ3MuXG5cdFx0XHRpbml0KHRhcmdldCwgdmFycywgdHdlZW4pIHtcblx0XHRcdFx0dHdlZW4uX29uSW5pdCA9IHR3ZWVuID0+IHtcblx0XHRcdFx0XHRsZXQgdGVtcCwgcDtcblx0XHRcdFx0XHRpZiAoX2lzU3RyaW5nKHZhcnMpKSB7XG5cdFx0XHRcdFx0XHR0ZW1wID0ge307XG5cdFx0XHRcdFx0XHRfZm9yRWFjaE5hbWUodmFycywgbmFtZSA9PiB0ZW1wW25hbWVdID0gMSk7IC8vaWYgdGhlIHVzZXIgcGFzc2VzIGluIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMgdG8gcm91bmRQcm9wcywgbGlrZSBcIngseVwiLCB3ZSByb3VuZCB0byB3aG9sZSBudW1iZXJzLlxuXHRcdFx0XHRcdFx0dmFycyA9IHRlbXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtb2RpZmllcikge1xuXHRcdFx0XHRcdFx0dGVtcCA9IHt9O1xuXHRcdFx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0XHRcdFx0dGVtcFtwXSA9IG1vZGlmaWVyKHZhcnNbcF0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFycyA9IHRlbXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF9hZGRNb2RpZmllcnModHdlZW4sIHZhcnMpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cbi8vcmVnaXN0ZXIgY29yZSBwbHVnaW5zXG5leHBvcnQgY29uc3QgZ3NhcCA9IF9nc2FwLnJlZ2lzdGVyUGx1Z2luKHtcblx0XHRuYW1lOlwiYXR0clwiLFxuXHRcdGluaXQodGFyZ2V0LCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcblx0XHRcdGxldCBwLCBwdDtcblx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdHB0ID0gdGhpcy5hZGQodGFyZ2V0LCBcInNldEF0dHJpYnV0ZVwiLCAodGFyZ2V0LmdldEF0dHJpYnV0ZShwKSB8fCAwKSArIFwiXCIsIHZhcnNbcF0sIGluZGV4LCB0YXJnZXRzLCAwLCAwLCBwKTtcblx0XHRcdFx0cHQgJiYgKHB0Lm9wID0gcCk7XG5cdFx0XHRcdHRoaXMuX3Byb3BzLnB1c2gocCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCB7XG5cdFx0bmFtZTpcImVuZEFycmF5XCIsXG5cdFx0aW5pdCh0YXJnZXQsIHZhbHVlKSB7XG5cdFx0XHRsZXQgaSA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0dGhpcy5hZGQodGFyZ2V0LCBpLCB0YXJnZXRbaV0gfHwgMCwgdmFsdWVbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0X2J1aWxkTW9kaWZpZXJQbHVnaW4oXCJyb3VuZFByb3BzXCIsIF9yb3VuZE1vZGlmaWVyKSxcblx0X2J1aWxkTW9kaWZpZXJQbHVnaW4oXCJtb2RpZmllcnNcIiksXG5cdF9idWlsZE1vZGlmaWVyUGx1Z2luKFwic25hcFwiLCBzbmFwKVxuKSB8fCBfZ3NhcDsgLy90byBwcmV2ZW50IHRoZSBjb3JlIHBsdWdpbnMgZnJvbSBiZWluZyBkcm9wcGVkIHZpYSBhZ2dyZXNzaXZlIHRyZWUgc2hha2luZywgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlIHZhcmlhYmxlIGRlY2xhcmF0aW9uIGluIHRoaXMgd2F5LlxuXG5Ud2Vlbi52ZXJzaW9uID0gVGltZWxpbmUudmVyc2lvbiA9IGdzYXAudmVyc2lvbiA9IFwiMy43LjBcIjtcbl9jb3JlUmVhZHkgPSAxO1xuX3dpbmRvd0V4aXN0cygpICYmIF93YWtlKCk7XG5cbmV4cG9ydCBjb25zdCB7IFBvd2VyMCwgUG93ZXIxLCBQb3dlcjIsIFBvd2VyMywgUG93ZXI0LCBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgRWxhc3RpYywgQmFjaywgU3RlcHBlZEVhc2UsIEJvdW5jZSwgU2luZSwgRXhwbywgQ2lyYyB9ID0gX2Vhc2VNYXA7XG5leHBvcnQgeyBUd2VlbiBhcyBUd2Vlbk1heCwgVHdlZW4gYXMgVHdlZW5MaXRlLCBUaW1lbGluZSBhcyBUaW1lbGluZU1heCwgVGltZWxpbmUgYXMgVGltZWxpbmVMaXRlLCBnc2FwIGFzIGRlZmF1bHQsIHdyYXAsIHdyYXBZb3lvLCBkaXN0cmlidXRlLCByYW5kb20sIHNuYXAsIG5vcm1hbGl6ZSwgZ2V0VW5pdCwgY2xhbXAsIHNwbGl0Q29sb3IsIHRvQXJyYXksIHNlbGVjdG9yLCBtYXBSYW5nZSwgcGlwZSwgdW5pdGl6ZSwgaW50ZXJwb2xhdGUsIHNodWZmbGUgfTtcbi8vZXhwb3J0IHNvbWUgaW50ZXJuYWwgbWV0aG9kcy9vcm9qZWN0cyBmb3IgdXNlIGluIENTU1BsdWdpbiBzbyB0aGF0IHdlIGNhbiBleHRlcm5hbGl6ZSB0aGF0IGZpbGUgYW5kIGFsbG93IGN1c3RvbSBidWlsZHMgdGhhdCBleGNsdWRlIGl0LlxuZXhwb3J0IHsgX2dldFByb3BlcnR5LCBfbnVtRXhwLCBfbnVtV2l0aFVuaXRFeHAsIF9pc1N0cmluZywgX2lzVW5kZWZpbmVkLCBfcmVuZGVyQ29tcGxleFN0cmluZywgX3JlbEV4cCwgX3NldERlZmF1bHRzLCBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0sIF9mb3JFYWNoTmFtZSwgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSwgX2NvbG9yU3RyaW5nRmlsdGVyLCBfcmVwbGFjZVJhbmRvbSwgX2NoZWNrUGx1Z2luLCBfcGx1Z2lucywgX3RpY2tlciwgX2NvbmZpZywgX3JvdW5kTW9kaWZpZXIsIF9yb3VuZCwgX21pc3NpbmdQbHVnaW4sIF9nZXRTZXR0ZXIsIF9nZXRDYWNoZSwgX2NvbG9yRXhwIH0iLCIvKiFcbiAqIG1hdHJpeCAzLjcuMFxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyMSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbmxldCBfZG9jLCBfd2luLCBfZG9jRWxlbWVudCwgX2JvZHksXHRfZGl2Q29udGFpbmVyLCBfc3ZnQ29udGFpbmVyLCBfaWRlbnRpdHlNYXRyaXgsXG5cdF90cmFuc2Zvcm1Qcm9wID0gXCJ0cmFuc2Zvcm1cIixcblx0X3RyYW5zZm9ybU9yaWdpblByb3AgPSBfdHJhbnNmb3JtUHJvcCArIFwiT3JpZ2luXCIsXG5cdF9oYXNPZmZzZXRCdWcsXG5cdF9zZXREb2MgPSBlbGVtZW50ID0+IHtcblx0XHRsZXQgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGVsZW1lbnQ7XG5cdFx0aWYgKCEoX3RyYW5zZm9ybVByb3AgaW4gZWxlbWVudC5zdHlsZSkgJiYgXCJtc1RyYW5zZm9ybVwiIGluIGVsZW1lbnQuc3R5bGUpIHsgLy90byBpbXByb3ZlIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgTWljcm9zb2Z0IGJyb3dzZXJzXG5cdFx0XHRfdHJhbnNmb3JtUHJvcCA9IFwibXNUcmFuc2Zvcm1cIjtcblx0XHRcdF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiO1xuXHRcdH1cblx0XHR3aGlsZSAoZG9jLnBhcmVudE5vZGUgJiYgKGRvYyA9IGRvYy5wYXJlbnROb2RlKSkge1x0fVxuXHRcdF93aW4gPSB3aW5kb3c7XG5cdFx0X2lkZW50aXR5TWF0cml4ID0gbmV3IE1hdHJpeDJEKCk7XG5cdFx0aWYgKGRvYykge1xuXHRcdFx0X2RvYyA9IGRvYztcblx0XHRcdF9kb2NFbGVtZW50ID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdF9ib2R5ID0gZG9jLmJvZHk7XG5cdFx0XHQvLyBub3cgdGVzdCBmb3IgdGhlIG9mZnNldCByZXBvcnRpbmcgYnVnLiBVc2UgZmVhdHVyZSBkZXRlY3Rpb24gaW5zdGVhZCBvZiBicm93c2VyIHNuaWZmaW5nIHRvIG1ha2UgdGhpbmdzIG1vcmUgYnVsbGV0cHJvb2YgYW5kIGZ1dHVyZS1wcm9vZi4gSG9wZWZ1bGx5IFNhZmFyaSB3aWxsIGZpeCB0aGVpciBidWcgc29vbiBidXQgaXQncyAyMDIwIGFuZCBpdCdzIHN0aWxsIG5vdCBmaXhlZC5cblx0XHRcdGxldCBkMSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuXHRcdFx0XHRkMiA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdFx0X2JvZHkuYXBwZW5kQ2hpbGQoZDEpO1xuXHRcdFx0ZDEuYXBwZW5kQ2hpbGQoZDIpO1xuXHRcdFx0ZDEuc3R5bGUucG9zaXRpb24gPSBcInN0YXRpY1wiO1xuXHRcdFx0ZDEuc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gXCJ0cmFuc2xhdGUzZCgwLDAsMXB4KVwiO1xuXHRcdFx0X2hhc09mZnNldEJ1ZyA9IChkMi5vZmZzZXRQYXJlbnQgIT09IGQxKTtcblx0XHRcdF9ib2R5LnJlbW92ZUNoaWxkKGQxKTtcblx0XHR9XG5cdFx0cmV0dXJuIGRvYztcblx0fSxcblx0X2ZvcmNlTm9uWmVyb1NjYWxlID0gZSA9PiB7IC8vIHdhbGtzIHVwIHRoZSBlbGVtZW50J3MgYW5jZXN0b3JzIGFuZCBmaW5kcyBhbnkgdGhhdCBoYWQgdGhlaXIgc2NhbGUgc2V0IHRvIDAgdmlhIEdTQVAsIGFuZCBjaGFuZ2VzIHRoZW0gdG8gMC4wMDAxIHRvIGVuc3VyZSB0aGF0IG1lYXN1cmVtZW50cyB3b3JrLiBGaXJlZm94IGhhcyBhIGJ1ZyB0aGF0IGNhdXNlcyBpdCB0byBpbmNvcnJlY3RseSByZXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgd2hlbiBzY2FsZSBpcyAwLlxuXHRcdGxldCBhLCBjYWNoZTtcblx0XHR3aGlsZSAoZSAmJiBlICE9PSBfYm9keSkge1xuXHRcdFx0Y2FjaGUgPSBlLl9nc2FwO1xuXHRcdFx0Y2FjaGUgJiYgY2FjaGUudW5jYWNoZSAmJiBjYWNoZS5nZXQoZSwgXCJ4XCIpOyAvLyBmb3JjZSByZS1wYXJzaW5nIG9mIHRyYW5zZm9ybXMgaWYgbmVjZXNzYXJ5XG5cdFx0XHRpZiAoY2FjaGUgJiYgIWNhY2hlLnNjYWxlWCAmJiAhY2FjaGUuc2NhbGVZICYmIGNhY2hlLnJlbmRlclRyYW5zZm9ybSkge1xuXHRcdFx0XHRjYWNoZS5zY2FsZVggPSBjYWNoZS5zY2FsZVkgPSAxZS00O1xuXHRcdFx0XHRjYWNoZS5yZW5kZXJUcmFuc2Zvcm0oMSwgY2FjaGUpO1xuXHRcdFx0XHRhID8gYS5wdXNoKGNhY2hlKSA6IChhID0gW2NhY2hlXSk7XG5cdFx0XHR9XG5cdFx0XHRlID0gZS5wYXJlbnROb2RlO1xuXHRcdH1cblx0XHRyZXR1cm4gYTtcblx0fSxcblx0Ly8gcG9zc2libGUgZnV0dXJlIGFkZGl0aW9uOiBwYXNzIGFuIGVsZW1lbnQgdG8gX2ZvcmNlRGlzcGxheSgpIGFuZCBpdCdsbCB3YWxrIHVwIGFsbCBpdHMgYW5jZXN0b3JzIGFuZCBtYWtlIHN1cmUgYW55dGhpbmcgd2l0aCBkaXNwbGF5OiBub25lIGlzIHNldCB0byBkaXNwbGF5OiBibG9jaywgYW5kIGlmIHRoZXJlJ3Mgbm8gcGFyZW50Tm9kZSwgaXQnbGwgYWRkIGl0IHRvIHRoZSBib2R5LiBJdCByZXR1cm5zIGFuIEFycmF5IHRoYXQgeW91IGNhbiB0aGVuIGZlZWQgdG8gX3JldmVydERpc3BsYXkoKSB0byBoYXZlIGl0IHJldmVydCBhbGwgdGhlIGNoYW5nZXMgaXQgbWFkZS5cblx0Ly8gX2ZvcmNlRGlzcGxheSA9IGUgPT4ge1xuXHQvLyBcdGxldCBhID0gW10sXG5cdC8vIFx0XHRwYXJlbnQ7XG5cdC8vIFx0d2hpbGUgKGUgJiYgZSAhPT0gX2JvZHkpIHtcblx0Ly8gXHRcdHBhcmVudCA9IGUucGFyZW50Tm9kZTtcblx0Ly8gXHRcdChfd2luLmdldENvbXB1dGVkU3R5bGUoZSkuZGlzcGxheSA9PT0gXCJub25lXCIgfHwgIXBhcmVudCkgJiYgYS5wdXNoKGUsIGUuc3R5bGUuZGlzcGxheSwgcGFyZW50KSAmJiAoZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiKTtcblx0Ly8gXHRcdHBhcmVudCB8fCBfYm9keS5hcHBlbmRDaGlsZChlKTtcblx0Ly8gXHRcdGUgPSBwYXJlbnQ7XG5cdC8vIFx0fVxuXHQvLyBcdHJldHVybiBhO1xuXHQvLyB9LFxuXHQvLyBfcmV2ZXJ0RGlzcGxheSA9IGEgPT4ge1xuXHQvLyBcdGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrPTMpIHtcblx0Ly8gXHRcdGFbaSsxXSA/IChhW2ldLnN0eWxlLmRpc3BsYXkgPSBhW2krMV0pIDogYVtpXS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImRpc3BsYXlcIik7XG5cdC8vIFx0XHRhW2krMl0gfHwgYVtpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGFbaV0pO1xuXHQvLyBcdH1cblx0Ly8gfSxcblx0X3N2Z1RlbXBzID0gW10sIC8vd2UgY3JlYXRlIDMgZWxlbWVudHMgZm9yIFNWRywgYW5kIDMgZm9yIG90aGVyIERPTSBlbGVtZW50cyBhbmQgY2FjaGUgdGhlbSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gVGhleSBnZXQgbmVzdGVkIGluIF9kaXZDb250YWluZXIgYW5kIF9zdmdDb250YWluZXIgc28gdGhhdCBqdXN0IG9uZSBlbGVtZW50IGlzIGFkZGVkIHRvIHRoZSBET00gb24gZWFjaCBzdWNjZXNzaXZlIGF0dGVtcHQuIEFnYWluLCBwZXJmb3JtYW5jZSBpcyBrZXkuXG5cdF9kaXZUZW1wcyA9IFtdLFxuXHRfZ2V0RG9jU2Nyb2xsVG9wID0gKCkgPT4gX3dpbi5wYWdlWU9mZnNldCAgfHwgX2RvYy5zY3JvbGxUb3AgfHwgX2RvY0VsZW1lbnQuc2Nyb2xsVG9wIHx8IF9ib2R5LnNjcm9sbFRvcCB8fCAwLFxuXHRfZ2V0RG9jU2Nyb2xsTGVmdCA9ICgpID0+IF93aW4ucGFnZVhPZmZzZXQgfHwgX2RvYy5zY3JvbGxMZWZ0IHx8IF9kb2NFbGVtZW50LnNjcm9sbExlZnQgfHwgX2JvZHkuc2Nyb2xsTGVmdCB8fCAwLFxuXHRfc3ZnT3duZXIgPSBlbGVtZW50ID0+IGVsZW1lbnQub3duZXJTVkdFbGVtZW50IHx8ICgoZWxlbWVudC50YWdOYW1lICsgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJzdmdcIiA/IGVsZW1lbnQgOiBudWxsKSxcblx0X2lzRml4ZWQgPSBlbGVtZW50ID0+IHtcblx0XHRpZiAoX3dpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSBcImZpeGVkXCIpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXHRcdGlmIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHsgLy8gYXZvaWQgZG9jdW1lbnQgZnJhZ21lbnRzIHdoaWNoIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG5cdFx0XHRyZXR1cm4gX2lzRml4ZWQoZWxlbWVudCk7XG5cdFx0fVxuXHR9LFxuXHRfY3JlYXRlU2libGluZyA9IChlbGVtZW50LCBpKSA9PiB7XG5cdFx0aWYgKGVsZW1lbnQucGFyZW50Tm9kZSAmJiAoX2RvYyB8fCBfc2V0RG9jKGVsZW1lbnQpKSkge1xuXHRcdFx0bGV0IHN2ZyA9IF9zdmdPd25lcihlbGVtZW50KSxcblx0XHRcdFx0bnMgPSBzdmcgPyAoc3ZnLmdldEF0dHJpYnV0ZShcInhtbG5zXCIpIHx8IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIikgOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixcblx0XHRcdFx0dHlwZSA9IHN2ZyA/IChpID8gXCJyZWN0XCIgOiBcImdcIikgOiBcImRpdlwiLFxuXHRcdFx0XHR4ID0gaSAhPT0gMiA/IDAgOiAxMDAsXG5cdFx0XHRcdHkgPSBpID09PSAzID8gMTAwIDogMCxcblx0XHRcdFx0Y3NzID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO3BvaW50ZXItZXZlbnRzOm5vbmU7bWFyZ2luOjA7cGFkZGluZzowO1wiLFxuXHRcdFx0XHRlID0gX2RvYy5jcmVhdGVFbGVtZW50TlMgPyBfZG9jLmNyZWF0ZUVsZW1lbnROUyhucy5yZXBsYWNlKC9eaHR0cHMvLCBcImh0dHBcIiksIHR5cGUpIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpO1xuXHRcdFx0aWYgKGkpIHtcblx0XHRcdFx0aWYgKCFzdmcpIHtcblx0XHRcdFx0XHRpZiAoIV9kaXZDb250YWluZXIpIHtcblx0XHRcdFx0XHRcdF9kaXZDb250YWluZXIgPSBfY3JlYXRlU2libGluZyhlbGVtZW50KTtcblx0XHRcdFx0XHRcdF9kaXZDb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGNzcztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZS5zdHlsZS5jc3NUZXh0ID0gY3NzICsgXCJ3aWR0aDowLjFweDtoZWlnaHQ6MC4xcHg7dG9wOlwiICsgeSArIFwicHg7bGVmdDpcIiArIHggKyBcInB4XCI7XG5cdFx0XHRcdFx0X2RpdkNvbnRhaW5lci5hcHBlbmRDaGlsZChlKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9zdmdDb250YWluZXIgfHwgKF9zdmdDb250YWluZXIgPSBfY3JlYXRlU2libGluZyhlbGVtZW50KSk7XG5cdFx0XHRcdFx0ZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCAwLjAxKTtcblx0XHRcdFx0XHRlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCAwLjAxKTtcblx0XHRcdFx0XHRlLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHggKyBcIixcIiArIHkgKyBcIilcIik7XG5cdFx0XHRcdFx0X3N2Z0NvbnRhaW5lci5hcHBlbmRDaGlsZChlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGU7XG5cdFx0fVxuXHRcdHRocm93IFwiTmVlZCBkb2N1bWVudCBhbmQgcGFyZW50LlwiO1xuXHR9LFxuXHRfY29uc29saWRhdGUgPSBtID0+IHsgLy8gcmVwbGFjZXMgU1ZHVHJhbnNmb3JtTGlzdC5jb25zb2xpZGF0ZSgpIGJlY2F1c2UgYSBidWcgaW4gRmlyZWZveCBjYXVzZXMgaXQgdG8gYnJlYWsgcG9pbnRlciBldmVudHMuIFNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIzMjQ4LXRvdWNoLWlzLW5vdC13b3JraW5nLW9uLWRyYWdnYWJsZS1pbi1maXJlZm94LXdpbmRvd3MtdjMyNC8/dGFiPWNvbW1lbnRzI2NvbW1lbnQtMTA5ODAwXG5cdFx0bGV0IGMgPSBuZXcgTWF0cml4MkQoKSxcblx0XHRcdGkgPSAwO1xuXHRcdGZvciAoOyBpIDwgbS5udW1iZXJPZkl0ZW1zOyBpKyspIHtcblx0XHRcdGMubXVsdGlwbHkobS5nZXRJdGVtKGkpLm1hdHJpeCk7XG5cdFx0fVxuXHRcdHJldHVybiBjO1xuXHR9LFxuXHRfcGxhY2VTaWJsaW5ncyA9IChlbGVtZW50LCBhZGp1c3RHT2Zmc2V0KSA9PiB7XG5cdFx0bGV0IHN2ZyA9IF9zdmdPd25lcihlbGVtZW50KSxcblx0XHRcdGlzUm9vdFNWRyA9IGVsZW1lbnQgPT09IHN2Zyxcblx0XHRcdHNpYmxpbmdzID0gc3ZnID8gX3N2Z1RlbXBzIDogX2RpdlRlbXBzLFxuXHRcdFx0cGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlLFxuXHRcdFx0Y29udGFpbmVyLCBtLCBiLCB4LCB5LCBjcztcblx0XHRpZiAoZWxlbWVudCA9PT0gX3dpbikge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0fVxuXHRcdHNpYmxpbmdzLmxlbmd0aCB8fCBzaWJsaW5ncy5wdXNoKF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQsIDEpLCBfY3JlYXRlU2libGluZyhlbGVtZW50LCAyKSwgX2NyZWF0ZVNpYmxpbmcoZWxlbWVudCwgMykpO1xuXHRcdGNvbnRhaW5lciA9IHN2ZyA/IF9zdmdDb250YWluZXIgOiBfZGl2Q29udGFpbmVyO1xuXHRcdGlmIChzdmcpIHtcblx0XHRcdGIgPSBpc1Jvb3RTVkcgPyB7eDowLCB5OjB9IDogZWxlbWVudC5nZXRCQm94KCk7XG5cdFx0XHRtID0gZWxlbWVudC50cmFuc2Zvcm0gPyBlbGVtZW50LnRyYW5zZm9ybS5iYXNlVmFsIDoge307IC8vIElFMTEgZG9lc24ndCBmb2xsb3cgdGhlIHNwZWMuXG5cdFx0XHRpZiAobS5udW1iZXJPZkl0ZW1zKSB7XG5cdFx0XHRcdG0gPSBtLm51bWJlck9mSXRlbXMgPiAxID8gX2NvbnNvbGlkYXRlKG0pIDogbS5nZXRJdGVtKDApLm1hdHJpeDsgLy8gZG9uJ3QgY2FsbCBtLmNvbnNvbGlkYXRlKCkubWF0cml4IGJlY2F1c2UgYSBidWcgaW4gRmlyZWZveCBtYWtlcyBwb2ludGVyIGV2ZW50cyBub3Qgd29yayB3aGVuIGNvbnNvbGlkYXRlKCkgaXMgY2FsbGVkIG9uIHRoZSBzYW1lIHRpY2sgYXMgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkhIFNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIzMjQ4LXRvdWNoLWlzLW5vdC13b3JraW5nLW9uLWRyYWdnYWJsZS1pbi1maXJlZm94LXdpbmRvd3MtdjMyNC8/dGFiPWNvbW1lbnRzI2NvbW1lbnQtMTA5ODAwXG5cdFx0XHRcdHggPSBtLmEgKiBiLnggKyBtLmMgKiBiLnk7XG5cdFx0XHRcdHkgPSBtLmIgKiBiLnggKyBtLmQgKiBiLnk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtID0gX2lkZW50aXR5TWF0cml4O1xuXHRcdFx0XHR4ID0gYi54O1xuXHRcdFx0XHR5ID0gYi55O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFkanVzdEdPZmZzZXQgJiYgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZ1wiKSB7XG5cdFx0XHRcdHggPSB5ID0gMDtcblx0XHRcdH1cblx0XHRcdChpc1Jvb3RTVkcgPyBzdmcgOiBwYXJlbnQpLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwibWF0cml4KFwiICsgbS5hICsgXCIsXCIgKyBtLmIgKyBcIixcIiArIG0uYyArIFwiLFwiICsgbS5kICsgXCIsXCIgKyAobS5lICsgeCkgKyBcIixcIiArIChtLmYgKyB5KSArIFwiKVwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9IHkgPSAwO1xuXHRcdFx0aWYgKF9oYXNPZmZzZXRCdWcpIHsgLy8gc29tZSBicm93c2VycyAobGlrZSBTYWZhcmkpIGhhdmUgYSBidWcgdGhhdCBjYXVzZXMgdGhlbSB0byBtaXNyZXBvcnQgb2Zmc2V0IHZhbHVlcy4gV2hlbiBhbiBhbmNlc3RvciBlbGVtZW50IGhhcyBhIHRyYW5zZm9ybSBhcHBsaWVkLCBpdCdzIHN1cHBvc2VkIHRvIHRyZWF0IGl0IGFzIGlmIGl0J3MgcG9zaXRpb246IHJlbGF0aXZlIChuZXcgY29udGV4dCkuIFNhZmFyaSBib3RjaGVzIHRoaXMsIHNvIHdlIG5lZWQgdG8gZmluZCB0aGUgY2xvc2VzdCBhbmNlc3RvciAoYmV0d2VlbiB0aGUgZWxlbWVudCBhbmQgaXRzIG9mZnNldFBhcmVudCkgdGhhdCBoYXMgYSB0cmFuc2Zvcm0gYXBwbGllZCBhbmQgaWYgb25lIGlzIGZvdW5kLCBncmFiIGl0cyBvZmZzZXRUb3AvTGVmdCBhbmQgc3VidHJhY3QgdGhlbSB0byBjb21wZW5zYXRlLlxuXHRcdFx0XHRtID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHRcdGIgPSBlbGVtZW50O1xuXHRcdFx0XHR3aGlsZSAoYiAmJiAoYiA9IGIucGFyZW50Tm9kZSkgJiYgYiAhPT0gbSAmJiBiLnBhcmVudE5vZGUpIHtcblx0XHRcdFx0XHRpZiAoKF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShiKVtfdHJhbnNmb3JtUHJvcF0gKyBcIlwiKS5sZW5ndGggPiA0KSB7XG5cdFx0XHRcdFx0XHR4ID0gYi5vZmZzZXRMZWZ0O1xuXHRcdFx0XHRcdFx0eSA9IGIub2Zmc2V0VG9wO1xuXHRcdFx0XHRcdFx0YiA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjcyA9IF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblx0XHRcdGlmIChjcy5wb3NpdGlvbiAhPT0gXCJhYnNvbHV0ZVwiKSB7XG5cdFx0XHRcdG0gPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdFx0d2hpbGUgKHBhcmVudCAmJiBwYXJlbnQgIT09IG0pIHsgLy8gaWYgdGhlcmUncyBhbiBhbmNlc3RvciBlbGVtZW50IGJldHdlZW4gdGhlIGVsZW1lbnQgYW5kIGl0cyBvZmZzZXRQYXJlbnQgdGhhdCdzIHNjcm9sbGVkLCB3ZSBtdXN0IGZhY3RvciB0aGF0IGluLlxuXHRcdFx0XHRcdHggKz0gcGFyZW50LnNjcm9sbExlZnQgfHwgMDtcblx0XHRcdFx0XHR5ICs9IHBhcmVudC5zY3JvbGxUb3AgfHwgMDtcblx0XHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YiA9IGNvbnRhaW5lci5zdHlsZTtcblx0XHRcdGIudG9wID0gKGVsZW1lbnQub2Zmc2V0VG9wIC0geSkgKyBcInB4XCI7XG5cdFx0XHRiLmxlZnQgPSAoZWxlbWVudC5vZmZzZXRMZWZ0IC0geCkgKyBcInB4XCI7XG5cdFx0XHRiW190cmFuc2Zvcm1Qcm9wXSA9IGNzW190cmFuc2Zvcm1Qcm9wXTtcblx0XHRcdGJbX3RyYW5zZm9ybU9yaWdpblByb3BdID0gY3NbX3RyYW5zZm9ybU9yaWdpblByb3BdO1xuXHRcdFx0Ly8gYi5ib3JkZXIgPSBtLmJvcmRlcjtcblx0XHRcdC8vIGIuYm9yZGVyTGVmdFN0eWxlID0gbS5ib3JkZXJMZWZ0U3R5bGU7XG5cdFx0XHQvLyBiLmJvcmRlclRvcFN0eWxlID0gbS5ib3JkZXJUb3BTdHlsZTtcblx0XHRcdC8vIGIuYm9yZGVyTGVmdFdpZHRoID0gbS5ib3JkZXJMZWZ0V2lkdGg7XG5cdFx0XHQvLyBiLmJvcmRlclRvcFdpZHRoID0gbS5ib3JkZXJUb3BXaWR0aDtcblx0XHRcdGIucG9zaXRpb24gPSBjcy5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gXCJmaXhlZFwiIDogXCJhYnNvbHV0ZVwiO1xuXHRcdFx0ZWxlbWVudC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cdFx0fVxuXHRcdHJldHVybiBjb250YWluZXI7XG5cdH0sXG5cdF9zZXRNYXRyaXggPSAobSwgYSwgYiwgYywgZCwgZSwgZikgPT4ge1xuXHRcdG0uYSA9IGE7XG5cdFx0bS5iID0gYjtcblx0XHRtLmMgPSBjO1xuXHRcdG0uZCA9IGQ7XG5cdFx0bS5lID0gZTtcblx0XHRtLmYgPSBmO1xuXHRcdHJldHVybiBtO1xuXHR9O1xuXG5leHBvcnQgY2xhc3MgTWF0cml4MkQge1xuXHRjb25zdHJ1Y3RvcihhPTEsIGI9MCwgYz0wLCBkPTEsIGU9MCwgZj0wKSB7XG5cdFx0X3NldE1hdHJpeCh0aGlzLCBhLCBiLCBjLCBkLCBlLCBmKTtcblx0fVxuXG5cdGludmVyc2UoKSB7XG5cdFx0bGV0IHthLCBiLCBjLCBkLCBlLCBmfSA9IHRoaXMsXG5cdFx0XHRkZXRlcm1pbmFudCA9IChhICogZCAtIGIgKiBjKSB8fCAxZS0xMDtcblx0XHRyZXR1cm4gX3NldE1hdHJpeChcblx0XHRcdHRoaXMsXG5cdFx0XHRkIC8gZGV0ZXJtaW5hbnQsXG5cdFx0XHQtYiAvIGRldGVybWluYW50LFxuXHRcdFx0LWMgLyBkZXRlcm1pbmFudCxcblx0XHRcdGEgLyBkZXRlcm1pbmFudCxcblx0XHRcdChjICogZiAtIGQgKiBlKSAvIGRldGVybWluYW50LFxuXHRcdFx0LShhICogZiAtIGIgKiBlKSAvIGRldGVybWluYW50XG5cdFx0KTtcblx0fVxuXG5cdG11bHRpcGx5KG1hdHJpeCkge1xuXHRcdGxldCB7YSwgYiwgYywgZCwgZSwgZn0gPSB0aGlzLFxuXHRcdFx0YTIgPSBtYXRyaXguYSxcblx0XHRcdGIyID0gbWF0cml4LmMsXG5cdFx0XHRjMiA9IG1hdHJpeC5iLFxuXHRcdFx0ZDIgPSBtYXRyaXguZCxcblx0XHRcdGUyID0gbWF0cml4LmUsXG5cdFx0XHRmMiA9IG1hdHJpeC5mO1xuXHRcdHJldHVybiBfc2V0TWF0cml4KHRoaXMsXG5cdFx0XHRhMiAqIGEgKyBjMiAqIGMsXG5cdFx0XHRhMiAqIGIgKyBjMiAqIGQsXG5cdFx0XHRiMiAqIGEgKyBkMiAqIGMsXG5cdFx0XHRiMiAqIGIgKyBkMiAqIGQsXG5cdFx0XHRlICsgZTIgKiBhICsgZjIgKiBjLFxuXHRcdFx0ZiArIGUyICogYiArIGYyICogZCk7XG5cdH1cblxuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IE1hdHJpeDJEKHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRoaXMuZCwgdGhpcy5lLCB0aGlzLmYpO1xuXHR9XG5cblx0ZXF1YWxzKG1hdHJpeCkge1xuXHRcdGxldCB7YSwgYiwgYywgZCwgZSwgZn0gPSB0aGlzO1xuXHRcdHJldHVybiAoYSA9PT0gbWF0cml4LmEgJiYgYiA9PT0gbWF0cml4LmIgJiYgYyA9PT0gbWF0cml4LmMgJiYgZCA9PT0gbWF0cml4LmQgJiYgZSA9PT0gbWF0cml4LmUgJiYgZiA9PT0gbWF0cml4LmYpO1xuXHR9XG5cblx0YXBwbHkocG9pbnQsIGRlY29yYXRlZT17fSkge1xuXHRcdGxldCB7eCwgeX0gPSBwb2ludCxcblx0XHRcdHthLCBiLCBjLCBkLCBlLCBmfSA9IHRoaXM7XG5cdFx0ZGVjb3JhdGVlLnggPSAoeCAqIGEgKyB5ICogYyArIGUpIHx8IDA7XG5cdFx0ZGVjb3JhdGVlLnkgPSAoeCAqIGIgKyB5ICogZCArIGYpIHx8IDA7XG5cdFx0cmV0dXJuIGRlY29yYXRlZTtcblx0fVxuXG59XG5cbi8vIEZlZWQgaW4gYW4gZWxlbWVudCBhbmQgaXQnbGwgcmV0dXJuIGEgMkQgbWF0cml4IChvcHRpb25hbGx5IGludmVydGVkKSBzbyB0aGF0IHlvdSBjYW4gdHJhbnNsYXRlIGJldHdlZW4gY29vcmRpbmF0ZSBzcGFjZXMuXG4vLyBJbnZlcnRpbmcgbGV0cyB5b3UgdHJhbnNsYXRlIGEgZ2xvYmFsIHBvaW50IGludG8gYSBsb2NhbCBjb29yZGluYXRlIHNwYWNlLiBObyBpbnZlcnRpbmcgbGV0cyB5b3UgZ28gdGhlIG90aGVyIHdheS5cbi8vIFdlIG5lZWRlZCB0aGlzIHRvIHdvcmsgYXJvdW5kIHZhcmlvdXMgYnJvd3NlciBidWdzLCBsaWtlIEZpcmVmb3ggZG9lc24ndCBhY2N1cmF0ZWx5IHJlcG9ydCBnZXRTY3JlZW5DVE0oKSB3aGVuIHRoZXJlXG4vLyBhcmUgdHJhbnNmb3JtcyBhcHBsaWVkIHRvIGFuY2VzdG9yIGVsZW1lbnRzLlxuLy8gVGhlIG1hdHJpeCBtYXRoIHRvIGNvbnZlcnQgYW55IHgveSBjb29yZGluYXRlIGlzIGFzIGZvbGxvd3MsIHdoaWNoIGlzIHdyYXBwZWQgaW4gYSBjb252ZW5pZW50IGFwcGx5KCkgbWV0aG9kIG9mIE1hdHJpeDJEIGFib3ZlOlxuLy8gICAgIHR4ID0gbS5hICogeCArIG0uYyAqIHkgKyBtLmVcbi8vICAgICB0eSA9IG0uYiAqIHggKyBtLmQgKiB5ICsgbS5mXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xvYmFsTWF0cml4KGVsZW1lbnQsIGludmVyc2UsIGFkanVzdEdPZmZzZXQsIGluY2x1ZGVTY3JvbGxJbkZpeGVkKSB7IC8vIGFkanVzdEdPZmZzZXQgaXMgdHlwaWNhbGx5IHVzZWQgb25seSB3aGVuIGdyYWJiaW5nIGFuIGVsZW1lbnQncyBQQVJFTlQncyBnbG9iYWwgbWF0cml4LCBhbmQgaXQgaWdub3JlcyB0aGUgeC95IG9mZnNldCBvZiBhbnkgU1ZHIDxnPiBlbGVtZW50cyBiZWNhdXNlIHRoZXkgYmVoYXZlIGluIGEgc3BlY2lhbCB3YXkuXG5cdGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5wYXJlbnROb2RlIHx8IChfZG9jIHx8IF9zZXREb2MoZWxlbWVudCkpLmRvY3VtZW50RWxlbWVudCA9PT0gZWxlbWVudCkge1xuXHRcdHJldHVybiBuZXcgTWF0cml4MkQoKTtcblx0fVxuXHRsZXQgemVyb1NjYWxlcyA9IF9mb3JjZU5vblplcm9TY2FsZShlbGVtZW50KSxcblx0XHRzdmcgPSBfc3ZnT3duZXIoZWxlbWVudCksXG5cdFx0dGVtcHMgPSBzdmcgPyBfc3ZnVGVtcHMgOiBfZGl2VGVtcHMsXG5cdFx0Y29udGFpbmVyID0gX3BsYWNlU2libGluZ3MoZWxlbWVudCwgYWRqdXN0R09mZnNldCksXG5cdFx0YjEgPSB0ZW1wc1swXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcblx0XHRiMiA9IHRlbXBzWzFdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuXHRcdGIzID0gdGVtcHNbMl0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG5cdFx0cGFyZW50ID0gY29udGFpbmVyLnBhcmVudE5vZGUsXG5cdFx0aXNGaXhlZCA9ICFpbmNsdWRlU2Nyb2xsSW5GaXhlZCAmJiBfaXNGaXhlZChlbGVtZW50KSxcblx0XHRtID0gbmV3IE1hdHJpeDJEKFxuXHRcdFx0KGIyLmxlZnQgLSBiMS5sZWZ0KSAvIDEwMCxcblx0XHRcdChiMi50b3AgLSBiMS50b3ApIC8gMTAwLFxuXHRcdFx0KGIzLmxlZnQgLSBiMS5sZWZ0KSAvIDEwMCxcblx0XHRcdChiMy50b3AgLSBiMS50b3ApIC8gMTAwLFxuXHRcdFx0YjEubGVmdCArIChpc0ZpeGVkID8gMCA6IF9nZXREb2NTY3JvbGxMZWZ0KCkpLFxuXHRcdFx0YjEudG9wICsgKGlzRml4ZWQgPyAwIDogX2dldERvY1Njcm9sbFRvcCgpKVxuXHRcdCk7XG5cdHBhcmVudC5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuXHRpZiAoemVyb1NjYWxlcykge1xuXHRcdGIxID0gemVyb1NjYWxlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKGIxLS0pIHtcblx0XHRcdGIyID0gemVyb1NjYWxlc1tiMV07XG5cdFx0XHRiMi5zY2FsZVggPSBiMi5zY2FsZVkgPSAwO1xuXHRcdFx0YjIucmVuZGVyVHJhbnNmb3JtKDEsIGIyKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGludmVyc2UgPyBtLmludmVyc2UoKSA6IG07XG59XG5cbmV4cG9ydCB7IF9nZXREb2NTY3JvbGxUb3AsIF9nZXREb2NTY3JvbGxMZWZ0LCBfc2V0RG9jIH07XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBnZXRNYXRyaXgoZWxlbWVudCkge1xuLy8gXHRfZG9jIHx8IF9zZXREb2MoZWxlbWVudCk7XG4vLyBcdGxldCBtID0gKF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVtfdHJhbnNmb3JtUHJvcF0gKyBcIlwiKS5zdWJzdHIoNykubWF0Y2goL1stLl0qXFxkK1suZVxcLStdKlxcZCpbZVxcLVxcK10qXFxkKi9nKSxcbi8vIFx0XHRpczJEID0gbSAmJiBtLmxlbmd0aCA9PT0gNjtcbi8vIFx0cmV0dXJuICFtIHx8IG0ubGVuZ3RoIDwgNiA/IG5ldyBNYXRyaXgyRCgpIDogbmV3IE1hdHJpeDJEKCttWzBdLCArbVsxXSwgK21baXMyRCA/IDIgOiA0XSwgK21baXMyRCA/IDMgOiA1XSwgK21baXMyRCA/IDQgOiAxMl0sICttW2lzMkQgPyA1IDogMTNdKTtcbi8vIH0iLCIvKiFcbiAqIHBhdGhzIDMuNy4wXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOC0yMDIxLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuLyogZXNsaW50LWRpc2FibGUgKi9cblxubGV0IF9zdmdQYXRoRXhwID0gL1thY2hsbXFzdHZ6XXwoLT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspPylbMC05XS9pZyxcblx0X251bWJlcnNFeHAgPSAvKD86KC0pP1xcZCpcXC4/XFxkKig/OmVbXFwtK10/XFxkKyk/KVswLTldL2lnLFxuXHRfc2NpZW50aWZpYyA9IC9bXFwrXFwtXT9cXGQqXFwuP1xcZCtlW1xcK1xcLV0/XFxkKy9pZyxcblx0X3NlbGVjdG9yRXhwID0gLyheWyNcXC5dW2Etel18W2EteV1bYS16XSkvaSxcblx0X0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuXHRfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG5cdF9zaW4gPSBNYXRoLnNpbixcblx0X2NvcyA9IE1hdGguY29zLFxuXHRfYWJzID0gTWF0aC5hYnMsXG5cdF9zcXJ0ID0gTWF0aC5zcXJ0LFxuXHRfYXRhbjIgPSBNYXRoLmF0YW4yLFxuXHRfbGFyZ2VOdW0gPSAxZTgsXG5cdF9pc1N0cmluZyA9IHZhbHVlID0+IHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIsXG5cdF9pc051bWJlciA9IHZhbHVlID0+IHR5cGVvZih2YWx1ZSkgPT09IFwibnVtYmVyXCIsXG5cdF9pc1VuZGVmaW5lZCA9IHZhbHVlID0+IHR5cGVvZih2YWx1ZSkgPT09IFwidW5kZWZpbmVkXCIsXG5cdF90ZW1wID0ge30sXG5cdF90ZW1wMiA9IHt9LFxuXHRfcm91bmRpbmdOdW0gPSAxZTUsXG5cdF93cmFwUHJvZ3Jlc3MgPSBwcm9ncmVzcyA9PiAoTWF0aC5yb3VuZCgocHJvZ3Jlc3MgKyBfbGFyZ2VOdW0pICUgMSAqIF9yb3VuZGluZ051bSkgLyBfcm91bmRpbmdOdW0pIHx8ICgocHJvZ3Jlc3MgPCAwKSA/IDAgOiAxKSwgLy9pZiBwcm9ncmVzcyBsYW5kcyBvbiAxLCB0aGUgJSB3aWxsIG1ha2UgaXQgMCB3aGljaCBpcyB3aHkgd2UgfHwgMSwgYnV0IG5vdCBpZiBpdCdzIG5lZ2F0aXZlIGJlY2F1c2UgaXQgbWFrZXMgbW9yZSBzZW5zZSBmb3IgbW90aW9uIHRvIGVuZCBhdCAwIGluIHRoYXQgY2FzZS5cblx0X3JvdW5kID0gdmFsdWUgPT4gKE1hdGgucm91bmQodmFsdWUgKiBfcm91bmRpbmdOdW0pIC8gX3JvdW5kaW5nTnVtKSB8fCAwLFxuXHRfcm91bmRQcmVjaXNlID0gdmFsdWUgPT4gKE1hdGgucm91bmQodmFsdWUgKiAxZTEwKSAvIDFlMTApIHx8IDAsXG5cdF9zcGxpdFNlZ21lbnQgPSAocmF3UGF0aCwgc2VnSW5kZXgsIGksIHQpID0+IHtcblx0XHRsZXQgc2VnbWVudCA9IHJhd1BhdGhbc2VnSW5kZXhdLFxuXHRcdFx0c2hpZnQgPSB0ID09PSAxID8gNiA6IHN1YmRpdmlkZVNlZ21lbnQoc2VnbWVudCwgaSwgdCk7XG5cdFx0aWYgKHNoaWZ0ICYmIHNoaWZ0ICsgaSArIDIgPCBzZWdtZW50Lmxlbmd0aCkge1xuXHRcdFx0cmF3UGF0aC5zcGxpY2Uoc2VnSW5kZXgsIDAsIHNlZ21lbnQuc2xpY2UoMCwgaSArIHNoaWZ0ICsgMikpO1xuXHRcdFx0c2VnbWVudC5zcGxpY2UoMCwgaSArIHNoaWZ0KTtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0fSxcblx0X3JldmVyc2VSYXdQYXRoID0gKHJhd1BhdGgsIHNraXBPdXRlcikgPT4ge1xuXHRcdGxldCBpID0gcmF3UGF0aC5sZW5ndGg7XG5cdFx0c2tpcE91dGVyIHx8IHJhd1BhdGgucmV2ZXJzZSgpO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdHJhd1BhdGhbaV0ucmV2ZXJzZWQgfHwgcmV2ZXJzZVNlZ21lbnQocmF3UGF0aFtpXSk7XG5cdFx0fVxuXHR9LFxuXHRfY29weU1ldGFEYXRhID0gKHNvdXJjZSwgY29weSkgPT4ge1xuXHRcdGNvcHkudG90YWxMZW5ndGggPSBzb3VyY2UudG90YWxMZW5ndGg7XG5cdFx0aWYgKHNvdXJjZS5zYW1wbGVzKSB7IC8vc2VnbWVudFxuXHRcdFx0Y29weS5zYW1wbGVzID0gc291cmNlLnNhbXBsZXMuc2xpY2UoMCk7XG5cdFx0XHRjb3B5Lmxvb2t1cCA9IHNvdXJjZS5sb29rdXAuc2xpY2UoMCk7XG5cdFx0XHRjb3B5Lm1pbkxlbmd0aCA9IHNvdXJjZS5taW5MZW5ndGg7XG5cdFx0XHRjb3B5LnJlc29sdXRpb24gPSBzb3VyY2UucmVzb2x1dGlvbjtcblx0XHR9IGVsc2UgaWYgKHNvdXJjZS50b3RhbFBvaW50cykgeyAvL3Jhd1BhdGhcblx0XHRcdGNvcHkudG90YWxQb2ludHMgPSBzb3VyY2UudG90YWxQb2ludHM7XG5cdFx0fVxuXHRcdHJldHVybiBjb3B5O1xuXHR9LFxuXHQvL3B1c2hlcyBhIG5ldyBzZWdtZW50IGludG8gYSByYXdQYXRoLCBidXQgaWYgaXRzIHN0YXJ0aW5nIHZhbHVlcyBtYXRjaCB0aGUgZW5kaW5nIHZhbHVlcyBvZiB0aGUgbGFzdCBzZWdtZW50LCBpdCdsbCBtZXJnZSBpdCBpbnRvIHRoYXQgc2FtZSBzZWdtZW50ICh0byByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWdtZW50cylcblx0X2FwcGVuZE9yTWVyZ2UgPSAocmF3UGF0aCwgc2VnbWVudCkgPT4ge1xuXHRcdGxldCBpbmRleCA9IHJhd1BhdGgubGVuZ3RoLFxuXHRcdFx0cHJldlNlZyA9IHJhd1BhdGhbaW5kZXggLSAxXSB8fCBbXSxcblx0XHRcdGwgPSBwcmV2U2VnLmxlbmd0aDtcblx0XHRpZiAoaW5kZXggJiYgc2VnbWVudFswXSA9PT0gcHJldlNlZ1tsLTJdICYmIHNlZ21lbnRbMV0gPT09IHByZXZTZWdbbC0xXSkge1xuXHRcdFx0c2VnbWVudCA9IHByZXZTZWcuY29uY2F0KHNlZ21lbnQuc2xpY2UoMikpO1xuXHRcdFx0aW5kZXgtLTtcblx0XHR9XG5cdFx0cmF3UGF0aFtpbmRleF0gPSBzZWdtZW50O1xuXHR9LFxuXHRfYmVzdERpc3RhbmNlO1xuXG4vKiBURVJNSU5PTE9HWVxuIC0gUmF3UGF0aCAtIGFuIGFycmF5IG9mIGFycmF5cywgb25lIGZvciBlYWNoIFNlZ21lbnQuIEEgc2luZ2xlIFJhd1BhdGggY291bGQgaGF2ZSBtdWx0aXBsZSBcIk1cIiBjb21tYW5kcywgZGVmaW5pbmcgU2VnbWVudHMgKHBhdGhzIGFyZW4ndCBhbHdheXMgY29ubmVjdGVkKS5cbiAtIFNlZ21lbnQgLSBhbiBhcnJheSBjb250YWluaW5nIGEgc2VxdWVuY2Ugb2YgQ3ViaWMgQmV6aWVyIGNvb3JkaW5hdGVzIGluIGFsdGVybmF0aW5nIHgsIHksIHgsIHkgZm9ybWF0LiBTdGFydGluZyBhbmNob3IsIHRoZW4gY29udHJvbCBwb2ludCAxLCBjb250cm9sIHBvaW50IDIsIGFuZCBlbmRpbmcgYW5jaG9yLCB0aGVuIHRoZSBuZXh0IGNvbnRyb2wgcG9pbnQgMSwgY29udHJvbCBwb2ludCAyLCBhbmNob3IsIGV0Yy4gVXNlcyBsZXNzIG1lbW9yeSB0aGFuIGFuIGFycmF5IHdpdGggYSBidW5jaCBvZiB7eCwgeX0gcG9pbnRzLlxuIC0gQmV6aWVyIC0gYSBzaW5nbGUgY3ViaWMgQmV6aWVyIHdpdGggYSBzdGFydGluZyBhbmNob3IsIHR3byBjb250cm9sIHBvaW50cywgYW5kIGFuIGVuZGluZyBhbmNob3IuXG4gLSB0aGUgdmFyaWFibGUgXCJ0XCIgaXMgdHlwaWNhbGx5IHRoZSBwb3NpdGlvbiBhbG9uZyBhbiBpbmRpdmlkdWFsIEJlemllciBwYXRoICh0aW1lKSBhbmQgaXQncyBOT1QgbGluZWFyLCBtZWFuaW5nIGl0IGNvdWxkIGFjY2VsZXJhdGUvZGVjZWxlcmF0ZSBiYXNlZCBvbiB0aGUgY29udHJvbCBwb2ludHMgd2hlcmVhcyB0aGUgXCJwXCIgb3IgXCJwcm9ncmVzc1wiIHZhbHVlIGlzIGxpbmVhcmx5IG1hcHBlZCB0byB0aGUgd2hvbGUgcGF0aCwgc28gaXQgc2hvdWxkbid0IHJlYWxseSBhY2NlbGVyYXRlL2RlY2VsZXJhdGUgYmFzZWQgb24gY29udHJvbCBwb2ludHMuIFNvIGEgcHJvZ3Jlc3Mgb2YgMC4yIHdvdWxkIGJlIGFsbW9zdCBleGFjdGx5IDIwJSBhbG9uZyB0aGUgcGF0aC4gXCJ0XCIgaXMgT05MWSBpbiBhbiBpbmRpdmlkdWFsIEJlemllciBwaWVjZS5cbiAqL1xuXG4vL2FjY2VwdHMgYmFzaWMgc2VsZWN0b3IgdGV4dCwgYSBwYXRoIGluc3RhbmNlLCBhIFJhd1BhdGggaW5zdGFuY2UsIG9yIGEgU2VnbWVudCBhbmQgcmV0dXJucyBhIFJhd1BhdGggKG1ha2VzIGl0IGVhc3kgdG8gaG9tb2dlbml6ZSB0aGluZ3MpLiBJZiBhbiBlbGVtZW50IG9yIHNlbGVjdG9yIHRleHQgaXMgcGFzc2VkIGluLCBpdCdsbCBhbHNvIGNhY2hlIHRoZSB2YWx1ZSBzbyB0aGF0IGlmIGl0J3MgcXVlcmllZCBhZ2FpbiwgaXQnbGwganVzdCB0YWtlIHRoZSBwYXRoIGRhdGEgZnJvbSB0aGVyZSBpbnN0ZWFkIG9mIHBhcnNpbmcgaXQgYWxsIG92ZXIgYWdhaW4gKGFzIGxvbmcgYXMgdGhlIHBhdGggZGF0YSBpdHNlbGYgaGFzbid0IGNoYW5nZWQgLSBpdCdsbCBjaGVjaykuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmF3UGF0aCh2YWx1ZSkge1xuXHR2YWx1ZSA9IChfaXNTdHJpbmcodmFsdWUpICYmIF9zZWxlY3RvckV4cC50ZXN0KHZhbHVlKSkgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHZhbHVlKSB8fCB2YWx1ZSA6IHZhbHVlO1xuXHRsZXQgZSA9IHZhbHVlLmdldEF0dHJpYnV0ZSA/IHZhbHVlIDogMCxcblx0XHRyYXdQYXRoO1xuXHRpZiAoZSAmJiAodmFsdWUgPSB2YWx1ZS5nZXRBdHRyaWJ1dGUoXCJkXCIpKSkge1xuXHRcdC8vaW1wbGVtZW50cyBjYWNoaW5nXG5cdFx0aWYgKCFlLl9nc1BhdGgpIHtcblx0XHRcdGUuX2dzUGF0aCA9IHt9O1xuXHRcdH1cblx0XHRyYXdQYXRoID0gZS5fZ3NQYXRoW3ZhbHVlXTtcblx0XHRyZXR1cm4gKHJhd1BhdGggJiYgIXJhd1BhdGguX2RpcnR5KSA/IHJhd1BhdGggOiAoZS5fZ3NQYXRoW3ZhbHVlXSA9IHN0cmluZ1RvUmF3UGF0aCh2YWx1ZSkpO1xuXHR9XG5cdHJldHVybiAhdmFsdWUgPyBjb25zb2xlLndhcm4oXCJFeHBlY3RpbmcgYSA8cGF0aD4gZWxlbWVudCBvciBhbiBTVkcgcGF0aCBkYXRhIHN0cmluZ1wiKSA6IF9pc1N0cmluZyh2YWx1ZSkgPyBzdHJpbmdUb1Jhd1BhdGgodmFsdWUpIDogKF9pc051bWJlcih2YWx1ZVswXSkpID8gW3ZhbHVlXSA6IHZhbHVlO1xufVxuXG4vL2NvcGllcyBhIFJhd1BhdGggV0lUSE9VVCB0aGUgbGVuZ3RoIG1ldGEgZGF0YSAoZm9yIHNwZWVkKVxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlSYXdQYXRoKHJhd1BhdGgpIHtcblx0bGV0IGEgPSBbXSxcblx0XHRpID0gMDtcblx0Zm9yICg7IGkgPCByYXdQYXRoLmxlbmd0aDsgaSsrKSB7XG5cdFx0YVtpXSA9IF9jb3B5TWV0YURhdGEocmF3UGF0aFtpXSwgcmF3UGF0aFtpXS5zbGljZSgwKSk7XG5cdH1cblx0cmV0dXJuIF9jb3B5TWV0YURhdGEocmF3UGF0aCwgYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXZlcnNlU2VnbWVudChzZWdtZW50KSB7XG5cdGxldCBpID0gMCxcblx0XHR5O1xuXHRzZWdtZW50LnJldmVyc2UoKTsgLy90aGlzIHdpbGwgaW52ZXJ0IHRoZSBvcmRlciB5LCB4LCB5LCB4IHNvIHdlIG11c3QgZmxpcCBpdCBiYWNrLlxuXHRmb3IgKDsgaSA8IHNlZ21lbnQubGVuZ3RoOyBpICs9IDIpIHtcblx0XHR5ID0gc2VnbWVudFtpXTtcblx0XHRzZWdtZW50W2ldID0gc2VnbWVudFtpKzFdO1xuXHRcdHNlZ21lbnRbaSsxXSA9IHk7XG5cdH1cblx0c2VnbWVudC5yZXZlcnNlZCA9ICFzZWdtZW50LnJldmVyc2VkO1xufVxuXG5cblxubGV0IF9jcmVhdGVQYXRoID0gKGUsIGlnbm9yZSkgPT4ge1xuXHRcdGxldCBwYXRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJwYXRoXCIpLFxuXHRcdFx0YXR0ciA9IFtdLnNsaWNlLmNhbGwoZS5hdHRyaWJ1dGVzKSxcblx0XHRcdGkgPSBhdHRyLmxlbmd0aCxcblx0XHRcdG5hbWU7XG5cdFx0aWdub3JlID0gXCIsXCIgKyBpZ25vcmUgKyBcIixcIjtcblx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdG5hbWUgPSBhdHRyW2ldLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7IC8vaW4gTWljcm9zb2Z0IEVkZ2UsIGlmIHlvdSBkb24ndCBzZXQgdGhlIGF0dHJpYnV0ZSB3aXRoIGEgbG93ZXJjYXNlIG5hbWUsIGl0IGRvZXNuJ3QgcmVuZGVyIGNvcnJlY3RseSEgU3VwZXIgd2VpcmQuXG5cdFx0XHRpZiAoaWdub3JlLmluZGV4T2YoXCIsXCIgKyBuYW1lICsgXCIsXCIpIDwgMCkge1xuXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIG5hbWUsIGF0dHJbaV0ubm9kZVZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHBhdGg7XG5cdH0sXG5cdF90eXBlQXR0cnMgPSB7XG5cdFx0cmVjdDpcInJ4LHJ5LHgseSx3aWR0aCxoZWlnaHRcIixcblx0XHRjaXJjbGU6XCJyLGN4LGN5XCIsXG5cdFx0ZWxsaXBzZTpcInJ4LHJ5LGN4LGN5XCIsXG5cdFx0bGluZTpcIngxLHgyLHkxLHkyXCJcblx0fSxcblx0X2F0dHJUb09iaiA9IChlLCBhdHRycykgPT4ge1xuXHRcdGxldCBwcm9wcyA9IGF0dHJzID8gYXR0cnMuc3BsaXQoXCIsXCIpIDogW10sXG5cdFx0XHRvYmogPSB7fSxcblx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRvYmpbcHJvcHNbaV1dID0gK2UuZ2V0QXR0cmlidXRlKHByb3BzW2ldKSB8fCAwO1xuXHRcdH1cblx0XHRyZXR1cm4gb2JqO1xuXHR9O1xuXG4vL2NvbnZlcnRzIGFuIFNWRyBzaGFwZSBsaWtlIDxjaXJjbGU+LCA8cmVjdD4sIDxwb2x5Z29uPiwgPHBvbHlsaW5lPiwgPGVsbGlwc2U+LCBldGMuIHRvIGEgPHBhdGg+LCBzd2FwcGluZyBpdCBpbiBhbmQgY29weWluZyB0aGUgYXR0cmlidXRlcyB0byBtYXRjaC5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9QYXRoKGVsZW1lbnQsIHN3YXApIHtcblx0bGV0IHR5cGUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRjaXJjID0gMC41NTIyODQ3NDk4MzEsXG5cdFx0ZGF0YSwgeCwgeSwgciwgcnksIHBhdGgsIHJjaXJjLCByeWNpcmMsIHBvaW50cywgdywgaCwgeDIsIHgzLCB4NCwgeDUsIHg2LCB5MiwgeTMsIHk0LCB5NSwgeTYsIGF0dHI7XG5cdGlmICh0eXBlID09PSBcInBhdGhcIiB8fCAhZWxlbWVudC5nZXRCQm94KSB7XG5cdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdH1cblx0cGF0aCA9IF9jcmVhdGVQYXRoKGVsZW1lbnQsIFwieCx5LHdpZHRoLGhlaWdodCxjeCxjeSxyeCxyeSxyLHgxLHgyLHkxLHkyLHBvaW50c1wiKTtcblx0YXR0ciA9IF9hdHRyVG9PYmooZWxlbWVudCwgX3R5cGVBdHRyc1t0eXBlXSk7XG5cdGlmICh0eXBlID09PSBcInJlY3RcIikge1xuXHRcdHIgPSBhdHRyLnJ4O1xuXHRcdHJ5ID0gYXR0ci5yeSB8fCByO1xuXHRcdHggPSBhdHRyLng7XG5cdFx0eSA9IGF0dHIueTtcblx0XHR3ID0gYXR0ci53aWR0aCAtIHIgKiAyO1xuXHRcdGggPSBhdHRyLmhlaWdodCAtIHJ5ICogMjtcblx0XHRpZiAociB8fCByeSkgeyAvL2lmIHRoZXJlIGFyZSByb3VuZGVkIGNvcm5lcnMsIHJlbmRlciBjdWJpYyBiZXppZXJzXG5cdFx0XHR4MiA9IHggKyByICogKDEgLSBjaXJjKTtcblx0XHRcdHgzID0geCArIHI7XG5cdFx0XHR4NCA9IHgzICsgdztcblx0XHRcdHg1ID0geDQgKyByICogY2lyYztcblx0XHRcdHg2ID0geDQgKyByO1xuXHRcdFx0eTIgPSB5ICsgcnkgKiAoMSAtIGNpcmMpO1xuXHRcdFx0eTMgPSB5ICsgcnk7XG5cdFx0XHR5NCA9IHkzICsgaDtcblx0XHRcdHk1ID0geTQgKyByeSAqIGNpcmM7XG5cdFx0XHR5NiA9IHk0ICsgcnk7XG5cdFx0XHRkYXRhID0gXCJNXCIgKyB4NiArIFwiLFwiICsgeTMgKyBcIiBWXCIgKyB5NCArIFwiIENcIiArIFt4NiwgeTUsIHg1LCB5NiwgeDQsIHk2LCB4NCAtICh4NCAtIHgzKSAvIDMsIHk2LCB4MyArICh4NCAtIHgzKSAvIDMsIHk2LCB4MywgeTYsIHgyLCB5NiwgeCwgeTUsIHgsIHk0LCB4LCB5NCAtICh5NCAtIHkzKSAvIDMsIHgsIHkzICsgKHk0IC0geTMpIC8gMywgeCwgeTMsIHgsIHkyLCB4MiwgeSwgeDMsIHksIHgzICsgKHg0IC0geDMpIC8gMywgeSwgeDQgLSAoeDQgLSB4MykgLyAzLCB5LCB4NCwgeSwgeDUsIHksIHg2LCB5MiwgeDYsIHkzXS5qb2luKFwiLFwiKSArIFwielwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gXCJNXCIgKyAoeCArIHcpICsgXCIsXCIgKyB5ICsgXCIgdlwiICsgaCArIFwiIGhcIiArICgtdykgKyBcIiB2XCIgKyAoLWgpICsgXCIgaFwiICsgdyArIFwielwiO1xuXHRcdH1cblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09IFwiY2lyY2xlXCIgfHwgdHlwZSA9PT0gXCJlbGxpcHNlXCIpIHtcblx0XHRpZiAodHlwZSA9PT0gXCJjaXJjbGVcIikge1xuXHRcdFx0ciA9IHJ5ID0gYXR0ci5yO1xuXHRcdFx0cnljaXJjID0gciAqIGNpcmM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHIgPSBhdHRyLnJ4O1xuXHRcdFx0cnkgPSBhdHRyLnJ5O1xuXHRcdFx0cnljaXJjID0gcnkgKiBjaXJjO1xuXHRcdH1cblx0XHR4ID0gYXR0ci5jeDtcblx0XHR5ID0gYXR0ci5jeTtcblx0XHRyY2lyYyA9IHIgKiBjaXJjO1xuXHRcdGRhdGEgPSBcIk1cIiArICh4K3IpICsgXCIsXCIgKyB5ICsgXCIgQ1wiICsgW3grciwgeSArIHJ5Y2lyYywgeCArIHJjaXJjLCB5ICsgcnksIHgsIHkgKyByeSwgeCAtIHJjaXJjLCB5ICsgcnksIHggLSByLCB5ICsgcnljaXJjLCB4IC0gciwgeSwgeCAtIHIsIHkgLSByeWNpcmMsIHggLSByY2lyYywgeSAtIHJ5LCB4LCB5IC0gcnksIHggKyByY2lyYywgeSAtIHJ5LCB4ICsgciwgeSAtIHJ5Y2lyYywgeCArIHIsIHldLmpvaW4oXCIsXCIpICsgXCJ6XCI7XG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gXCJsaW5lXCIpIHtcblx0XHRkYXRhID0gXCJNXCIgKyBhdHRyLngxICsgXCIsXCIgKyBhdHRyLnkxICsgXCIgTFwiICsgYXR0ci54MiArIFwiLFwiICsgYXR0ci55MjsgLy9wcmV2aW91c2x5LCB3ZSBqdXN0IGNvbnZlcnRlZCB0byBcIk14LHkgTHgseVwiIGJ1dCBTYWZhcmkgaGFzIGJ1Z3MgdGhhdCBjYXVzZSB0aGF0IG5vdCB0byByZW5kZXIgcHJvcGVybHkgd2hlbiB1c2luZyBhIHN0cm9rZS1kYXNoYXJyYXkgdGhhdCdzIG5vdCBmdWxseSB2aXNpYmxlISBVc2luZyBhIGN1YmljIGJlemllciBmaXhlcyB0aGF0IGlzc3VlLlxuXHR9IGVsc2UgaWYgKHR5cGUgPT09IFwicG9seWxpbmVcIiB8fCB0eXBlID09PSBcInBvbHlnb25cIikge1xuXHRcdHBvaW50cyA9IChlbGVtZW50LmdldEF0dHJpYnV0ZShcInBvaW50c1wiKSArIFwiXCIpLm1hdGNoKF9udW1iZXJzRXhwKSB8fCBbXTtcblx0XHR4ID0gcG9pbnRzLnNoaWZ0KCk7XG5cdFx0eSA9IHBvaW50cy5zaGlmdCgpO1xuXHRcdGRhdGEgPSBcIk1cIiArIHggKyBcIixcIiArIHkgKyBcIiBMXCIgKyBwb2ludHMuam9pbihcIixcIik7XG5cdFx0aWYgKHR5cGUgPT09IFwicG9seWdvblwiKSB7XG5cdFx0XHRkYXRhICs9IFwiLFwiICsgeCArIFwiLFwiICsgeSArIFwielwiO1xuXHRcdH1cblx0fVxuXHRwYXRoLnNldEF0dHJpYnV0ZShcImRcIiwgcmF3UGF0aFRvU3RyaW5nKHBhdGguX2dzUmF3UGF0aCA9IHN0cmluZ1RvUmF3UGF0aChkYXRhKSkpO1xuXHRpZiAoc3dhcCAmJiBlbGVtZW50LnBhcmVudE5vZGUpIHtcblx0XHRlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHBhdGgsIGVsZW1lbnQpO1xuXHRcdGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcblx0fVxuXHRyZXR1cm4gcGF0aDtcbn1cblxuXG5cbi8vcmV0dXJucyB0aGUgcm90YXRpb24gKGluIGRlZ3JlZXMpIGF0IGEgcGFydGljdWxhciBwcm9ncmVzcyBvbiBhIHJhd1BhdGggKHRoZSBzbG9wZSBvZiB0aGUgdGFuZ2VudClcbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3RhdGlvbkF0UHJvZ3Jlc3MocmF3UGF0aCwgcHJvZ3Jlc3MpIHtcblx0bGV0IGQgPSBnZXRQcm9ncmVzc0RhdGEocmF3UGF0aCwgcHJvZ3Jlc3MgPj0gMSA/IDEgLSAxZS05IDogcHJvZ3Jlc3MgPyBwcm9ncmVzcyA6IDFlLTkpO1xuXHRyZXR1cm4gZ2V0Um90YXRpb25BdEJlemllclQoZC5zZWdtZW50LCBkLmksIGQudCk7XG59XG5cbmZ1bmN0aW9uIGdldFJvdGF0aW9uQXRCZXppZXJUKHNlZ21lbnQsIGksIHQpIHtcblx0bGV0IGEgPSBzZWdtZW50W2ldLFxuXHRcdGIgPSBzZWdtZW50W2krMl0sXG5cdFx0YyA9IHNlZ21lbnRbaSs0XSxcblx0XHR4O1xuXHRhICs9IChiIC0gYSkgKiB0O1xuXHRiICs9IChjIC0gYikgKiB0O1xuXHRhICs9IChiIC0gYSkgKiB0O1xuXHR4ID0gYiArICgoYyArIChzZWdtZW50W2krNl0gLSBjKSAqIHQpIC0gYikgKiB0IC0gYTtcblx0YSA9IHNlZ21lbnRbaSsxXTtcblx0YiA9IHNlZ21lbnRbaSszXTtcblx0YyA9IHNlZ21lbnRbaSs1XTtcblx0YSArPSAoYiAtIGEpICogdDtcblx0YiArPSAoYyAtIGIpICogdDtcblx0YSArPSAoYiAtIGEpICogdDtcblx0cmV0dXJuIF9yb3VuZChfYXRhbjIoYiArICgoYyArIChzZWdtZW50W2krN10gLSBjKSAqIHQpIC0gYikgKiB0IC0gYSwgeCkgKiBfUkFEMkRFRyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzbGljZVJhd1BhdGgocmF3UGF0aCwgc3RhcnQsIGVuZCkge1xuXHRlbmQgPSBfaXNVbmRlZmluZWQoZW5kKSA/IDEgOiBfcm91bmRQcmVjaXNlKGVuZCkgfHwgMDsgLy8gd2UgbXVzdCByb3VuZCB0byBhdm9pZCBpc3N1ZXMgbGlrZSA0LjE1IC8gOCA9IDAuODMwMDAwMDAwMDAwMDAwMSBpbnN0ZWFkIG9mIDAuODMgb3IgMi44IC8gNSA9IDAuNTU5OTk5OTk5OTk5OTk5OSBpbnN0ZWFkIG9mIDAuNTYgYW5kIGlmIHNvbWVvbmUgaXMgZG9pbmcgYSBsb29wIGxpa2Ugc3RhcnQ6IDIuOCAvIDAuNSwgZW5kOiAyLjggLyAwLjUgKyAxLlxuXHRzdGFydCA9IF9yb3VuZFByZWNpc2Uoc3RhcnQpIHx8IDA7XG5cdGxldCBsb29wcyA9IE1hdGgubWF4KDAsIH5+KF9hYnMoZW5kIC0gc3RhcnQpIC0gMWUtOCkpLFxuXHRcdHBhdGggPSBjb3B5UmF3UGF0aChyYXdQYXRoKTtcblx0aWYgKHN0YXJ0ID4gZW5kKSB7XG5cdFx0c3RhcnQgPSAxIC0gc3RhcnQ7XG5cdFx0ZW5kID0gMSAtIGVuZDtcblx0XHRfcmV2ZXJzZVJhd1BhdGgocGF0aCk7XG5cdFx0cGF0aC50b3RhbExlbmd0aCA9IDA7XG5cdH1cblx0aWYgKHN0YXJ0IDwgMCB8fCBlbmQgPCAwKSB7XG5cdFx0bGV0IG9mZnNldCA9IE1hdGguYWJzKH5+TWF0aC5taW4oc3RhcnQsIGVuZCkpICsgMTtcblx0XHRzdGFydCArPSBvZmZzZXQ7XG5cdFx0ZW5kICs9IG9mZnNldDtcblx0fVxuXHRwYXRoLnRvdGFsTGVuZ3RoIHx8IGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyhwYXRoKTtcblx0bGV0IHdyYXAgPSAoZW5kID4gMSksXG5cdFx0cyA9IGdldFByb2dyZXNzRGF0YShwYXRoLCBzdGFydCwgX3RlbXAsIHRydWUpLFxuXHRcdGUgPSBnZXRQcm9ncmVzc0RhdGEocGF0aCwgZW5kLCBfdGVtcDIpLFxuXHRcdGVTZWcgPSBlLnNlZ21lbnQsXG5cdFx0c1NlZyA9IHMuc2VnbWVudCxcblx0XHRlU2VnSW5kZXggPSBlLnNlZ0luZGV4LFxuXHRcdHNTZWdJbmRleCA9IHMuc2VnSW5kZXgsXG5cdFx0ZWkgPSBlLmksXG5cdFx0c2kgPSBzLmksXG5cdFx0c2FtZVNlZ21lbnQgPSAoc1NlZ0luZGV4ID09PSBlU2VnSW5kZXgpLFxuXHRcdHNhbWVCZXppZXIgPSAoZWkgPT09IHNpICYmIHNhbWVTZWdtZW50KSxcblx0XHR3cmFwc0JlaGluZCwgc1NoaWZ0LCBlU2hpZnQsIGksIGNvcHksIHRvdGFsU2VnbWVudHMsIGwsIGo7XG5cdGlmICh3cmFwIHx8IGxvb3BzKSB7XG5cdFx0d3JhcHNCZWhpbmQgPSBlU2VnSW5kZXggPCBzU2VnSW5kZXggfHwgKHNhbWVTZWdtZW50ICYmIGVpIDwgc2kpIHx8IChzYW1lQmV6aWVyICYmIGUudCA8IHMudCk7XG5cdFx0aWYgKF9zcGxpdFNlZ21lbnQocGF0aCwgc1NlZ0luZGV4LCBzaSwgcy50KSkge1xuXHRcdFx0c1NlZ0luZGV4Kys7XG5cdFx0XHRpZiAoIXdyYXBzQmVoaW5kKSB7XG5cdFx0XHRcdGVTZWdJbmRleCsrO1xuXHRcdFx0XHRpZiAoc2FtZUJlemllcikge1xuXHRcdFx0XHRcdGUudCA9IChlLnQgLSBzLnQpIC8gKDEgLSBzLnQpO1xuXHRcdFx0XHRcdGVpID0gMDtcblx0XHRcdFx0fSBlbHNlIGlmIChzYW1lU2VnbWVudCkge1xuXHRcdFx0XHRcdGVpIC09IHNpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICgxIC0gKGVuZCAtIHN0YXJ0KSA8IDFlLTUpIHtcblx0XHRcdGVTZWdJbmRleCA9IHNTZWdJbmRleCAtIDE7XG5cdFx0fSBlbHNlIGlmICghZS50ICYmIGVTZWdJbmRleCkge1xuXHRcdFx0ZVNlZ0luZGV4LS07XG5cdFx0fSBlbHNlIGlmIChfc3BsaXRTZWdtZW50KHBhdGgsIGVTZWdJbmRleCwgZWksIGUudCkgJiYgd3JhcHNCZWhpbmQpIHtcblx0XHRcdHNTZWdJbmRleCsrO1xuXHRcdH1cblx0XHRpZiAocy50ID09PSAxKSB7XG5cdFx0XHRzU2VnSW5kZXggPSAoc1NlZ0luZGV4ICsgMSkgJSBwYXRoLmxlbmd0aDtcblx0XHR9XG5cdFx0Y29weSA9IFtdO1xuXHRcdHRvdGFsU2VnbWVudHMgPSBwYXRoLmxlbmd0aDtcblx0XHRsID0gMSArIHRvdGFsU2VnbWVudHMgKiBsb29wcztcblx0XHRqID0gc1NlZ0luZGV4O1xuXHRcdGwgKz0gKCh0b3RhbFNlZ21lbnRzIC0gc1NlZ0luZGV4KSArIGVTZWdJbmRleCkgJSB0b3RhbFNlZ21lbnRzO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdF9hcHBlbmRPck1lcmdlKGNvcHksIHBhdGhbaisrICUgdG90YWxTZWdtZW50c10pO1xuXHRcdH1cblx0XHRwYXRoID0gY29weTtcblx0fSBlbHNlIHtcblx0XHRlU2hpZnQgPSBlLnQgPT09IDEgPyA2IDogc3ViZGl2aWRlU2VnbWVudChlU2VnLCBlaSwgZS50KTtcblx0XHRpZiAoc3RhcnQgIT09IGVuZCkge1xuXHRcdFx0c1NoaWZ0ID0gc3ViZGl2aWRlU2VnbWVudChzU2VnLCBzaSwgc2FtZUJlemllciA/IHMudCAvIGUudCA6IHMudCk7XG5cdFx0XHRzYW1lU2VnbWVudCAmJiAoZVNoaWZ0ICs9IHNTaGlmdCk7XG5cdFx0XHRlU2VnLnNwbGljZShlaSArIGVTaGlmdCArIDIpO1xuXHRcdFx0KHNTaGlmdCB8fCBzaSkgJiYgc1NlZy5zcGxpY2UoMCwgc2kgKyBzU2hpZnQpO1xuXHRcdFx0aSA9IHBhdGgubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHQvL2Nob3Agb2ZmIGFueSBleHRyYSBzZWdtZW50c1xuXHRcdFx0XHQoaSA8IHNTZWdJbmRleCB8fCBpID4gZVNlZ0luZGV4KSAmJlx0cGF0aC5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVTZWcuYW5nbGUgPSBnZXRSb3RhdGlvbkF0QmV6aWVyVChlU2VnLCBlaSArIGVTaGlmdCwgMCk7IC8vcmVjb3JkIHRoZSB2YWx1ZSBiZWZvcmUgd2UgY2hvcCBiZWNhdXNlIGl0J2xsIGJlIGltcG9zc2libGUgdG8gZGV0ZXJtaW5lIHRoZSBhbmdsZSBhZnRlciBpdHMgbGVuZ3RoIGlzIDAhXG5cdFx0XHRlaSArPSBlU2hpZnQ7XG5cdFx0XHRzID0gZVNlZ1tlaV07XG5cdFx0XHRlID0gZVNlZ1tlaSsxXTtcblx0XHRcdGVTZWcubGVuZ3RoID0gZVNlZy50b3RhbExlbmd0aCA9IDA7XG5cdFx0XHRlU2VnLnRvdGFsUG9pbnRzID0gcGF0aC50b3RhbFBvaW50cyA9IDg7XG5cdFx0XHRlU2VnLnB1c2gocywgZSwgcywgZSwgcywgZSwgcywgZSk7XG5cdFx0fVxuXHR9XG5cdHBhdGgudG90YWxMZW5ndGggPSAwO1xuXHRyZXR1cm4gcGF0aDtcbn1cblxuLy9tZWFzdXJlcyBhIFNlZ21lbnQgYWNjb3JkaW5nIHRvIGl0cyByZXNvbHV0aW9uIChzbyBpZiBzZWdtZW50LnJlc29sdXRpb24gaXMgNiwgZm9yIGV4YW1wbGUsIGl0J2xsIHRha2UgNiBzYW1wbGVzIGVxdWFsbHkgYWNyb3NzIGVhY2ggQmV6aWVyKSBhbmQgY3JlYXRlL3BvcHVsYXRlIGEgXCJzYW1wbGVzXCIgQXJyYXkgdGhhdCBoYXMgdGhlIGxlbmd0aCB1cCB0byBlYWNoIG9mIHRob3NlIHNhbXBsZSBwb2ludHMgKGFsd2F5cyBpbmNyZWFzaW5nIGZyb20gdGhlIHN0YXJ0KSBhcyB3ZWxsIGFzIGEgXCJsb29rdXBcIiBhcnJheSB0aGF0J3MgYnJva2VuIHVwIGFjY29yZGluZyB0byB0aGUgc21hbGxlc3QgZGlzdGFuY2UgYmV0d2VlbiAyIHNhbXBsZXMuIFRoaXMgZ2l2ZXMgdXMgYSB2ZXJ5IGZhc3Qgd2F5IG9mIGxvb2tpbmcgdXAgYSBwcm9ncmVzcyBwb3NpdGlvbiByYXRoZXIgdGhhbiBsb29waW5nIHRocm91Z2ggYWxsIHRoZSBwb2ludHMvQmV6aWVycy4gWW91IGNhbiBvcHRpb25hbGx5IGhhdmUgaXQgb25seSBtZWFzdXJlIGEgc3Vic2V0LCBzdGFydGluZyBhdCBzdGFydEluZGV4IGFuZCBnb2luZyBmb3IgYSBzcGVjaWZpYyBudW1iZXIgb2YgYmV6aWVycyAocmVtZW1iZXIsIHRoZXJlIGFyZSAzIHgveSBwYWlycyBlYWNoLCBmb3IgYSB0b3RhbCBvZiA2IGVsZW1lbnRzIGZvciBlYWNoIEJlemllcikuIEl0IHdpbGwgYWxzbyBwb3B1bGF0ZSBhIFwidG90YWxMZW5ndGhcIiBwcm9wZXJ0eSwgYnV0IHRoYXQncyBub3QgZ2VuZXJhbGx5IHN1cGVyIGFjY3VyYXRlIGJlY2F1c2UgYnkgZGVmYXVsdCBpdCdsbCBvbmx5IHRha2UgNiBzYW1wbGVzIHBlciBCZXppZXIuIEJ1dCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgaXQncyBwZXJmZWN0bHkgYWRlcXVhdGUgZm9yIG1lYXN1cmluZyBwcm9ncmVzcyB2YWx1ZXMgYWxvbmcgdGhlIHBhdGguIElmIHlvdSBuZWVkIGEgbW9yZSBhY2N1cmF0ZSB0b3RhbExlbmd0aCwgZWl0aGVyIGluY3JlYXNlIHRoZSByZXNvbHV0aW9uIG9yIHVzZSB0aGUgbW9yZSBhZHZhbmNlZCBiZXppZXJUb1BvaW50cygpIG1ldGhvZCB3aGljaCBrZWVwcyBhZGRpbmcgcG9pbnRzIHVudGlsIHRoZXkgZG9uJ3QgZGV2aWF0ZSBieSBtb3JlIHRoYW4gYSBjZXJ0YWluIHByZWNpc2lvbiB2YWx1ZS5cbmZ1bmN0aW9uIG1lYXN1cmVTZWdtZW50KHNlZ21lbnQsIHN0YXJ0SW5kZXgsIGJlemllclF0eSkge1xuXHRzdGFydEluZGV4ID0gc3RhcnRJbmRleCB8fCAwO1xuXHRpZiAoIXNlZ21lbnQuc2FtcGxlcykge1xuXHRcdHNlZ21lbnQuc2FtcGxlcyA9IFtdO1xuXHRcdHNlZ21lbnQubG9va3VwID0gW107XG5cdH1cblx0bGV0IHJlc29sdXRpb24gPSB+fnNlZ21lbnQucmVzb2x1dGlvbiB8fCAxMixcblx0XHRpbmMgPSAxIC8gcmVzb2x1dGlvbixcblx0XHRlbmRJbmRleCA9IGJlemllclF0eSA/IHN0YXJ0SW5kZXggKyBiZXppZXJRdHkgKiA2ICsgMSA6IHNlZ21lbnQubGVuZ3RoLFxuXHRcdHgxID0gc2VnbWVudFtzdGFydEluZGV4XSxcblx0XHR5MSA9IHNlZ21lbnRbc3RhcnRJbmRleCArIDFdLFxuXHRcdHNhbXBsZXNJbmRleCA9IHN0YXJ0SW5kZXggPyAoc3RhcnRJbmRleCAvIDYpICogcmVzb2x1dGlvbiA6IDAsXG5cdFx0c2FtcGxlcyA9IHNlZ21lbnQuc2FtcGxlcyxcblx0XHRsb29rdXAgPSBzZWdtZW50Lmxvb2t1cCxcblx0XHRtaW4gPSAoc3RhcnRJbmRleCA/IHNlZ21lbnQubWluTGVuZ3RoIDogX2xhcmdlTnVtKSB8fCBfbGFyZ2VOdW0sXG5cdFx0cHJldkxlbmd0aCA9IHNhbXBsZXNbc2FtcGxlc0luZGV4ICsgYmV6aWVyUXR5ICogcmVzb2x1dGlvbiAtIDFdLFxuXHRcdGxlbmd0aCA9IHN0YXJ0SW5kZXggPyBzYW1wbGVzW3NhbXBsZXNJbmRleC0xXSA6IDAsXG5cdFx0aSwgaiwgeDQsIHgzLCB4MiwgeGQsIHhkMSwgeTQsIHkzLCB5MiwgeWQsIHlkMSwgaW52LCB0LCBsZW5ndGhJbmRleCwgbCwgc2VnTGVuZ3RoO1xuXHRzYW1wbGVzLmxlbmd0aCA9IGxvb2t1cC5sZW5ndGggPSAwO1xuXHRmb3IgKGogPSBzdGFydEluZGV4ICsgMjsgaiA8IGVuZEluZGV4OyBqICs9IDYpIHtcblx0XHR4NCA9IHNlZ21lbnRbaiArIDRdIC0geDE7XG5cdFx0eDMgPSBzZWdtZW50W2ogKyAyXSAtIHgxO1xuXHRcdHgyID0gc2VnbWVudFtqXSAtIHgxO1xuXHRcdHk0ID0gc2VnbWVudFtqICsgNV0gLSB5MTtcblx0XHR5MyA9IHNlZ21lbnRbaiArIDNdIC0geTE7XG5cdFx0eTIgPSBzZWdtZW50W2ogKyAxXSAtIHkxO1xuXHRcdHhkID0geGQxID0geWQgPSB5ZDEgPSAwO1xuXHRcdGlmIChfYWJzKHg0KSA8IDFlLTUgJiYgX2Ficyh5NCkgPCAxZS01ICYmIF9hYnMoeDIpICsgX2Ficyh5MikgPCAxZS01KSB7IC8vZHVtcCBwb2ludHMgdGhhdCBhcmUgc3VmZmljaWVudGx5IGNsb3NlIChiYXNpY2FsbHkgcmlnaHQgb24gdG9wIG9mIGVhY2ggb3RoZXIsIG1ha2luZyBhIGJlemllciBzdXBlciB0aW55IG9yIDAgbGVuZ3RoKVxuXHRcdFx0aWYgKHNlZ21lbnQubGVuZ3RoID4gOCkge1xuXHRcdFx0XHRzZWdtZW50LnNwbGljZShqLCA2KTtcblx0XHRcdFx0aiAtPSA2O1xuXHRcdFx0XHRlbmRJbmRleCAtPSA2O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGkgPSAxOyBpIDw9IHJlc29sdXRpb247IGkrKykge1xuXHRcdFx0XHR0ID0gaW5jICogaTtcblx0XHRcdFx0aW52ID0gMSAtIHQ7XG5cdFx0XHRcdHhkID0geGQxIC0gKHhkMSA9ICh0ICogdCAqIHg0ICsgMyAqIGludiAqICh0ICogeDMgKyBpbnYgKiB4MikpICogdCk7XG5cdFx0XHRcdHlkID0geWQxIC0gKHlkMSA9ICh0ICogdCAqIHk0ICsgMyAqIGludiAqICh0ICogeTMgKyBpbnYgKiB5MikpICogdCk7XG5cdFx0XHRcdGwgPSBfc3FydCh5ZCAqIHlkICsgeGQgKiB4ZCk7XG5cdFx0XHRcdGlmIChsIDwgbWluKSB7XG5cdFx0XHRcdFx0bWluID0gbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRsZW5ndGggKz0gbDtcblx0XHRcdFx0c2FtcGxlc1tzYW1wbGVzSW5kZXgrK10gPSBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHgxICs9IHg0O1xuXHRcdHkxICs9IHk0O1xuXHR9XG5cdGlmIChwcmV2TGVuZ3RoKSB7XG5cdFx0cHJldkxlbmd0aCAtPSBsZW5ndGg7XG5cdFx0Zm9yICg7IHNhbXBsZXNJbmRleCA8IHNhbXBsZXMubGVuZ3RoOyBzYW1wbGVzSW5kZXgrKykge1xuXHRcdFx0c2FtcGxlc1tzYW1wbGVzSW5kZXhdICs9IHByZXZMZW5ndGg7XG5cdFx0fVxuXHR9XG5cdGlmIChzYW1wbGVzLmxlbmd0aCAmJiBtaW4pIHtcblx0XHRzZWdtZW50LnRvdGFsTGVuZ3RoID0gc2VnTGVuZ3RoID0gc2FtcGxlc1tzYW1wbGVzLmxlbmd0aC0xXSB8fCAwO1xuXHRcdHNlZ21lbnQubWluTGVuZ3RoID0gbWluO1xuXHRcdGwgPSBsZW5ndGhJbmRleCA9IDA7XG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ0xlbmd0aDsgaSArPSBtaW4pIHtcblx0XHRcdGxvb2t1cFtsKytdID0gKHNhbXBsZXNbbGVuZ3RoSW5kZXhdIDwgaSkgPyArK2xlbmd0aEluZGV4IDogbGVuZ3RoSW5kZXg7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHNlZ21lbnQudG90YWxMZW5ndGggPSBzYW1wbGVzWzBdID0gMDtcblx0fVxuXHRyZXR1cm4gc3RhcnRJbmRleCA/IGxlbmd0aCAtIHNhbXBsZXNbc3RhcnRJbmRleCAvIDIgLSAxXSA6IGxlbmd0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyhyYXdQYXRoLCByZXNvbHV0aW9uKSB7XG5cdGxldCBwYXRoTGVuZ3RoLCBwb2ludHMsIGk7XG5cdGZvciAoaSA9IHBhdGhMZW5ndGggPSBwb2ludHMgPSAwOyBpIDwgcmF3UGF0aC5sZW5ndGg7IGkrKykge1xuXHRcdHJhd1BhdGhbaV0ucmVzb2x1dGlvbiA9IH5+cmVzb2x1dGlvbiB8fCAxMjsgLy9zdGVwcyBwZXIgQmV6aWVyIGN1cnZlIChhbmNob3IsIDIgY29udHJvbCBwb2ludHMsIHRvIGFuY2hvcilcblx0XHRwb2ludHMgKz0gcmF3UGF0aFtpXS5sZW5ndGg7XG5cdFx0cGF0aExlbmd0aCArPSBtZWFzdXJlU2VnbWVudChyYXdQYXRoW2ldKTtcblx0fVxuXHRyYXdQYXRoLnRvdGFsUG9pbnRzID0gcG9pbnRzO1xuXHRyYXdQYXRoLnRvdGFsTGVuZ3RoID0gcGF0aExlbmd0aDtcblx0cmV0dXJuIHJhd1BhdGg7XG59XG5cbi8vZGl2aWRlIHNlZ21lbnRbaV0gYXQgcG9zaXRpb24gdCAodmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBwcm9ncmVzcyBhbG9uZyB0aGF0IHBhcnRpY3VsYXIgY3ViaWMgYmV6aWVyIHNlZ21lbnQgdGhhdCBzdGFydHMgYXQgc2VnbWVudFtpXSkuIFJldHVybnMgaG93IG1hbnkgZWxlbWVudHMgd2VyZSBzcGxpY2VkIGludG8gdGhlIHNlZ21lbnQgYXJyYXkgKGVpdGhlciAwIG9yIDYpXG5leHBvcnQgZnVuY3Rpb24gc3ViZGl2aWRlU2VnbWVudChzZWdtZW50LCBpLCB0KSB7XG5cdGlmICh0IDw9IDAgfHwgdCA+PSAxKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblx0bGV0IGF4ID0gc2VnbWVudFtpXSxcblx0XHRheSA9IHNlZ21lbnRbaSsxXSxcblx0XHRjcDF4ID0gc2VnbWVudFtpKzJdLFxuXHRcdGNwMXkgPSBzZWdtZW50W2krM10sXG5cdFx0Y3AyeCA9IHNlZ21lbnRbaSs0XSxcblx0XHRjcDJ5ID0gc2VnbWVudFtpKzVdLFxuXHRcdGJ4ID0gc2VnbWVudFtpKzZdLFxuXHRcdGJ5ID0gc2VnbWVudFtpKzddLFxuXHRcdHgxYSA9IGF4ICsgKGNwMXggLSBheCkgKiB0LFxuXHRcdHgyID0gY3AxeCArIChjcDJ4IC0gY3AxeCkgKiB0LFxuXHRcdHkxYSA9IGF5ICsgKGNwMXkgLSBheSkgKiB0LFxuXHRcdHkyID0gY3AxeSArIChjcDJ5IC0gY3AxeSkgKiB0LFxuXHRcdHgxID0geDFhICsgKHgyIC0geDFhKSAqIHQsXG5cdFx0eTEgPSB5MWEgKyAoeTIgLSB5MWEpICogdCxcblx0XHR4MmEgPSBjcDJ4ICsgKGJ4IC0gY3AyeCkgKiB0LFxuXHRcdHkyYSA9IGNwMnkgKyAoYnkgLSBjcDJ5KSAqIHQ7XG5cdHgyICs9ICh4MmEgLSB4MikgKiB0O1xuXHR5MiArPSAoeTJhIC0geTIpICogdDtcblx0c2VnbWVudC5zcGxpY2UoaSArIDIsIDQsXG5cdFx0X3JvdW5kKHgxYSksICAgICAgICAgICAgICAgICAgLy9maXJzdCBjb250cm9sIHBvaW50XG5cdFx0X3JvdW5kKHkxYSksXG5cdFx0X3JvdW5kKHgxKSwgICAgICAgICAgICAgICAgICAgLy9zZWNvbmQgY29udHJvbCBwb2ludFxuXHRcdF9yb3VuZCh5MSksXG5cdFx0X3JvdW5kKHgxICsgKHgyIC0geDEpICogdCksICAgLy9uZXcgZmFicmljYXRlZCBhbmNob3Igb24gbGluZVxuXHRcdF9yb3VuZCh5MSArICh5MiAtIHkxKSAqIHQpLFxuXHRcdF9yb3VuZCh4MiksICAgICAgICAgICAgICAgICAgIC8vdGhpcmQgY29udHJvbCBwb2ludFxuXHRcdF9yb3VuZCh5MiksXG5cdFx0X3JvdW5kKHgyYSksICAgICAgICAgICAgICAgICAgLy9mb3VydGggY29udHJvbCBwb2ludFxuXHRcdF9yb3VuZCh5MmEpXG5cdCk7XG5cdHNlZ21lbnQuc2FtcGxlcyAmJiBzZWdtZW50LnNhbXBsZXMuc3BsaWNlKCgoaSAvIDYpICogc2VnbWVudC5yZXNvbHV0aW9uKSB8IDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuXHRyZXR1cm4gNjtcbn1cblxuLy8gcmV0dXJucyBhbiBvYmplY3Qge3BhdGgsIHNlZ21lbnQsIHNlZ0luZGV4LCBpLCB0fVxuZnVuY3Rpb24gZ2V0UHJvZ3Jlc3NEYXRhKHJhd1BhdGgsIHByb2dyZXNzLCBkZWNvcmF0ZWUsIHB1c2hUb05leHRJZkF0RW5kKSB7XG5cdGRlY29yYXRlZSA9IGRlY29yYXRlZSB8fCB7fTtcblx0cmF3UGF0aC50b3RhbExlbmd0aCB8fCBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMocmF3UGF0aCk7XG5cdGlmIChwcm9ncmVzcyA8IDAgfHwgcHJvZ3Jlc3MgPiAxKSB7XG5cdFx0cHJvZ3Jlc3MgPSBfd3JhcFByb2dyZXNzKHByb2dyZXNzKTtcblx0fVxuXHRsZXQgc2VnSW5kZXggPSAwLFxuXHRcdHNlZ21lbnQgPSByYXdQYXRoWzBdLFxuXHRcdHNhbXBsZXMsIHJlc29sdXRpb24sIGxlbmd0aCwgbWluLCBtYXgsIGksIHQ7XG5cdGlmICghcHJvZ3Jlc3MpIHtcblx0XHR0ID0gaSA9IHNlZ0luZGV4ID0gMDtcblx0XHRzZWdtZW50ID0gcmF3UGF0aFswXTtcblx0fSBlbHNlIGlmIChwcm9ncmVzcyA9PT0gMSkge1xuXHRcdHQgPSAxO1xuXHRcdHNlZ0luZGV4ID0gcmF3UGF0aC5sZW5ndGggLSAxO1xuXHRcdHNlZ21lbnQgPSByYXdQYXRoW3NlZ0luZGV4XTtcblx0XHRpID0gc2VnbWVudC5sZW5ndGggLSA4O1xuXHR9IGVsc2Uge1xuXHRcdGlmIChyYXdQYXRoLmxlbmd0aCA+IDEpIHsgLy9zcGVlZCBvcHRpbWl6YXRpb246IG1vc3Qgb2YgdGhlIHRpbWUsIHRoZXJlJ3Mgb25seSBvbmUgc2VnbWVudCBzbyBza2lwIHRoZSByZWN1cnNpb24uXG5cdFx0XHRsZW5ndGggPSByYXdQYXRoLnRvdGFsTGVuZ3RoICogcHJvZ3Jlc3M7XG5cdFx0XHRtYXggPSBpID0gMDtcblx0XHRcdHdoaWxlICgobWF4ICs9IHJhd1BhdGhbaSsrXS50b3RhbExlbmd0aCkgPCBsZW5ndGgpIHtcblx0XHRcdFx0c2VnSW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdFx0c2VnbWVudCA9IHJhd1BhdGhbc2VnSW5kZXhdO1xuXHRcdFx0bWluID0gbWF4IC0gc2VnbWVudC50b3RhbExlbmd0aDtcblx0XHRcdHByb2dyZXNzID0gKChsZW5ndGggLSBtaW4pIC8gKG1heCAtIG1pbikpIHx8IDA7XG5cdFx0fVxuXHRcdHNhbXBsZXMgPSBzZWdtZW50LnNhbXBsZXM7XG5cdFx0cmVzb2x1dGlvbiA9IHNlZ21lbnQucmVzb2x1dGlvbjsgLy9ob3cgbWFueSBzYW1wbGVzIHBlciBjdWJpYyBiZXppZXIgY2h1bmtcblx0XHRsZW5ndGggPSBzZWdtZW50LnRvdGFsTGVuZ3RoICogcHJvZ3Jlc3M7XG5cdFx0aSA9IHNlZ21lbnQubG9va3VwW35+KGxlbmd0aCAvIHNlZ21lbnQubWluTGVuZ3RoKV0gfHwgMDtcblx0XHRtaW4gPSBpID8gc2FtcGxlc1tpLTFdIDogMDtcblx0XHRtYXggPSBzYW1wbGVzW2ldO1xuXHRcdGlmIChtYXggPCBsZW5ndGgpIHtcblx0XHRcdG1pbiA9IG1heDtcblx0XHRcdG1heCA9IHNhbXBsZXNbKytpXTtcblx0XHR9XG5cdFx0dCA9ICgxIC8gcmVzb2x1dGlvbikgKiAoKChsZW5ndGggLSBtaW4pIC8gKG1heCAtIG1pbikpICsgKChpICUgcmVzb2x1dGlvbikpKTtcblx0XHRpID0gfn4oaSAvIHJlc29sdXRpb24pICogNjtcblx0XHRpZiAocHVzaFRvTmV4dElmQXRFbmQgJiYgdCA9PT0gMSkge1xuXHRcdFx0aWYgKGkgKyA2IDwgc2VnbWVudC5sZW5ndGgpIHtcblx0XHRcdFx0aSArPSA2O1xuXHRcdFx0XHR0ID0gMDtcblx0XHRcdH0gZWxzZSBpZiAoc2VnSW5kZXggKyAxIDwgcmF3UGF0aC5sZW5ndGgpIHtcblx0XHRcdFx0aSA9IHQgPSAwO1xuXHRcdFx0XHRzZWdtZW50ID0gcmF3UGF0aFsrK3NlZ0luZGV4XTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZGVjb3JhdGVlLnQgPSB0O1xuXHRkZWNvcmF0ZWUuaSA9IGk7XG5cdGRlY29yYXRlZS5wYXRoID0gcmF3UGF0aDtcblx0ZGVjb3JhdGVlLnNlZ21lbnQgPSBzZWdtZW50O1xuXHRkZWNvcmF0ZWUuc2VnSW5kZXggPSBzZWdJbmRleDtcblx0cmV0dXJuIGRlY29yYXRlZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBvc2l0aW9uT25QYXRoKHJhd1BhdGgsIHByb2dyZXNzLCBpbmNsdWRlQW5nbGUsIHBvaW50KSB7XG5cdGxldCBzZWdtZW50ID0gcmF3UGF0aFswXSxcblx0XHRyZXN1bHQgPSBwb2ludCB8fCB7fSxcblx0XHRzYW1wbGVzLCByZXNvbHV0aW9uLCBsZW5ndGgsIG1pbiwgbWF4LCBpLCB0LCBhLCBpbnY7XG5cdGlmIChwcm9ncmVzcyA8IDAgfHwgcHJvZ3Jlc3MgPiAxKSB7XG5cdFx0cHJvZ3Jlc3MgPSBfd3JhcFByb2dyZXNzKHByb2dyZXNzKTtcblx0fVxuXHRpZiAocmF3UGF0aC5sZW5ndGggPiAxKSB7IC8vc3BlZWQgb3B0aW1pemF0aW9uOiBtb3N0IG9mIHRoZSB0aW1lLCB0aGVyZSdzIG9ubHkgb25lIHNlZ21lbnQgc28gc2tpcCB0aGUgcmVjdXJzaW9uLlxuXHRcdGxlbmd0aCA9IHJhd1BhdGgudG90YWxMZW5ndGggKiBwcm9ncmVzcztcblx0XHRtYXggPSBpID0gMDtcblx0XHR3aGlsZSAoKG1heCArPSByYXdQYXRoW2krK10udG90YWxMZW5ndGgpIDwgbGVuZ3RoKSB7XG5cdFx0XHRzZWdtZW50ID0gcmF3UGF0aFtpXTtcblx0XHR9XG5cdFx0bWluID0gbWF4IC0gc2VnbWVudC50b3RhbExlbmd0aDtcblx0XHRwcm9ncmVzcyA9ICgobGVuZ3RoIC0gbWluKSAvIChtYXggLSBtaW4pKSB8fCAwO1xuXHR9XG5cdHNhbXBsZXMgPSBzZWdtZW50LnNhbXBsZXM7XG5cdHJlc29sdXRpb24gPSBzZWdtZW50LnJlc29sdXRpb247XG5cdGxlbmd0aCA9IHNlZ21lbnQudG90YWxMZW5ndGggKiBwcm9ncmVzcztcblx0aSA9IHNlZ21lbnQubG9va3VwW3Byb2dyZXNzIDwgMSA/IH5+KGxlbmd0aCAvIHNlZ21lbnQubWluTGVuZ3RoKSA6IHNlZ21lbnQubG9va3VwLmxlbmd0aCAtIDFdIHx8IDA7XG5cdG1pbiA9IGkgPyBzYW1wbGVzW2ktMV0gOiAwO1xuXHRtYXggPSBzYW1wbGVzW2ldO1xuXHRpZiAobWF4IDwgbGVuZ3RoKSB7XG5cdFx0bWluID0gbWF4O1xuXHRcdG1heCA9IHNhbXBsZXNbKytpXTtcblx0fVxuXHR0ID0gKCgxIC8gcmVzb2x1dGlvbikgKiAoKChsZW5ndGggLSBtaW4pIC8gKG1heCAtIG1pbikpICsgKChpICUgcmVzb2x1dGlvbikpKSkgfHwgMDtcblx0aW52ID0gMSAtIHQ7XG5cdGkgPSB+fihpIC8gcmVzb2x1dGlvbikgKiA2O1xuXHRhID0gc2VnbWVudFtpXTtcblx0cmVzdWx0LnggPSBfcm91bmQoKHQgKiB0ICogKHNlZ21lbnRbaSArIDZdIC0gYSkgKyAzICogaW52ICogKHQgKiAoc2VnbWVudFtpICsgNF0gLSBhKSArIGludiAqIChzZWdtZW50W2kgKyAyXSAtIGEpKSkgKiB0ICsgYSk7XG5cdHJlc3VsdC55ID0gX3JvdW5kKCh0ICogdCAqIChzZWdtZW50W2kgKyA3XSAtIChhID0gc2VnbWVudFtpKzFdKSkgKyAzICogaW52ICogKHQgKiAoc2VnbWVudFtpICsgNV0gLSBhKSArIGludiAqIChzZWdtZW50W2kgKyAzXSAtIGEpKSkgKiB0ICsgYSk7XG5cdGlmIChpbmNsdWRlQW5nbGUpIHtcblx0XHRyZXN1bHQuYW5nbGUgPSBzZWdtZW50LnRvdGFsTGVuZ3RoID8gZ2V0Um90YXRpb25BdEJlemllclQoc2VnbWVudCwgaSwgdCA+PSAxID8gMSAtIDFlLTkgOiB0ID8gdCA6IDFlLTkpIDogc2VnbWVudC5hbmdsZSB8fCAwO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cblxuXG4vL2FwcGxpZXMgYSBtYXRyaXggdHJhbnNmb3JtIHRvIFJhd1BhdGggKG9yIGEgc2VnbWVudCBpbiBhIFJhd1BhdGgpIGFuZCByZXR1cm5zIHdoYXRldmVyIHdhcyBwYXNzZWQgaW4gKGl0IHRyYW5zZm9ybXMgdGhlIHZhbHVlcyBpbiB0aGUgYXJyYXkocyksIG5vdCBhIGNvcHkpLlxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVJhd1BhdGgocmF3UGF0aCwgYSwgYiwgYywgZCwgdHgsIHR5KSB7XG5cdGxldCBqID0gcmF3UGF0aC5sZW5ndGgsXG5cdFx0c2VnbWVudCwgbCwgaSwgeCwgeTtcblx0d2hpbGUgKC0taiA+IC0xKSB7XG5cdFx0c2VnbWVudCA9IHJhd1BhdGhbal07XG5cdFx0bCA9IHNlZ21lbnQubGVuZ3RoO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDIpIHtcblx0XHRcdHggPSBzZWdtZW50W2ldO1xuXHRcdFx0eSA9IHNlZ21lbnRbaSsxXTtcblx0XHRcdHNlZ21lbnRbaV0gPSB4ICogYSArIHkgKiBjICsgdHg7XG5cdFx0XHRzZWdtZW50W2krMV0gPSB4ICogYiArIHkgKiBkICsgdHk7XG5cdFx0fVxuXHR9XG5cdHJhd1BhdGguX2RpcnR5ID0gMTtcblx0cmV0dXJuIHJhd1BhdGg7XG59XG5cblxuXG4vLyB0cmFuc2xhdGVzIFNWRyBhcmMgZGF0YSBpbnRvIGEgc2VnbWVudCAoY3ViaWMgYmV6aWVycykuIEFuZ2xlIGlzIGluIGRlZ3JlZXMuXG5mdW5jdGlvbiBhcmNUb1NlZ21lbnQobGFzdFgsIGxhc3RZLCByeCwgcnksIGFuZ2xlLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgeCwgeSkge1xuXHRpZiAobGFzdFggPT09IHggJiYgbGFzdFkgPT09IHkpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0cnggPSBfYWJzKHJ4KTtcblx0cnkgPSBfYWJzKHJ5KTtcblx0bGV0IGFuZ2xlUmFkID0gKGFuZ2xlICUgMzYwKSAqIF9ERUcyUkFELFxuXHRcdGNvc0FuZ2xlID0gX2NvcyhhbmdsZVJhZCksXG5cdFx0c2luQW5nbGUgPSBfc2luKGFuZ2xlUmFkKSxcblx0XHRQSSA9IE1hdGguUEksXG5cdFx0VFdPUEkgPSBQSSAqIDIsXG5cdFx0ZHgyID0gKGxhc3RYIC0geCkgLyAyLFxuXHRcdGR5MiA9IChsYXN0WSAtIHkpIC8gMixcblx0XHR4MSA9IChjb3NBbmdsZSAqIGR4MiArIHNpbkFuZ2xlICogZHkyKSxcblx0XHR5MSA9ICgtc2luQW5nbGUgKiBkeDIgKyBjb3NBbmdsZSAqIGR5MiksXG5cdFx0eDFfc3EgPSB4MSAqIHgxLFxuXHRcdHkxX3NxID0geTEgKiB5MSxcblx0XHRyYWRpaUNoZWNrID0geDFfc3EgLyAocnggKiByeCkgKyB5MV9zcSAvIChyeSAqIHJ5KTtcblx0aWYgKHJhZGlpQ2hlY2sgPiAxKSB7XG5cdFx0cnggPSBfc3FydChyYWRpaUNoZWNrKSAqIHJ4O1xuXHRcdHJ5ID0gX3NxcnQocmFkaWlDaGVjaykgKiByeTtcblx0fVxuXHRsZXQgcnhfc3EgPSByeCAqIHJ4LFxuXHRcdHJ5X3NxID0gcnkgKiByeSxcblx0XHRzcSA9ICgocnhfc3EgKiByeV9zcSkgLSAocnhfc3EgKiB5MV9zcSkgLSAocnlfc3EgKiB4MV9zcSkpIC8gKChyeF9zcSAqIHkxX3NxKSArIChyeV9zcSAqIHgxX3NxKSk7XG5cdGlmIChzcSA8IDApIHtcblx0XHRzcSA9IDA7XG5cdH1cblx0bGV0IGNvZWYgPSAoKGxhcmdlQXJjRmxhZyA9PT0gc3dlZXBGbGFnKSA/IC0xIDogMSkgKiBfc3FydChzcSksXG5cdFx0Y3gxID0gY29lZiAqICgocnggKiB5MSkgLyByeSksXG5cdFx0Y3kxID0gY29lZiAqIC0oKHJ5ICogeDEpIC8gcngpLFxuXHRcdHN4MiA9IChsYXN0WCArIHgpIC8gMixcblx0XHRzeTIgPSAobGFzdFkgKyB5KSAvIDIsXG5cdFx0Y3ggPSBzeDIgKyAoY29zQW5nbGUgKiBjeDEgLSBzaW5BbmdsZSAqIGN5MSksXG5cdFx0Y3kgPSBzeTIgKyAoc2luQW5nbGUgKiBjeDEgKyBjb3NBbmdsZSAqIGN5MSksXG5cdFx0dXggPSAoeDEgLSBjeDEpIC8gcngsXG5cdFx0dXkgPSAoeTEgLSBjeTEpIC8gcnksXG5cdFx0dnggPSAoLXgxIC0gY3gxKSAvIHJ4LFxuXHRcdHZ5ID0gKC15MSAtIGN5MSkgLyByeSxcblx0XHR0ZW1wID0gdXggKiB1eCArIHV5ICogdXksXG5cdFx0YW5nbGVTdGFydCA9ICgodXkgPCAwKSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModXggLyBfc3FydCh0ZW1wKSksXG5cdFx0YW5nbGVFeHRlbnQgPSAoKHV4ICogdnkgLSB1eSAqIHZ4IDwgMCkgPyAtMSA6IDEpICogTWF0aC5hY29zKCh1eCAqIHZ4ICsgdXkgKiB2eSkgLyBfc3FydCh0ZW1wICogKHZ4ICogdnggKyB2eSAqIHZ5KSkpO1xuXHRpc05hTihhbmdsZUV4dGVudCkgJiYgKGFuZ2xlRXh0ZW50ID0gUEkpOyAvL3JhcmUgZWRnZSBjYXNlLiBNYXRoLmNvcygtMSkgaXMgTmFOLlxuXHRpZiAoIXN3ZWVwRmxhZyAmJiBhbmdsZUV4dGVudCA+IDApIHtcblx0XHRhbmdsZUV4dGVudCAtPSBUV09QSTtcblx0fSBlbHNlIGlmIChzd2VlcEZsYWcgJiYgYW5nbGVFeHRlbnQgPCAwKSB7XG5cdFx0YW5nbGVFeHRlbnQgKz0gVFdPUEk7XG5cdH1cblx0YW5nbGVTdGFydCAlPSBUV09QSTtcblx0YW5nbGVFeHRlbnQgJT0gVFdPUEk7XG5cdGxldCBzZWdtZW50cyA9IE1hdGguY2VpbChfYWJzKGFuZ2xlRXh0ZW50KSAvIChUV09QSSAvIDQpKSxcblx0XHRyYXdQYXRoID0gW10sXG5cdFx0YW5nbGVJbmNyZW1lbnQgPSBhbmdsZUV4dGVudCAvIHNlZ21lbnRzLFxuXHRcdGNvbnRyb2xMZW5ndGggPSA0IC8gMyAqIF9zaW4oYW5nbGVJbmNyZW1lbnQgLyAyKSAvICgxICsgX2NvcyhhbmdsZUluY3JlbWVudCAvIDIpKSxcblx0XHRtYSA9IGNvc0FuZ2xlICogcngsXG5cdFx0bWIgPSBzaW5BbmdsZSAqIHJ4LFxuXHRcdG1jID0gc2luQW5nbGUgKiAtcnksXG5cdFx0bWQgPSBjb3NBbmdsZSAqIHJ5LFxuXHRcdGk7XG5cdGZvciAoaSA9IDA7IGkgPCBzZWdtZW50czsgaSsrKSB7XG5cdFx0YW5nbGUgPSBhbmdsZVN0YXJ0ICsgaSAqIGFuZ2xlSW5jcmVtZW50O1xuXHRcdHgxID0gX2NvcyhhbmdsZSk7XG5cdFx0eTEgPSBfc2luKGFuZ2xlKTtcblx0XHR1eCA9IF9jb3MoYW5nbGUgKz0gYW5nbGVJbmNyZW1lbnQpO1xuXHRcdHV5ID0gX3NpbihhbmdsZSk7XG5cdFx0cmF3UGF0aC5wdXNoKHgxIC0gY29udHJvbExlbmd0aCAqIHkxLCB5MSArIGNvbnRyb2xMZW5ndGggKiB4MSwgdXggKyBjb250cm9sTGVuZ3RoICogdXksIHV5IC0gY29udHJvbExlbmd0aCAqIHV4LCB1eCwgdXkpO1xuXHR9XG5cdC8vbm93IHRyYW5zZm9ybSBhY2NvcmRpbmcgdG8gdGhlIGFjdHVhbCBzaXplIG9mIHRoZSBlbGxpcHNlL2FyYyAodGhlIGJlemllcnMgd2VyZSBub3JhbWxpemVkLCBiZXR3ZWVuIDAgYW5kIDEgb24gYSBjaXJjbGUpLlxuXHRmb3IgKGkgPSAwOyBpIDwgcmF3UGF0aC5sZW5ndGg7IGkrPTIpIHtcblx0XHR4MSA9IHJhd1BhdGhbaV07XG5cdFx0eTEgPSByYXdQYXRoW2krMV07XG5cdFx0cmF3UGF0aFtpXSA9IHgxICogbWEgKyB5MSAqIG1jICsgY3g7XG5cdFx0cmF3UGF0aFtpKzFdID0geDEgKiBtYiArIHkxICogbWQgKyBjeTtcblx0fVxuXHRyYXdQYXRoW2ktMl0gPSB4OyAvL2Fsd2F5cyBzZXQgdGhlIGVuZCB0byBleGFjdGx5IHdoZXJlIGl0J3Mgc3VwcG9zZWQgdG8gYmVcblx0cmF3UGF0aFtpLTFdID0geTtcblx0cmV0dXJuIHJhd1BhdGg7XG59XG5cbi8vU3BpdHMgYmFjayBhIFJhd1BhdGggd2l0aCBhYnNvbHV0ZSBjb29yZGluYXRlcy4gRWFjaCBzZWdtZW50IHN0YXJ0cyB3aXRoIGEgXCJtb3ZlVG9cIiBjb21tYW5kICh4IGNvb3JkaW5hdGUsIHRoZW4geSkgYW5kIHRoZW4gMiBjb250cm9sIHBvaW50cyAoeCwgeSwgeCwgeSksIHRoZW4gYW5jaG9yLiBUaGUgZ29hbCBpcyB0byBtaW5pbWl6ZSBtZW1vcnkgYW5kIG1heGltaXplIHNwZWVkLlxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvUmF3UGF0aChkKSB7XG5cdGxldCBhID0gKGQgKyBcIlwiKS5yZXBsYWNlKF9zY2llbnRpZmljLCBtID0+IHsgbGV0IG4gPSArbTsgcmV0dXJuIChuIDwgMC4wMDAxICYmIG4gPiAtMC4wMDAxKSA/IDAgOiBuOyB9KS5tYXRjaChfc3ZnUGF0aEV4cCkgfHwgW10sIC8vc29tZSBhdXRob3JpbmcgcHJvZ3JhbXMgc3BpdCBvdXQgdmVyeSBzbWFsbCBudW1iZXJzIGluIHNjaWVudGlmaWMgbm90YXRpb24gbGlrZSBcIjFlLTVcIiwgc28gbWFrZSBzdXJlIHdlIHJvdW5kIHRoYXQgZG93biB0byAwIGZpcnN0LlxuXHRcdHBhdGggPSBbXSxcblx0XHRyZWxhdGl2ZVggPSAwLFxuXHRcdHJlbGF0aXZlWSA9IDAsXG5cdFx0dHdvVGhpcmRzID0gMiAvIDMsXG5cdFx0ZWxlbWVudHMgPSBhLmxlbmd0aCxcblx0XHRwb2ludHMgPSAwLFxuXHRcdGVycm9yTWVzc2FnZSA9IFwiRVJST1I6IG1hbGZvcm1lZCBwYXRoOiBcIiArIGQsXG5cdFx0aSwgaiwgeCwgeSwgY29tbWFuZCwgaXNSZWxhdGl2ZSwgc2VnbWVudCwgc3RhcnRYLCBzdGFydFksIGRpZlgsIGRpZlksIGJlemllcnMsIHByZXZDb21tYW5kLCBmbGFnMSwgZmxhZzIsXG5cdFx0bGluZSA9IGZ1bmN0aW9uKHN4LCBzeSwgZXgsIGV5KSB7XG5cdFx0XHRkaWZYID0gKGV4IC0gc3gpIC8gMztcblx0XHRcdGRpZlkgPSAoZXkgLSBzeSkgLyAzO1xuXHRcdFx0c2VnbWVudC5wdXNoKHN4ICsgZGlmWCwgc3kgKyBkaWZZLCBleCAtIGRpZlgsIGV5IC0gZGlmWSwgZXgsIGV5KTtcblx0XHR9O1xuXHRpZiAoIWQgfHwgIWlzTmFOKGFbMF0pIHx8IGlzTmFOKGFbMV0pKSB7XG5cdFx0Y29uc29sZS5sb2coZXJyb3JNZXNzYWdlKTtcblx0XHRyZXR1cm4gcGF0aDtcblx0fVxuXHRmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHM7IGkrKykge1xuXHRcdHByZXZDb21tYW5kID0gY29tbWFuZDtcblx0XHRpZiAoaXNOYU4oYVtpXSkpIHtcblx0XHRcdGNvbW1hbmQgPSBhW2ldLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRpc1JlbGF0aXZlID0gKGNvbW1hbmQgIT09IGFbaV0pOyAvL2xvd2VyIGNhc2UgbWVhbnMgcmVsYXRpdmVcblx0XHR9IGVsc2UgeyAvL2NvbW1hbmRzIGxpa2UgXCJDXCIgY2FuIGJlIHN0cnVuZyB0b2dldGhlciB3aXRob3V0IGFueSBuZXcgY29tbWFuZCBjaGFyYWN0ZXJzIGJldHdlZW4uXG5cdFx0XHRpLS07XG5cdFx0fVxuXHRcdHggPSArYVtpICsgMV07XG5cdFx0eSA9ICthW2kgKyAyXTtcblx0XHRpZiAoaXNSZWxhdGl2ZSkge1xuXHRcdFx0eCArPSByZWxhdGl2ZVg7XG5cdFx0XHR5ICs9IHJlbGF0aXZlWTtcblx0XHR9XG5cdFx0aWYgKCFpKSB7XG5cdFx0XHRzdGFydFggPSB4O1xuXHRcdFx0c3RhcnRZID0geTtcblx0XHR9XG5cblx0XHQvLyBcIk1cIiAobW92ZSlcblx0XHRpZiAoY29tbWFuZCA9PT0gXCJNXCIpIHtcblx0XHRcdGlmIChzZWdtZW50KSB7XG5cdFx0XHRcdGlmIChzZWdtZW50Lmxlbmd0aCA8IDgpIHsgLy9pZiB0aGUgcGF0aCBkYXRhIHdhcyBmdW5reSBhbmQganVzdCBoYWQgYSBNIHdpdGggbm8gYWN0dWFsIGRyYXdpbmcgYW55d2hlcmUsIHNraXAgaXQuXG5cdFx0XHRcdFx0cGF0aC5sZW5ndGggLT0gMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwb2ludHMgKz0gc2VnbWVudC5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlbGF0aXZlWCA9IHN0YXJ0WCA9IHg7XG5cdFx0XHRyZWxhdGl2ZVkgPSBzdGFydFkgPSB5O1xuXHRcdFx0c2VnbWVudCA9IFt4LCB5XTtcblx0XHRcdHBhdGgucHVzaChzZWdtZW50KTtcblx0XHRcdGkgKz0gMjtcblx0XHRcdGNvbW1hbmQgPSBcIkxcIjsgLy9hbiBcIk1cIiB3aXRoIG1vcmUgdGhhbiAyIHZhbHVlcyBnZXRzIGludGVycHJldGVkIGFzIFwibGluZVRvXCIgY29tbWFuZHMgKFwiTFwiKS5cblxuXHRcdC8vIFwiQ1wiIChjdWJpYyBiZXppZXIpXG5cdFx0fSBlbHNlIGlmIChjb21tYW5kID09PSBcIkNcIikge1xuXHRcdFx0aWYgKCFzZWdtZW50KSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBbMCwgMF07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWlzUmVsYXRpdmUpIHtcblx0XHRcdFx0cmVsYXRpdmVYID0gcmVsYXRpdmVZID0gMDtcblx0XHRcdH1cblx0XHRcdC8vbm90ZTogXCIqMVwiIGlzIGp1c3QgYSBmYXN0L3Nob3J0IHdheSB0byBjYXN0IHRoZSB2YWx1ZSBhcyBhIE51bWJlci4gV0FBQVkgZmFzdGVyIGluIENocm9tZSwgc2xpZ2h0bHkgc2xvd2VyIGluIEZpcmVmb3guXG5cdFx0XHRzZWdtZW50LnB1c2goeCxcdHksIHJlbGF0aXZlWCArIGFbaSArIDNdICogMSwgcmVsYXRpdmVZICsgYVtpICsgNF0gKiAxLCAocmVsYXRpdmVYICs9IGFbaSArIDVdICogMSksXHQocmVsYXRpdmVZICs9IGFbaSArIDZdICogMSkpO1xuXHRcdFx0aSArPSA2O1xuXG5cdFx0Ly8gXCJTXCIgKGNvbnRpbnVhdGlvbiBvZiBjdWJpYyBiZXppZXIpXG5cdFx0fSBlbHNlIGlmIChjb21tYW5kID09PSBcIlNcIikge1xuXHRcdFx0ZGlmWCA9IHJlbGF0aXZlWDtcblx0XHRcdGRpZlkgPSByZWxhdGl2ZVk7XG5cdFx0XHRpZiAocHJldkNvbW1hbmQgPT09IFwiQ1wiIHx8IHByZXZDb21tYW5kID09PSBcIlNcIikge1xuXHRcdFx0XHRkaWZYICs9IHJlbGF0aXZlWCAtIHNlZ21lbnRbc2VnbWVudC5sZW5ndGggLSA0XTtcblx0XHRcdFx0ZGlmWSArPSByZWxhdGl2ZVkgLSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gM107XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWlzUmVsYXRpdmUpIHtcblx0XHRcdFx0cmVsYXRpdmVYID0gcmVsYXRpdmVZID0gMDtcblx0XHRcdH1cblx0XHRcdHNlZ21lbnQucHVzaChkaWZYLCBkaWZZLCB4LFx0eSwgKHJlbGF0aXZlWCArPSBhW2kgKyAzXSAqIDEpLCAocmVsYXRpdmVZICs9IGFbaSArIDRdICogMSkpO1xuXHRcdFx0aSArPSA0O1xuXG5cdFx0Ly8gXCJRXCIgKHF1YWRyYXRpYyBiZXppZXIpXG5cdFx0fSBlbHNlIGlmIChjb21tYW5kID09PSBcIlFcIikge1xuXHRcdFx0ZGlmWCA9IHJlbGF0aXZlWCArICh4IC0gcmVsYXRpdmVYKSAqIHR3b1RoaXJkcztcblx0XHRcdGRpZlkgPSByZWxhdGl2ZVkgKyAoeSAtIHJlbGF0aXZlWSkgKiB0d29UaGlyZHM7XG5cdFx0XHRpZiAoIWlzUmVsYXRpdmUpIHtcblx0XHRcdFx0cmVsYXRpdmVYID0gcmVsYXRpdmVZID0gMDtcblx0XHRcdH1cblx0XHRcdHJlbGF0aXZlWCArPSBhW2kgKyAzXSAqIDE7XG5cdFx0XHRyZWxhdGl2ZVkgKz0gYVtpICsgNF0gKiAxO1xuXHRcdFx0c2VnbWVudC5wdXNoKGRpZlgsIGRpZlksIHJlbGF0aXZlWCArICh4IC0gcmVsYXRpdmVYKSAqIHR3b1RoaXJkcywgcmVsYXRpdmVZICsgKHkgLSByZWxhdGl2ZVkpICogdHdvVGhpcmRzLCByZWxhdGl2ZVgsIHJlbGF0aXZlWSk7XG5cdFx0XHRpICs9IDQ7XG5cblx0XHQvLyBcIlRcIiAoY29udGludWF0aW9uIG9mIHF1YWRyYXRpYyBiZXppZXIpXG5cdFx0fSBlbHNlIGlmIChjb21tYW5kID09PSBcIlRcIikge1xuXHRcdFx0ZGlmWCA9IHJlbGF0aXZlWCAtIHNlZ21lbnRbc2VnbWVudC5sZW5ndGggLSA0XTtcblx0XHRcdGRpZlkgPSByZWxhdGl2ZVkgLSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gM107XG5cdFx0XHRzZWdtZW50LnB1c2gocmVsYXRpdmVYICsgZGlmWCwgcmVsYXRpdmVZICsgZGlmWSwgeCArICgocmVsYXRpdmVYICsgZGlmWCAqIDEuNSkgLSB4KSAqIHR3b1RoaXJkcywgeSArICgocmVsYXRpdmVZICsgZGlmWSAqIDEuNSkgLSB5KSAqIHR3b1RoaXJkcywgKHJlbGF0aXZlWCA9IHgpLCAocmVsYXRpdmVZID0geSkpO1xuXHRcdFx0aSArPSAyO1xuXG5cdFx0Ly8gXCJIXCIgKGhvcml6b250YWwgbGluZSlcblx0XHR9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiSFwiKSB7XG5cdFx0XHRsaW5lKHJlbGF0aXZlWCwgcmVsYXRpdmVZLCAocmVsYXRpdmVYID0geCksIHJlbGF0aXZlWSk7XG5cdFx0XHRpICs9IDE7XG5cblx0XHQvLyBcIlZcIiAodmVydGljYWwgbGluZSlcblx0XHR9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiVlwiKSB7XG5cdFx0XHQvL2FkanVzdCB2YWx1ZXMgYmVjYXVzZSB0aGUgZmlyc3QgKGFuZCBvbmx5IG9uZSkgaXNuJ3QgeCBpbiB0aGlzIGNhc2UsIGl0J3MgeS5cblx0XHRcdGxpbmUocmVsYXRpdmVYLCByZWxhdGl2ZVksIHJlbGF0aXZlWCwgKHJlbGF0aXZlWSA9IHggKyAoaXNSZWxhdGl2ZSA/IHJlbGF0aXZlWSAtIHJlbGF0aXZlWCA6IDApKSk7XG5cdFx0XHRpICs9IDE7XG5cblx0XHQvLyBcIkxcIiAobGluZSkgb3IgXCJaXCIgKGNsb3NlKVxuXHRcdH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJMXCIgfHwgY29tbWFuZCA9PT0gXCJaXCIpIHtcblx0XHRcdGlmIChjb21tYW5kID09PSBcIlpcIikge1xuXHRcdFx0XHR4ID0gc3RhcnRYO1xuXHRcdFx0XHR5ID0gc3RhcnRZO1xuXHRcdFx0XHRzZWdtZW50LmNsb3NlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29tbWFuZCA9PT0gXCJMXCIgfHwgX2FicyhyZWxhdGl2ZVggLSB4KSA+IDAuNSB8fCBfYWJzKHJlbGF0aXZlWSAtIHkpID4gMC41KSB7XG5cdFx0XHRcdGxpbmUocmVsYXRpdmVYLCByZWxhdGl2ZVksIHgsIHkpO1xuXHRcdFx0XHRpZiAoY29tbWFuZCA9PT0gXCJMXCIpIHtcblx0XHRcdFx0XHRpICs9IDI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlbGF0aXZlWCA9IHg7XG5cdFx0XHRyZWxhdGl2ZVkgPSB5O1xuXG5cdFx0Ly8gXCJBXCIgKGFyYylcblx0XHR9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiQVwiKSB7XG5cdFx0XHRmbGFnMSA9IGFbaSs0XTtcblx0XHRcdGZsYWcyID0gYVtpKzVdO1xuXHRcdFx0ZGlmWCA9IGFbaSs2XTtcblx0XHRcdGRpZlkgPSBhW2krN107XG5cdFx0XHRqID0gNztcblx0XHRcdGlmIChmbGFnMS5sZW5ndGggPiAxKSB7IC8vIGZvciBjYXNlcyB3aGVuIHRoZSBmbGFncyBhcmUgbWVyZ2VkLCBsaWtlIFwiYTggOCAwIDAxOCA4XCIgKHRoZSAwIGFuZCAxIGZsYWdzIGFyZSBXSVRIIHRoZSB4IHZhbHVlIG9mIDgsIGJ1dCBpdCBjb3VsZCBhbHNvIGJlIFwiYTggOCAwIDAxLTggOFwiIHNvIGl0IG1heSBpbmNsdWRlIHggb3Igbm90KVxuXHRcdFx0XHRpZiAoZmxhZzEubGVuZ3RoIDwgMykge1xuXHRcdFx0XHRcdGRpZlkgPSBkaWZYO1xuXHRcdFx0XHRcdGRpZlggPSBmbGFnMjtcblx0XHRcdFx0XHRqLS07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGlmWSA9IGZsYWcyO1xuXHRcdFx0XHRcdGRpZlggPSBmbGFnMS5zdWJzdHIoMik7XG5cdFx0XHRcdFx0ai09Mjtcblx0XHRcdFx0fVxuXHRcdFx0XHRmbGFnMiA9IGZsYWcxLmNoYXJBdCgxKTtcblx0XHRcdFx0ZmxhZzEgPSBmbGFnMS5jaGFyQXQoMCk7XG5cdFx0XHR9XG5cdFx0XHRiZXppZXJzID0gYXJjVG9TZWdtZW50KHJlbGF0aXZlWCwgcmVsYXRpdmVZLCArYVtpKzFdLCArYVtpKzJdLCArYVtpKzNdLCArZmxhZzEsICtmbGFnMiwgKGlzUmVsYXRpdmUgPyByZWxhdGl2ZVggOiAwKSArIGRpZlgqMSwgKGlzUmVsYXRpdmUgPyByZWxhdGl2ZVkgOiAwKSArIGRpZlkqMSk7XG5cdFx0XHRpICs9IGo7XG5cdFx0XHRpZiAoYmV6aWVycykge1xuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgYmV6aWVycy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdHNlZ21lbnQucHVzaChiZXppZXJzW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVsYXRpdmVYID0gc2VnbWVudFtzZWdtZW50Lmxlbmd0aC0yXTtcblx0XHRcdHJlbGF0aXZlWSA9IHNlZ21lbnRbc2VnbWVudC5sZW5ndGgtMV07XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS5sb2coZXJyb3JNZXNzYWdlKTtcblx0XHR9XG5cdH1cblx0aSA9IHNlZ21lbnQubGVuZ3RoO1xuXHRpZiAoaSA8IDYpIHsgLy9pbiBjYXNlIHRoZXJlJ3Mgb2RkIFNWRyBsaWtlIGEgTTAsMCBjb21tYW5kIGF0IHRoZSB2ZXJ5IGVuZC5cblx0XHRwYXRoLnBvcCgpO1xuXHRcdGkgPSAwO1xuXHR9IGVsc2UgaWYgKHNlZ21lbnRbMF0gPT09IHNlZ21lbnRbaS0yXSAmJiBzZWdtZW50WzFdID09PSBzZWdtZW50W2ktMV0pIHtcblx0XHRzZWdtZW50LmNsb3NlZCA9IHRydWU7XG5cdH1cblx0cGF0aC50b3RhbFBvaW50cyA9IHBvaW50cyArIGk7XG5cdHJldHVybiBwYXRoO1xufVxuXG4vL3BvcHVsYXRlcyB0aGUgcG9pbnRzIGFycmF5IGluIGFsdGVybmF0aW5nIHgveSB2YWx1ZXMgKGxpa2UgW3gsIHksIHgsIHkuLi5dIGluc3RlYWQgb2YgaW5kaXZpZHVhbCBwb2ludCBvYmplY3RzIFt7eCwgeX0sIHt4LCB5fS4uLl0gdG8gY29uc2VydmUgbWVtb3J5IGFuZCBzdGF5IGluIGxpbmUgd2l0aCBob3cgd2UncmUgaGFuZGxpbmcgc2VnbWVudCBhcnJheXNcbmV4cG9ydCBmdW5jdGlvbiBiZXppZXJUb1BvaW50cyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIHRocmVzaG9sZCwgcG9pbnRzLCBpbmRleCkge1xuXHRsZXQgeDEyID0gKHgxICsgeDIpIC8gMixcblx0XHR5MTIgPSAoeTEgKyB5MikgLyAyLFxuXHRcdHgyMyA9ICh4MiArIHgzKSAvIDIsXG5cdFx0eTIzID0gKHkyICsgeTMpIC8gMixcblx0XHR4MzQgPSAoeDMgKyB4NCkgLyAyLFxuXHRcdHkzNCA9ICh5MyArIHk0KSAvIDIsXG5cdFx0eDEyMyA9ICh4MTIgKyB4MjMpIC8gMixcblx0XHR5MTIzID0gKHkxMiArIHkyMykgLyAyLFxuXHRcdHgyMzQgPSAoeDIzICsgeDM0KSAvIDIsXG5cdFx0eTIzNCA9ICh5MjMgKyB5MzQpIC8gMixcblx0XHR4MTIzNCA9ICh4MTIzICsgeDIzNCkgLyAyLFxuXHRcdHkxMjM0ID0gKHkxMjMgKyB5MjM0KSAvIDIsXG5cdFx0ZHggPSB4NCAtIHgxLFxuXHRcdGR5ID0geTQgLSB5MSxcblx0XHRkMiA9IF9hYnMoKHgyIC0geDQpICogZHkgLSAoeTIgLSB5NCkgKiBkeCksXG5cdFx0ZDMgPSBfYWJzKCh4MyAtIHg0KSAqIGR5IC0gKHkzIC0geTQpICogZHgpLFxuXHRcdGxlbmd0aDtcblx0aWYgKCFwb2ludHMpIHtcblx0XHRwb2ludHMgPSBbeDEsIHkxLCB4NCwgeTRdO1xuXHRcdGluZGV4ID0gMjtcblx0fVxuXHRwb2ludHMuc3BsaWNlKGluZGV4IHx8IHBvaW50cy5sZW5ndGggLSAyLCAwLCB4MTIzNCwgeTEyMzQpO1xuXHRpZiAoKGQyICsgZDMpICogKGQyICsgZDMpID4gdGhyZXNob2xkICogKGR4ICogZHggKyBkeSAqIGR5KSkge1xuXHRcdGxlbmd0aCA9IHBvaW50cy5sZW5ndGg7XG5cdFx0YmV6aWVyVG9Qb2ludHMoeDEsIHkxLCB4MTIsIHkxMiwgeDEyMywgeTEyMywgeDEyMzQsIHkxMjM0LCB0aHJlc2hvbGQsIHBvaW50cywgaW5kZXgpO1xuXHRcdGJlemllclRvUG9pbnRzKHgxMjM0LCB5MTIzNCwgeDIzNCwgeTIzNCwgeDM0LCB5MzQsIHg0LCB5NCwgdGhyZXNob2xkLCBwb2ludHMsIGluZGV4ICsgMiArIChwb2ludHMubGVuZ3RoIC0gbGVuZ3RoKSk7XG5cdH1cblx0cmV0dXJuIHBvaW50cztcbn1cblxuLypcbmZ1bmN0aW9uIGdldEFuZ2xlQmV0d2VlblBvaW50cyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyKSB7IC8vYW5nbGUgYmV0d2VlbiAzIHBvaW50cyBpbiByYWRpYW5zXG5cdHZhciBkeDEgPSB4MSAtIHgwLFxuXHRcdGR5MSA9IHkxIC0geTAsXG5cdFx0ZHgyID0geDIgLSB4MSxcblx0XHRkeTIgPSB5MiAtIHkxLFxuXHRcdGR4MyA9IHgyIC0geDAsXG5cdFx0ZHkzID0geTIgLSB5MCxcblx0XHRhID0gZHgxICogZHgxICsgZHkxICogZHkxLFxuXHRcdGIgPSBkeDIgKiBkeDIgKyBkeTIgKiBkeTIsXG5cdFx0YyA9IGR4MyAqIGR4MyArIGR5MyAqIGR5Mztcblx0cmV0dXJuIE1hdGguYWNvcyggKGEgKyBiIC0gYykgLyBfc3FydCg0ICogYSAqIGIpICk7XG59LFxuKi9cblxuLy9wb2ludHNUb1NlZ21lbnQoKSBkb2Vzbid0IGhhbmRsZSBmbGF0IGNvb3JkaW5hdGVzICh3aGVyZSB5IGlzIGFsd2F5cyAwKSB0aGUgd2F5IHdlIG5lZWQgKHRoZSByZXN1bHRpbmcgY29udHJvbCBwb2ludHMgYXJlIGFsd2F5cyByaWdodCBvbiB0b3Agb2YgdGhlIGFuY2hvcnMpLCBzbyB0aGlzIGZ1bmN0aW9uIGJhc2ljYWxseSBtYWtlcyB0aGUgY29udHJvbCBwb2ludHMgZ28gZGlyZWN0bHkgdXAgYW5kIGRvd24sIHZhcnlpbmcgaW4gbGVuZ3RoIGJhc2VkIG9uIHRoZSBjdXJ2aW5lc3MgKG1vcmUgY3VydnksIGZ1cnRoZXIgY29udHJvbCBwb2ludHMpXG5leHBvcnQgZnVuY3Rpb24gZmxhdFBvaW50c1RvU2VnbWVudChwb2ludHMsIGN1cnZpbmVzcz0xKSB7XG5cdGxldCB4ID0gcG9pbnRzWzBdLFxuXHRcdHkgPSAwLFxuXHRcdHNlZ21lbnQgPSBbeCwgeV0sXG5cdFx0aSA9IDI7XG5cdGZvciAoOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSs9Mikge1xuXHRcdHNlZ21lbnQucHVzaChcblx0XHRcdHgsXG5cdFx0XHR5LFxuXHRcdFx0cG9pbnRzW2ldLFxuXHRcdFx0KHkgPSAocG9pbnRzW2ldIC0geCkgKiBjdXJ2aW5lc3MgLyAyKSxcblx0XHRcdCh4ID0gcG9pbnRzW2ldKSxcblx0XHRcdC15XG5cdFx0KTtcblx0fVxuXHRyZXR1cm4gc2VnbWVudDtcbn1cblxuLy9wb2ludHMgaXMgYW4gYXJyYXkgb2YgeC95IHBvaW50cywgbGlrZSBbeCwgeSwgeCwgeSwgeCwgeV1cbmV4cG9ydCBmdW5jdGlvbiBwb2ludHNUb1NlZ21lbnQocG9pbnRzLCBjdXJ2aW5lc3MsIGNvcm5lclRocmVzaG9sZCkge1xuXHQvL3BvaW50cyA9IHNpbXBsaWZ5UG9pbnRzKHBvaW50cywgdG9sZXJhbmNlKTtcblx0X2Ficyhwb2ludHNbMF0gLSBwb2ludHNbMl0pIDwgMWUtNCAmJiBfYWJzKHBvaW50c1sxXSAtIHBvaW50c1szXSkgPCAxZS00ICYmIChwb2ludHMgPSBwb2ludHMuc2xpY2UoMikpOyAvLyBpZiB0aGUgZmlyc3QgdHdvIHBvaW50cyBhcmUgc3VwZXIgY2xvc2UsIGR1bXAgdGhlIGZpcnN0IG9uZS5cblx0bGV0IGwgPSBwb2ludHMubGVuZ3RoLTIsXG5cdFx0eCA9ICtwb2ludHNbMF0sXG5cdFx0eSA9ICtwb2ludHNbMV0sXG5cdFx0bmV4dFggPSArcG9pbnRzWzJdLFxuXHRcdG5leHRZID0gK3BvaW50c1szXSxcblx0XHRzZWdtZW50ID0gW3gsIHksIHgsIHldLFxuXHRcdGR4MiA9IG5leHRYIC0geCxcblx0XHRkeTIgPSBuZXh0WSAtIHksXG5cdFx0Y2xvc2VkID0gTWF0aC5hYnMocG9pbnRzW2xdIC0geCkgPCAwLjAwMSAmJiBNYXRoLmFicyhwb2ludHNbbCsxXSAtIHkpIDwgMC4wMDEsXG5cdFx0cHJldlgsIHByZXZZLCBhbmdsZSwgc2xvcGUsIGksIGR4MSwgZHgzLCBkeTEsIGR5MywgZDEsIGQyLCBhLCBiLCBjO1xuXHRpZiAoaXNOYU4oY29ybmVyVGhyZXNob2xkKSkge1xuXHRcdGNvcm5lclRocmVzaG9sZCA9IE1hdGguUEkgLyAxMDtcblx0fVxuXHRpZiAoY2xvc2VkKSB7IC8vIGlmIHRoZSBzdGFydCBhbmQgZW5kIHBvaW50cyBhcmUgYmFzaWNhbGx5IG9uIHRvcCBvZiBlYWNoIG90aGVyLCBjbG9zZSB0aGUgc2VnbWVudCBieSBhZGRpbmcgdGhlIDJuZCBwb2ludCB0byB0aGUgZW5kLCBhbmQgdGhlIDJuZC10by1sYXN0IHBvaW50IHRvIHRoZSBiZWdpbm5pbmcgKHdlJ2xsIHJlbW92ZSB0aGVtIGF0IHRoZSBlbmQsIGJ1dCB0aGlzIGFsbG93cyB0aGUgY3VydmF0dXJlIHRvIGxvb2sgcGVyZmVjdClcblx0XHRwb2ludHMucHVzaChuZXh0WCwgbmV4dFkpO1xuXHRcdG5leHRYID0geDtcblx0XHRuZXh0WSA9IHk7XG5cdFx0eCA9IHBvaW50c1tsLTJdO1xuXHRcdHkgPSBwb2ludHNbbC0xXTtcblx0XHRwb2ludHMudW5zaGlmdCh4LCB5KTtcblx0XHRsKz00O1xuXHR9XG5cdGN1cnZpbmVzcyA9IChjdXJ2aW5lc3MgfHwgY3VydmluZXNzID09PSAwKSA/ICtjdXJ2aW5lc3MgOiAxO1xuXHRmb3IgKGkgPSAyOyBpIDwgbDsgaSs9Mikge1xuXHRcdHByZXZYID0geDtcblx0XHRwcmV2WSA9IHk7XG5cdFx0eCA9IG5leHRYO1xuXHRcdHkgPSBuZXh0WTtcblx0XHRuZXh0WCA9ICtwb2ludHNbaSsyXTtcblx0XHRuZXh0WSA9ICtwb2ludHNbaSszXTtcblx0XHRpZiAoeCA9PT0gbmV4dFggJiYgeSA9PT0gbmV4dFkpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRkeDEgPSBkeDI7XG5cdFx0ZHkxID0gZHkyO1xuXHRcdGR4MiA9IG5leHRYIC0geDtcblx0XHRkeTIgPSBuZXh0WSAtIHk7XG5cdFx0ZHgzID0gbmV4dFggLSBwcmV2WDtcblx0XHRkeTMgPSBuZXh0WSAtIHByZXZZO1xuXHRcdGEgPSBkeDEgKiBkeDEgKyBkeTEgKiBkeTE7XG5cdFx0YiA9IGR4MiAqIGR4MiArIGR5MiAqIGR5Mjtcblx0XHRjID0gZHgzICogZHgzICsgZHkzICogZHkzO1xuXHRcdGFuZ2xlID0gTWF0aC5hY29zKCAoYSArIGIgLSBjKSAvIF9zcXJ0KDQgKiBhICogYikgKTsgLy9hbmdsZSBiZXR3ZWVuIHRoZSAzIHBvaW50c1xuXHRcdGQyID0gKGFuZ2xlIC8gTWF0aC5QSSkgKiBjdXJ2aW5lc3M7IC8vdGVtcG9yYXJ5IHByZWNhbGN1bGF0aW9uIGZvciBzcGVlZCAocmV1c2luZyBkMiB2YXJpYWJsZSlcblx0XHRkMSA9IF9zcXJ0KGEpICogZDI7IC8vdGhlIHRpZ2h0ZXIgdGhlIGFuZ2xlLCB0aGUgc2hvcnRlciB3ZSBtYWtlIHRoZSBoYW5kbGVzIGluIHByb3BvcnRpb24uXG5cdFx0ZDIgKj0gX3NxcnQoYik7XG5cdFx0aWYgKHggIT09IHByZXZYIHx8IHkgIT09IHByZXZZKSB7XG5cdFx0XHRpZiAoYW5nbGUgPiBjb3JuZXJUaHJlc2hvbGQpIHtcblx0XHRcdFx0c2xvcGUgPSBfYXRhbjIoZHkzLCBkeDMpO1xuXHRcdFx0XHRzZWdtZW50LnB1c2goXG5cdFx0XHRcdFx0X3JvdW5kKHggLSBfY29zKHNsb3BlKSAqIGQxKSwgICAvL2ZpcnN0IGNvbnRyb2wgcG9pbnRcblx0XHRcdFx0XHRfcm91bmQoeSAtIF9zaW4oc2xvcGUpICogZDEpLFxuXHRcdFx0XHRcdF9yb3VuZCh4KSwgICAgICAgICAgICAgICAgICAgICAgLy9hbmNob3Jcblx0XHRcdFx0XHRfcm91bmQoeSksXG5cdFx0XHRcdFx0X3JvdW5kKHggKyBfY29zKHNsb3BlKSAqIGQyKSwgICAvL3NlY29uZCBjb250cm9sIHBvaW50XG5cdFx0XHRcdFx0X3JvdW5kKHkgKyBfc2luKHNsb3BlKSAqIGQyKVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2xvcGUgPSBfYXRhbjIoZHkxLCBkeDEpO1xuXHRcdFx0XHRzZWdtZW50LnB1c2goXG5cdFx0XHRcdFx0X3JvdW5kKHggLSBfY29zKHNsb3BlKSAqIGQxKSwgICAvL2ZpcnN0IGNvbnRyb2wgcG9pbnRcblx0XHRcdFx0XHRfcm91bmQoeSAtIF9zaW4oc2xvcGUpICogZDEpKTtcblx0XHRcdFx0c2xvcGUgPSBfYXRhbjIoZHkyLCBkeDIpO1xuXHRcdFx0XHRzZWdtZW50LnB1c2goXG5cdFx0XHRcdFx0X3JvdW5kKHgpLCAgICAgICAgICAgICAgICAgICAgICAvL2FuY2hvclxuXHRcdFx0XHRcdF9yb3VuZCh5KSxcblx0XHRcdFx0XHRfcm91bmQoeCArIF9jb3Moc2xvcGUpICogZDIpLCAgIC8vc2Vjb25kIGNvbnRyb2wgcG9pbnRcblx0XHRcdFx0XHRfcm91bmQoeSArIF9zaW4oc2xvcGUpICogZDIpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHggIT09IG5leHRYIHx8IHkgIT09IG5leHRZIHx8IHNlZ21lbnQubGVuZ3RoIDwgNCA/IHNlZ21lbnQucHVzaChfcm91bmQobmV4dFgpLCBfcm91bmQobmV4dFkpLCBfcm91bmQobmV4dFgpLCBfcm91bmQobmV4dFkpKSA6IHNlZ21lbnQubGVuZ3RoIC09IDI7XG5cdGlmIChjbG9zZWQpIHtcblx0XHRzZWdtZW50LnNwbGljZSgwLCA2KTtcblx0XHRzZWdtZW50Lmxlbmd0aCA9IHNlZ21lbnQubGVuZ3RoIC0gNjtcblx0fVxuXHRyZXR1cm4gc2VnbWVudDtcbn1cblxuLy9yZXR1cm5zIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYW4geC95IGNvb3JkaW5hdGUgYW5kIGEgc2VnbWVudCBiZXR3ZWVuIHgxL3kxIGFuZCB4Mi95MlxuZnVuY3Rpb24gcG9pbnRUb1NlZ0Rpc3QoeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcblx0bGV0IGR4ID0geDIgLSB4MSxcblx0XHRkeSA9IHkyIC0geTEsXG5cdFx0dDtcblx0aWYgKGR4IHx8IGR5KSB7XG5cdFx0dCA9ICgoeCAtIHgxKSAqIGR4ICsgKHkgLSB5MSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXHRcdGlmICh0ID4gMSkge1xuXHRcdFx0eDEgPSB4Mjtcblx0XHRcdHkxID0geTI7XG5cdFx0fSBlbHNlIGlmICh0ID4gMCkge1xuXHRcdFx0eDEgKz0gZHggKiB0O1xuXHRcdFx0eTEgKz0gZHkgKiB0O1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gKHggLSB4MSkgKiogMiArICh5IC0geTEpICoqIDI7XG59XG5cbmZ1bmN0aW9uIHNpbXBsaWZ5U3RlcChwb2ludHMsIGZpcnN0LCBsYXN0LCB0b2xlcmFuY2UsIHNpbXBsaWZpZWQpIHtcblx0bGV0IG1heFNxRGlzdCA9IHRvbGVyYW5jZSxcblx0XHRmaXJzdFggPSBwb2ludHNbZmlyc3RdLFxuXHRcdGZpcnN0WSA9IHBvaW50c1tmaXJzdCsxXSxcblx0XHRsYXN0WCA9IHBvaW50c1tsYXN0XSxcblx0XHRsYXN0WSA9IHBvaW50c1tsYXN0KzFdLFxuXHRcdGluZGV4LCBpLCBkO1xuXHRmb3IgKGkgPSBmaXJzdCArIDI7IGkgPCBsYXN0OyBpICs9IDIpIHtcblx0XHRkID0gcG9pbnRUb1NlZ0Rpc3QocG9pbnRzW2ldLCBwb2ludHNbaSsxXSwgZmlyc3RYLCBmaXJzdFksIGxhc3RYLCBsYXN0WSk7XG5cdFx0aWYgKGQgPiBtYXhTcURpc3QpIHtcblx0XHRcdGluZGV4ID0gaTtcblx0XHRcdG1heFNxRGlzdCA9IGQ7XG5cdFx0fVxuXHR9XG5cdGlmIChtYXhTcURpc3QgPiB0b2xlcmFuY2UpIHtcblx0XHRpbmRleCAtIGZpcnN0ID4gMiAmJiBzaW1wbGlmeVN0ZXAocG9pbnRzLCBmaXJzdCwgaW5kZXgsIHRvbGVyYW5jZSwgc2ltcGxpZmllZCk7XG5cdFx0c2ltcGxpZmllZC5wdXNoKHBvaW50c1tpbmRleF0sIHBvaW50c1tpbmRleCsxXSk7XG5cdFx0bGFzdCAtIGluZGV4ID4gMiAmJiBzaW1wbGlmeVN0ZXAocG9pbnRzLCBpbmRleCwgbGFzdCwgdG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcblx0fVxufVxuXG4vL3BvaW50cyBpcyBhbiBhcnJheSBvZiB4L3kgdmFsdWVzIGxpa2UgW3gsIHksIHgsIHksIHgsIHldXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxpZnlQb2ludHMocG9pbnRzLCB0b2xlcmFuY2UpIHtcblx0bGV0IHByZXZYID0gcGFyc2VGbG9hdChwb2ludHNbMF0pLFxuXHRcdHByZXZZID0gcGFyc2VGbG9hdChwb2ludHNbMV0pLFxuXHRcdHRlbXAgPSBbcHJldlgsIHByZXZZXSxcblx0XHRsID0gcG9pbnRzLmxlbmd0aCAtIDIsXG5cdFx0aSwgeCwgeSwgZHgsIGR5LCByZXN1bHQsIGxhc3Q7XG5cdHRvbGVyYW5jZSA9ICh0b2xlcmFuY2UgfHwgMSkgKiogMjtcblx0Zm9yIChpID0gMjsgaSA8IGw7IGkgKz0gMikge1xuXHRcdHggPSBwYXJzZUZsb2F0KHBvaW50c1tpXSk7XG5cdFx0eSA9IHBhcnNlRmxvYXQocG9pbnRzW2krMV0pO1xuXHRcdGR4ID0gcHJldlggLSB4O1xuXHRcdGR5ID0gcHJldlkgLSB5O1xuXHRcdGlmIChkeCAqIGR4ICsgZHkgKiBkeSA+IHRvbGVyYW5jZSkge1xuXHRcdFx0dGVtcC5wdXNoKHgsIHkpO1xuXHRcdFx0cHJldlggPSB4O1xuXHRcdFx0cHJldlkgPSB5O1xuXHRcdH1cblx0fVxuXHR0ZW1wLnB1c2gocGFyc2VGbG9hdChwb2ludHNbbF0pLCBwYXJzZUZsb2F0KHBvaW50c1tsKzFdKSk7XG5cdGxhc3QgPSB0ZW1wLmxlbmd0aCAtIDI7XG5cdHJlc3VsdCA9IFt0ZW1wWzBdLCB0ZW1wWzFdXTtcblx0c2ltcGxpZnlTdGVwKHRlbXAsIDAsIGxhc3QsIHRvbGVyYW5jZSwgcmVzdWx0KTtcblx0cmVzdWx0LnB1c2godGVtcFtsYXN0XSwgdGVtcFtsYXN0KzFdKTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xvc2VzdFByb2dyZXNzT25CZXppZXIoaXRlcmF0aW9ucywgcHgsIHB5LCBzdGFydCwgZW5kLCBzbGljZXMsIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuXHRsZXQgaW5jID0gKGVuZCAtIHN0YXJ0KSAvIHNsaWNlcyxcblx0XHRiZXN0ID0gMCxcblx0XHR0ID0gc3RhcnQsXG5cdFx0eCwgeSwgZCwgZHgsIGR5LCBpbnY7XG5cdF9iZXN0RGlzdGFuY2UgPSBfbGFyZ2VOdW07XG5cdHdoaWxlICh0IDw9IGVuZCkge1xuXHRcdGludiA9IDEgLSB0O1xuXHRcdHggPSBpbnYgKiBpbnYgKiBpbnYgKiB4MCArIDMgKiBpbnYgKiBpbnYgKiB0ICogeDEgKyAzICogaW52ICogdCAqIHQgKiB4MiArIHQgKiB0ICogdCAqIHgzO1xuXHRcdHkgPSBpbnYgKiBpbnYgKiBpbnYgKiB5MCArIDMgKiBpbnYgKiBpbnYgKiB0ICogeTEgKyAzICogaW52ICogdCAqIHQgKiB5MiArIHQgKiB0ICogdCAqIHkzO1xuXHRcdGR4ID0geCAtIHB4O1xuXHRcdGR5ID0geSAtIHB5O1xuXHRcdGQgPSBkeCAqIGR4ICsgZHkgKiBkeTtcblx0XHRpZiAoZCA8IF9iZXN0RGlzdGFuY2UpIHtcblx0XHRcdF9iZXN0RGlzdGFuY2UgPSBkO1xuXHRcdFx0YmVzdCA9IHQ7XG5cdFx0fVxuXHRcdHQgKz0gaW5jO1xuXHR9XG5cdHJldHVybiAoaXRlcmF0aW9ucyA+IDEpID8gZ2V0Q2xvc2VzdFByb2dyZXNzT25CZXppZXIoaXRlcmF0aW9ucyAtIDEsIHB4LCBweSwgTWF0aC5tYXgoYmVzdCAtIGluYywgMCksIE1hdGgubWluKGJlc3QgKyBpbmMsIDEpLCBzbGljZXMsIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MykgOiBiZXN0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xvc2VzdERhdGEocmF3UGF0aCwgeCwgeSwgc2xpY2VzKSB7IC8vcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgY2xvc2VzdCBqLCBpLCBhbmQgdCAoaiBpcyB0aGUgc2VnbWVudCBpbmRleCwgaSBpcyB0aGUgaW5kZXggb2YgdGhlIHBvaW50IGluIHRoYXQgc2VnbWVudCwgYW5kIHQgaXMgdGhlIHRpbWUvcHJvZ3Jlc3MgYWxvbmcgdGhhdCBiZXppZXIpXG5cdGxldCBjbG9zZXN0ID0ge2o6MCwgaTowLCB0OjB9LFxuXHRcdGJlc3REaXN0YW5jZSA9IF9sYXJnZU51bSxcblx0XHRpLCBqLCB0LCBzZWdtZW50O1xuXHRmb3IgKGogPSAwOyBqIDwgcmF3UGF0aC5sZW5ndGg7IGorKykge1xuXHRcdHNlZ21lbnQgPSByYXdQYXRoW2pdO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdtZW50Lmxlbmd0aDsgaSs9Nikge1xuXHRcdFx0dCA9IGdldENsb3Nlc3RQcm9ncmVzc09uQmV6aWVyKDEsIHgsIHksIDAsIDEsIHNsaWNlcyB8fCAyMCwgc2VnbWVudFtpXSwgc2VnbWVudFtpKzFdLCBzZWdtZW50W2krMl0sIHNlZ21lbnRbaSszXSwgc2VnbWVudFtpKzRdLCBzZWdtZW50W2krNV0sIHNlZ21lbnRbaSs2XSwgc2VnbWVudFtpKzddKTtcblx0XHRcdGlmIChiZXN0RGlzdGFuY2UgPiBfYmVzdERpc3RhbmNlKSB7XG5cdFx0XHRcdGJlc3REaXN0YW5jZSA9IF9iZXN0RGlzdGFuY2U7XG5cdFx0XHRcdGNsb3Nlc3QuaiA9IGo7XG5cdFx0XHRcdGNsb3Nlc3QuaSA9IGk7XG5cdFx0XHRcdGNsb3Nlc3QudCA9IHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBjbG9zZXN0O1xufVxuXG4vL3N1YmRpdmlkZSBhIFNlZ21lbnQgY2xvc2VzdCB0byBhIHNwZWNpZmljIHgseSBjb29yZGluYXRlXG5leHBvcnQgZnVuY3Rpb24gc3ViZGl2aWRlU2VnbWVudE5lYXIoeCwgeSwgc2VnbWVudCwgc2xpY2VzLCBpdGVyYXRpb25zKSB7XG5cdGxldCBsID0gc2VnbWVudC5sZW5ndGgsXG5cdFx0YmVzdERpc3RhbmNlID0gX2xhcmdlTnVtLFxuXHRcdGJlc3RUID0gMCxcblx0XHRiZXN0U2VnbWVudEluZGV4ID0gMCxcblx0XHR0LCBpO1xuXHRzbGljZXMgPSBzbGljZXMgfHwgMjA7XG5cdGl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zIHx8IDM7XG5cdGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDYpIHtcblx0XHR0ID0gZ2V0Q2xvc2VzdFByb2dyZXNzT25CZXppZXIoMSwgeCwgeSwgMCwgMSwgc2xpY2VzLCBzZWdtZW50W2ldLCBzZWdtZW50W2krMV0sIHNlZ21lbnRbaSsyXSwgc2VnbWVudFtpKzNdLCBzZWdtZW50W2krNF0sIHNlZ21lbnRbaSs1XSwgc2VnbWVudFtpKzZdLCBzZWdtZW50W2krN10pO1xuXHRcdGlmIChiZXN0RGlzdGFuY2UgPiBfYmVzdERpc3RhbmNlKSB7XG5cdFx0XHRiZXN0RGlzdGFuY2UgPSBfYmVzdERpc3RhbmNlO1xuXHRcdFx0YmVzdFQgPSB0O1xuXHRcdFx0YmVzdFNlZ21lbnRJbmRleCA9IGk7XG5cdFx0fVxuXHR9XG5cdHQgPSBnZXRDbG9zZXN0UHJvZ3Jlc3NPbkJlemllcihpdGVyYXRpb25zLCB4LCB5LCBiZXN0VCAtIDAuMDUsIGJlc3RUICsgMC4wNSwgc2xpY2VzLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXhdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXgrMV0sIHNlZ21lbnRbYmVzdFNlZ21lbnRJbmRleCsyXSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4KzNdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXgrNF0sIHNlZ21lbnRbYmVzdFNlZ21lbnRJbmRleCs1XSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4KzZdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXgrN10pO1xuXHRzdWJkaXZpZGVTZWdtZW50KHNlZ21lbnQsIGJlc3RTZWdtZW50SW5kZXgsIHQpO1xuXHRyZXR1cm4gYmVzdFNlZ21lbnRJbmRleCArIDY7XG59XG5cbi8qXG5UYWtlcyBhbnkgb2YgdGhlIGZvbGxvd2luZyBhbmQgY29udmVydHMgaXQgdG8gYW4gYWxsIEN1YmljIEJlemllciBTVkcgZGF0YSBzdHJpbmc6XG4tIEEgPHBhdGg+IGRhdGEgc3RyaW5nIGxpa2UgXCJNMCwwIEwyLDQgdjIwLDE1IEgxMDBcIlxuLSBBIFJhd1BhdGgsIGxpa2UgW1t4LCB5LCB4LCB5LCB4LCB5LCB4LCB5XVtbeCwgeSwgeCwgeSwgeCwgeSwgeCwgeV1dXG4tIEEgU2VnbWVudCwgbGlrZSBbeCwgeSwgeCwgeSwgeCwgeSwgeCwgeV1cblxuTm90ZTogYWxsIG51bWJlcnMgYXJlIHJvdW5kZWQgZG93biB0byB0aGUgY2xvc2VzdCAwLjAwMSB0byBtaW5pbWl6ZSBtZW1vcnksIG1heGltaXplIHNwZWVkLCBhbmQgYXZvaWQgb2RkIG51bWJlcnMgbGlrZSAxZS0xM1xuKi9cbmV4cG9ydCBmdW5jdGlvbiByYXdQYXRoVG9TdHJpbmcocmF3UGF0aCkge1xuXHRpZiAoX2lzTnVtYmVyKHJhd1BhdGhbMF0pKSB7IC8vaW4gY2FzZSBhIHNlZ21lbnQgaXMgcGFzc2VkIGluIGluc3RlYWRcblx0XHRyYXdQYXRoID0gW3Jhd1BhdGhdO1xuXHR9XG5cdGxldCByZXN1bHQgPSBcIlwiLFxuXHRcdGwgPSByYXdQYXRoLmxlbmd0aCxcblx0XHRzbCwgcywgaSwgc2VnbWVudDtcblx0Zm9yIChzID0gMDsgcyA8IGw7IHMrKykge1xuXHRcdHNlZ21lbnQgPSByYXdQYXRoW3NdO1xuXHRcdHJlc3VsdCArPSBcIk1cIiArIF9yb3VuZChzZWdtZW50WzBdKSArIFwiLFwiICsgX3JvdW5kKHNlZ21lbnRbMV0pICsgXCIgQ1wiO1xuXHRcdHNsID0gc2VnbWVudC5sZW5ndGg7XG5cdFx0Zm9yIChpID0gMjsgaSA8IHNsOyBpKyspIHtcblx0XHRcdHJlc3VsdCArPSBfcm91bmQoc2VnbWVudFtpKytdKSArIFwiLFwiICsgX3JvdW5kKHNlZ21lbnRbaSsrXSkgKyBcIiBcIiArIF9yb3VuZChzZWdtZW50W2krK10pICsgXCIsXCIgKyBfcm91bmQoc2VnbWVudFtpKytdKSArIFwiIFwiICsgX3JvdW5kKHNlZ21lbnRbaSsrXSkgKyBcIixcIiArIF9yb3VuZChzZWdtZW50W2ldKSArIFwiIFwiO1xuXHRcdH1cblx0XHRpZiAoc2VnbWVudC5jbG9zZWQpIHtcblx0XHRcdHJlc3VsdCArPSBcInpcIjtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLypcbi8vIHRha2VzIGEgc2VnbWVudCB3aXRoIGNvb3JkaW5hdGVzIFt4LCB5LCB4LCB5LCAuLi5dIGFuZCBjb252ZXJ0cyB0aGUgY29udHJvbCBwb2ludHMgaW50byBhbmdsZXMgYW5kIGxlbmd0aHMgW3gsIHksIGFuZ2xlLCBsZW5ndGgsIGFuZ2xlLCBsZW5ndGgsIHgsIHksIGFuZ2xlLCBsZW5ndGgsIC4uLl0gc28gdGhhdCBpdCBhbmltYXRlcyBtb3JlIGNsZWFubHkgYW5kIGF2b2lkcyBvZGQgYnJlYWtzL2tpbmtzLiBGb3IgZXhhbXBsZSwgaWYgeW91IGFuaW1hdGUgZnJvbSAxIG8nY2xvY2sgdG8gNiBvJ2Nsb2NrLCBpdCdkIGp1c3QgZ28gZGlyZWN0bHkvbGluZWFybHkgcmF0aGVyIHRoYW4gYXJvdW5kLiBTbyB0aGUgbGVuZ3RoIHdvdWxkIGJlIHZlcnkgc2hvcnQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdHdlZW4uXG5leHBvcnQgZnVuY3Rpb24gY3BDb29yZHNUb0FuZ2xlcyhzZWdtZW50LCBjb3B5KSB7XG5cdHZhciByZXN1bHQgPSBjb3B5ID8gc2VnbWVudC5zbGljZSgwKSA6IHNlZ21lbnQsXG5cdFx0eCwgeSwgaTtcblx0Zm9yIChpID0gMDsgaSA8IHNlZ21lbnQubGVuZ3RoOyBpKz02KSB7XG5cdFx0eCA9IHNlZ21lbnRbaSsyXSAtIHNlZ21lbnRbaV07XG5cdFx0eSA9IHNlZ21lbnRbaSszXSAtIHNlZ21lbnRbaSsxXTtcblx0XHRyZXN1bHRbaSsyXSA9IE1hdGguYXRhbjIoeSwgeCk7XG5cdFx0cmVzdWx0W2krM10gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cdFx0eCA9IHNlZ21lbnRbaSs2XSAtIHNlZ21lbnRbaSs0XTtcblx0XHR5ID0gc2VnbWVudFtpKzddIC0gc2VnbWVudFtpKzVdO1xuXHRcdHJlc3VsdFtpKzRdID0gTWF0aC5hdGFuMih5LCB4KTtcblx0XHRyZXN1bHRbaSs1XSA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vLyB0YWtlcyBhIHNlZ21lbnQgdGhhdCB3YXMgY29udmVydGVkIHdpdGggY3BDb29yZHNUb0FuZ2xlcygpIHRvIGhhdmUgYW5nbGVzIGFuZCBsZW5ndGhzIGluc3RlYWQgb2YgY29vcmRpbmF0ZXMgZm9yIHRoZSBjb250cm9sIHBvaW50cywgYW5kIGNvbnZlcnRzIGl0IEJBQ0sgaW50byBjb29yZGluYXRlcy5cbmV4cG9ydCBmdW5jdGlvbiBjcEFuZ2xlc1RvQ29vcmRzKHNlZ21lbnQsIGNvcHkpIHtcblx0dmFyIHJlc3VsdCA9IGNvcHkgPyBzZWdtZW50LnNsaWNlKDApIDogc2VnbWVudCxcblx0XHRsZW5ndGggPSBzZWdtZW50Lmxlbmd0aCxcblx0XHRybmQgPSAxMDAwLFxuXHRcdGFuZ2xlLCBsLCBpLCBqO1xuXHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKz02KSB7XG5cdFx0YW5nbGUgPSBzZWdtZW50W2krMl07XG5cdFx0bCA9IHNlZ21lbnRbaSszXTsgLy9sZW5ndGhcblx0XHRyZXN1bHRbaSsyXSA9ICgoKHNlZ21lbnRbaV0gKyBNYXRoLmNvcyhhbmdsZSkgKiBsKSAqIHJuZCkgfCAwKSAvIHJuZDtcblx0XHRyZXN1bHRbaSszXSA9ICgoKHNlZ21lbnRbaSsxXSArIE1hdGguc2luKGFuZ2xlKSAqIGwpICogcm5kKSB8IDApIC8gcm5kO1xuXHRcdGFuZ2xlID0gc2VnbWVudFtpKzRdO1xuXHRcdGwgPSBzZWdtZW50W2krNV07IC8vbGVuZ3RoXG5cdFx0cmVzdWx0W2krNF0gPSAoKChzZWdtZW50W2krNl0gLSBNYXRoLmNvcyhhbmdsZSkgKiBsKSAqIHJuZCkgfCAwKSAvIHJuZDtcblx0XHRyZXN1bHRbaSs1XSA9ICgoKHNlZ21lbnRbaSs3XSAtIE1hdGguc2luKGFuZ2xlKSAqIGwpICogcm5kKSB8IDApIC8gcm5kO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8vYWRkcyBhbiBcImlzU21vb3RoXCIgYXJyYXkgdG8gZWFjaCBzZWdtZW50IGFuZCBwb3B1bGF0ZXMgaXQgd2l0aCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNtb290aCAodGhlIGNvbnRyb2wgcG9pbnRzIGhhdmUgYmFzaWNhbGx5IHRoZSBzYW1lIHNsb3BlKS4gRm9yIGFueSBzbW9vdGggY29udHJvbCBwb2ludHMsIGl0IGNvbnZlcnRzIHRoZSBjb29yZGluYXRlcyBpbnRvIGFuZ2xlICh4LCBpbiByYWRpYW5zKSBhbmQgbGVuZ3RoICh5KSBhbmQgcHV0cyB0aGVtIGludG8gdGhlIHNhbWUgaW5kZXggdmFsdWUgaW4gYSBzbW9vdGhEYXRhIGFycmF5LlxuZXhwb3J0IGZ1bmN0aW9uIHBvcHVsYXRlU21vb3RoRGF0YShyYXdQYXRoKSB7XG5cdGxldCBqID0gcmF3UGF0aC5sZW5ndGgsXG5cdFx0c21vb3RoLCBzZWdtZW50LCB4LCB5LCB4MiwgeTIsIGksIGwsIGEsIGEyLCBpc1Ntb290aCwgc21vb3RoRGF0YTtcblx0d2hpbGUgKC0taiA+IC0xKSB7XG5cdFx0c2VnbWVudCA9IHJhd1BhdGhbal07XG5cdFx0aXNTbW9vdGggPSBzZWdtZW50LmlzU21vb3RoID0gc2VnbWVudC5pc1Ntb290aCB8fCBbMCwgMCwgMCwgMF07XG5cdFx0c21vb3RoRGF0YSA9IHNlZ21lbnQuc21vb3RoRGF0YSA9IHNlZ21lbnQuc21vb3RoRGF0YSB8fCBbMCwgMCwgMCwgMF07XG5cdFx0aXNTbW9vdGgubGVuZ3RoID0gNDtcblx0XHRsID0gc2VnbWVudC5sZW5ndGggLSAyO1xuXHRcdGZvciAoaSA9IDY7IGkgPCBsOyBpICs9IDYpIHtcblx0XHRcdHggPSBzZWdtZW50W2ldIC0gc2VnbWVudFtpIC0gMl07XG5cdFx0XHR5ID0gc2VnbWVudFtpICsgMV0gLSBzZWdtZW50W2kgLSAxXTtcblx0XHRcdHgyID0gc2VnbWVudFtpICsgMl0gLSBzZWdtZW50W2ldO1xuXHRcdFx0eTIgPSBzZWdtZW50W2kgKyAzXSAtIHNlZ21lbnRbaSArIDFdO1xuXHRcdFx0YSA9IF9hdGFuMih5LCB4KTtcblx0XHRcdGEyID0gX2F0YW4yKHkyLCB4Mik7XG5cdFx0XHRzbW9vdGggPSAoTWF0aC5hYnMoYSAtIGEyKSA8IDAuMDkpO1xuXHRcdFx0aWYgKHNtb290aCkge1xuXHRcdFx0XHRzbW9vdGhEYXRhW2kgLSAyXSA9IGE7XG5cdFx0XHRcdHNtb290aERhdGFbaSArIDJdID0gYTI7XG5cdFx0XHRcdHNtb290aERhdGFbaSAtIDFdID0gX3NxcnQoeCAqIHggKyB5ICogeSk7XG5cdFx0XHRcdHNtb290aERhdGFbaSArIDNdID0gX3NxcnQoeDIgKiB4MiArIHkyICogeTIpO1xuXHRcdFx0fVxuXHRcdFx0aXNTbW9vdGgucHVzaChzbW9vdGgsIHNtb290aCwgMCwgMCwgc21vb3RoLCBzbW9vdGgpO1xuXHRcdH1cblx0XHQvL2lmIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludHMgYXJlIGlkZW50aWNhbCwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3MgYSBzbW9vdGggdHJhbnNpdGlvbi4gV2UgbXVzdCBoYW5kbGUgdGhpcyBhIGJpdCBkaWZmZXJlbnRseSBkdWUgdG8gdGhlaXIgcG9zaXRpb25zIGluIHRoZSBhcnJheS5cblx0XHRpZiAoc2VnbWVudFtsXSA9PT0gc2VnbWVudFswXSAmJiBzZWdtZW50W2wrMV0gPT09IHNlZ21lbnRbMV0pIHtcblx0XHRcdHggPSBzZWdtZW50WzBdIC0gc2VnbWVudFtsLTJdO1xuXHRcdFx0eSA9IHNlZ21lbnRbMV0gLSBzZWdtZW50W2wtMV07XG5cdFx0XHR4MiA9IHNlZ21lbnRbMl0gLSBzZWdtZW50WzBdO1xuXHRcdFx0eTIgPSBzZWdtZW50WzNdIC0gc2VnbWVudFsxXTtcblx0XHRcdGEgPSBfYXRhbjIoeSwgeCk7XG5cdFx0XHRhMiA9IF9hdGFuMih5MiwgeDIpO1xuXHRcdFx0aWYgKE1hdGguYWJzKGEgLSBhMikgPCAwLjA5KSB7XG5cdFx0XHRcdHNtb290aERhdGFbbC0yXSA9IGE7XG5cdFx0XHRcdHNtb290aERhdGFbMl0gPSBhMjtcblx0XHRcdFx0c21vb3RoRGF0YVtsLTFdID0gX3NxcnQoeCAqIHggKyB5ICogeSk7XG5cdFx0XHRcdHNtb290aERhdGFbM10gPSBfc3FydCh4MiAqIHgyICsgeTIgKiB5Mik7XG5cdFx0XHRcdGlzU21vb3RoW2wtMl0gPSBpc1Ntb290aFtsLTFdID0gdHJ1ZTsgLy9kb24ndCBjaGFuZ2UgaW5kZXhlcyAyIGFuZCAzIGJlY2F1c2Ugd2UnbGwgdHJpZ2dlciBldmVyeXRoaW5nIGZyb20gdGhlIEVORCwgYW5kIHRoaXMgd2lsbCBvcHRpbWl6ZSBmaWxlIHNpemUgYSBiaXQuXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiByYXdQYXRoO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50VG9TY3JlZW4oc3ZnRWxlbWVudCwgcG9pbnQpIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7IC8vYnkgZGVmYXVsdCwgdGFrZSB0aGUgZmlyc3Qgc2V0IG9mIGNvb3JkaW5hdGVzIGluIHRoZSBwYXRoIGFzIHRoZSBwb2ludFxuXHRcdGxldCByYXdQYXRoID0gZ2V0UmF3UGF0aChzdmdFbGVtZW50KTtcblx0XHRwb2ludCA9IHN2Z0VsZW1lbnQub3duZXJTVkdFbGVtZW50LmNyZWF0ZVNWR1BvaW50KCk7XG5cdFx0cG9pbnQueCA9IHJhd1BhdGhbMF1bMF07XG5cdFx0cG9pbnQueSA9IHJhd1BhdGhbMF1bMV07XG5cdH1cblx0cmV0dXJuIHBvaW50Lm1hdHJpeFRyYW5zZm9ybShzdmdFbGVtZW50LmdldFNjcmVlbkNUTSgpKTtcbn1cblxuKi8iLCIvKiFcbiAqIHN0cmluZ3M6IDMuNy4wXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOC0yMDIxLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuLyogZXNsaW50LWRpc2FibGUgKi9cblxubGV0IF90cmltRXhwID0gLyheXFxzK3xcXHMrJCkvZztcblxuZXhwb3J0IGNvbnN0IGVtb2ppRXhwID0gLyhbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdKD86W1xcdTIwMERcXHVGRTBGXVtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0pezIsfXxcXHVEODNEXFx1REM2OSg/OlxcdTIwMEQoPzooPzpcXHVEODNEXFx1REM2OVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY3fCg/OlxcdUQ4M0RcXHVEQzY5XFx1MjAwRCk/XFx1RDgzRFxcdURDNjYpfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8XFx1RDgzRFxcdURDNjlcXHUyMDBEKD86XFx1RDgzRFxcdURDNjlcXHUyMDBEKT9cXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REM2OVxcdTIwMEQoPzpcXHVEODNEXFx1REM2OVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXxcXHVEODNDXFx1REZGM1xcdUZFMEZcXHUyMDBEXFx1RDgzQ1xcdURGMDh8KD86XFx1RDgzQ1tcXHVERkMzXFx1REZDNFxcdURGQ0FdfFxcdUQ4M0RbXFx1REM2RVxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XXxcXHVEODNFW1xcdUREMjZcXHVERDM3LVxcdUREMzlcXHVERDNEXFx1REQzRVxcdURERDYtXFx1RERERF0pKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRnxcXHVEODNEXFx1REM2OSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml0pfCg/OlxcdUQ4M0NbXFx1REZDM1xcdURGQzRcXHVERkNBXXxcXHVEODNEW1xcdURDNkVcXHVEQzZGXFx1REM3MVxcdURDNzNcXHVEQzc3XFx1REM4MVxcdURDODJcXHVEQzg2XFx1REM4N1xcdURFNDUtXFx1REU0N1xcdURFNEJcXHVERTREXFx1REU0RVxcdURFQTNcXHVERUI0LVxcdURFQjZdfFxcdUQ4M0VbXFx1REQyNlxcdUREMzctXFx1REQzOVxcdUREM0MtXFx1REQzRVxcdURERDYtXFx1RERERl0pXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGfFxcdUQ4M0NcXHVEREZEXFx1RDgzQ1xcdURERjB8XFx1RDgzQ1xcdURERjZcXHVEODNDXFx1RERFNnxcXHVEODNDXFx1RERGNFxcdUQ4M0NcXHVEREYyfFxcdUQ4M0NcXHVEREU5KD86XFx1RDgzQ1tcXHVEREVBXFx1RERFQ1xcdURERUZcXHVEREYwXFx1RERGMlxcdURERjRcXHVEREZGXSl8XFx1RDgzQ1xcdURERjcoPzpcXHVEODNDW1xcdURERUFcXHVEREY0XFx1RERGOFxcdURERkFcXHVEREZDXSl8XFx1RDgzQ1xcdURERTgoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFOVxcdURERUItXFx1RERFRVxcdURERjAtXFx1RERGNVxcdURERjdcXHVEREZBLVxcdURERkZdKXwoPzpcXHUyNkY5fFxcdUQ4M0NbXFx1REZDQlxcdURGQ0NdfFxcdUQ4M0RcXHVERDc1KSg/OlxcdUZFMEZcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXXwoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml0pXFx1RkUwRnwoPzpcXHVEODNEXFx1REM0MVxcdUZFMEZcXHUyMDBEXFx1RDgzRFxcdURERTh8XFx1RDgzRFxcdURDNjkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0RcXHVEQzY4KD86KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF0pKVxcdUZFMEZ8XFx1RDgzQ1xcdURERjIoPzpcXHVEODNDW1xcdURERTZcXHVEREU4LVxcdURERURcXHVEREYwLVxcdURERkZdKXxcXHVEODNEXFx1REM2OVxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSl8XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pKXxcXHVEODNDXFx1RERGMSg/OlxcdUQ4M0NbXFx1RERFNi1cXHVEREU4XFx1RERFRVxcdURERjBcXHVEREY3LVxcdURERkJcXHVEREZFXSl8XFx1RDgzQ1xcdURERUYoPzpcXHVEODNDW1xcdURERUFcXHVEREYyXFx1RERGNFxcdURERjVdKXxcXHVEODNDXFx1RERFRCg/OlxcdUQ4M0NbXFx1RERGMFxcdURERjJcXHVEREYzXFx1RERGN1xcdURERjlcXHVEREZBXSl8XFx1RDgzQ1xcdURERUIoPzpcXHVEODNDW1xcdURERUUtXFx1RERGMFxcdURERjJcXHVEREY0XFx1RERGN10pfFsjXFwqMC05XVxcdUZFMEZcXHUyMEUzfFxcdUQ4M0NcXHVEREU3KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFN1xcdURERTktXFx1RERFRlxcdURERjEtXFx1RERGNFxcdURERjYtXFx1RERGOVxcdURERkJcXHVEREZDXFx1RERGRVxcdURERkZdKXxcXHVEODNDXFx1RERFNig/OlxcdUQ4M0NbXFx1RERFOC1cXHVEREVDXFx1RERFRVxcdURERjFcXHVEREYyXFx1RERGNFxcdURERjYtXFx1RERGQVxcdURERkNcXHVEREZEXFx1RERGRl0pfFxcdUQ4M0NcXHVEREZGKD86XFx1RDgzQ1tcXHVEREU2XFx1RERGMlxcdURERkNdKXxcXHVEODNDXFx1RERGNSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERUEtXFx1RERFRFxcdURERjAtXFx1RERGM1xcdURERjctXFx1RERGOVxcdURERkNcXHVEREZFXSl8XFx1RDgzQ1xcdURERkIoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQVxcdURERUNcXHVEREVFXFx1RERGM1xcdURERkFdKXxcXHVEODNDXFx1RERGMyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBLVxcdURERUNcXHVEREVFXFx1RERGMVxcdURERjRcXHVEREY1XFx1RERGN1xcdURERkFcXHVEREZGXSl8XFx1RDgzQ1xcdURGRjRcXHVEQjQwXFx1REM2N1xcdURCNDBcXHVEQzYyKD86XFx1REI0MFxcdURDNzdcXHVEQjQwXFx1REM2Q1xcdURCNDBcXHVEQzczfFxcdURCNDBcXHVEQzczXFx1REI0MFxcdURDNjNcXHVEQjQwXFx1REM3NHxcXHVEQjQwXFx1REM2NVxcdURCNDBcXHVEQzZFXFx1REI0MFxcdURDNjcpXFx1REI0MFxcdURDN0Z8XFx1RDgzRFxcdURDNjgoPzpcXHUyMDBEKD86XFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNEXFx1REM2OHwoPzooPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHUyMDBEKT9cXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnwoPzooPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHUyMDBEKT9cXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml0pfCg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml0pKXxcXHVEODNDXFx1RERGOCg/OlxcdUQ4M0NbXFx1RERFNi1cXHVEREVBXFx1RERFQy1cXHVEREY0XFx1RERGNy1cXHVEREY5XFx1RERGQlxcdURERkQtXFx1RERGRl0pfFxcdUQ4M0NcXHVEREYwKD86XFx1RDgzQ1tcXHVEREVBXFx1RERFQy1cXHVEREVFXFx1RERGMlxcdURERjNcXHVEREY1XFx1RERGN1xcdURERkNcXHVEREZFXFx1RERGRl0pfFxcdUQ4M0NcXHVEREZFKD86XFx1RDgzQ1tcXHVEREVBXFx1RERGOV0pfFxcdUQ4M0NcXHVEREVFKD86XFx1RDgzQ1tcXHVEREU4LVxcdURERUFcXHVEREYxLVxcdURERjRcXHVEREY2LVxcdURERjldKXxcXHVEODNDXFx1RERGOSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREU5XFx1RERFQi1cXHVEREVEXFx1RERFRi1cXHVEREY0XFx1RERGN1xcdURERjlcXHVEREZCXFx1RERGQ1xcdURERkZdKXxcXHVEODNDXFx1RERFQyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERTdcXHVEREU5LVxcdURERUVcXHVEREYxLVxcdURERjNcXHVEREY1LVxcdURERkFcXHVEREZDXFx1RERGRV0pfFxcdUQ4M0NcXHVEREZBKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFQ1xcdURERjJcXHVEREYzXFx1RERGOFxcdURERkVcXHVEREZGXSl8XFx1RDgzQ1xcdURERUEoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQVxcdURERUNcXHVEREVEXFx1RERGNy1cXHVEREZBXSl8XFx1RDgzQ1xcdURERkMoPzpcXHVEODNDW1xcdURERUJcXHVEREY4XSl8KD86XFx1MjZGOXxcXHVEODNDW1xcdURGQ0JcXHVERkNDXXxcXHVEODNEXFx1REQ3NSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OlxcdUQ4M0NbXFx1REZDM1xcdURGQzRcXHVERkNBXXxcXHVEODNEW1xcdURDNkVcXHVEQzcxXFx1REM3M1xcdURDNzdcXHVEQzgxXFx1REM4MlxcdURDODZcXHVEQzg3XFx1REU0NS1cXHVERTQ3XFx1REU0QlxcdURFNERcXHVERTRFXFx1REVBM1xcdURFQjQtXFx1REVCNl18XFx1RDgzRVtcXHVERDI2XFx1REQzNy1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREQ2LVxcdURERERdKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8KD86W1xcdTI2MURcXHUyNzBBLVxcdTI3MERdfFxcdUQ4M0NbXFx1REY4NVxcdURGQzJcXHVERkM3XXxcXHVEODNEW1xcdURDNDJcXHVEQzQzXFx1REM0Ni1cXHVEQzUwXFx1REM2NlxcdURDNjdcXHVEQzcwXFx1REM3MlxcdURDNzQtXFx1REM3NlxcdURDNzhcXHVEQzdDXFx1REM4M1xcdURDODVcXHVEQ0FBXFx1REQ3NFxcdUREN0FcXHVERDkwXFx1REQ5NVxcdUREOTZcXHVERTRDXFx1REU0RlxcdURFQzBcXHVERUNDXXxcXHVEODNFW1xcdUREMTgtXFx1REQxQ1xcdUREMUVcXHVERDFGXFx1REQzMC1cXHVERDM2XFx1REREMS1cXHVEREQ1XSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFxcdUQ4M0RcXHVEQzY4KD86XFx1MjAwRCg/Oig/Oig/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY3fCg/Oig/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY2KXxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OltcXHUyNjFEXFx1MjZGOVxcdTI3MEEtXFx1MjcwRF18XFx1RDgzQ1tcXHVERjg1XFx1REZDMi1cXHVERkM0XFx1REZDN1xcdURGQ0EtXFx1REZDQ118XFx1RDgzRFtcXHVEQzQyXFx1REM0M1xcdURDNDYtXFx1REM1MFxcdURDNjYtXFx1REM2OVxcdURDNkVcXHVEQzcwLVxcdURDNzhcXHVEQzdDXFx1REM4MS1cXHVEQzgzXFx1REM4NS1cXHVEQzg3XFx1RENBQVxcdURENzRcXHVERDc1XFx1REQ3QVxcdUREOTBcXHVERDk1XFx1REQ5NlxcdURFNDUtXFx1REU0N1xcdURFNEItXFx1REU0RlxcdURFQTNcXHVERUI0LVxcdURFQjZcXHVERUMwXFx1REVDQ118XFx1RDgzRVtcXHVERDE4LVxcdUREMUNcXHVERDFFXFx1REQxRlxcdUREMjZcXHVERDMwLVxcdUREMzlcXHVERDNEXFx1REQzRVxcdURERDEtXFx1RERERF0pKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98KD86W1xcdTIzMUFcXHUyMzFCXFx1MjNFOS1cXHUyM0VDXFx1MjNGMFxcdTIzRjNcXHUyNUZEXFx1MjVGRVxcdTI2MTRcXHUyNjE1XFx1MjY0OC1cXHUyNjUzXFx1MjY3RlxcdTI2OTNcXHUyNkExXFx1MjZBQVxcdTI2QUJcXHUyNkJEXFx1MjZCRVxcdTI2QzRcXHUyNkM1XFx1MjZDRVxcdTI2RDRcXHUyNkVBXFx1MjZGMlxcdTI2RjNcXHUyNkY1XFx1MjZGQVxcdTI2RkRcXHUyNzA1XFx1MjcwQVxcdTI3MEJcXHUyNzI4XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc5NS1cXHUyNzk3XFx1MjdCMFxcdTI3QkZcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XXxcXHVEODNDW1xcdURDMDRcXHVEQ0NGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdURERTYtXFx1RERGRlxcdURFMDFcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzNlxcdURFMzgtXFx1REUzQVxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERjIwXFx1REYyRC1cXHVERjM1XFx1REYzNy1cXHVERjdDXFx1REY3RS1cXHVERjkzXFx1REZBMC1cXHVERkNBXFx1REZDRi1cXHVERkQzXFx1REZFMC1cXHVERkYwXFx1REZGNFxcdURGRjgtXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURDM0VcXHVEQzQwXFx1REM0Mi1cXHVEQ0ZDXFx1RENGRi1cXHVERDNEXFx1REQ0Qi1cXHVERDRFXFx1REQ1MC1cXHVERDY3XFx1REQ3QVxcdUREOTVcXHVERDk2XFx1RERBNFxcdURERkItXFx1REU0RlxcdURFODAtXFx1REVDNVxcdURFQ0NcXHVERUQwLVxcdURFRDJcXHVERUVCXFx1REVFQ1xcdURFRjQtXFx1REVGOF18XFx1RDgzRVtcXHVERDEwLVxcdUREM0FcXHVERDNDLVxcdUREM0VcXHVERDQwLVxcdURENDVcXHVERDQ3LVxcdURENENcXHVERDUwLVxcdURENkJcXHVERDgwLVxcdUREOTdcXHVEREMwXFx1REREMC1cXHVEREU2XSl8KD86WyNcXCowLTlcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA0XFx1MjYwRVxcdTI2MTFcXHUyNjE0XFx1MjYxNVxcdTI2MThcXHUyNjFEXFx1MjYyMFxcdTI2MjJcXHUyNjIzXFx1MjYyNlxcdTI2MkFcXHUyNjJFXFx1MjYyRlxcdTI2MzgtXFx1MjYzQVxcdTI2NDBcXHUyNjQyXFx1MjY0OC1cXHUyNjUzXFx1MjY2MFxcdTI2NjNcXHUyNjY1XFx1MjY2NlxcdTI2NjhcXHUyNjdCXFx1MjY3RlxcdTI2OTItXFx1MjY5N1xcdTI2OTlcXHUyNjlCXFx1MjY5Q1xcdTI2QTBcXHUyNkExXFx1MjZBQVxcdTI2QUJcXHUyNkIwXFx1MjZCMVxcdTI2QkRcXHUyNkJFXFx1MjZDNFxcdTI2QzVcXHUyNkM4XFx1MjZDRVxcdTI2Q0ZcXHUyNkQxXFx1MjZEM1xcdTI2RDRcXHUyNkU5XFx1MjZFQVxcdTI2RjAtXFx1MjZGNVxcdTI2RjctXFx1MjZGQVxcdTI2RkRcXHUyNzAyXFx1MjcwNVxcdTI3MDgtXFx1MjcwRFxcdTI3MEZcXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2M1xcdTI3NjRcXHUyNzk1LVxcdTI3OTdcXHUyN0ExXFx1MjdCMFxcdTI3QkZcXHUyOTM0XFx1MjkzNVxcdTJCMDUtXFx1MkIwN1xcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XXxcXHVEODNDW1xcdURDMDRcXHVEQ0NGXFx1REQ3MFxcdURENzFcXHVERDdFXFx1REQ3RlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREU2LVxcdURERkZcXHVERTAxXFx1REUwMlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGMjFcXHVERjI0LVxcdURGOTNcXHVERjk2XFx1REY5N1xcdURGOTktXFx1REY5QlxcdURGOUUtXFx1REZGMFxcdURGRjMtXFx1REZGNVxcdURGRjctXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURDRkRcXHVEQ0ZGLVxcdUREM0RcXHVERDQ5LVxcdURENEVcXHVERDUwLVxcdURENjdcXHVERDZGXFx1REQ3MFxcdURENzMtXFx1REQ3QVxcdUREODdcXHVERDhBLVxcdUREOERcXHVERDkwXFx1REQ5NVxcdUREOTZcXHVEREE0XFx1RERBNVxcdUREQThcXHVEREIxXFx1RERCMlxcdUREQkNcXHVEREMyLVxcdUREQzRcXHVEREQxLVxcdURERDNcXHVERERDLVxcdUREREVcXHVEREUxXFx1RERFM1xcdURERThcXHVEREVGXFx1RERGM1xcdURERkEtXFx1REU0RlxcdURFODAtXFx1REVDNVxcdURFQ0ItXFx1REVEMlxcdURFRTAtXFx1REVFNVxcdURFRTlcXHVERUVCXFx1REVFQ1xcdURFRjBcXHVERUYzLVxcdURFRjhdfFxcdUQ4M0VbXFx1REQxMC1cXHVERDNBXFx1REQzQy1cXHVERDNFXFx1REQ0MC1cXHVERDQ1XFx1REQ0Ny1cXHVERDRDXFx1REQ1MC1cXHVERDZCXFx1REQ4MC1cXHVERDk3XFx1RERDMFxcdURERDAtXFx1RERFNl0pXFx1RkUwRikvO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dChlKSB7XG5cdGxldCB0eXBlID0gZS5ub2RlVHlwZSxcblx0XHRyZXN1bHQgPSBcIlwiO1xuXHRpZiAodHlwZSA9PT0gMSB8fCB0eXBlID09PSA5IHx8IHR5cGUgPT09IDExKSB7XG5cdFx0aWYgKHR5cGVvZihlLnRleHRDb250ZW50KSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0cmV0dXJuIGUudGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoZSA9IGUuZmlyc3RDaGlsZDsgZTsgZSA9IGUubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJlc3VsdCArPSBnZXRUZXh0KGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICh0eXBlID09PSAzIHx8IHR5cGUgPT09IDQpIHtcblx0XHRyZXR1cm4gZS5ub2RlVmFsdWU7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0SW5uZXJIVE1MKGVsZW1lbnQsIGRlbGltaXRlciwgdHJpbSkge1xuXHRsZXQgbm9kZSA9IGVsZW1lbnQuZmlyc3RDaGlsZCxcblx0XHRyZXN1bHQgPSBbXTtcblx0d2hpbGUgKG5vZGUpIHtcblx0XHRpZiAobm9kZS5ub2RlVHlwZSA9PT0gMykge1xuXHRcdFx0cmVzdWx0LnB1c2goLi4uZW1vamlTYWZlU3BsaXQoKG5vZGUubm9kZVZhbHVlICsgXCJcIikucmVwbGFjZSgvXlxcbisvZywgXCJcIikucmVwbGFjZSgvXFxzKy9nLCBcIiBcIiksIGRlbGltaXRlciwgdHJpbSkpO1xuXHRcdH0gZWxzZSBpZiAoKG5vZGUubm9kZU5hbWUgKyBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcImJyXCIpIHtcblx0XHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoLTFdICs9IFwiPGJyPlwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQucHVzaChub2RlLm91dGVySFRNTCk7XG5cdFx0fVxuXHRcdG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qXG4vL3NtYWxsZXIga2IgdmVyc2lvbiB0aGF0IG9ubHkgaGFuZGxlcyB0aGUgc2ltcGxlciBlbW9qaSdzLCB3aGljaCBpcyBvZnRlbiBwZXJmZWN0bHkgYWRlcXVhdGUuXG5cbmxldCBfZW1vamkgPSBcIltcXHVFMDAwLVxcdUY4RkZdfFxcdUQ4M0NbXFx1REMwMC1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1REZGRl18W1xcdTI2OTQtXFx1MjY5N118XFx1RDgzRVtcXHVERDEwLVxcdURENURdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl1cIixcblx0X2Vtb2ppRXhwID0gbmV3IFJlZ0V4cChfZW1vamkpLFxuXHRfZW1vamlBbmRDaGFyc0V4cCA9IG5ldyBSZWdFeHAoX2Vtb2ppICsgXCJ8LlwiLCBcImdcIiksXG5cdF9lbW9qaVNhZmVTcGxpdCA9ICh0ZXh0LCBkZWxpbWl0ZXIsIHRyaW0pID0+IHtcblx0XHRpZiAodHJpbSkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZShfdHJpbUV4cCwgXCJcIik7XG5cdFx0fVxuXHRcdHJldHVybiAoKGRlbGltaXRlciA9PT0gXCJcIiB8fCAhZGVsaW1pdGVyKSAmJiBfZW1vamlFeHAudGVzdCh0ZXh0KSkgPyB0ZXh0Lm1hdGNoKF9lbW9qaUFuZENoYXJzRXhwKSA6IHRleHQuc3BsaXQoZGVsaW1pdGVyIHx8IFwiXCIpO1xuXHR9O1xuICovXG5leHBvcnQgZnVuY3Rpb24gZW1vamlTYWZlU3BsaXQodGV4dCwgZGVsaW1pdGVyLCB0cmltKSB7XG5cdHRleHQgKz0gXCJcIjsgLy8gbWFrZSBzdXJlIGl0J3MgY2FzdCBhcyBhIHN0cmluZy4gU29tZW9uZSBtYXkgcGFzcyBpbiBhIG51bWJlci5cblx0aWYgKHRyaW0pIHtcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKF90cmltRXhwLCBcIlwiKTtcblx0fVxuXHRpZiAoZGVsaW1pdGVyICYmIGRlbGltaXRlciAhPT0gXCJcIikge1xuXHRcdHJldHVybiB0ZXh0LnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpLnNwbGl0KGRlbGltaXRlcik7XG5cdH1cblx0bGV0IHJlc3VsdCA9IFtdLFxuXHRcdGwgPSB0ZXh0Lmxlbmd0aCxcblx0XHRpID0gMCxcblx0XHRqLCBjaGFyYWN0ZXI7XG5cdGZvciAoOyBpIDwgbDsgaSsrKSB7XG5cdFx0Y2hhcmFjdGVyID0gdGV4dC5jaGFyQXQoaSk7XG5cdFx0aWYgKChjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSA+PSAweEQ4MDAgJiYgY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkgPD0gMHhEQkZGKSB8fCAodGV4dC5jaGFyQ29kZUF0KGkrMSkgPj0gMHhGRTAwICYmIHRleHQuY2hhckNvZGVBdChpKzEpIDw9IDB4RkUwRikpIHsgLy9zcGVjaWFsIGVtb2ppIGNoYXJhY3RlcnMgdXNlIDIgb3IgNCB1bmljb2RlIGNoYXJhY3RlcnMgdGhhdCB3ZSBtdXN0IGtlZXAgdG9nZXRoZXIuXG5cdFx0XHRqID0gKCh0ZXh0LnN1YnN0cihpLCAxMikuc3BsaXQoZW1vamlFeHApIHx8IFtdKVsxXSB8fCBcIlwiKS5sZW5ndGggfHwgMjtcblx0XHRcdGNoYXJhY3RlciA9IHRleHQuc3Vic3RyKGksIGopO1xuXHRcdFx0cmVzdWx0LmVtb2ppID0gMTtcblx0XHRcdGkgKz0gaiAtIDE7XG5cdFx0fVxuXHRcdHJlc3VsdC5wdXNoKGNoYXJhY3RlciA9PT0gXCI+XCIgPyBcIiZndDtcIiA6IChjaGFyYWN0ZXIgPT09IFwiPFwiKSA/IFwiJmx0O1wiIDogY2hhcmFjdGVyKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufSJdLCJzb3VyY2VSb290IjoiIn0=